<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>🏴‍☠️浴巾的贼船🏴‍☠️</title>
  <icon>https://www.gravatar.com/avatar/4693869db7cae9524536dea3133cf541</icon>
  
  <link href="https://chunyujin.top/atom.xml" rel="self"/>
  
  <link href="https://chunyujin.top/"/>
  <updated>2023-01-07T14:37:58.080Z</updated>
  <id>https://chunyujin.top/</id>
  
  <author>
    <name>浴巾</name>
    <email>3029795434@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>博客图集(阿里云图床)</title>
    <link href="https://chunyujin.top/chunyujin/c2a9db75.html"/>
    <id>https://chunyujin.top/chunyujin/c2a9db75.html</id>
    <published>2023-01-07T14:25:00.000Z</published>
    <updated>2023-01-07T14:37:58.080Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300142246.jpg" alt="67243791_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300145467.jpg" alt="睡莲"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300149266.png" alt="79640557_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300150858.png" alt="99940581_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300152503.jpg" alt="ss"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300157190.jpg" alt="51562163_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300159454.png" alt="101965789_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300202846.jpg" alt="78830672_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300203045.jpg" alt="74724305_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300205537.jpg" alt="100938340_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301114389.jpg" alt="100938340_p0的副本2"></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300207368.gif" alt="original"  /><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301145729.png" alt="head"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300211286.png" alt="76834683_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300216305.png" alt="A0E1D3CE-D536-443C-9583-9FC6C0BFBC5C"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300228844.png" alt="016269CA-735E-498F-8C68-29AAAB6DAFBB"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301100230.jpg" alt="74364959_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301103690.jpg" alt="98288115_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301116378.jpg" alt="98473741_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301103283.jpg" alt="99287912_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301105836.jpg" alt="99287912_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301922412.png" alt="截屏2022-12-30 19.21.59"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301929027.png" alt="截屏2022-12-30 19.29.38"></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301938709.jpg" alt="97451569_p0"  /><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212302043621.jpg"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212302044439.jpg"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212302109225.jpg" alt="101204641_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010017530.jpg" alt="78440564_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010140253.png" alt="截屏2023-01-01 01.38.06"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010141063.jpg" alt="100613443_p3"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010143595.jpg" alt="100307349_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301011054071.jpg" alt="82492410_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301011057668.jpg" alt="65231299_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301072223869.png" alt="未命名的设计"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301072231029.png" alt="未命名的设计"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301072233799.png" alt="未命名的设计"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301072235859.png" alt="未命名的设计"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="图集" scheme="https://chunyujin.top/categories/%E5%9B%BE%E9%9B%86/"/>
    
    
    <category term="资源" scheme="https://chunyujin.top/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>解决butterfly在黑色模式下主页和顶部封面过暗</title>
    <link href="https://chunyujin.top/chunyujin/dffbd9e1.html"/>
    <id>https://chunyujin.top/chunyujin/dffbd9e1.html</id>
    <published>2023-01-06T10:52:00.000Z</published>
    <updated>2023-01-06T10:54:13.811Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>解决黑色模式下主页和顶部封面过暗:</p><p>在<code>/themes/butterfly/source/css/_mode/darkmode.styl </code></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061849015.png" alt="截屏2023-01-06 18.47.52"></p><p>调整第48行括号里的小数点后的数值，默认是.9，数值越大越暗</p><h5 id="before"><a href="#before" class="headerlink" title="before:"></a>before:</h5><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061850337.png"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061848023.png" alt="截屏2023-01-06 18.48.21"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061848940.png" alt="截屏2023-01-06 18.48.32"></p><h5 id="after："><a href="#after：" class="headerlink" title="after："></a>after：</h5><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061850100.png" alt="截屏2023-01-06 18.50.37"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061851886.png" alt="截屏2023-01-06 18.51.00"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061851284.png" alt="截屏2023-01-06 18.51.22"></p><p><a href="http://chunyujin.top/chunyujin/5b04b880.html">相关问题链接：解决黑色模式下文章预览封面及内部图片过暗</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Skill" scheme="https://chunyujin.top/categories/Skill/"/>
    
    <category term="Hero" scheme="https://chunyujin.top/categories/Skill/Hero/"/>
    
    
    <category term="Hexo" scheme="https://chunyujin.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>解决黑色模式下文章预览封面及内部图片过暗</title>
    <link href="https://chunyujin.top/chunyujin/5b04b880.html"/>
    <id>https://chunyujin.top/chunyujin/5b04b880.html</id>
    <published>2023-01-06T10:46:00.000Z</published>
    <updated>2023-01-06T10:59:00.060Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>解决黑色模式下文章预览封面及内部图片过暗</p><p>在<code>/themes/butterfly/source/css/_mode/darkmode.styl </code></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061854032.png" alt="截屏2023-01-06 18.54.56"></p><p>106、108行brightness括号里的值，brightness范围0~1，值越小，图片越暗</p><h5 id="before："><a href="#before：" class="headerlink" title="before："></a>before：</h5><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061858116.png" alt="截屏2023-01-06 18.57.57"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061858319.png" alt="截屏2023-01-06 18.56.21"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061858195.png" alt="截屏2023-01-06 18.56.29"></p><h5 id="after："><a href="#after：" class="headerlink" title="after："></a>after：</h5><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061858048.png" alt="截屏2023-01-06 18.56.47"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061858987.png" alt="截屏2023-01-06 18.57.03"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061858832.png" alt="截屏2023-01-06 18.57.10"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Skill" scheme="https://chunyujin.top/categories/Skill/"/>
    
    <category term="Hero" scheme="https://chunyujin.top/categories/Skill/Hero/"/>
    
    
    <category term="Hexo" scheme="https://chunyujin.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>常用指令&amp;权限管理</title>
    <link href="https://chunyujin.top/chunyujin/1c776eb1.html"/>
    <id>https://chunyujin.top/chunyujin/1c776eb1.html</id>
    <published>2023-01-06T08:50:00.000Z</published>
    <updated>2023-01-06T08:50:50.738Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><h4 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h4><h5 id="文件的分类"><a href="#文件的分类" class="headerlink" title="文件的分类"></a>文件的分类</h5><blockquote><p><strong>普通文件</strong>，文件属性为[-]</p><p><strong>目录文件</strong>，属性为[d]，文件夹(目录)也是一种文件，是内容为文件的文件，是能用 # cd指令进入的</p><p><strong>块设备文件</strong>，属性为[b]，表示为装置文件里面的可供储存的接口设备(可随机存取装置)，比如硬盘、光驱等。例如一号硬盘的代码是 &#x2F;dev&#x2F;hda1等文件</p><p><strong>字符设备文件</strong>，属性为[c]，表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)、屏幕等</p><p><strong>套接字文件</strong>，属性为[s]，这类文件通常用在网络数据连接，可以启动一个程序来监听客户端的要求，客户端就可以通过套接字来进行数据通信。最常在 &#x2F;var&#x2F;run目录中看到这种文件类型</p><p><strong>管道文件</strong>，属性为[p]，FIFO也是一种特殊的文件类型，它主要的目的是，解决多个程序同时存取一个文件所造成的错误。FIFO是first-in-first-out(先进先出)的缩写</p><p><strong>链接文件</strong>，属性为[l]，类似于Windows里的快捷方式和macOS的替身</p></blockquote><h5 id="文件-x3D-文件属性-文件内容"><a href="#文件-x3D-文件属性-文件内容" class="headerlink" title="文件 &#x3D; 文件属性 + 文件内容"></a>文件 &#x3D; 文件属性 + 文件内容</h5><blockquote><p>当我们在电脑上创建了一个空白文档的时候，查看一下文件的详细信息，会发现这个空白文档并不是占用了0内存，它是占用了内存的。因为要存储这个文档的属性，包括创建时间、修改日期、种类、拥有者等等</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212291208514.png" alt="截屏2022-12-29 12.08.43" style="zoom:50%;" /></blockquote><h5 id="常用的单词："><a href="#常用的单词：" class="headerlink" title="常用的单词："></a>常用的单词：</h5><blockquote><p>command 命令</p><p>option 选项</p><p>dirname 目录名</p></blockquote><h4 id="建议有不懂的指令就去man查找！"><a href="#建议有不懂的指令就去man查找！" class="headerlink" title="建议有不懂的指令就去man查找！"></a>建议有不懂的指令就去man查找！</h4><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><p>一个指令由基本指令、选项、目标、其他内容组成的，除基本指令外的内容都并不是必须的，内容对应相应功能</p><p>一条指令可以添加多个选项，意味着一条指令实现多种功能的结合</p><p>&#x3D;&#x3D;<strong>凡是放方括号里的内容都代表不是必须的，可以不存在</strong>&#x3D;&#x3D;，括号外的内容都是必须的</p><p><strong>指令中，选项的位置正常来讲是可以移动的，并不是固定的必须要按照某种顺序出现在某个位置</strong></p><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><p><code>ls [选项] [指定文件]</code></p><h5 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h5><p>对于目录，该命令列出该目录下的所有文件；对于一般文件，将列出该文件。(默认是按照名称排序的)</p><p>&#x3D;&#x3D;（如果不跟指定目录或文件，则默认是当前目录）&#x3D;&#x3D;</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181010049.png" alt="截屏2022-12-18 10.10.52" style="zoom:50%;" /><h5 id="常用选项："><a href="#常用选项：" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-l # 列出各文件的详细信息。ls -l 可以简写成 ll</span><br><span class="line">-a # 列出所有文件， 包括以.开头的隐藏文件</span><br><span class="line">-d # 只显示指定目录，不显示目录内容</span><br><span class="line">-s(小写) # 显示文件的块数</span><br><span class="line">-S(大写) # 按大小降序排列</span><br><span class="line">-r # 反向排序</span><br><span class="line">-t # 按修改时间先后排序</span><br><span class="line">-h # 按用户易读的方式显示文件大小</span><br><span class="line">-k # 以k字节的形式输出大小(一般输出的时候就是以这种方式输出的，用处不是很大)</span><br><span class="line">-R # 列出所有子目录的文件(递归)</span><br><span class="line">-1 # 一行只输出一个文件</span><br><span class="line">-n # 用数字的UID、GID代替owner、group名称</span><br><span class="line">-i # 显示文件的inode(索引节点)</span><br><span class="line">-F # 在每个文件名后附上一个字符以说明该文件的类型，*表示可执行程序，/表示目录，@表示符号连接，|表示FIFOs，=表示套接字(sockets)。（目录类型识别）</span><br></pre></td></tr></table></figure><blockquote><p><strong>&#x3D;&#x3D;-l&#x3D;&#x3D; ：列出各文件的详细信息。<u>ls -l 可以简写成 ll</u></strong></p><div><center><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181050726.png" alt="image-20221218105015699" style="zoom:30%;" /><br>Linux文件默认是按照名称排序的</center></div><p><strong>&#x3D;&#x3D;-a&#x3D;&#x3D; ：列出所有文件， 包括以.开头的隐藏文件。例如：ls -a [指定目标]</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181011049.png" alt="截屏2022-12-18 10.11.38" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181015520.png" alt="截屏2022-12-18 10.15.19" style="zoom:50%;" /><blockquote><p>可以看出当前目录.和上级目录..是作为隐藏文件保存的</p><p><strong>注意：当前目录.和上级目录..算是当前目录的子目录！</strong></p><p>所以会显示当前目录.的子目录个数是7，分别是：当前目录.，上级目录..，code，date，dir1，dir1-bak，test1</p><p>显示code目录中的子目录个数是3，但是实际上一看code中只有一个子目录hellobite，这就是因为code的当前目录和上级目录也算作了code的子目录，而当前目录和上级目录是隐藏文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181038966.png" alt="截屏2022-12-18 10.38.42" style="zoom:50%;" /><p>同样，显示code的子目录hellobite含有的子目录的个数是2，但是实际上查看发现hellobite中没有子目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181039261.png" alt="截屏2022-12-18 10.39.46" style="zoom:50%;" /></blockquote><p><strong>&#x3D;&#x3D;-d&#x3D;&#x3D; ：只显示指定目录，不显示目录内容</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181016521.png" alt="截屏2022-12-18 10.16.52" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181013186.png" alt="截屏2022-12-18 10.13.50" style="zoom:50%;" /><p><strong>&#x3D;&#x3D;-s&#x3D;&#x3D;（小写 ：显示文件的块数</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181216093.png" alt="截屏2022-12-18 12.16.51" style="zoom:50%;" /><p><strong>&#x3D;&#x3D;-S&#x3D;&#x3D;（大写：按大小降序排列</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181232314.png" alt="截屏2022-12-18 12.32.31" style="zoom:50%;" /><p><strong>&#x3D;&#x3D;-r&#x3D;&#x3D; ：反向排序</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181530665.png" alt="截屏2022-12-18 15.30.32" style="zoom:50%;" /><p><strong>&#x3D;&#x3D;-t&#x3D;&#x3D; ： 按修改时间先后排序</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181706732.png" alt="image-20221218170624706" style="zoom:50%;" /><p><strong>&#x3D;&#x3D;-h&#x3D;&#x3D; ：按用户易读的方式显示文件大小</strong></p><p>就是换算了一下单位</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181640118.png" alt="截屏2022-12-18 16.40.15" style="zoom:50%;" /><p><strong>&#x3D;&#x3D;-R&#x3D;&#x3D; ： 列出所有子目录的文件(递归)</strong></p><center class = "half">        <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181722837.png" alt="截屏2022-12-18 17.22.03" style="zoom:40%;" />                <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181723755.png" alt="iShot_2022-12-18_17.21.42" style="zoom:35%;" /></center><p><strong>&#x3D;&#x3D;-1&#x3D;&#x3D; ： 一行只输出一个文件</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181736886.png" alt="截屏2022-12-18 17.36.33" style="zoom:50%;" /><p>&#x3D;&#x3D;-n&#x3D;&#x3D;：用数字的UID、GID代替owner、group名称</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181741224.png" alt="截屏2022-12-18 17.41.47" style="zoom:50%;" /><p>&#x3D;&#x3D;-i&#x3D;&#x3D;：显示文件的inode(索引节点)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181929066.png" alt="截屏2022-12-18 19.29.50" style="zoom:50%;" /><p>&#x3D;&#x3D;-F&#x3D;&#x3D;：在每个文件名后附上一个字符以说明该文件的类型，*表示可执行程序，&#x2F;表示目录，@表示符号连接，|表示FIFOs，&#x3D;表示套接字(sockets)。（目录类型识别）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212190918116.png" alt="截屏2022-12-19 09.17.01" style="zoom:50%;" /></blockquote><h4 id="文件块-简介"><a href="#文件块-简介" class="headerlink" title="文件块(简介)"></a>文件块(简介)</h4><p>(后续会详细学习)</p><p>Linux系统的心脏部分就是其文件系统，文件系统提供了层次结构的目录和文件。</p><p>一般情况下，文件系统将磁盘空间划分为<font color = red>每1024个字节一组，也称为一块</font>（有的Linux将512字节划为一块），编号从0到整个内存的最大块数。</p><p>文件访问系统访问磁盘的时候基本单位是4kb，也就是说是4个块为一个基本单位</p><p>所以在查看文件的总块数的时候会发现都是4的倍数</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181216093.png" alt="截屏2022-12-18 12.16.51" style="zoom:50%;" /><h4 id="inode索引节点-简介"><a href="#inode索引节点-简介" class="headerlink" title="inode索引节点(简介)"></a>inode索引节点(简介)</h4><p>(后续会详细学习)</p><p>用来存放档案和目录的基本信息，包含时间、档名、使用者及群组等</p><h4 id="UID和GID-简介"><a href="#UID和GID-简介" class="headerlink" title="UID和GID(简介)"></a>UID和GID(简介)</h4><p>(后续会详细学习)</p><p>登陆 Linux 系统时，虽然输入的是自己的用户名和密码，但其实 Linux 并不认识你的用户名称，它只认识用户名对应的 ID 号（也就是一串数字）。Linux 系统将所有用户的名称与 ID 的对应关系都存储在 &#x2F;etc&#x2F;passwd 文件中</p><blockquote><p>说白了，用户名并无实际作用，仅是为了方便用户的记忆而已。</p></blockquote><p>Linux 系统中，每个用户的 ID 细分为 2 种，分别是用户 ID（User ID，简称 UID）和组 ID（Group ID，简称 GID），这与文件有拥有者和拥有群组两种属性相对应</p><p>每个文件都有自己的拥有者 ID 和群组 ID，当显示文件属性时，系统会根据 &#x2F;etc&#x2F;passwd 和 &#x2F;etc&#x2F;group 文件中的内容，分别找到 UID 和 GID 对应的用户名和群组名，然后显示出来</p><center><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181915000.gif" /></center><blockquote><p>&#x2F;etc&#x2F;passwd 文件和 &#x2F;etc&#x2F;group 文件，后续文章会做详细讲解，这里只需要知道，在 &#x2F;etc&#x2F;passwd 文件中，利用 UID 可以找到对应的用户名；在 &#x2F;etc&#x2F;group 文件中，利用 GID 可以找到对应的群组名</p></blockquote><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><p><code>pwd</code></p><h5 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h5><p>显示用户当前所在目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212190925534.png" alt="image-20221219092508502" style="zoom:50%;" /><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><h5 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h5><p><code>cd [指定目录]</code></p><h5 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a>功能：</h5><p>进入到指定目录下</p><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd .. # 返回上级目录(相对路径)</span><br><span class="line">cd /home/litao/linux/ # 绝对路径 </span><br><span class="line">cd ../day02/ # 相对路径</span><br><span class="line">cd ~ # 进入用户家目录</span><br><span class="line">cd - # 返回最近访问的目录</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212190929706.png" alt="截屏2022-12-19 09.29.01" style="zoom:50%;" /><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><h5 id="语法：-3"><a href="#语法：-3" class="headerlink" title="语法："></a>语法：</h5><p><code>date [option]......[+format]</code></p><p>option用来设置时间</p><p>format用来显示时间</p><h5 id="功能：-3"><a href="#功能：-3" class="headerlink" title="功能："></a>功能：</h5><p>显示与设定系统的日期与时间</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221219111457827.png" alt="image-20221219111457827" style="zoom:80%;" /><h5 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h5><ol><li>显示时间：</li></ol><p>使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中常用的标记列表如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+%Y # 显示完整年份(0000~9999)</span><br><span class="line">+%m # 显示月份(1~12)</span><br><span class="line">+%d # 显示天(01~31)</span><br><span class="line">+%F # 显示年月日，相当于指令 +%Y-%m-%d</span><br><span class="line">+%H # 显示小时(00~23)</span><br><span class="line">+%M # 显示分钟(00~59)</span><br><span class="line">+%S # 显示秒(00~61)</span><br><span class="line">+%X # 显示时分秒，相当于指令 +%H:%M:%S</span><br></pre></td></tr></table></figure><center>  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191246406.png" alt="截屏2022-12-19 12.46.55" style="zoom:50%;" />  <br>  Mac的终端默认是中文所以输出的最后一行是中文的</center><ol start="2"><li>设定时间</li></ol><p>只有root才有权限设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">date -s # 设置当前时间，只有root权限才能设置，其他只能查看。</span><br><span class="line">date -s 20080523 # 设置成20080523，这样会把具体时间设置成空00:00:00 </span><br><span class="line">date -s 01:01:01 # 设置具体时间，不会对日期做更改</span><br><span class="line">date -s &quot;01:01:01 2008-05-23&quot; # 这样可以设置全部时间</span><br><span class="line">date -s &quot;01:01:01 20080523&quot; # 这样可以设置全部时间</span><br><span class="line">date -s &quot;2008-05-23 01:01:01&quot; # 这样可以设置全部时间</span><br><span class="line">date -s &quot;20080523 01:01:01&quot; # 这样可以设置全部时间</span><br></pre></td></tr></table></figure><p>3.时间戳转换</p><p>Unix时间戳(英文为Unix epoch, Unix time, POSIX time 或 Unix timestamp)是从1970年1月1日(UTC&#x2F;GMT的 午夜)开始所经过的秒数，不考虑闰秒</p><p>时间-&gt;时间戳：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date +%s </span><br></pre></td></tr></table></figure><p>时间戳-&gt;时间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -d@时间戳时间</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191256969.png" alt="截屏2022-12-19 12.56.52" style="zoom:50%;" /><h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><h5 id="语法：-4"><a href="#语法：-4" class="headerlink" title="语法："></a>语法：</h5><p><code>cal [option] [月份] [年份]</code></p><h5 id="功能：-4"><a href="#功能：-4" class="headerlink" title="功能："></a>功能：</h5><p>查看并输出指定年份的指定月份的日历</p><p>省略月份则输出指定年份整年的日历(如果只有一个参数，只能表示年份)</p><p>都省略则输出系统时间所在月的日历</p><h5 id="常用选项：-1"><a href="#常用选项：-1" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-3 # 显示指定日期所在的前一个月份、当前月份、后一个月份的日历</span><br><span class="line">-j # 显示指定日期在当前年中的第几天(从1月1号开始算)</span><br><span class="line">-y # 显示一整年12个月的日历</span><br></pre></td></tr></table></figure><figure class="half">  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222248298.png" alt="截屏2022-12-22 22.42.54" style="zoom:40%;" />  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222248633.png" alt="截屏2022-12-22 22.47.35" style="zoom: 40%;" /></figure><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><h5 id="语法：-5"><a href="#语法：-5" class="headerlink" title="语法："></a>语法：</h5><p><code>touch [选项]……[文件]……</code></p><h5 id="功能：-5"><a href="#功能：-5" class="headerlink" title="功能："></a>功能：</h5><ol><li>如果文件已存在，更改文件(包括目录文件)的时间记录，包括存取时间和修改时间</li><li>如果文件不存在，创建这个文件(不能新建目录)</li></ol><center class = "half">  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191000119.png" alt="截屏2022-12-19 09.59.53" style="zoom:45%;" />  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191000049.png" alt="截屏2022-12-19 10.00.01" style="zoom:45%;" />  </center><h5 id="常用选项：-2"><a href="#常用选项：-2" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-a，--time=atime，--time=access，--time=use # 只更改存取时间</span><br><span class="line">-m，--time=mtime，--time=modify # 只更改修改时间</span><br><span class="line">-c，--no-creat # 不创建文件</span><br><span class="line">-d [时间] # 将时间记录改为给定的时间，时间可以使用各种不同的格式</span><br><span class="line">-t [时间] # 将时间记录改为给定的时间，时间必须使用[[YY]YY]MMDDhhmm[.SS]，不再放括号里的是必须有的，方括号里的是可以省略的</span><br><span class="line">-r [参考文件] # 将时间记录改为跟参考文件一样的时间</span><br><span class="line">-f # 会被忽略处理，是为了与其他 unix 系统的相容性而保留</span><br></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;-a&#x3D;&#x3D;</p><p>无法直观展示</p><p>&#x3D;&#x3D;-m&#x3D;&#x3D;</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191004398.png" alt="image-20221219100439373" style="zoom:50%;" /><p>&#x3D;&#x3D;-c&#x3D;&#x3D;</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191005165.png" alt="image-20221219100520143" style="zoom:50%;" /><p>&#x3D;&#x3D;-d [时间]&#x3D;&#x3D;</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191008543.png" alt="截屏2022-12-19 10.07.57" style="zoom:50%;" /><p>&#x3D;&#x3D;-t&#x3D;&#x3D; [时间]</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191713110.png" alt="截屏2022-12-19 17.13.54" style="zoom:50%;" /></blockquote><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><h5 id="语法：-6"><a href="#语法：-6" class="headerlink" title="语法："></a>语法：</h5><p><code>mkdir [-p] DIRNAME</code></p><h5 id="功能：-6"><a href="#功能：-6" class="headerlink" title="功能："></a>功能：</h5><p>在当前目录下创建一个名为DIRNAME的目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191720623.png" alt="截屏2022-12-19 17.20.02" style="zoom:50%;" /><h5 id="常用选项：-3"><a href="#常用选项：-3" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p # 后跟一个路径。如果路径中有不存在的目录，则会创建出这些不存在的路径。也就是可以一次性创建一个路径，多个目录。（或--parents）</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191725268.png" alt="截屏2022-12-19 17.25.07" style="zoom:50%;" /><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><h5 id="语法：-7"><a href="#语法：-7" class="headerlink" title="语法："></a>语法：</h5><p><code>rmdir [-p] 目录</code></p><h5 id="适用对象："><a href="#适用对象：" class="headerlink" title="适用对象："></a>适用对象：</h5><p>具有指定目录的权限的所有使用者</p><h5 id="功能：-7"><a href="#功能：-7" class="headerlink" title="功能："></a>功能：</h5><p>删除指定目录，目录必须是空的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191733118.png" alt="截屏2022-12-19 17.33.29" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191736474.png" alt="截屏2022-12-19 17.36.12" style="zoom:50%;" /><h5 id="常用选项：-4"><a href="#常用选项：-4" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-p # 当指定目录被删除后它的父目录变成空的话，连同父目录一起删除</span><br><span class="line">* # 借助通配符*，满足匹配条件的文件都会被复制。</span><br><span class="line">? # 同上</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191739720.png" alt="截屏2022-12-19 17.39.04" style="zoom:50%;" /><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><h5 id="语法：-8"><a href="#语法：-8" class="headerlink" title="语法："></a>语法：</h5><p><code>rm [option] 文件</code></p><h5 id="适用对象：-1"><a href="#适用对象：-1" class="headerlink" title="适用对象："></a>适用对象：</h5><p>所有使用者</p><h5 id="功能：-8"><a href="#功能：-8" class="headerlink" title="功能："></a>功能：</h5><p>删除文件，搭配选项可以删除目录</p><p>注意，文件一旦删除无法恢复！</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212200955025.png" alt="截屏2022-12-20 09.55.42" style="zoom:50%;" /><h5 id="常用选项：-5"><a href="#常用选项：-5" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-r # 删除目录及其下所有文件</span><br><span class="line">* # 借助通配符*，满足匹配条件的文件都会被复制。</span><br><span class="line">? # 同上</span><br><span class="line">-f # 即使文件属性为只读(即写保护)，亦直接删除，无需逐一确认</span><br><span class="line">-i # 删除前逐一询问确认</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201000703.png" alt="截屏2022-12-20 10.00.09" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201003511.png" alt="截屏2022-12-20 10.03.31" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201000976.png" alt="截屏2022-12-20 10.00.26" style="zoom:50%;" /><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><h5 id="语法：-9"><a href="#语法：-9" class="headerlink" title="语法："></a>语法：</h5><p><code>man [option] command</code></p><h5 id="功能：-9"><a href="#功能：-9" class="headerlink" title="功能："></a>功能：</h5><p>查找指定命令的用法</p><h5 id="补充说明："><a href="#补充说明：" class="headerlink" title="补充说明："></a>补充说明：</h5><ol><li><p>Linux手册是联机手册，进行联机查找</p></li><li><p>执行<code>man man</code>指令可以查询man的详细信息，包括用法、每章节的内容分类等</p></li><li><p>帮助文档分为8章：</p><blockquote><p>1 是普通的命令 </p><p>2 是系统调用,如open,write之类的(通过这个，至少可以很方便的查到调用这个函数，需要加什么头文 件) </p><p>3 是库函数,如printf,fread</p><p>4 是特殊文件,也就是&#x2F;dev下的各种设备文件 </p><p>5 是指文件的格式,比如passwd, 就会说明这个文件中各个字段的含义 </p><p>6 是给游戏留的,由各个游戏自己定义</p><p>7 是附件还有一些变量,比如向environ这种全局变量在这里就有说明 </p><p>8 是系统管理用的命令,这些命令只能由root使用,如ifconfig </p></blockquote></li><li><p>man 命令中常用按键以及用途</p><table><thead><tr><th>按键</th><th>用途</th></tr></thead><tbody><tr><td>空格键</td><td>向下翻一页</td></tr><tr><td>PaGe down</td><td>向下翻一页</td></tr><tr><td>PaGe up</td><td>向上翻一页</td></tr><tr><td>home</td><td>直接前往首页</td></tr><tr><td>end</td><td>直接前往尾页</td></tr><tr><td>&#x2F;</td><td>从上至下搜索某个关键词，如“&#x2F;linux”</td></tr><tr><td>？</td><td>从下至上搜索某个关键词，如“?linux”</td></tr><tr><td>n</td><td>定位到下一个搜索到的关键词</td></tr><tr><td>N</td><td>定位到上一个搜索到的关键词</td></tr><tr><td>q</td><td>退出帮助文档</td></tr><tr><td>鼠标滚轮</td><td>上下翻页</td></tr></tbody></table></li></ol><h5 id="常用选项：-6"><a href="#常用选项：-6" class="headerlink" title="常用选项："></a><a href="https://cloud.tencent.com/developer/article/1725969">常用选项：</a></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num # 只在第num章节中进行查找</span><br><span class="line">-k # 后面的command可以是缺省的，进行模糊查找</span><br><span class="line">-a，--all # 寻找所有匹配的手册页</span><br><span class="line">-f，--whatis # 相当于whatis</span><br><span class="line">-i，--ignore-case # 查找手册页时不区分大小写(默认)</span><br><span class="line">-I，--match-case # 区分大小写</span><br></pre></td></tr></table></figure><h4 id="whatis"><a href="#whatis" class="headerlink" title="whatis"></a>whatis</h4><p>Linux 中的 <code>whatis</code> 命令可以从它的字面意思可以看出来，就是“这是什么”，通过它可以知道某命令是用来干什么的，而且是用很简短的方式来描述。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201055267.png" alt="截屏2022-12-20 10.55.10" style="zoom:50%;" /><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><h5 id="语法：-10"><a href="#语法：-10" class="headerlink" title="语法："></a>语法：</h5><p><code>cp [option] 源文件 指定目录下的目标文件</code></p><h5 id="功能：-10"><a href="#功能：-10" class="headerlink" title="功能："></a>功能：</h5><p>将 源文件 在指定目录下 复制出指定文件</p><blockquote><p>如果省略指定目录，则默认是当前目录</p><p>如果省略目标文件，则会在指定目录下复制出跟源文件同名的文件</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201625241.png" alt="截屏2022-12-20 16.25.29" style="zoom:50%;" /><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><ol><li><p>本质过程是根据源文件复制创建出一个新的文件，所以如果目标文件跟已存在的文件重名，会覆盖已存在的文件(且默认不会询问)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201628004.png" alt="截屏2022-12-20 16.28.04" style="zoom:50%;" /></li><li><p>如果要复制目录，则必须加上<code>-r</code>选项，</p></li><li><p>指定文件的类型必须跟源文件类型一样，普通文件只能复制出普通文件，源文件只能复制出源文件</p></li><li><p>可以一次性复制多个源文件，各个源文件之间用空格间隔，最后跟一个指定目录，各个源文件会复制到指定目录中去</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201630006.png" alt="截屏2022-12-20 16.30.35" style="zoom:50%;" /></li></ol><h5 id="常用选项：-7"><a href="#常用选项：-7" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-r # 复制目录(并递归复制该源目录下所有的子目录和文件)</span><br><span class="line">-f，--force # 强制复制，且覆盖已经存在的文件之前不询问用户。如果文件不能打开，可以用它强行复制</span><br><span class="line">-i，--interactive # 在覆盖已存在的文件之前选询问用户(与-f相反)</span><br><span class="line">-u # 当源文件比目标文件新时才会复制，否则不复制成目标文件</span><br><span class="line">* # 借助通配符*，满足匹配条件的文件都会被复制。</span><br><span class="line">? # 同上</span><br></pre></td></tr></table></figure><h4 id="通配符-简介"><a href="#通配符-简介" class="headerlink" title="通配符(简介)"></a>通配符(简介)</h4><p>(后续会详细学习)</p><p>linux常用通配符有* ，？，[ ]，[^]，[:space:]，[:punct:]，[:lower:]，[:upper:]，[:digit:]，[:alnum:]等等</p><p>它是由shell解析，并且一般用于匹配文件名，实际上就是shell解释器去解析的特殊符号</p><blockquote><blockquote><ol><li><p>&#x3D;&#x3D;<strong>通配符不仅会匹配当前目录下的满足条件的文件，还会<u>递归匹配</u>子目录下的满足条件的文件</strong>&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;<strong>开始字符和结束字符都可以省略</strong>&#x3D;&#x3D;</p><blockquote><p>在匹配文件的时候，被匹配的文件名会被分成三部分：开始字符、中间字符、结束字符</p><p>分别对应文件名的开头、中间、结尾</p><blockquote><p>如果开始字符被省略，那么被匹配的字符就变成了：中间字符、结束字符</p><p>则文件名的开头、中间都被视为中间字符，结尾被视为结束字符</p><p>匹配时寻找 文件名结尾 跟 结束字符 相同，且 文件名开头和中间 满足中间字符要求 的文件</p><p>(比如有的通配符要求中间只能有一个字符，那么只有文件名结尾跟结束字符相同，且除了文件名结尾之外的部分(也就是开头和中间)只有一个字符的才能满足匹配要求)</p></blockquote><blockquote><p>如果结束字符被省略，那么被匹配的字符就变成了：开始字符、结束字符</p><p>那么文件名的开头被视为开始字符，中间和结尾被视为结束字符</p><p>匹配时寻找 文件名开头 跟 开始字符 相同，且 文件名中间和结尾 满足中间字符要求 的文件</p></blockquote><blockquote><p>如果开始字符和结束字符都被省略，被匹配的字符只有中间字符</p><p>整个文件名都被视为中间字符，所有 满足中间字符要求 的文件名都会被匹配上</p></blockquote></blockquote></li></ol></blockquote><p>**&#x3D;&#x3D;<em>：匹配任意多个字符&#x3D;&#x3D;</em>*</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开始字符*结束字符 # 会匹配满足 文件名开头 和 文件名结尾 分别与开始字符和结束字符相同的、中间有任意多个字符的文件</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201812569.png" alt="截屏2022-12-20 18.12.08" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201940130.jpeg" alt="IMG_0865" style="zoom:40%;" /><p><strong>&#x3D;&#x3D;?：匹配任意一个字符&#x3D;&#x3D;</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开始字符?结束字符 # 会匹配满足 文件名开头 和 文件名结尾 分别与开始字符和结束字符相同的、中间只有一个字符的文件。</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202250451.png" alt="截屏2022-12-20 22.50.14" style="zoom:50%;" /><p>&#x3D;&#x3D;<strong>[…]：匹配中括号内出现的任意一个字符</strong>&#x3D;&#x3D;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开始字符[…]结束字符 # 会匹配满足 文件名开头 和 文件名结尾 分别与开始字符和结束字符相同的、中间存在于[]内且只有一个字符的文件</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202311425.png" alt="截屏2022-12-20 23.11.52" style="zoom:50%;" /><p>&#x3D;&#x3D;<strong>[!…]：不匹配中括号内出现的任意一个字符</strong>&#x3D;&#x3D;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开始字符[!…]结束字符 # 会匹配满足 文件名开头 和 文件名结尾 分别与开始字符和结束字符相同的、中间不存在于[]内且只有一个字符的文件</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202317821.png" alt="截屏2022-12-20 23.17.01" style="zoom:50%;" /></blockquote><p><strong>&#x3D;&#x3D;通配符可以作为一个选项，在非常多的命令中都可以用到，用来匹配文件名&#x3D;&#x3D;</strong></p><p>一般出现在要shell命令或脚本中，匹配特定的文件名</p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><h5 id="语法：-11"><a href="#语法：-11" class="headerlink" title="语法："></a>语法：</h5><p><code>mv [option] 源文件 指定目录</code></p><p><code>mv [option] 源文件 文件名</code>(文件名也可以是指定目录下的某个文件的文件名，但是这样不是多此一举了吗)</p><h5 id="功能：-11"><a href="#功能：-11" class="headerlink" title="功能："></a>功能：</h5><p>将 源文件 <strong>移动</strong> 到指定目录下。如果指定目录下存在与源文件重名的文件，则默认会被刚移动进来的源文件覆盖掉</p><p>将 源文件 <strong>改名</strong>为 给定的文件名。如果当前目录下已经存在与给定文件名重名的文件，则默认会被新改过名的源文件覆盖掉</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202331000.png" alt="截屏2022-12-20 23.31.16" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202343117.png" alt="截屏2022-12-20 23.43.13" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202333934.png" alt="截屏2022-12-20 23.33.52" style="zoom:50%;" /><h5 id="常用选项：-8"><a href="#常用选项：-8" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-f # force强制，在移动或改名时，如果出现了重名情况，不会询问而是直接复覆盖</span><br><span class="line">-i # 在移动或改名时，如果出现了重名情况，会询问是否覆盖</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202348339.png" alt="截屏2022-12-20 23.48.30" style="zoom:50%;" /><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><h5 id="语法：-12"><a href="#语法：-12" class="headerlink" title="语法："></a>语法：</h5><p><code>cat [选项] [目标文件]</code></p><h5 id="功能：-12"><a href="#功能：-12" class="headerlink" title="功能："></a>功能：</h5><p>输出内容到指定输出设备(默认指定输出设备是显示器)：</p><p>如果目标文件没被省略，<strong>打印&#x2F;输出</strong>目标文件的内容</p><p>如果目标文件被省略，则是<strong>打印&#x2F;输出</strong>刚刚从键盘上输入的内容(Linux下一切皆文件，默认将键盘视为了文件)，ctrl + c结束</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202353491.png" alt="image-20221220235315449" style="zoom:50%;" /><h5 id="常用选项：-9"><a href="#常用选项：-9" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-b # 对非空输出行编号 </span><br><span class="line">-n # 对输出的所有行编号</span><br><span class="line">-s # 不输出多行空行 </span><br></pre></td></tr></table></figure><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><h5 id="语法：-13"><a href="#语法：-13" class="headerlink" title="语法："></a>语法：</h5><p><code>more [选项] 文件</code></p><h5 id="功能：-13"><a href="#功能：-13" class="headerlink" title="功能："></a>功能：</h5><p>类似于cat，但是逐页后翻逐页<strong>打印&#x2F;输出</strong>，并可以查看前面已<strong>打印&#x2F;输出</strong>的内容，支持跳转</p><h5 id="按键用途："><a href="#按键用途：" class="headerlink" title="按键用途："></a>按键用途：</h5><blockquote><table><thead><tr><th>按键</th><th>用途</th></tr></thead><tbody><tr><td>空格space，f，ctrl+f</td><td>向下滚动一屏(后翻，下一页)</td></tr><tr><td>b(意味着back)，ctrl+b</td><td>向上滚动一屏(前翻，上一页)</td></tr><tr><td>q</td><td>退出查看</td></tr><tr><td>enter</td><td>向下n行，需要定义。默认为1行</td></tr><tr><td>&#x3D;</td><td>输出当前的行号</td></tr><tr><td>!命令</td><td>调用shell，并执行命令</td></tr><tr><td>v</td><td>调用vi编辑器</td></tr></tbody></table></blockquote><blockquote><p>向后翻页</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212211159652.gif" alt="Dec-21-2022 11-58-30" style="zoom: 80%;" /><p>向前翻页，按q退出</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212211200255.gif" alt="Dec-21-2022 11-59-56" style="zoom:80%;" /><p>文件内容是被打印出来的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212211204121.gif" alt="Dec-21-2022 12-03-52" style="zoom:80%;" /></blockquote><h5 id="常用选项：-10"><a href="#常用选项：-10" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+NUM # 从文件的第NUM行开始打印</span><br><span class="line">-NUM # 每页只输出NUM行</span><br><span class="line">+/STRING # 在目标文件中寻找含有字符串STRING的一行，并从它的前两行开始打印</span><br><span class="line">-p # 不滚屏，清屏并打印文本</span><br><span class="line">-c # 不滚屏，打印文本并清理行尾</span><br><span class="line">-u # 不打印文件中的下划线</span><br><span class="line">-s # 压缩多个连续空行为一个空行</span><br><span class="line">-d # 显示帮助，提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能</span><br><span class="line">-f # 统计逻辑行数而不是屏幕行数</span><br><span class="line">-l # 忽略ctrl+l(换页)字符，抑制换页(form feed)后的暂停</span><br></pre></td></tr></table></figure><h5 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h5><p>cat和more指令的本质是将文件内容&#x3D;&#x3D;<strong>打印</strong>&#x3D;&#x3D;出来。</p><p>因此实际上只能不断打印输出文件后面的内容，对于文件前面的内容，只能通过翻页的方式查看已经打印出来的。</p><p>当用 more +NUM，从第NUM行开始查看的时候，NUM行之前的内容由于没有被打印出来，所以无法查看到。</p><p>&#x3D;&#x3D;所以cat和more指令更像是文件内容打印指令，而不是正统的文件内容查看指令。&#x3D;&#x3D;</p><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><h5 id="说明：-2"><a href="#说明：-2" class="headerlink" title="说明："></a>说明：</h5><p>&#x3D;&#x3D;Linux正统的文件内容查看工具&#x3D;&#x3D;</p><p>less是进入文件内部加载，进行浏览查看，而不是将文件内容打印出来再进行查看</p><p>less在查看之前不会加载整个文件，只加载浏览位置的内容</p><p>less可以随意浏览文件内容，可以用上下、翻页(pagedown\pageup)、空格、回车、b、f等按键 随意前后移动查看，功能强大，用法具有弹性</p><blockquote><p>前后移动查看</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212211220727.gif" alt="Dec-21-2022 12-20-22" style="zoom:80%;" /><p>退出，发现less并不是将文件内容打印出来，而是进入文件加载，进行浏览查看</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212211223871.gif" alt="Dec-21-2022 12-22-53" style="zoom:80%;" /></blockquote><h5 id="语法：-14"><a href="#语法：-14" class="headerlink" title="语法："></a>语法：</h5><p><code>less [option] 文件</code></p><h5 id="按键用途：-1"><a href="#按键用途：-1" class="headerlink" title="按键用途："></a>按键用途：</h5><table><thead><tr><th>按键</th><th>用途</th></tr></thead><tbody><tr><td>按键</td><td>用途</td></tr><tr><td>空格space，f，ctrl+f，pageup</td><td>向下滚动一屏(后翻，下一页)</td></tr><tr><td>b(意味着back)，ctrl+b，pagedown</td><td>向上滚动一屏(前翻，上一页)</td></tr><tr><td>d，ctrl + d</td><td>向下滚动半屏</td></tr><tr><td>u，ctrl + u</td><td>向上移动半屏</td></tr><tr><td>↓，j</td><td>向下滚动一行</td></tr><tr><td>↑，k</td><td>向上滚动一行</td></tr><tr><td>g</td><td>移动到第一行</td></tr><tr><td>NUMg</td><td>移动到文件的第NUM行</td></tr><tr><td>G</td><td>移动到最后一行</td></tr><tr><td>enter</td><td>向下n行，需要定义。默认为1行</td></tr><tr><td>q，ZZ</td><td>退出查看</td></tr><tr><td>&#x2F;STRING</td><td>向下搜索“STRING”</td></tr><tr><td>?STRING</td><td>向上搜索“STRING”</td></tr><tr><td>n</td><td>重复前一个搜索（与 &#x2F; 或 ? 有关）</td></tr><tr><td>N</td><td>反向重复前一个搜索（与 &#x2F; 或 ? 有关）</td></tr><tr><td>ma</td><td>使用a标记文本的当前位置</td></tr><tr><td>a</td><td>跳转到a标记处</td></tr><tr><td>h</td><td>显示less的帮助文档</td></tr><tr><td>!命令</td><td>调用shell，并执行命令</td></tr><tr><td>v</td><td>调用vi编辑器</td></tr></tbody></table><h5 id="常用选项-可以在浏览文件时使用"><a href="#常用选项-可以在浏览文件时使用" class="headerlink" title="常用选项(可以在浏览文件时使用):"></a>常用选项(可以在浏览文件时使用):</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-i # 忽略搜索时的大小写</span><br><span class="line">-N # 显示每行的行号，再用一次会取消显示每行的行号</span><br></pre></td></tr></table></figure><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><h5 id="语法：-15"><a href="#语法：-15" class="headerlink" title="语法："></a>语法：</h5><p><code>head [option] 文件</code></p><h5 id="功能：-14"><a href="#功能：-14" class="headerlink" title="功能："></a>功能：</h5><p>从指定文件的开头开始输出到标准输出，到文件的某位置结束。默认打印前10行</p><h5 id="常用选项：-11"><a href="#常用选项：-11" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-n +NUM # 打印前NUM行，可以简写成 -n NUM 或 -nNUM 或者 -NUM</span><br><span class="line">-n -NUM # 从第一行开始打印，到倒数第NUM行停止。</span><br><span class="line">-c +SIZE # 从头开始打印，到SIZE个字节停止。可以简写成 -c SIZE 或 -cSIZE</span><br><span class="line">-c -SIZE # 从头开始打印，到倒数第SIZE个字节停止。</span><br><span class="line">-q # 不显示详细处理信息，比如文件名 (默认就是隐藏的)</span><br><span class="line">-v # 显示详细处理信息</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222148587.png" alt="image-20221222214831555" style="zoom:50%;" /><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><h5 id="语法：-16"><a href="#语法：-16" class="headerlink" title="语法："></a>语法：</h5><p><code>tail [option] [文件]</code></p><h5 id="功能：-15"><a href="#功能：-15" class="headerlink" title="功能："></a>功能：</h5><p>有指定文件时，用于从文件某位置开始输出到标准输出，到文件末尾结束。默认打印文件的最后10行。</p><p>无指定文件时，作为输入信息进行处理。</p><p>常用来查看日志文件。</p><h5 id="常用选项：-12"><a href="#常用选项：-12" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-n -NUM # 从倒数第NUM行开始输出，到结尾结束。可以简写成 -n NUM 或 -nNUM 或 -NUM。</span><br><span class="line">-n +NUM # 从正数第NUM行开始输出，到结尾结束。</span><br><span class="line">-c -SIZE # 从倒数第SIZE个字节开始输出，到结尾结束。可以简写成 -c SIZE 或 -cSIZE</span><br><span class="line">-c +SIZE # 从正数第SIZE个字节开始输出，到结尾结束。</span><br><span class="line">-f # 循环读取</span><br><span class="line">-p # 不显示详细处理信息，比如文件名(默认就是不显示的)</span><br><span class="line">-v # 显示详细的处理信息</span><br><span class="line">-s S # 与-f合用，表示在每反复的间隔休息S秒</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222152371.png" alt="截屏2022-12-22 21.52.01" style="zoom:50%;" /><blockquote><p>现在创建了一个一共100行的文件，请取出第50行</p><center>  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222153309.png" alt="截屏2022-12-22 21.53.18" style="zoom:50%;" /><br>生成1到100的序列并输出重定向到文件atest</center><p>方法一：</p><blockquote><p>将atest的前50行输出重定向到新文件tmp中</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222157524.png" alt="截屏2022-12-22 21.57.55" style="zoom:50%;" /><p>输出tmp的最后一行</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222158536.png" alt="截屏2022-12-22 21.58.37" style="zoom:50%;" /></blockquote><p>方法二：</p><blockquote><p>利用管道，输出atest的前五十行的最后一行s</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222159422.png" alt="截屏2022-12-22 21.59.30" style="zoom:50%;" /></blockquote></blockquote><h4 id="管道-简介"><a href="#管道-简介" class="headerlink" title="管道(简介)"></a>管道(简介)</h4><p>将两个或者多个命令（程序或者进程）连接到一起，把一个命令的输出作为下一个命令的输入，以这种方式连接的两个或者多个命令就形成了<strong>管道（pipe）</strong></p><p>管道可以级联多个命令，将上一个命令的输出作为下一个命令的输入，实现流水线式的操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command1 | command2</span><br><span class="line">command1 | command2 |......| commandN </span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212220959035.png" alt="截屏2022-12-22 09.59.25" style="zoom:50%;" /><p>当在两个命令之间设置管道时，管道符<code>|</code>左边命令的输出就变成了右边命令的输入。只要第一个命令向标准输出写入，而第二个命令是从标准输入读取，那么这两个命令就可以形成一个管道。大部分的 Linux 命令都可以用来形成管道。</p><blockquote><p>这里需要注意，command1 必须有正确输出，而 command2 必须可以处理 command2 的输出结果；而且 command2 只能处理 command1 的正确输出结果，不能处理 command1 的错误信息。</p></blockquote><p>多个被级联起来的命令就像是组成了几条管道联通起来，数据资源在里面进行了传输，非常形象</p><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><h5 id="语法：-17"><a href="#语法：-17" class="headerlink" title="语法："></a>语法：</h5><p><code>echo [option] 输出内容 [输出重定向]</code></p><h5 id="功能：-16"><a href="#功能：-16" class="headerlink" title="功能："></a>功能：</h5><p>将内容输出到到标准输出(默认输出设备是显示器，可以通过输出重定向进行更改输出设备)</p><h5 id="常用选项：-13"><a href="#常用选项：-13" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-e # 支持反斜杠控制的字符转换(具体参见下表)</span><br><span class="line">-n # 取消输出后行末的换行符号(内容输出后换行)</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222100949.png" alt="截屏2022-12-22 21.00.02" style="zoom:50%;" /><center>控制字符表⬇️</center><table><thead><tr><th>控制字符</th><th>作 用</th></tr></thead><tbody><tr><td>\</td><td>输出\本身</td></tr><tr><td>\a</td><td>输出警告音</td></tr><tr><td>\b</td><td>退格键，也就是向左删除键</td></tr><tr><td>\c</td><td>取消输出行末的换行符。和“-n”选项一致</td></tr><tr><td>\e</td><td>Esc键</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\r</td><td>回车键</td></tr><tr><td>\t</td><td>制表符，也就是Tab键</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\Onnn</td><td>按照八进制 ASCII 码表输出字符。其中 0 为数字 0，nnn 是三位八进制数</td></tr><tr><td>\xhh</td><td>按照十六进制 ASCH 码表输出字符。其中 hh 是两位十六进制数</td></tr></tbody></table><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222106931.png" alt="截屏2022-12-22 21.06.54" style="zoom:50%;" /><p>echo经常搭配输出重定向使用，将输入输出到指定文件中，而且如果指定文件不存在，还会创建出来(输出重定向的作用)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222108421.png" alt="截屏2022-12-22 21.08.08" style="zoom:50%;" /><p><a href="http://c.biancheng.net/linux/echo.html">更高级的玩法还看这里</a></p><h4 id="重定向-简介"><a href="#重定向-简介" class="headerlink" title="重定向(简介)"></a>重定向(简介)</h4><p>Linux 中标准的<strong>输入设备&#x2F;标准输入 默认是 键盘</strong>，标准的<strong>输出设备&#x2F;标准输入 默认是 显示器</strong></p><ul><li>输入重定向：指的是重新指定设备来代替键盘作为新的输入设备；</li><li>输出重定向：指的是重新指定设备来代替显示器作为新的输出设备。</li></ul><blockquote><p>新的输入设备：通常是指文件或者命令的执行结果</p><p>新的输出设备：通常是指文件</p></blockquote><p><strong>输入重定向：</strong></p><blockquote><table><thead><tr><th>命令符号格式</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将指定文件作为命令的输入设备</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>表示从标准输入设备（键盘）中读入，直到遇到分界符才停止（读入的数据不包括分界符），这里的分界符其实就是自定义的字符串</td></tr><tr><td>命令 &lt; 文件 1 &gt; 文件 2</td><td>将文件 1 作为命令的输入设备，该命令的执行结果输出到文件 2 中。</td></tr></tbody></table><p>命令 &lt; 文件：用文件代替默认输入设备(键盘)的输入</p><blockquote><p>当使用cat命令时，如果不加目标文件，会从默认输入设备上获取输入并输出到默认输出设备</p><p>更改默认输入设备为指定文件(这就跟cat命令后面加目标文件一个效果了)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212221723418.png" alt="截屏2022-12-22 17.23.54" style="zoom:50%;" /></blockquote><p>命令 &lt;&lt; 分界符：</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212221724262.png" alt="截屏2022-12-22 17.24.45" style="zoom:50%;" /></blockquote><p>命令 &lt; 文件 1 &gt; 文件 2：是输入重定向和输出重定向的结合使用</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212221727249.png" alt="截屏2022-12-22 17.27.12" style="zoom:50%;" /></blockquote></blockquote><p><strong>输出重定向：</strong></p><p>使用频率更高，将命令的结果重定向输出到指定的新输出设备(即文件)中</p><p><strong>&#x3D;&#x3D;注意&#x3D;&#x3D;如果指定的文件是不存在的，输出重定向的时候会创建出这个文件</strong></p><p>输出重定向按<u>性质</u> 分为 标准输出重定向和 错误输出重定向 两种</p><blockquote><p>当命令正确执行时，会产生正确的输出结果，此时将正确的输出结果作为输出设备时是标准输出重定向</p><p>当命令执行失败时，会产生错误输出信息，此时将错误输出信息作为输出设备时时错误输出重定向</p><p>两种在写法上没有区别，只是按照命令的执行成功与否进行了分类</p></blockquote><p>输出重定向按<u>用法</u> 分为 清空写入重定向(&gt;) 和 追加写入重定向(&gt;&gt;)</p><blockquote><p>清空写入重定向(&gt;)：将命令的结果重定向输出到指定的文件中，如果该文件原来已经包含数据，会清空原有数据，再写入新数据</p><p>追加写入重定向(&gt;&gt;)：将命令的结果重定向输出到指定的文件中，如果该文件原来已经包含数据，新数据会写入原有数据的后面</p></blockquote><blockquote><table><thead><tr><th>命令符号格式</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，会清空原有数据，再写入新数据。</td></tr><tr><td>命令 2&gt; 文件</td><td>将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，会清空原有数据，再写入新数据。<br />注意，”2&gt;”是固定格式</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，新数据将写入到原有内容的后面。</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，新数据将写入到原有内容的后面。<br />注意，”2&gt;”是固定格式</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或者 命令 &amp;&gt;&gt; 文件</td><td>将标准输出或者错误输出写入到指定文件，如果该文件中已包含数据，新数据将写入到原有内容的后面。<br />注意，第一种写法中，最后的 “2&gt;&amp;1” 是一体的，可以认为是固定写法。</td></tr></tbody></table><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222048427.png" alt="截屏2022-12-22 20.47.56" style="zoom:50%;" /></blockquote><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><h5 id="语法：-18"><a href="#语法：-18" class="headerlink" title="语法："></a>语法：</h5><p><code>find [pathname] [option]</code></p><h5 id="功能：-17"><a href="#功能：-17" class="headerlink" title="功能："></a>功能：</h5><p>在指定目录下查找文件</p><p>任何位于选项参数之前的字符串都被视为指定目录</p><p>如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p><h5 id="常用选项：-14"><a href="#常用选项：-14" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-name &quot;NAME&quot; # 在指定目录和子目录下查找文件名为NAME的文件，双引号可以省略。可以结合通配符使用，这个时候加上双引号搜索到的才是是全面的</span><br><span class="line">-type TYPE # 文件类型是TYPE的文件。f是普通文件，d是目录</span><br></pre></td></tr></table></figure><blockquote><p>查看更多用法<a href="https://www.runoob.com/linux/linux-comm-find.html">点这里</a></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212241118537.png" alt="截屏2022-12-24 11.18.40" style="zoom:50%;" /><blockquote><p>Linux下find命令提供了相当多的查找条件，功能很强大。由于find具有强大的功能，所以它的选项也很 多，其中大部分选项都值得我们花时间来了解一下。</p><p>即使系统中含有网络文件系统( NFS)，find命令在该文件系统中同样有效，只你具有相应的权限。</p><p>在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系 统可能会花费很长的时间(这里是指30G字节以上的文件系统)。 </p></blockquote></blockquote><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>行文本过滤工具</p><h5 id="语法：-19"><a href="#语法：-19" class="headerlink" title="语法："></a>语法：</h5><p><code>grep [option] &quot;STRING&quot; 指定文件</code></p><h5 id="功能：-18"><a href="#功能：-18" class="headerlink" title="功能："></a>功能：</h5><p>用于查找指定文件里包含STRING的行，将其打印出来</p><p>双引号可以省略</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212241130543.png" alt="截屏2022-12-24 11.30.14" style="zoom:50%;" /><h5 id="常用选项：-15"><a href="#常用选项：-15" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-i # 查找时忽略大小写</span><br><span class="line">-n # 顺便输出在文件中的行号</span><br><span class="line">-v # 反向选择，即打印出不包含被查找的字符串的行</span><br></pre></td></tr></table></figure><figure style=half>  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212241150576.png" alt="截屏2022-12-24 11.49.36" style="zoom:50%;" />  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212241150581.png" alt="截屏2022-12-24 11.49.46" style="zoom:50%;" /></figure><h3 id="打包-和-压缩："><a href="#打包-和-压缩：" class="headerlink" title="打包 和 压缩："></a>打包 和 压缩：</h3><p>&#x3D;&#x3D;打包&#x3D;&#x3D;：也称归档、备份，指的是一个文件或者目录的集合，而这个集合被存储在一个文件中。打包文件没有经过压缩，因此占用的空间就是打包文件中所有文件的总空间。</p><blockquote><p>将多个文件打包形成一个包</p></blockquote><p>&#x3D;&#x3D;压缩&#x3D;&#x3D;：利用算法将文件进行处理，以达到保留最大文件信息而让文件体积变小的目的。</p><blockquote><p>只能将一个文件压缩成一个压缩包</p></blockquote><p>打包就像是将行李放进行李箱。压缩就像是为了减少行李的大小，用收纳法将行李的体积折叠的尽可能小，这样就能在箱子里放入更多的行李，也可以将打包好的行李进行收纳，这样行李占用的体积就更小，可以用更小的行李箱。</p><p>压缩是将文件的大小减小，起到减少资源占用的作用。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212261737354.jpeg" alt="IMG_0891" style="zoom:50%;" /><p>如果想一次性压缩许多零零散散的文件或目录，就得要先把它们打成一个包，然后把这个包压缩。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212261747026.jpeg" alt="IMG_0892" style="zoom:50%;" /><p>压缩软件打包压缩格式界面：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212261740678.jpeg" alt="截屏2022-12-26 17.36.56" style="zoom:50%;" /><h3 id="关于普通文件类型的说明："><a href="#关于普通文件类型的说明：" class="headerlink" title="关于普通文件类型的说明："></a>关于普通文件类型的说明：</h3><p>文件的分类就分为<a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB">上面介绍的几类</a></p><p>在Linux中，并不以文件的后缀来区分文件类型，无论是<code>.c</code> <code>.cpp</code> <code> .zip</code> <code> .tar</code> <code>.txt</code>等，都是普通文件类型，文件后缀只是在处理文件的时候进行区分，比如只有<code>.zip</code>等才能解压，<code>.c</code> <code> .cpp</code>等才能编译等。它们都是普通文件。</p><h3 id="zip-x2F-unzip压缩"><a href="#zip-x2F-unzip压缩" class="headerlink" title="zip&#x2F;unzip压缩"></a>zip&#x2F;unzip压缩</h3><p>压缩包拓展名&#x2F;后缀 是<code>.zip</code></p><h5 id="语法-x2F-功能："><a href="#语法-x2F-功能：" class="headerlink" title="语法&#x2F;功能："></a>语法&#x2F;功能：</h5><p><code>zip [option] ZIPNAME 目标文件 </code>：将目标文件压缩为名称为ZIPNAME的压缩包。压缩包的<code>.zip</code>后缀可带可不带，会自动补上</p><p><code>unzip [option] 指定压缩包  </code>：将压缩包解压到当前目录下。若当前目录下有文件与解压后文件重名，会进行询问是否覆盖。注意，解压后文件的名称是压缩前文件的名称，并不是压缩包的名称。</p><h5 id="常用选项：-16"><a href="#常用选项：-16" class="headerlink" title="常用选项："></a>常用选项：</h5><p>zip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-r # 递归处理，将指定目录下的所有文件和子目录一并处理，分别形成单独的压缩包</span><br><span class="line">-m # 将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中</span><br><span class="line">-v # 显示详细的压缩过程信息(默认)</span><br><span class="line">-q # 在压缩的时候不显示命令的执行过程</span><br><span class="line">-数字 # 压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好</span><br><span class="line">-u # 更新压缩文件，即往压缩文件中添加新文件</span><br></pre></td></tr></table></figure><p>unzip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-d 指定目录 # 将压缩包解压到指定目录</span><br><span class="line">-n # 解压时不覆盖已经存在的文件</span><br><span class="line">-o # 解压时覆盖已经存在的文件，且不向用户询问</span><br><span class="line">-v # 不解压，只是查看压缩包的详细信息，包括压缩包中包含的文件大小、文件名、压缩比等</span><br><span class="line">-t # 不解压，测试压缩包有损坏</span><br><span class="line">-x 文件列表 # 解压，但不包含文件列表中的指定文件</span><br></pre></td></tr></table></figure><h4 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h4><p>只能压缩普通文件。</p><p>就算指定了目录，也是将目录下的所有普通文件一一单独压缩出来。压缩文件的拓展名&#x2F;后缀是<code>.gz</code></p><blockquote><p>gzip压缩完之后源文件会被删除</p></blockquote><h5 id="语法-x2F-功能：-1"><a href="#语法-x2F-功能：-1" class="headerlink" title="语法&#x2F;功能："></a>语法&#x2F;功能：</h5><p><code>gzip [option] 指定文件</code></p><blockquote><p>gzip命令十分简单，不需要指定压缩后的文件的名称，压缩后文件的名称是 <code>源文件名.gz</code></p></blockquote><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令:"></a>常用命令:</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-c # 将压缩数据输出到标准输出中，并保留源文件。可以将数据重定向到压缩包中，这样在不删除源文件的同时还不会将数据打印到屏幕上</span><br><span class="line">-d # 对压缩包解压</span><br><span class="line">-f # 强行压缩或解压文件，不理会文件名或者硬连接是否存在以及该文件是否为符号连接。</span><br><span class="line">-r # 递归压缩指定目录下及其子目录下的所有普通文件</span><br><span class="line">-v # 压缩和解压时，显示压缩包的文件名和压缩比等详细信息</span><br><span class="line">-l # 显示每个压缩文件的大小、压缩比，未压缩文件的大小、未压缩文件的名称等详细信息</span><br><span class="line">-数字 # 压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好</span><br><span class="line">-h # 显示帮助</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212251324128.png" alt="截屏2022-12-25 13.23.46" style="zoom:50%;" /><h4 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h4><p>只能压缩普通文件。</p><p>就算指定了目录，也是将目录下的所有普通文件一一单独压缩出来。压缩文件的拓展名&#x2F;后缀是<code>.bz2</code></p><p>从理论上来讲，bzip2的算法比gzip更先进、压缩比更好；而gzip的压缩速度相对来讲更快</p><blockquote><p>bzip2压缩完之后源文件会被删除</p></blockquote><h5 id="语法：-20"><a href="#语法：-20" class="headerlink" title="语法："></a>语法：</h5><p><code>bzip2 [option] 指定文件</code></p><blockquote><p>gzip命令十分简单，不需要指定压缩后的文件的名称，压缩后文件的名称是 <code>源文件名.bz2</code></p></blockquote><h5 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-c # 将压缩和解压的结果送到标准输出</span><br><span class="line">-d # 解压</span><br><span class="line">-f # 压缩或解压时，若出现输出文件与现有文件重名，会直接覆盖。(默认是不会覆盖的)</span><br><span class="line">-h # 显示帮助</span><br><span class="line">-k # 在压缩或解压后不会删除源文件</span><br><span class="line">-s # 强制进行压缩</span><br><span class="line">-V # 显示版本信息</span><br></pre></td></tr></table></figure><h3 id="tar打包-x2F-解包"><a href="#tar打包-x2F-解包" class="headerlink" title="tar打包&#x2F;解包"></a>tar打包&#x2F;解包</h3><h5 id="语法：-21"><a href="#语法：-21" class="headerlink" title="语法："></a>语法：</h5><p><code>tar [option] 指定文件</code></p><h4 id="打包："><a href="#打包：" class="headerlink" title="打包："></a>打包：</h4><p>也称归档、备份</p><p>打包并不是压缩，只是将文件打包到一个集合中，但是如果想要将一堆文件进行压缩的话，首先就得先把这堆零零散散的文件打一个包，这样才方便压缩。所以打包是很重要的。打包后的文件后缀为<code>.tar</code></p><h5 id="常用选项：-17"><a href="#常用选项：-17" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-c # 进行打包的指令</span><br><span class="line">-f TARNAME # 指定包的文件名为TARNAME。注意要加上.tar后缀</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本质上是将打包好的内容输出到名为TARNAME的tar包中</span></span><br><span class="line">-v # 显示详细过程信息</span><br><span class="line">-A # 追加tar文件到打包文件中</span><br><span class="line">-z TARGZIPNAME # 询问是否在打包后同时进行gzip压缩，并将压缩包命名为TARGZIPNAME。注意要加上后缀.tar.gz</span><br><span class="line">-j TARBZIP2NAME # 询问是否在打包后同时进行bzip2压缩，并将压缩包命名为TAEBZIP2NAME。要加后缀.tar.bz2</span><br><span class="line">-p # 打包的时候保留源文件的属性（权限等）</span><br><span class="line">-N &quot;YYYY/MM/DD&quot; # 打包比某日期新的文件</span><br><span class="line">--exclude 文件 # 打包时不打包该文件</span><br><span class="line">-u # 更新原压缩包的文件</span><br></pre></td></tr></table></figure><h5 id="说明：-3"><a href="#说明：-3" class="headerlink" title="说明："></a>说明：</h5><blockquote><ol><li>-cfv 常视作打包的习惯用法</li><li>tar命令的选项中 <code>-</code> 是可加可不加的，比如 <code>-cfv</code> 和 <code>cfv</code> 是一样的</li><li>tar可以将多个文件进行打包，文件之间用空格间隔开就可以。</li><li>tar也可以将目录下的所有文件都打包，例如将date目录下的所有文件都打包：<code>tar -cvf date.tar ./date/</code></li><li>通常都是在打包时同时进行gzip或者bzip2压缩</li><li><u>要注意，一般情况Linux命令的选项是可以不管顺序的，但是在这里</u>，-f后面紧跟包的名称，所以压缩的时候要把-f放在选项最后，否则会报错</li></ol></blockquote><h5 id="应用举例："><a href="#应用举例：" class="headerlink" title="应用举例："></a>应用举例：</h5><blockquote><ol><li><p>将 .&#x2F;test 目录下的文件全部打包为<code>test.tar</code></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271109047.png" alt="截屏2022-12-27 11.09.06" style="zoom:50%;" /></li><li><p>将test目录下的文件全部打包并压缩为<code>tt.tar.gz</code></p><blockquote><p>注意选项的顺序，-f要放在选项的最后面，否则会报错</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271116816.png" alt="image-20221227111606770" style="zoom:50%;" /></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271116841.png" alt="截屏2022-12-27 11.16.26" style="zoom:50%;" /></li><li><p>打包 .&#x2F;test 和 .&#x2F;date并压缩为<code>myfile.tar.gz</code>，但是不打包.&#x2F;test中的date</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271124056.png" alt="截屏2022-12-27 11.24.12" style="zoom:50%;" /></li><li><p>将用户目录下的所有文件备份并压缩，且保留其权限</p><p>(使用的相对路径，也可以使用绝对路径)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271217612.png" alt="截屏2022-12-27 12.17.13" style="zoom:50%;" /><blockquote><p>在最后一行会提示：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271217195.png" alt="截屏2022-12-27 12.17.34" style="zoom:50%;" /><p>这是因为我们将用户目录中的所有文件都备份并压缩了，在执行完命令之后，会在当前目录下生成压缩包</p><p>而当前目录就是用户目录，所以压缩包声明在了用户目录下</p><p>原来的目标文件，也是用户目录，所以原来的目标文件内容发生了变化，就会给出这个提示</p><p>如果再执行一次这个命令(使用的绝对路径，也可以使用相对路径)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271223698.png" alt="截屏2022-12-27 12.23.07" style="zoom:50%;" /><p>会在压缩的时候显示</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271224909.png" alt="截屏2022-12-27 12.23.57" style="zoom:50%;" /><p>因为在压缩之前已经有了yujin.tar.gz这个文件，在压缩用户目录的时候会将它压缩，然后在压缩完用户目录之后又会生成yujin.tar.gz这个压缩包，相当于时间先后、新旧文件的更改，所以会给出这种说明</p></blockquote></li><li><p>在test目录下，比2022&#x2F;12&#x2F;26新的文件才会被打包</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271232344.png" alt="截屏2022-12-27 12.32.14" style="zoom:50%;" /><blockquote><p>命令的最后面可以是<code>./test</code>也可以是<code>./test/</code>或者<code>test</code>、 <code>test/</code></p></blockquote></li></ol></blockquote><h4 id="解包："><a href="#解包：" class="headerlink" title="解包："></a>解包：</h4><h5 id="常用选项：-18"><a href="#常用选项：-18" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-t # 不解包，直接查看tar包里的内容</span><br><span class="line">-x # 解包</span><br><span class="line">-v # 显示详细过程信息</span><br><span class="line">-f # 查看或解包.tar时带上这个选项</span><br><span class="line">-z # 如果压缩包是.tar.gz，那么查看或者解包的时候要加上这个选项</span><br><span class="line">-j # 如果压缩包是.tar.bz2，那么查看或者解包的时候要加上这个选项</span><br><span class="line">-C 指定目录 # 解压到指定目录。如果不带此选项，默认是解包到当前目录</span><br></pre></td></tr></table></figure><h5 id="应用举例：-1"><a href="#应用举例：-1" class="headerlink" title="应用举例："></a>应用举例：</h5><blockquote><ol><li><p>查看上面压缩的<code>mylife.tar.gz</code>中的文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271147961.png" alt="截屏2022-12-27 11.47.24" style="zoom:50%;" /></li><li><p>将<code>test.tar</code>解包到date目录下</p><p>可以先进入到指定目录，再解压到当前目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271152042.png" alt="截屏2022-12-27 11.52.25" style="zoom:50%;" /><p>也可以用选项-C直接解压到指定目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271240994.png" alt="image-20221227124038949" style="zoom:50%;" /></li><li><p>只想将<code>test.tar.gz</code>中的dir1解开到当前目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271813984.png" alt="截屏2022-12-27 18.13.21" style="zoom:50%;" /><blockquote><p>可以看到，解压出的文件是按照原来的层级形成的，解压出test目录下的dir1目录下的mytest.c</p></blockquote></li><li><p>将a目录进行打包，并立即在dir1目录下解开它(这就相当于将a目录移动到dir1目录下，跟cp类似)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271749705.png" alt="截屏2022-12-27 17.49.53" style="zoom:50%;" /><blockquote><p>运用了管道，将前一个命令的输出作为后一个命令的输入</p><p>这里的单独的<code>-</code>意思是标准输入输出(standard input , standard output)</p><p>在前面的命令中，是将a目录进行打包，然后输出到-f 后面的文件中，-f后面跟的是-，也就是标准输出，所以就是将打包好的a目录输出到了标准输出</p><p>在后面的命令中，-xvf 后面跟的是 - ，也就是要解压的包是标准输出上的，并解压到dir1</p><p>这样就用管道命令和标准输入输出实现了</p></blockquote></li></ol></blockquote><h3 id="bc"><a href="#bc" class="headerlink" title="bc"></a>bc</h3><p>可以很方便进行浮点运算，用的时候man一下查找用法即可，此处不再赘述</p><h3 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h3><h5 id="语法：-22"><a href="#语法：-22" class="headerlink" title="语法："></a>语法：</h5><p><code>uname [option]</code></p><h5 id="功能：-19"><a href="#功能：-19" class="headerlink" title="功能："></a>功能：</h5><p>显示电脑的操作系统等信息</p><h5 id="常用选项：-19"><a href="#常用选项：-19" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a # 输出所有详细信息，依次为内核名称、主机名、内核版本号、内核版本、硬件名、处理器类型、硬件平台信息、操作系统名称</span><br></pre></td></tr></table></figure><h3 id="几个重要的热键"><a href="#几个重要的热键" class="headerlink" title="几个重要的热键"></a>几个重要的热键</h3><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>Tab</td><td>命令补全、档案补齐</td></tr><tr><td>ctrl + c</td><td>终止当前进程</td></tr><tr><td>ctrl + d</td><td>代表“键盘输入结束(End of file,EOF,End of input)“的意思；<br />另外，也可以取代exit命令来登出Linux账户</td></tr></tbody></table><p><u>更多快捷键请见linuxJournal中的快捷键整理</u></p><h2 id="Linux权限的概念"><a href="#Linux权限的概念" class="headerlink" title="Linux权限的概念"></a>Linux权限的概念</h2><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>Linux中有两种用户：超级用户(root)、普通用户</p><blockquote><p>超级用户：可以在Linux系统内做任何事情，不受限制。命令提示符是：#</p><p>普通用户：在Linux下做有限的事情。命令提示符是：$</p></blockquote><h4 id="用户切换指令：su"><a href="#用户切换指令：su" class="headerlink" title="用户切换指令：su"></a>用户切换指令：su</h4><h5 id="语法：-23"><a href="#语法：-23" class="headerlink" title="语法："></a>语法：</h5><p><code>su [USERNAME]</code></p><h5 id="功能：-20"><a href="#功能：-20" class="headerlink" title="功能："></a>功能：</h5><p>切换用户</p><h5 id="说明：-4"><a href="#说明：-4" class="headerlink" title="说明："></a>说明：</h5><p>当只使用su命令的时候，是切换到root用户，输入root用户的密码</p><p>当使用 su USERNAME 的时候，是切换到名称为USERNAME的普通用户，并要输入那个用户的密码；如果是从root切换到别的普通用户，不需要输入密码</p><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><h5 id="语法：-24"><a href="#语法：-24" class="headerlink" title="语法："></a>语法：</h5><p><code>sudo [option] 指令</code></p><h5 id="功能：-21"><a href="#功能：-21" class="headerlink" title="功能："></a>功能：</h5><p>以root身份执行当前指令</p><h5 id="说明：-5"><a href="#说明：-5" class="headerlink" title="说明："></a>说明：</h5><p>不会切换身份，只是用root身份执行指令，当前用户(使用sudo命令的用户)不变，相当于在执行指令的时候暂时提高了权限</p><h5 id="常用选项：-20"><a href="#常用选项：-20" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-u USERNAME # 以USERNAME身份执行当前命令</span><br><span class="line">-l # 显示当前用户(使用sudo命令的用户)的权限</span><br></pre></td></tr></table></figure><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><h4 id="文件访问者的分类："><a href="#文件访问者的分类：" class="headerlink" title="文件访问者的分类："></a>文件访问者的分类：</h4><p>访问文件的人有三种</p><blockquote><p>文件的所有者：u——User</p><p>文件所有者所在组的用户：g——Group</p><p>其他用户：o——Others</p></blockquote><p>其中，文件的创建者不一定就是文件的所有者，文件的所有权是可以转让的</p><p>Group，在工作中，一般是以团队进行的，文件的所有者是属于某一个团队的，这个团队的人有时就需要访问这个文件，文件所有者可以创建一个Group，指定在Group里的所有人对于这个文件的访问权限。文件所有者本人本身就是一个团队，他可以往团队里加人。</p><p>Others就是不属于前两者的人。</p><h4 id="文件类型和访问权限-文件属性-："><a href="#文件类型和访问权限-文件属性-：" class="headerlink" title="文件类型和访问权限(文件属性)："></a>文件类型和访问权限(文件属性)：</h4><p>在使用<code>ll</code>命令的时候会展示出文件的详细信息</p><div><center><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181050726.png" alt="image-20221218105015699" style="zoom:30%;" /><br>Linux文件默认是按照名称排序的</center></div><p>文件属性包括文件类型和文件权限，文件类型就是文件的种类，包括普通文件、目录文件等，详细在一开始有讲过<a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB">在这里可以查看一下</a></p><p>文件权限就是，文件访问者对于文件的访问权限是如何的</p><blockquote><ul><li><p>读(r):Read 对文件而言，具有读取文件内容的权限；对目录来说，具有ls浏览该目录信息的权限</p></li><li><p>写(w):Write 对文件而言，具有修改文件内容的权限；对目录来说具有创建删除移动目录内文件的权限 </p></li><li><p>执行(x):execute 对文件而言，具有执行文件的权限；对目录来说，具有cd进入目录的权限</p></li><li><p>“-“表示不具有该项权限</p></li></ul><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212281710542.png" alt="截屏2022-12-28 17.10.03" style="zoom: 33%;" /></blockquote><h4 id="文件权限的表示方法："><a href="#文件权限的表示方法：" class="headerlink" title="文件权限的表示方法："></a>文件权限的表示方法：</h4><ol><li><p>字符表示方法</p><table><thead><tr><th align="center">Linux字符表示</th><th align="center">权限说明</th><th align="center">Linux字符表示</th><th align="center">权限说明</th></tr></thead><tbody><tr><td align="center">r–</td><td align="center">只读</td><td align="center">-w-</td><td align="center">仅可写</td></tr><tr><td align="center">–x</td><td align="center">仅可执行</td><td align="center">rw-</td><td align="center">可读可写</td></tr><tr><td align="center">-wx</td><td align="center">可写可执行</td><td align="center">r-x</td><td align="center">可读可执行</td></tr><tr><td align="center">rwx</td><td align="center">全部权限</td><td align="center">—</td><td align="center">无任何权限</td></tr></tbody></table></li><li><p>8进制数值表示方法</p><p>对于权限的顺序，可以排列为r、w、x</p><p>对于权限的有无，可以用二进制表示，0表示没有这个权限，1表示有这个权限</p><p>故r、w、x这三个权限可以用三个二进制数表示，而三个二进制数又能被一个八进制数表示</p><table><thead><tr><th>权限符号</th><th>二进制</th><th>八进制</th></tr></thead><tbody><tr><td>—</td><td>000</td><td>0</td></tr><tr><td>r–</td><td>100</td><td>4</td></tr><tr><td>-w-</td><td>010</td><td>2</td></tr><tr><td>–r</td><td>001</td><td>1</td></tr><tr><td>rw-</td><td>110</td><td>6</td></tr><tr><td>r-x</td><td>101</td><td>5</td></tr><tr><td>-wx</td><td>011</td><td>3</td></tr><tr><td>rwx</td><td>111</td><td>7</td></tr></tbody></table></li></ol><h4 id="文件访问权限的设置方法："><a href="#文件访问权限的设置方法：" class="headerlink" title="文件访问权限的设置方法："></a>文件访问权限的设置方法：</h4><h5 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h5><h6 id="功能：-22"><a href="#功能：-22" class="headerlink" title="功能："></a>功能：</h6><p>设置文件的访问权限</p><h6 id="语法：-25"><a href="#语法：-25" class="headerlink" title="语法："></a>语法：</h6><p><code>chmod [option] 权限 文件</code></p><h6 id="说明：-6"><a href="#说明：-6" class="headerlink" title="说明："></a>说明：</h6><p>只有文件所有者和root用户才能修改文件访问权限的权限</p><h6 id="常用选项：-21"><a href="#常用选项：-21" class="headerlink" title="常用选项："></a>常用选项：</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R # 递归修改目录文件的权限</span><br></pre></td></tr></table></figure><h6 id="权限格式一："><a href="#权限格式一：" class="headerlink" title="权限格式一："></a>权限格式一：</h6><p>用户表示符 +或-或&#x3D; 文件权限字符</p><blockquote><p>用户表示符：</p><ul><li>u拥有者</li><li>g同组者</li><li>o其他用户</li><li>a所有用户</li></ul><p>+：向用户增加(追加)权限</p><p>-：向用户取消(减少)权限</p><p>&#x3D;：向用户赋予权限，也就是用户只有被赋予的权限</p></blockquote><blockquote><p>向hello.txt的拥有者追加执行权限</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282037692.png" alt="截屏2022-12-28 20.36.43" style="zoom:50%;" /><p>向hello.txt的同组者减少可写权限</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282040631.png" alt="截屏2022-12-28 20.40.03" style="zoom:50%;" /><p>向hello.txt的其他人只赋予可写权限</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282041865.png" alt="截屏2022-12-28 20.41.15" style="zoom:50%;" /><blockquote><p>可以看到others原来是有rw权限，但是被赋予w权限之后，就只有w权限了</p></blockquote></blockquote><h6 id="权限格式二："><a href="#权限格式二：" class="headerlink" title="权限格式二："></a>权限格式二：</h6><p>三个8进制数表示权限   （方便常用）</p><blockquote><p>第一个八进制数表示user的权限</p><p>第二个表示group的权限</p><p>第三个表示other的权限</p><p>跟文件的权限对应</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212281710542.png" alt="截屏2022-12-28 17.10.03" style="zoom: 25%;" /></blockquote><blockquote><p>将hello.txt的文件权限设置为rwx rwx rwx</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282045567.png" alt="截屏2022-12-28 20.45.01" style="zoom:50%;" /><blockquote><p>rwx对应的二进制就是111，对应的八进制数就是7</p></blockquote><p>将hello.txt的文件权限设置为555</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282049750.png" alt="截屏2022-12-28 20.49.33" style="zoom:50%;" /><blockquote><p>5对应的权限就是101即r-x</p></blockquote><p>将hello.txt的文件权限设置为754</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282050739.png" alt="截屏2022-12-28 20.50.54" style="zoom:50%;" /></blockquote><h5 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h5><h6 id="功能：-23"><a href="#功能：-23" class="headerlink" title="功能："></a>功能：</h6><p>修改文件的拥有者</p><h6 id="语法：-26"><a href="#语法：-26" class="headerlink" title="语法："></a>语法：</h6><p><code>chown [option] 用户名 文件名</code></p><h6 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h6><p>只有root用户才有权限使用这个命令</p><h6 id="常用选项：-22"><a href="#常用选项：-22" class="headerlink" title="常用选项："></a>常用选项：</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-v # 显示详细过程信息</span><br><span class="line">-R # 递归更改目录的拥有者</span><br><span class="line">-help # 查看用法帮助</span><br><span class="line">-f # 忽略错误信息</span><br></pre></td></tr></table></figure><h6 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h6><blockquote><p>把hello.txt的所属权从yujin转给chenyujin</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282101595.png" alt="截屏2022-12-28 21.01.19" style="zoom:50%;" /></blockquote><h5 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h5><h6 id="功能：-24"><a href="#功能：-24" class="headerlink" title="功能："></a>功能：</h6><p>修改文件所属组 </p><h6 id="语法：-27"><a href="#语法：-27" class="headerlink" title="语法："></a>语法：</h6><p><code>chgrp [option] 用户组名 文件名</code></p><h6 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h6><p>与chown不同，只要是文件原组里的用户，就可以修改文件的所属组</p><h6 id="常用选项：-23"><a href="#常用选项：-23" class="headerlink" title="常用选项："></a>常用选项：</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-v # 显示详细过程信息</span><br><span class="line">-c # 效果类似&quot;-v&quot;参数，但仅显示更改的部分。</span><br><span class="line">-R # 递归更改目录的拥有者</span><br></pre></td></tr></table></figure><h5 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h5><h6 id="功能：-25"><a href="#功能：-25" class="headerlink" title="功能："></a>功能：</h6><p>查看或修改文件权限掩码</p><h6 id="语法：-28"><a href="#语法：-28" class="headerlink" title="语法："></a>语法：</h6><p><code>umask 权限掩码值</code></p><h6 id="说明：-7"><a href="#说明：-7" class="headerlink" title="说明："></a>说明：</h6><p>将现有的默认权限减去权限掩码，即可产生创建文件时的预设权限</p><h5 id="权限掩码-简介"><a href="#权限掩码-简介" class="headerlink" title="权限掩码(简介)"></a>权限掩码(简介)</h5><p>英文名：unmask</p><p>在创建目录文件的时候，默认权限是775</p><p>在创建普通文件的时候，默认权限是664</p><p>（不同系统上可能有差别，此处以centOS7为例</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212171711414.png" alt="202212171709806" style="zoom:50%;" /><p>但是实际上：</p><blockquote><ol><li>普通目录的默认起始预设权限是777，普通文件的默认起始预设权限是666</li><li>权限掩码umask会在用户创建目录或者文件时拿掉一些默认起始权限，得到的才是创建之后的默认权限</li></ol><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask # 查看权限掩码</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212171704218.png" alt="截屏2022-12-17 17.03.59" style="zoom:50%;" /><p>当前系统下的权限掩码是0002（第一位不用看，代表特殊权限，此处暂不讨论。当然，在写权限的时候是可以带上的，比如0777</p><p>系统会拿掉权限掩码对应的权限，002则对应着owner: 0, grouper: 0, other: 2</p><p>意味着other会被拿掉2权限(2是八进制数，对应的二进制数是010，也就是w权限)</p><p>对于目录，ohter的默认起始权限是<strong>7</strong>(也就是111,rwx)，被拿掉<strong>2</strong>(也就是010,w)之后就变成了<strong>5</strong>(也就是101,rx)，所以创建出的目录的默认权限就变成了775</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212171731199.png" alt="截屏2022-12-17 17.31.22" style="zoom:40%;" /><p>对于文件，other的默认起始权限是<strong>6</strong>(110,rw)，被拿掉<strong>2</strong>(010,w)之后就变成了<strong>4</strong>(100,r)，所以创建出的文件默认权限就是664</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212171732621.png" alt="截屏2022-12-17 17.32.26" style="zoom:40%;" /></blockquote><p>注意，权限掩码是“拿掉”权限，而不是进行二进制减法，比如初始权限是111 110 110，权限掩码是000 000 001，得到的默认权限是111 110 110，而不是111 110 101，因为最后一位本来就没有权限，权限掩码只是拿掉权限，本来就没有权限，拿掉了还是没有权限</p></blockquote><h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><h5 id="功能：-26"><a href="#功能：-26" class="headerlink" title="功能："></a>功能：</h5><p>查看文件类型</p><h5 id="语法：-29"><a href="#语法：-29" class="headerlink" title="语法："></a>语法：</h5><p><code>file [option] 文件</code></p><h5 id="常用选项：-24"><a href="#常用选项：-24" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-c # 显示详细执行过程，便于排错或分析程序执行的情形 </span><br><span class="line">-z # 尝试去解读压缩文件的内容</span><br></pre></td></tr></table></figure><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282224254.png" alt="截屏2022-12-28 22.24.01" style="zoom:50%;" /></blockquote><h4 id="粘滞位"><a href="#粘滞位" class="headerlink" title="粘滞位"></a>粘滞位</h4><p>让我们回顾一下目录的权限：</p><blockquote><ul><li><p>读(r):Read 对目录来说，具有ls浏览该目录信息的权限</p></li><li><p>写(w):Write 对目录来说具有创建删除移动目录内文件的权限 </p></li><li><p>执行(x):execute 对目录来说，具有cd进入目录的权限</p></li></ul></blockquote><p>那这样的话，只要用户具有目录的w权限，就能删除目录中的文件。</p><p>那么问题来了，当张三和李四对于一个目录都有w的权限的时候，张三创建了一个文件，结果被李四删除了！我张三创建的文件你李四凭什么给我删除了！？这不科学呀</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282254005.png" alt="截屏2022-12-28 22.53.59" style="zoom:50%;" /><blockquote><p>这里yujin具有work目录的w权限(属于others)，他将work里root创建的root_work删除了</p></blockquote><p>为了解决这个不科学的问题，就出现了粘滞位</p><h5 id="说明-amp-功能-amp-用法："><a href="#说明-amp-功能-amp-用法：" class="headerlink" title="说明&amp;功能&amp;用法："></a>说明&amp;功能&amp;用法：</h5><p>目录的所有者可以对目录添加粘滞位，加上了粘滞位的目录，具有w权限的用户不能删除目录下别人的文件了，只能删除自己的文件</p><p><code>chmod +t 目录</code></p><blockquote><p>只有 root 和 目录所有者 才能给目录加上粘滞位</p></blockquote><blockquote><p>将work目录加上粘滞位之后，yujin就没办法删除root创建的文件root_work2了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282310392.png" alt="image-20221228231028314" style="zoom:50%;" /></blockquote><p><strong>当一个目录被加上粘滞位的时候，该目录下的文件只能由</strong></p><blockquote><ol><li><strong>root删除</strong></li><li><strong>该目录的所有者删除</strong></li><li><strong>该文件的所有者删除</strong></li></ol></blockquote><h4 id="关于权限的总结"><a href="#关于权限的总结" class="headerlink" title="关于权限的总结"></a>关于权限的总结</h4><blockquote><ul><li>目录的可执行权限是表示你可否在目录下执行命令</li><li>如果目录没有-x权限，则无法对目录执行任何命令，甚至无法cd 进入目, 即使目录仍然有-r 读权限(这 个地方很容易犯错，认为有读权限就可以进入目录读取目录下的文件) </li><li>而如果目录具有-x权限，但没有-r权限，则用户可以执行命令，可以cd进入目录。但由于没有目录的读 权限,所以在目录下，即使可以执行ls命令，但仍然没有权限读出目录下的文档。</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Linux" scheme="https://chunyujin.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://chunyujin.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>宏实现#pragma once&amp;#ifndef</title>
    <link href="https://chunyujin.top/chunyujin/5f33e850.html"/>
    <id>https://chunyujin.top/chunyujin/5f33e850.html</id>
    <published>2023-01-03T05:59:00.000Z</published>
    <updated>2023-01-03T06:06:32.459Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为了避免同一个头文件被包含(include)多次，C&#x2F;C++中有两种宏实现的方式：一种是#pragma once方式</p><p>一种是#ifndef的方式</p><p>有些编译器只支持其中的一种。</p><p>在能够支持这两种方式的编译器是，两者并没有太大的区别，但是两者仍然有一些细微的区别。</p><p><a href="https://blog.csdn.net/qq_43907537/article/details/107938459?ops_request_misc=&request_id=&biz_id=102&utm_term=?ops_request_misc=&request_id=&biz_id=102&utm_term=&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-107938459.nonecase&spm=1018.2226.3001.4187#pragma%20once&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-107938459.nonecase">#pragma once用法</a></p><p><a href="https://blog.csdn.net/qq_35027690/article/details/125865367">#ifndef, #define, #endif 理解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="编程日志" scheme="https://chunyujin.top/categories/%E7%BC%96%E7%A8%8B%E6%97%A5%E5%BF%97/"/>
    
    <category term="C&amp;C++" scheme="https://chunyujin.top/categories/%E7%BC%96%E7%A8%8B%E6%97%A5%E5%BF%97/C-C/"/>
    
    
    <category term="C++" scheme="https://chunyujin.top/tags/C/"/>
    
    <category term="C" scheme="https://chunyujin.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="https://chunyujin.top/chunyujin/d87f7e0c.html"/>
    <id>https://chunyujin.top/chunyujin/d87f7e0c.html</id>
    <published>2023-01-01T06:07:00.000Z</published>
    <updated>2023-01-01T06:10:19.998Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="欢迎使用坚果云Markdown"><a href="#欢迎使用坚果云Markdown" class="headerlink" title="欢迎使用坚果云Markdown"></a>欢迎使用坚果云Markdown</h3><h5 id="新增图片上传功能"><a href="#新增图片上传功能" class="headerlink" title="新增图片上传功能"></a>新增图片上传功能</h5><p>现在可以在文章中插入图片，将更丰富的内容分享给朋友了！</p><ul><li>您可以插入外链图片，或上传本地图片到文档中。</li><li>从本地上传的图片不支持外链引用，您可以通过坚果云分享链接来发布图文预览。</li><li>可上传的单张图片最大20M，支持PNG、JPG格式，使用时请留意账号流量或空间是否充足。</li><li>若有其他疑问，欢迎咨询官网在线客服。</li></ul><h3 id="Welcome-to-the-Nutstore-Markdown"><a href="#Welcome-to-the-Nutstore-Markdown" class="headerlink" title="Welcome to the Nutstore Markdown"></a>Welcome to the Nutstore Markdown</h3><h5 id="New-feature-Insert-pictures-in-your-articles-now"><a href="#New-feature-Insert-pictures-in-your-articles-now" class="headerlink" title="New feature! Insert pictures in your articles now!"></a>New feature! Insert pictures in your articles now!</h5><p>You can insert pictures from external links, or upload ones.</p><p>The pictures in the articles can not be used through external links. Please share your articles with the Nutstore share link.</p><p>The maximum size of the picture to upload is 20M. PNG and JPG are better. Be sure that your traffic and space are enough if you want to add a lot of pictures in your article.</p><p>Have any other questions, please contact our official customer service.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="https://chunyujin.top/categories/C/"/>
    
    
    <category term="C++" scheme="https://chunyujin.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>电脑正确坐姿：健康才是是第一生产力</title>
    <link href="https://chunyujin.top/chunyujin/768897a3.html"/>
    <id>https://chunyujin.top/chunyujin/768897a3.html</id>
    <published>2022-12-21T12:48:00.000Z</published>
    <updated>2022-12-31T17:42:21.557Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>🧑🏻‍💻</p><h3 id="电脑正确坐姿-健康才是是第一生产力！！"><a href="#电脑正确坐姿-健康才是是第一生产力！！" class="headerlink" title="电脑正确坐姿_健康才是是第一生产力！！"></a>电脑正确坐姿_健康才是是第一生产力！！</h3><blockquote><p>以下所有都只是建议，要根据自己情况来就行</p></blockquote><h4 id="挺直腰背。腰背可以靠在靠背上，放松，让靠背承力"><a href="#挺直腰背。腰背可以靠在靠背上，放松，让靠背承力" class="headerlink" title="挺直腰背。腰背可以靠在靠背上，放松，让靠背承力"></a>挺直腰背。腰背可以靠在靠背上，放松，让靠背承力</h4><h4 id="放松肩部肌肉，不要耸肩，颈肩背不要前倾，不要用肩膀承力"><a href="#放松肩部肌肉，不要耸肩，颈肩背不要前倾，不要用肩膀承力" class="headerlink" title="放松肩部肌肉，不要耸肩，颈肩背不要前倾，不要用肩膀承力"></a>放松肩部肌肉，不要耸肩，颈肩背不要前倾，不要用肩膀承力</h4><p>避免含胸驼背！！</p><p>建议购买人体工学椅或升降桌，调整高度到自己舒服的位置</p><h4 id="调整键盘位置：，大臂放松，自然下垂于身体两侧，键盘不要离身体太远，使大臂与小臂呈大约90～120度-键盘太远会导致前倾-；键盘高度最好位于肚脐高度附近，小臂自然舒适放在桌面上，使不会耸肩，不会使肩膀、大臂前倾，还能使视线能自然看到双手和键盘【根据自身舒适情况调整"><a href="#调整键盘位置：，大臂放松，自然下垂于身体两侧，键盘不要离身体太远，使大臂与小臂呈大约90～120度-键盘太远会导致前倾-；键盘高度最好位于肚脐高度附近，小臂自然舒适放在桌面上，使不会耸肩，不会使肩膀、大臂前倾，还能使视线能自然看到双手和键盘【根据自身舒适情况调整" class="headerlink" title="调整键盘位置：，大臂放松，自然下垂于身体两侧，键盘不要离身体太远，使大臂与小臂呈大约90～120度(键盘太远会导致前倾)；键盘高度最好位于肚脐高度附近，小臂自然舒适放在桌面上，使不会耸肩，不会使肩膀、大臂前倾，还能使视线能自然看到双手和键盘【根据自身舒适情况调整"></a>调整键盘位置：，大臂放松，自然下垂于身体两侧，键盘不要离身体太远，使大臂与小臂呈大约90～120度(键盘太远会导致前倾)；键盘高度最好位于肚脐高度附近，小臂自然舒适放在桌面上，使不会耸肩，不会使肩膀、大臂前倾，还能使视线能自然看到双手和键盘【根据自身舒适情况调整</h4><h4 id="保证视线平视显示器而不低头；与显示器保持合适距离，一般建议在1-5～2倍显示器高度之间，这样才能使观感舒适（比如27寸显示器高度为35～37cm，建议眼睛距离显示器52-5～70cm之间以达到舒适的观感"><a href="#保证视线平视显示器而不低头；与显示器保持合适距离，一般建议在1-5～2倍显示器高度之间，这样才能使观感舒适（比如27寸显示器高度为35～37cm，建议眼睛距离显示器52-5～70cm之间以达到舒适的观感" class="headerlink" title="保证视线平视显示器而不低头；与显示器保持合适距离，一般建议在1.5～2倍显示器高度之间，这样才能使观感舒适（比如27寸显示器高度为35～37cm，建议眼睛距离显示器52.5～70cm之间以达到舒适的观感"></a>保证视线平视显示器而不低头；与显示器保持合适距离，一般建议在1.5～2倍显示器高度之间，这样才能使观感舒适（比如27寸显示器高度为35～37cm，建议眼睛距离显示器52.5～70cm之间以达到舒适的观感</h4><p>如果显示器高度不够，可以购买增高支架或者桌面置物架来增高</p><h4 id="达到观感、腰背、肩膀、手臂、腰部都能十分舒适的平衡点"><a href="#达到观感、腰背、肩膀、手臂、腰部都能十分舒适的平衡点" class="headerlink" title="达到观感、腰背、肩膀、手臂、腰部都能十分舒适的平衡点"></a>达到观感、腰背、肩膀、手臂、腰部都能十分舒适的平衡点</h4><h3 id="总之，核心就是舒服：肩膀舒服，脖子舒服，腰部舒服，眼睛舒服，使用键鼠方便。"><a href="#总之，核心就是舒服：肩膀舒服，脖子舒服，腰部舒服，眼睛舒服，使用键鼠方便。" class="headerlink" title="总之，核心就是舒服：肩膀舒服，脖子舒服，腰部舒服，眼睛舒服，使用键鼠方便。"></a>总之，核心就是舒服：肩膀舒服，脖子舒服，腰部舒服，眼睛舒服，使用键鼠方便。</h3><h5 id="购买建议："><a href="#购买建议：" class="headerlink" title="购买建议："></a>购买建议：</h5><blockquote><p>人体工学椅</p><p>显示器支架臂</p></blockquote><hr><h4 id="关于为什么要把键盘放在桌面上而不是键盘托盘上："><a href="#关于为什么要把键盘放在桌面上而不是键盘托盘上：" class="headerlink" title="关于为什么要把键盘放在桌面上而不是键盘托盘上："></a>关于为什么要把键盘放在桌面上而不是键盘托盘上：</h4><p>[知乎链接](既然大家都喜欢把键盘放在桌子上，为什么电脑桌还要设计托盘？ - 华而无为的回答 - 知乎 <a href="https://www.zhihu.com/answer/2808056675">https://www.zhihu.com/answer/2808056675</a>)</p><p>最近本人一直在被这个问题纠结。本人在学校的时候宿舍使用了人体工学椅，可以调节高度到健康的位置。但是家里的办公桌是大电脑桌，有一个键盘托盘，桌子高度75cm，电脑托盘高度是60cm，本人身高较高，当键盘放在桌子上的时候，键盘会略微高于手肘，但是将手肘放到桌子上的时候，颈肩肘都是可以得到放松的，这属于比较小的误差吧。当键盘放在托盘上的时候，会感觉不习惯，而且本人用的是很薄的键盘，打字要去够才能够到。</p><ol><li><p>起始电脑托盘的存在属于电脑桌这个外设跟不上电子产品发展，电脑托盘属于落后的产物，电脑桌的传统设计在国内也没有更改过。电脑桌的基本设计理念一直延续着它刚诞生的情况，现在很多新的人体工程电脑桌要不就是升降的，要不就是不带键盘托盘的。</p></li><li><p>另一个方面，看现在的键盘，比较传统的薄膜键盘和机械键盘的厚度基本上是和上世纪的键盘厚度一样， 放到键盘托盘上还是可以比较容易敲击的；现在生产的比较新的薄膜键盘，都是极薄设计的，这种设计就是在桌面上用的比较爽的。 </p></li><li><p>当你将键盘放在托盘上的时候，你的姿势会维持在一个固定的角度，就像是身体被卡在了那里，虽然姿势满足健康坐姿，但是久坐之后对于身体是很不好的。当键盘鼠标放在桌子上的时候，可以很轻松调整自己的坐姿和更改键盘的位置，避免久坐不动的现象。</p></li><li><p>将键盘放到托盘里，人会里显示器很远，看不清显示器</p></li><li><p>将键盘放在托盘里，人很难看到键盘(要低头)，而且手感会下降(玄学，但是尝试一下会发现放在托盘里敲键盘的姿势是缩着手从上而下敲击键盘，感受不到键盘的手感)，视觉上不舒服，心理上不舒服(这一点对强迫症比较重要～～～)</p></li></ol><p>对于正确的电脑桌前坐姿而言，只要能满足健康的坐姿，建议还是将键盘放在桌子上的。如果不满足条件，可以通过调整座位高度或桌子高度实现。</p><p>现在去淘宝搜索人体工学办公桌，也都是舍弃了电脑托盘的设计居多，很少再见到带托盘的了，除非是在家具城买的老式的办公桌子。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="健康" scheme="https://chunyujin.top/categories/%E5%81%A5%E5%BA%B7/"/>
    
    
    <category term="健康" scheme="https://chunyujin.top/tags/%E5%81%A5%E5%BA%B7/"/>
    
  </entry>
  
  <entry>
    <title>关于Linux</title>
    <link href="https://chunyujin.top/chunyujin/7ef7519f.html"/>
    <id>https://chunyujin.top/chunyujin/7ef7519f.html</id>
    <published>2022-12-18T04:22:00.000Z</published>
    <updated>2022-12-31T03:53:33.703Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Linux是一种开源的操作系统"><a href="#Linux是一种开源的操作系统" class="headerlink" title="Linux是一种开源的操作系统"></a>Linux是一种开源的操作系统</h3><h4 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h4><p>计算机本质是许多硬件组成的一个整体</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212180856455.png" alt="image-20221218085649201" style="zoom:50%;" /><blockquote><p>设备驱动直接控制计算机的硬件，用户通过应用软件使用计算机</p><p>应用程序会调用多种设备驱动，驱动程序提供给应用程序接口，供应用程序调用接口来使用硬件</p><p>一个计算机上会有很多硬件，所以会有很多设备驱动，每个硬件对应的设备驱动也不一样；每个应用程序都会与很多设备驱动对接，还会经常有多个应用占用同一个硬件的情况，如何进行资源管理和分配是对于设计者来说是一件很麻烦的事情。</p><p>于是就有了操作系统，操作系统是用来管理软件和硬件的对接，并将硬件驱动程序的接口抽象化，行成一套简单的接口给上层的应用程序使用。</p><p>另外，设备驱动是嵌入到操作系统里的，上面讲的只是为了体现这几者的关系。</p></blockquote><p>世界三大操作系统：Windows，macOS，Linux</p><p>Windows是世界上市场份额占比最大的终端操作系统；macOS是基于Unix内核的操作系统；Linux是开源的操作系统，被广泛用于服务器、嵌入式，并且智能手机上的android操作系统正是基于Linux开发的子系统。</p><h4 id="为什么是开源"><a href="#为什么是开源" class="headerlink" title="为什么是开源"></a>为什么是开源</h4><p>开源是Linus大神的非常强烈的信念，当时在接触MINIX的时候，被MINIX只允许用在教育上的使用很不满，于是他便开始编写自己的开源操作系统，并一直坚持开源理念。</p><p>开源，即<u>开放源代码</u></p><p>这意味着任何人都可以使用，但请记得注明来源。</p><blockquote><p><strong>开放源代码</strong>（英语：Open Source）是一种在电脑程序出品前和开发中提供其内部代码的做法。</p><p>开放源代码在互联网上获得广泛使用，参加者需要大量更新电脑源代码。开放源代码使得生产模块、通信管道、交互社群获得改善。随后，一个新著作权、软件授权条款、域名和消费者提供创建的，一个新词开源软件诞生。</p><p>开源模型概念包括同时间不同时程和方法来生产，相对而言，更加集中式的软体设计模型，例如典型的商业软体公司。一个开源软体开发的主要原则和惯例是易货贸易和合作的同侪生产，经由免费公开的最终产品、原始信息、蓝图和文件。这逐渐应用在其它领域，例如生物技术。———<em>来源<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81">维基百科</a></em></p></blockquote><p>代码开源，意味着更安全、更高效、更稳定</p><p>因为全部的使用者都在使用且知悉源代码，一旦出现问题会被用户群体立即指出，甚至用户群体可以立即给出各种解决方案！</p><p>代码闭源则只能由商业公司内部维护</p><h3 id="Linux的应用场景"><a href="#Linux的应用场景" class="headerlink" title="Linux的应用场景"></a>Linux的应用场景</h3><p>服务器后台</p><p>嵌入式、树莓派</p><p>智能家电</p><p>车载系统</p><p>物联网</p><p>手机、平板电脑</p><p>……</p><p>一切都是基于Linux的开源特性</p><p>还有就是Linux确实很好用</p><p>这为无数人提供了便利！</p><h3 id="生动的补充"><a href="#生动的补充" class="headerlink" title="生动的补充"></a>生动的补充</h3><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212180928015.png" alt="image-20221218092828996"></p><h3 id="Linux下一切皆文件！！！"><a href="#Linux下一切皆文件！！！" class="headerlink" title="Linux下一切皆文件！！！"></a>Linux下一切皆文件！！！</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Linux" scheme="https://chunyujin.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://chunyujin.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>MinGw配置(Windows电脑)</title>
    <link href="https://chunyujin.top/chunyujin/1ee5d0ce.html"/>
    <id>https://chunyujin.top/chunyujin/1ee5d0ce.html</id>
    <published>2022-12-15T14:14:00.000Z</published>
    <updated>2023-01-01T06:30:44.518Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="安装MinGW"><a href="#安装MinGW" class="headerlink" title="安装MinGW"></a>安装MinGW</h4><p>相比在 Linux 平台上安装 GCC 编译环境，在 Windows 平台上安装 MinGW 是比较简单的，只需经历以下几个过程。</p><ol><li><p>打开 <a href="https://osdn.net/projects/mingw/">MinGW 官网</a>（点击即可进入官网），下载 MinGW 安装包。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215731250.png" alt="image-20221215215731250" style="zoom:67%;" /></li><li><p>下载完成后，会得到一个名为 mingw-get-setup.exe 的安装包，双击打开它，可以看到如下的对话框：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215752602.png" alt="image-20221215215752602" style="zoom:67%;" /></li><li><p>直接点击“Install”，进入下面的对话框，自定义安装位置，然后选择continue</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215808186.png" alt="image-20221215215808186" style="zoom:67%;" /></li><li><p>进入安装 MinGW 配置器的界面。安装完成之后，得到一个名为 “MinGW Installer Manager” 的软件，借助它，可以随时根据需要修改 GCC 编译器的配置。点击“continue”,会自动弹出配置界面，如下所示：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215823311.png" alt="image-20221215215823311" style="zoom:67%;" /></li><li><p>为使 GCC 同时支持编译 C 语言和 C++，需勾选图中标注的 2 项。我们知道，GCC 还支持其它编程语言，读者可借助此配置器，随时实际需要安装自己需要的编译环境。勾选完成后，在菜单栏中选择<code>Installation -&gt; Apply Changes</code>，弹出如下对话框：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215851706.png" alt="image-20221215215851706" style="zoom:67%;" /></li></ol><p>选择“Apply”。然后耐心等待，直至安装成功，即可关闭此界面。注意，整个安装过程中可能会提示某些组件下载失败，但没关系，后续需要时，可以通过 MinGw Installer（图 4 所示）安装界面中的 “All Packages”选项中，手动选择指定的安装包进行安装。</p><h4 id="添加到环境变量"><a href="#添加到环境变量" class="headerlink" title="添加到环境变量"></a>添加到环境变量</h4><p>打开<code>我的电脑</code>-&gt;<code>属性</code>-&gt;<code>高级系统设置</code>-&gt;<code>“高级”中的环境变量</code></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213001922.png" alt="image-20221215213001922" style="zoom:67%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213141396.png" alt="image-20221215213141396" style="zoom: 67%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213248912.png" alt="image-20221215213248912" style="zoom:67%;" /><p>在上方的“用户变量”的Path变量中添加MinGW的bin的位置</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213407962.png" alt="image-20221215213407962" style="zoom:67%;" /><blockquote><p>也可以在下方的“系统变量”的Path中添加MinGW的bin的位置</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213829809.png" alt="image-20221215213829809" style="zoom:67%;" /><p>环境变量、系统变量、用户变量的关系：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215214853021.png" alt="image-20221215214853021" style="zoom: 50%;" /><p>环境变量只是一个总称，代表了系统变量和用户变量，因此我们说环境变量都是指的系统变量和用户变量。系统变量就是系统级别的变量，用户需要使用系统变量。如果系统变量被修改了，而任何系统用户都在用系统变量，因此每个系统用户都将受到影响。用户变量运行在系统变量之上的，每个用户拥有不同的用户变量，不同用户的用户变量之间是并列的，也是互不干扰的。</p></blockquote><h4 id="检验配置完成"><a href="#检验配置完成" class="headerlink" title="检验配置完成"></a>检验配置完成</h4><p>打开命令行提示符，输入<code>gcc -v</code>或者<code>g++ -v</code></p><p>出现下面则说明成功</p><p><img>(<a href="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-12-15%20220238.png">https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-12-15%20220238.png</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Skill" scheme="https://chunyujin.top/categories/Skill/"/>
    
    <category term="MinGw" scheme="https://chunyujin.top/categories/Skill/MinGw/"/>
    
    
    <category term="MinGw" scheme="https://chunyujin.top/tags/MinGw/"/>
    
  </entry>
  
  <entry>
    <title>NotePad++配置</title>
    <link href="https://chunyujin.top/chunyujin/55caa4ef.html"/>
    <id>https://chunyujin.top/chunyujin/55caa4ef.html</id>
    <published>2022-12-15T14:00:00.000Z</published>
    <updated>2023-01-01T06:26:30.409Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>安装MinGW并添加到环境变量：</p><p><a href="http://chunyujin.top/chunyujin/1ee5d0ce.html">点此查看步骤(建议右键选择在新窗口中打开)</a></p><p>创建一个cpp文件并写一段测试代码</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215200029209.png" alt="image-20221215200029209"></p><p>点击顶部菜单栏的“运行”或者直接按F5</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215200205821.png" alt="image-20221215200205821"></p><p>输入一下宏定义命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd /k pushd &quot;$(CURRENT_DIRECTORY)&quot; &amp;&amp; g++ -o &quot;$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp;&amp; &quot;$(NAME_PART)&quot;.exe &amp; PAUSE &amp; EXIT</span><br></pre></td></tr></table></figure><p>点击运行即可</p><p>建议选择“保存”按键，将宏定义保存到快捷键，比如<code>ctrl + alt + n</code>(跟vscode的coderunner插件一样的快捷键)，下次运行直接快捷键即可</p><blockquote><p><code>cmd /k</code>：<strong>打开</strong> cmd 控制台，运行完程序让其停留而不自动关闭。</p><p><code>pushd &quot;$(CURRENT_DIRECTORY)&quot;</code>：<strong>将工作路径更换到源文件所在的路径</strong>，例如’pushd E:\kkk’相当于 cmd 中先<code>e:</code>再<code>cd kkk</code>，这条命令在源代码要调用同目录文件而只写了相对路径时尤为重要。因为 Notepad++ 的默认工作路径是它自己的安装路径。</p><p><code>g++ -o &quot;$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot;</code>：调用环境变量中的编译器 g++.exe 来将源代码<strong>编译</strong>成同名 exe 文件并输出到相同路径。</p><p><code>&quot;$(NAME_PART)&quot;.exe</code>：<strong>运行</strong>源代码编译出的可执行文件。</p><p><code>PAUSE</code>：暂停，提示<strong>“按任意键继续”</strong>，配合下一条命令实现“按任意键关闭”的效果，两者都没有的话程序运行完就会秒关。</p><p><code>EXIT</code>：<strong>关闭</strong> cmd 控制台，没有的话按任意键会退到 cmd 命令台，等待输入下一条命令。</p><ul><li><p>$(CURRENT_DIRECTORY)代表文件所在目录的路径。</p></li><li><p>$(NAME_PART)表示该文件无后缀部分的文件名。</p></li><li><p>$(FULL_CURRENT_PATH)代表当前完整的文件路径。</p></li><li><p>双引号（半角）：用于防止目录或文件名中含空格的情况。</p></li><li><p>“&amp;&amp;”和“&amp;”：前者表示上一条命令正常执行完再执行下一条命令，非正常则不执行下一条；后者无顾虑。例如一分为六后的后两条子命令，表示不管源代码编译、运行是否成功，都会出现“按任意键继续”字样，并且按任意键后关闭 cmd 控制台。</p></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Skill" scheme="https://chunyujin.top/categories/Skill/"/>
    
    <category term="IDE" scheme="https://chunyujin.top/categories/Skill/IDE/"/>
    
    
    <category term="NotePad++" scheme="https://chunyujin.top/tags/NotePad/"/>
    
  </entry>
  
  <entry>
    <title>VsCode_C++环境搭建(Mac m1芯片版本)</title>
    <link href="https://chunyujin.top/chunyujin/1580f89a.html"/>
    <id>https://chunyujin.top/chunyujin/1580f89a.html</id>
    <published>2022-12-13T02:11:00.000Z</published>
    <updated>2023-01-01T06:26:14.168Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.cnblogs.com/BYGAO/p/15135609.html">文章转载自百叶的自留地(2021年8月)，非商业用途，侵删</a></p><p>文末放了我的三个json文件配置，可以参考。</p><h2 id="1-下载VS-code"><a href="#1-下载VS-code" class="headerlink" title="1.下载VS code"></a>1.下载VS code</h2><p>VS code已针对m1 芯片进行了适配，去官网下载VS code Apple Silicon版并安装。</p><h2 id="2-确保clang已安装"><a href="#2-确保clang已安装" class="headerlink" title="2.确保clang已安装"></a>2.确保clang已安装</h2><p>在终端里输入<code>clang --version</code>查看是否已安装，若未安装，输入<code>xcode-select --install</code>读完条款输入agree安装即可。</p><h2 id="3-下载扩展"><a href="#3-下载扩展" class="headerlink" title="3.下载扩展"></a>3.下载扩展</h2><p>一共有三个扩展需要下载。<br>1.C&#x2F;C++<br>2.C++ Intellisense<br>3.CodeLLDB<br>4.Chinese(中文插件，可选)</p><h2 id="4-新建cpp文件"><a href="#4-新建cpp文件" class="headerlink" title="4.新建cpp文件"></a>4.新建cpp文件</h2><p>这里直接采用<a href="https://code.visualstudio.com/docs/cpp/config-clang-mac">微软官方文档</a>里的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; msg &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;from&quot;</span>, <span class="string">&quot;VS Code&quot;</span>, <span class="string">&quot;and the C++ extension!&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> string&amp; word : msg)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; word &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，在文件第10行输入<code>msg.</code>应该是能看到VS code跳出<code>assign</code>之类的提示的。</p><h2 id="5-配置文件"><a href="#5-配置文件" class="headerlink" title="5.配置文件"></a>5.配置文件</h2><h3 id="1-配置tasks-json文件"><a href="#1-配置tasks-json文件" class="headerlink" title="1.配置tasks.json文件"></a>1.配置tasks.json文件</h3><p>首先点击<code>终端</code>—<code>配置默认生成任务</code>—<code>C/C++ clang++</code>，会生成一个tasks.json文件，这是默认生成的，需要修改其中的<code>args</code>选项,添加一个<code>&quot;-std=c++17&quot;</code>，修改后为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;args&quot;</span>: [</span><br><span class="line"><span class="string">&quot;-g&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;file&#125;</span>&quot;</span>,</span><br><span class="line"><span class="string">&quot;-std=c++17&quot;</span>,</span><br><span class="line"><span class="string">&quot;-o&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;fileDirname&#125;</span>/<span class="variable">$&#123;fileBasenameNoExtension&#125;</span>&quot;</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>配置完后，会发现VS code提示语法错误，不要急，接下来就修正它。</p><h3 id="2-配置c-cpp-properties-json文件"><a href="#2-配置c-cpp-properties-json文件" class="headerlink" title="2.配置c_cpp_properties.json文件"></a>2.配置c_cpp_properties.json文件</h3><p>使用组合键<code>shift+command+p</code>（mac下shift就是<code>fn</code>键上面那个啦），调出<code>C/C++:编辑配置（json）</code>，会自动生成一个<code>c_cpp_properties.json</code>文件。</p><p>将<code>&quot;compilerPath&quot;: &quot;/usr/bin/clang&quot;,</code>修改为<code>&quot;compilerPath&quot;: &quot;/usr/bin/clang++&quot;,</code><br>将<code>&quot;&quot;cppStandard&quot;: &quot;c++98&quot;,</code>修改为<code>&quot;cppStandard&quot;: &quot;c++17&quot;,</code></p><p>其实只是将编译器修改为clang++，cpp标准修改为C++ 17.</p><h3 id="3-编译生成文件"><a href="#3-编译生成文件" class="headerlink" title="3.编译生成文件"></a>3.编译生成文件</h3><p>这么配置完后，其实VS code还是会报两个语法错误，不过这不要紧，这是因为还没更新的缘故。<br>点击<code>终端</code>—<code>运行生成任务</code>，运行完后会生成一个二进制文件，语法报错也没了，表示我们编译成功了。<br>如果想测试的话，新建一个终端，使用<code>./你的二进制文件名</code>，即可看到输出结果。</p><h3 id="4-配置launch-json文件"><a href="#4-配置launch-json文件" class="headerlink" title="4.配置launch.json文件"></a>4.配置launch.json文件</h3><p>点击<code>运行</code>—<code>添加配置</code>—<code>C++(GDB/LLDB)</code>—<code>clang++</code>，会生成一个<code>launch.json</code>文件。<br>将<code>&quot;type&quot;: &quot;cppdbg&quot;,</code>修改为<code>&quot;type&quot;: &quot;lldb&quot;,</code><br>至此，所有文件就配置完了。</p><h3 id="5-调试"><a href="#5-调试" class="headerlink" title="5.调试"></a>5.调试</h3><p>在文件的第10行放一个断点，点击<code>运行</code>—<code>启动调试</code>，就可以看到各种变量了。</p><h2 id="我的文件配置"><a href="#我的文件配置" class="headerlink" title="我的文件配置"></a>我的文件配置</h2><p>以下是我的三个json文件配置代码。<br><code>tasks.json</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line"><span class="string">&quot;tasks&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppbuild&quot;</span>,</span><br><span class="line"><span class="string">&quot;label&quot;</span>: <span class="string">&quot;C/C++: clang++ 生成活动文件&quot;</span>,</span><br><span class="line"><span class="string">&quot;command&quot;</span>: <span class="string">&quot;/usr/bin/clang++&quot;</span>,</span><br><span class="line"><span class="string">&quot;args&quot;</span>: [</span><br><span class="line"><span class="string">&quot;-g&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;file&#125;</span>&quot;</span>,</span><br><span class="line"><span class="string">&quot;-std=c++17&quot;</span>,</span><br><span class="line"><span class="string">&quot;-o&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;fileDirname&#125;</span>/<span class="variable">$&#123;fileBasenameNoExtension&#125;</span>&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;options&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;<span class="variable">$&#123;fileDirname&#125;</span>&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;problemMatcher&quot;</span>: [</span><br><span class="line"><span class="string">&quot;<span class="variable">$gcc</span>&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;group&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line"><span class="string">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;detail&quot;</span>: <span class="string">&quot;编译器: /usr/bin/clang++&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>c_cpp_properties.json</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Mac&quot;</span>,</span><br><span class="line">            <span class="string">&quot;includePath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;<span class="variable">$&#123;workspaceFolder&#125;</span>/**&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;defines&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;macFrameworkPath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;compilerPath&quot;</span>: <span class="string">&quot;/usr/bin/clang++&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cStandard&quot;</span>: <span class="string">&quot;c17&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cppStandard&quot;</span>: <span class="string">&quot;c++17&quot;</span>,</span><br><span class="line">            <span class="string">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;macos-clang-arm64&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>launch.json</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;clang++ - 生成和调试活动文件&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;lldb&quot;</span>,</span><br><span class="line">            <span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="string">&quot;program&quot;</span>: <span class="string">&quot;<span class="subst">$&#123;fileDirname&#125;</span>/<span class="subst">$&#123;fileBasenameNoExtension&#125;</span>&quot;</span>,</span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;<span class="subst">$&#123;fileDirname&#125;</span>&quot;</span>,</span><br><span class="line">            <span class="string">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;MIMode&quot;</span>: <span class="string">&quot;lldb&quot;</span>,</span><br><span class="line">            <span class="string">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;C/C++: clang++ 生成活动文件&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Skill" scheme="https://chunyujin.top/categories/Skill/"/>
    
    <category term="IDE" scheme="https://chunyujin.top/categories/Skill/IDE/"/>
    
    
    <category term="VsCode" scheme="https://chunyujin.top/tags/VsCode/"/>
    
  </entry>
  
  <entry>
    <title>用Calibre实现Kindle带封面传书</title>
    <link href="https://chunyujin.top/chunyujin/35444f4.html"/>
    <id>https://chunyujin.top/chunyujin/35444f4.html</id>
    <published>2022-12-12T16:00:00.000Z</published>
    <updated>2023-01-01T06:29:26.274Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="Kindle如何带封面传书"><a href="#Kindle如何带封面传书" class="headerlink" title="Kindle如何带封面传书"></a>Kindle如何带封面传书</h4><p>软件：Calibre</p><p>Kinlde传书以往分为两种方式，一种是邮件传输，另一种是数据线连接电脑传输</p><h5 id="邮件传书"><a href="#邮件传书" class="headerlink" title="邮件传书"></a>邮件传书</h5><blockquote><p>每部Kindle都有自己的邮箱，通过附件的方式给Kindle邮箱发送邮件就可以传书</p><p>但是Kinlde在2022年8月份就宣布停止mobi格式书籍的邮箱传输，并只支持epub</p><p>Kindle机器本身只支持azw格式，Kindle可以对mobi进行转换，成为azw格式</p><p>通过邮件传书，无论是mobi还是epub格式都是先通过线上转换，变成azw格式之后发送到kindle去的，而mobi格式通过邮箱传输可以保留原来的封面，epub格式则会失去封面，用邮箱传书的话要带封面只能用mobi格式</p><p>亚马逊以后将停止kindle邮箱传书，只能选择数据线传书</p></blockquote><h5 id="数据线传书"><a href="#数据线传书" class="headerlink" title="数据线传书"></a>数据线传书</h5><blockquote><p>mobi的书籍通过数据线传输之后会丢失封面，epub则因为Kindle硬件无法进行格式转换，无法读取。</p><p>网络上获取的资源一般都是mobi格式以及epub格式的</p></blockquote><p>以下是通过数据线带封面传书的步骤</p><p><strong>如果书籍带有封面，并且不需要更换，跳过2、3步骤，如果书籍没有封面或者封面不官方和美观，执行2、3步骤</strong></p><ol><li>将需要传输的书籍放到calibre里面</li><li><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202208231507207.png" alt="截屏2022-08-23 15.06.53" style="zoom:50%;" /></li><li><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202208231508238.png" alt="截屏2022-08-23 15.08.01" style="zoom:50%;" /></li><li><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202208231509350.png" alt="截屏2022-08-23 15.09.53" style="zoom:50%;" /></li><li>推出Kindle，但是不要关闭calibre</li><li>保持Kindle的wifi打开的状态，等待亚马逊删除封面</li><li>再次连接Kindle到电脑，等到calibre读取到Kindle，此时calibre会恢复刚刚导入到Kindle书籍的封面</li><li>大功告成，可以推出Kindle以及关闭calibre</li></ol><h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h5><blockquote><ol><li>关于“步骤6”中“亚马逊删除封面“，因为Kindle图书的正规获取渠道是亚马逊图书商城，对于图书的封面，亚马逊是从网络上获取的，网络获取分为邮件和亚马逊商城，通过邮件推送来的mobi格式的图书，自带封面信息，因此Kindle可以通过网络（邮件）下载到图书封面，从亚马逊图书商城里获得的图书，自然也会下载到图书封面信息。</li><li>通过数据线传输书籍，书籍信息中的封面信息无法作为元数据保存为图书信息，还会占用掉封片信息，因此需要等亚马逊删除掉封面之后再由calibre恢复（写入）元数据信息（书籍封面）</li><li>calibre的原理：</li></ol><blockquote><p>更改书籍的信息（元数据），从名称作者到封面</p><p>都可以自定义更改</p><p>并且还可以从官方根据书籍名称获取书籍元数据，并下载保存在图书中</p></blockquote></blockquote><h5 id="自己制作封面："><a href="#自己制作封面：" class="headerlink" title="自己制作封面："></a>自己制作封面：</h5><blockquote><blockquote><p>如果无法获取到在线的封面，可以自己制作封面，一般来说书籍中的第一页就是书的封面，我们可以在calibre双击打开书籍，然后截取封面。进入编辑原数据，将截图设定为封面</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212230933831.png" alt="截屏2022-12-23 09.31.25"  /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212230934612.png" alt="截屏2022-12-23 09.31.48"  /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212230934010.png" alt="截屏2022-12-23 09.31.59"  /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212230934909.png" alt="截屏2022-12-23 09.32.58"  /><p>完成之后不要忘了点左下角的确定</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212230934041.png" alt="截屏2022-12-23 09.33.07" style="zoom:50%;" /></blockquote><p>信息来源</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202208231555992.png" alt="截屏2022-08-23 15.33.18" style="zoom:50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Skill" scheme="https://chunyujin.top/categories/Skill/"/>
    
    <category term="Kindle" scheme="https://chunyujin.top/categories/Skill/Kindle/"/>
    
    
    <category term="Kindle" scheme="https://chunyujin.top/tags/Kindle/"/>
    
  </entry>
  
  <entry>
    <title>Linux_历史命令</title>
    <link href="https://chunyujin.top/chunyujin/6694219c.html"/>
    <id>https://chunyujin.top/chunyujin/6694219c.html</id>
    <published>2022-12-12T06:10:00.000Z</published>
    <updated>2023-01-01T05:43:11.863Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Linux会保存用户的历史指令"><a href="#Linux会保存用户的历史指令" class="headerlink" title="Linux会保存用户的历史指令"></a>Linux会保存用户的历史指令</h3><p>历史指令保存在用户目录下的.bash_history文件(历史记录文件)中，并且每条指令都用时间戳的形式记录了执行时刻</p><p>当用户通过shell进入Linux系统时，Linux系统会先将.bash_history中的保存的之前的历史指令读取到历史记录缓存区中，在用户正常退出shell之前，执行的所有指令也会先记录在缓存区中，当用户正常退出shell(exit或者control+d)时，shell进程会自动将历史记录缓存区中的所有历史记录写入到.bash_history中</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209114140665.png" alt="image-20221209114140665"></p><h4 id="查看历史缓冲区"><a href="#查看历史缓冲区" class="headerlink" title="查看历史缓冲区"></a>查看历史缓冲区</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history #查看历史记录缓存区中保存的历史指令</span><br></pre></td></tr></table></figure><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20221209112431.png" alt="QQ截图20221209112431"  /><p>从最开始到现在为止</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20221209112449.png"></p></blockquote><h5 id="通过键盘上下键快捷查看历史缓冲区"><a href="#通过键盘上下键快捷查看历史缓冲区" class="headerlink" title="通过键盘上下键快捷查看历史缓冲区"></a>通过键盘上下键快捷查看历史缓冲区</h5><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E5%BD%95%E5%B1%8F20221209120917.gif" alt="QQ录屏20221209120917"></p><h5 id="定量查看历史缓冲区的历史指令"><a href="#定量查看历史缓冲区的历史指令" class="headerlink" title="定量查看历史缓冲区的历史指令"></a>定量查看历史缓冲区的历史指令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history &lt;数字&gt; #查看缓冲区中最近的n条历史指令</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209172316597.png" alt="image-20221209172316597"></p><h4 id="手动写入-bash-history"><a href="#手动写入-bash-history" class="headerlink" title="手动写入.bash_history"></a>手动写入.bash_history</h4><p>如果执行了几条指令，比如执行两次<code>ls</code>和<code>ll</code>，查看一下历史缓存区</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209115827151.png" alt="image-20221209115827151"></p><p>再查看.bash_history，发现没有记录在里面，因为历史记录保存在了历史缓存区，当退出shell的时候才会自动从缓存区写入.bash_history</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209115907240.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history -w #手动将历史缓存写入用户目录下的.bash_history</span><br></pre></td></tr></table></figure><p>正常情况下，只有在 Shell 正常退出时，才会将缓冲区内容保存到.bash_history。如果想主动保存缓冲区的历史记录，执行 <code>-w</code> 选项即可</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209120133565.png" alt="image-20221209120133565"></p><h4 id="清除历史缓冲区"><a href="#清除历史缓冲区" class="headerlink" title="清除历史缓冲区"></a>清除历史缓冲区</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history -c #清除历史缓冲区</span><br></pre></td></tr></table></figure><p>历史缓冲区写入.bash_history其实就是用新内容覆盖掉原有内容，所以清除历史缓冲区就是清除本次登录用户时的所有操作的记录，不会删除之前的历史记录</p><h4 id="重复执行缓冲区历史指令"><a href="#重复执行缓冲区历史指令" class="headerlink" title="重复执行缓冲区历史指令"></a>重复执行缓冲区历史指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!&lt;数字&gt; #重复执行缓冲区中的第n条历史指令</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209173229978.png" alt="image-20221209173229978"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!-&lt;数字&gt; #重复执行缓冲区中倒数第n行历史指令</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209174342766.png" alt="image-20221209174342766"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!! #重复执行上一条命令</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209174410518.png" alt="image-20221209174410518"></p><h4 id="搜索历史命令"><a href="#搜索历史命令" class="headerlink" title="搜索历史命令"></a>搜索历史命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + r# 输入残缺指令，搜索对应完整历史指令</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212121356384.gif" alt="Dec-12-2022 13-56-09"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Linux" scheme="https://chunyujin.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://chunyujin.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>VsCode快捷键&amp;使用技巧</title>
    <link href="https://chunyujin.top/chunyujin/d25e6d9b.html"/>
    <id>https://chunyujin.top/chunyujin/d25e6d9b.html</id>
    <published>2022-12-09T09:57:00.000Z</published>
    <updated>2023-01-07T04:56:20.359Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h4><p>⌃ + ⌥ + N</p><p>ctrl + alt + N</p><h4 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h4><p>⌥ + ⇧ + F</p><p>alt + shift + F</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202209121909898.png" alt="截屏2022-09-12 18.49.36" style="zoom: 33%;" /><h4 id="批量更改变量、函数名称"><a href="#批量更改变量、函数名称" class="headerlink" title="批量更改变量、函数名称"></a>批量更改变量、函数名称</h4><p>光标选中名称</p><p>⌘ + ⇧ + L</p><p>ctrl + shift + L</p><h4 id="深浅模式跟随系统"><a href="#深浅模式跟随系统" class="headerlink" title="深浅模式跟随系统"></a>深浅模式跟随系统</h4><p>设置中搜索</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301071256453.png" alt="截屏2023-01-07 12.54.53"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Skill" scheme="https://chunyujin.top/categories/Skill/"/>
    
    <category term="IDE" scheme="https://chunyujin.top/categories/Skill/IDE/"/>
    
    
    <category term="VsCode" scheme="https://chunyujin.top/tags/VsCode/"/>
    
  </entry>
  
  <entry>
    <title>C++_map&amp;pair类</title>
    <link href="https://chunyujin.top/chunyujin/899a3eaf.html"/>
    <id>https://chunyujin.top/chunyujin/899a3eaf.html</id>
    <published>2022-12-05T03:52:00.000Z</published>
    <updated>2023-01-02T04:45:23.922Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h4><blockquote><p>STL中的容器分为序列式容器(vector、list、array、deque、forward_list)和关联式容器(map、multimap、set、multiset)</p><p>序列式容器的特点是保存元素时只保存元素本身，不会对存储的元素进行自动排序，元素排列的顺序取决于存储它们的顺序</p><p>关联式容器在存储元素的时候还会存储另一个跟元素相关的值，称为“键”，元素和它的“键”作为一个整体“键值对”存储在关联式容器中，关联式容器自动根据“键”的大小将元素作升序排序；另外，可以根据元素的“键”找到对应的元素。</p></blockquote><h4 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h4><blockquote><p>pair是C++STL标准库中的一个类模版，定义在头文件 <code>&lt;utility&gt;</code> 中</p><p>是专门用来表示“键值对”的类型</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="编程日志" scheme="https://chunyujin.top/categories/%E7%BC%96%E7%A8%8B%E6%97%A5%E5%BF%97/"/>
    
    <category term="C&amp;C++" scheme="https://chunyujin.top/categories/%E7%BC%96%E7%A8%8B%E6%97%A5%E5%BF%97/C-C/"/>
    
    
    <category term="C++" scheme="https://chunyujin.top/tags/C/"/>
    
    <category term="C++STL" scheme="https://chunyujin.top/tags/C-STL/"/>
    
  </entry>
  
  <entry>
    <title>C++_auto关键字</title>
    <link href="https://chunyujin.top/chunyujin/b4979a36.html"/>
    <id>https://chunyujin.top/chunyujin/b4979a36.html</id>
    <published>2022-12-04T15:02:00.000Z</published>
    <updated>2023-01-02T04:45:23.925Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://c.biancheng.net/view/3718.html">auto关键字(类型推导)</a></p><p>当STL的模板类型实例化的时候，如果实例化的类型是模版类型，那么使用迭代器是会报错的</p><p>比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; i;<span class="comment">//vecter的实例化类型是int</span></span><br><span class="line">vector&lt;T&gt; v;<span class="comment">//vector的实例化类型是模版类型T</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator I = i.<span class="built_in">begin</span>();<span class="comment">//正确</span></span><br><span class="line">  veector&lt;T&gt;::iterator V = v.<span class="built_in">begin</span>();<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为在模板参数T实例化之前，模板类型为int的vector明确了自己的类型就是int，故迭代器可以根据类型执行相应的关于空间的操作。而模版类型为T的vector尚不知道T究竟是什么类型，所以迭代器无法通过类型来执行操作</p></blockquote><p>auto关键字是在程序编译时自动推导出变量的类型，可以很自然地和泛型编程结合而不用去提前考虑变量的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;T&gt; v;<span class="comment">//vector的实例化类型是模版类型T</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> V = v.<span class="built_in">begin</span>();<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>auto会在最后编译的时候，会判断变量的类型。在编译时，一旦调用函数，T类型就已经实例化，并且v是vector，vector.begin()函数返回的就是vector的迭代器，因此编译器会推导出此时V的类型</p><p>&#x3D;&#x3D;因此auto可以将泛型编程(模板)跟STL很好地结合&#x3D;&#x3D;</p></blockquote><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212041341428.png" alt="iShot_2022-12-04_13.40.14"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="编程日志" scheme="https://chunyujin.top/categories/%E7%BC%96%E7%A8%8B%E6%97%A5%E5%BF%97/"/>
    
    <category term="C&amp;C++" scheme="https://chunyujin.top/categories/%E7%BC%96%E7%A8%8B%E6%97%A5%E5%BF%97/C-C/"/>
    
    
    <category term="C++" scheme="https://chunyujin.top/tags/C/"/>
    
    <category term="C++STL" scheme="https://chunyujin.top/tags/C-STL/"/>
    
  </entry>
  
  <entry>
    <title>C++_所有函数都可直接调用</title>
    <link href="https://chunyujin.top/chunyujin/5656723d.html"/>
    <id>https://chunyujin.top/chunyujin/5656723d.html</id>
    <published>2022-12-04T11:59:00.000Z</published>
    <updated>2023-01-02T04:45:23.924Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>无论函数是否有返回值，都可以直接调用</p><p>并不是说有返回值的函数在调用的时候必须用一个变量去承接返回值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="编程日志" scheme="https://chunyujin.top/categories/%E7%BC%96%E7%A8%8B%E6%97%A5%E5%BF%97/"/>
    
    <category term="C&amp;C++" scheme="https://chunyujin.top/categories/%E7%BC%96%E7%A8%8B%E6%97%A5%E5%BF%97/C-C/"/>
    
    
    <category term="C++" scheme="https://chunyujin.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++_vector常用用法</title>
    <link href="https://chunyujin.top/chunyujin/170bba21.html"/>
    <id>https://chunyujin.top/chunyujin/170bba21.html</id>
    <published>2022-12-04T06:38:00.000Z</published>
    <updated>2023-01-01T06:36:43.106Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h6 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a><a href="http://c.biancheng.net/view/6749.html">常用用法</a></h6><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212031057955.png" alt="iShot_2022-12-03_10.57.40"></p><h6 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a><a href="http://c.biancheng.net/view/6846.html">删除元素</a></h6><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212041438569.png" alt="iShot_2022-12-04_14.38.37"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="编程日志" scheme="https://chunyujin.top/categories/%E7%BC%96%E7%A8%8B%E6%97%A5%E5%BF%97/"/>
    
    <category term="C&amp;C++" scheme="https://chunyujin.top/categories/%E7%BC%96%E7%A8%8B%E6%97%A5%E5%BF%97/C-C/"/>
    
    
    <category term="C++" scheme="https://chunyujin.top/tags/C/"/>
    
    <category term="C++STL" scheme="https://chunyujin.top/tags/C-STL/"/>
    
  </entry>
  
  <entry>
    <title>C++_迭代器&amp;find()函数</title>
    <link href="https://chunyujin.top/chunyujin/874d4093.html"/>
    <id>https://chunyujin.top/chunyujin/874d4093.html</id>
    <published>2022-12-04T06:17:00.000Z</published>
    <updated>2023-01-02T04:45:23.927Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器(iterator)"></a><a href="http://c.biancheng.net/view/338.html">迭代器(iterator)</a></h3><h4 id="什么是迭代器"><a href="#什么是迭代器" class="headerlink" title="什么是迭代器"></a>什么是迭代器</h4><p>迭代器与容器的关系，相当于指针与数组的关系</p><p>因为容器是封装起来的，不知道内部是如何实现的，所以通过在内存中的地址的原理访问和遍历容器，一般来说是不实际的</p><p>要访问容器(顺序容器、关联容器)中的元素，就需要通过迭代器进行；就如同访问数组中的元素需要通过指针进行一样</p><p>用迭代器访问元素的操作也和用指针访问数组的操作很像</p><p>迭代器按照定义方式分成以下四种</p><blockquote><ol><li><p>正向迭代器，定义方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容器类名::iterator 迭代器名;</span><br></pre></td></tr></table></figure></li><li><p>常量正向迭代器，定义方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容器类名::const_iterator 迭代器名;</span><br></pre></td></tr></table></figure></li><li><p>反向迭代器，定义方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容器类名::reverse_iterator 迭代器名;</span><br></pre></td></tr></table></figure></li><li><p>常量反向迭代器，定义方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容器类名::const_reverse_iterator 迭代器名;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="迭代器用法示例"><a href="#迭代器用法示例" class="headerlink" title="迭代器用法示例"></a>迭代器用法示例</h4><p>通过迭代器可以读取它指向的元素，<code>*迭代器名</code>就表示迭代器指向的元素。通过非常量迭代器还能修改其指向的元素。</p><p>迭代器都可以进行<code>++</code>操作。反向迭代器和正向迭代器的区别在于：</p><ul><li>对正向迭代器进行<code>++</code>操作时，迭代器会指向容器中的后一个元素；</li><li>而对反向迭代器进行<code>++</code>操作时，迭代器会指向容器中的前一个元素。</li></ul><p>下面的程序演示了如何通过迭代器&#x3D;&#x3D;遍历一个 vector 容器&#x3D;&#x3D;中的所有元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;  <span class="comment">//v是存放int类型变量的可变长数组，开始时没有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n&lt;<span class="number">5</span>; ++n)</span><br><span class="line">        v.<span class="built_in">push_back</span>(n);  <span class="comment">//push_back成员函数在vector容器尾部添加一个元素</span></span><br><span class="line">  </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator i;  <span class="comment">//定义正向迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i) <span class="comment">//用迭代器遍历容器</span></span><br><span class="line">    &#123;  </span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//*i 就是迭代器i指向的元素</span></span><br><span class="line">        *i *= <span class="number">2</span>;  <span class="comment">//每个元素变为原来的2倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//用反向迭代器遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::reverse_iterator j = v.<span class="built_in">rbegin</span>(); j != v.<span class="built_in">rend</span>(); ++j)</span><br><span class="line">        cout &lt;&lt; *j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>程序的输出结果是：<br>0 1 2 3 4<br>8 6 4 2 0</p><p>第 6 行，vector 容器有多个构造函数，如果用无参构造函数初始化，则容器一开始是空的。</p><p>第 10 行，begin 成员函数返回指向容器中第一个元素的迭代器。++i 使得 i 指向容器中的下一个元素。end 成员函数返回的不是指向最后一个元素的迭代器，而是指向最后一个元素后面的位置的迭代器，因此循环的终止条件是<code>i != v.end()</code>。</p><p>第 16 行定义了反向迭代器用以遍历容器。反向迭代器进行<code>++</code>操作后，会指向容器中的上一个元素。rbegin 成员函数返回指向容器中最后一个元素的迭代器，rend 成员函数返回指向容器中第一个元素前面的位置的迭代器，因此本循环实际上是从后往前遍历整个数组。</p><p>如果迭代器指向了容器中最后一个元素的后面或第一个元素的前面，再通过该迭代器访问元素，就有可能导致程序崩溃，这和访问 NULL 或未初始化的指针指向的地方类似。</p><p>第 10 行和第 16 行，写<code>++i</code>、<code>++j</code>相比于写<code>i++</code>、<code>j++</code>，程序的执行速度更快。</p><p>回顾<code>++</code>被重载成前置和后置运算符的例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CDemo CDemo::<span class="keyword">operator</span>++ ()</span><br><span class="line">&#123;  <span class="comment">//前置++</span></span><br><span class="line">    ++n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">CDemo CDemo::<span class="keyword">operator</span> ++(<span class="type">int</span> k)</span><br><span class="line">&#123;  <span class="comment">//后置++</span></span><br><span class="line">    <span class="function">CDemo <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;  <span class="comment">//记录修改前的对象</span></span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span> tmp;  <span class="comment">//返回修改前的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后置<code>++</code>要多生成一个局部对象 tmp，因此执行速度比前置的慢。同理，迭代器是一个对象，<a href="http://c.biancheng.net/stl/">STL</a> 在重载迭代器的<code>++</code>运算符时，后置形式也比前置形式慢。在次数很多的循环中，<code>++i</code>和<code>i++</code>可能就会造成运行时间上可观的差别了。因此，本教程在前面特别提到，对循环控制变量i，要养成写<code>++i</code>、不写<code>i++</code>的习惯。</p></blockquote><p>注意，容器适配器 stack、queue 和 priority_queue 没有迭代器。容器适配器有一些成员函数，可以用来对元素进行访问。</p><h4 id="迭代器的功能分类"><a href="#迭代器的功能分类" class="headerlink" title="迭代器的功能分类"></a>迭代器的功能分类</h4><p>不同容器的迭代器，其功能强弱有所不同。容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。例如，排序算法需要通过随机访问迭代器来访问容器中的元素，因此有的容器就不支持排序算法。</p><p>常用的迭代器按功能强弱分为输入、输出、正向、双向、随机访问五种，这里只介绍常用的三种。</p><blockquote><ol><li><p>正向迭代器。假设 p 是一个正向迭代器，则 p 支持以下操作：++p，p++，*p。此外，两个正向迭代器可以互相赋值，还可以用<code>==</code>和<code>!=</code>运算符进行比较。</p></li><li><p>双向迭代器。双向迭代器具有正向迭代器的全部功能。除此之外，若 p 是一个双向迭代器，则<code>--p</code>和<code>p--</code>都是有定义的。<code>--p</code>使得 p 朝和<code>++p</code>相反的方向移动。</p></li><li><p>随机访问迭代器。随机访问迭代器具有双向迭代器的全部功能。若 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p></li></ol><ul><li>p+&#x3D;i：使得 p 往后移动 i 个元素。</li><li>p-&#x3D;i：使得 p 往前移动 i 个元素。</li><li>p+i：返回 p 后面第 i 个元素的迭代器。</li><li>p-i：返回 p 前面第 i 个元素的迭代器。</li><li>p[i]：返回 p 后面第 i 个元素的引用。</li></ul><p>此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 运算符进行比较。<code>p1&lt;p2</code>的含义是：p1 经过若干次（至少一次）<code>++</code>操作后，就会等于 p2。其他比较方式的含义与此类似。</p><p>&#x3D;&#x3D;对于两个随机访问迭代器 p1、p2，表达式<code>p2-p1</code>也是有定义的，其返回值是 p2 所指向元素和 p1 所指向元素的序号(下标)之差（也可以说是 p2 和 p1 之间的元素个数减一）。&#x3D;&#x3D;</p><blockquote><p>例如在vector中返回某个元素的下标</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span><span class="comment">//std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span><span class="comment">//std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; temp = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = temp.<span class="built_in">begin</span>();</span><br><span class="line">it += <span class="number">2</span>;<span class="comment">//p+=i</span></span><br><span class="line"><span class="comment">//此时it对应的元素下标为</span></span><br><span class="line"><span class="type">int</span> index = it - temp.<span class="built_in">begin</span>();<span class="comment">//p2-p1</span></span><br><span class="line">cout &lt;&lt; index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出2</p></blockquote></blockquote><p>不同容器的迭代器的功能:</p><table><thead><tr><th>容器</th><th>迭代器功能</th></tr></thead><tbody><tr><td>vector</td><td>随机访问</td></tr><tr><td>deque</td><td>随机访问</td></tr><tr><td>list</td><td>双向</td></tr><tr><td>set &#x2F; multiset</td><td>双向</td></tr><tr><td>map &#x2F; multimap</td><td>双向</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr><tr><td>priority_queue</td><td>不支持迭代器</td></tr></tbody></table><blockquote><p>vector 的迭代器是随机迭代器，因此&#x3D;&#x3D;遍历 vector 容器&#x3D;&#x3D;有以下几种做法。下面的程序中，每个循环演示了一种做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//v被初始化成有100个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; v.<span class="built_in">size</span>() ; ++i) <span class="comment">//size返回元素个数</span></span><br><span class="line">        cout &lt;&lt; v[i]; <span class="comment">//像普通数组一样使用vector容器</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator i;</span><br><span class="line">    <span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span> (); ++i) <span class="comment">//用 != 比较两个迭代器</span></span><br><span class="line">        cout &lt;&lt; * i;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span> ();++i) <span class="comment">//用 &lt; 比较两个迭代器</span></span><br><span class="line">        cout &lt;&lt; * i;</span><br><span class="line">  </span><br><span class="line">    i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(i &lt; v.<span class="built_in">end</span>()) &#123; <span class="comment">//间隔一个输出</span></span><br><span class="line">        cout &lt;&lt; * i;</span><br><span class="line">        i += <span class="number">2</span>; <span class="comment">// 随机访问迭代器支持 &quot;+= 整数&quot;  的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>list 容器的迭代器是双向迭代器。</p><p>假设 v 和 i 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure><p>则以下代码是合法的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=v.<span class="built_in">begin</span>(); i!=v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">  cout &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p>以下代码则不合法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=v.<span class="built_in">begin</span>(); i&lt;v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">  cout &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p>因为双向迭代器不支持用 “&lt;” 进行比较。以下代码也不合法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">  cout &lt;&lt; v[i];</span><br></pre></td></tr></table></figure><p>因为 list 不支持随机访问迭代器的容器，也不支持用下标随机访问其元素。</p></blockquote><p><strong>&#x3D;&#x3D;在 <a href="http://c.biancheng.net/cplus/">C++</a> 中，数组也是容器。数组的迭代器就是指针，而且是随机访问迭代器。例如，对于数组 int a[10]，int * 类型的指针就是其迭代器。则 a、a+1、a+2 都是 a 的迭代器。&#x3D;&#x3D;</strong></p><h4 id="迭代器的辅助函数-好用"><a href="#迭代器的辅助函数-好用" class="headerlink" title="迭代器的辅助函数(好用)"></a>迭代器的辅助函数(好用)</h4><p>STL 中有用于操作迭代器的三个函数模板</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">advance</span>(p, n) </span><br></pre></td></tr></table></figure><p>使迭代器 p 向前或向后移动 n 个元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">distance</span>(p, q)</span><br></pre></td></tr></table></figure><p>计算两个迭代器之间的距离，即迭代器 p 经过多少次 + + 操作后和迭代器 q 相等。如果调用时 p 已经指向 q 的后面，则这个函数会陷入死循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">iter_swap</span>(p, q)</span><br></pre></td></tr></table></figure><p>用于交换两个迭代器 p、q 指向的值</p></blockquote><p>要使用上述模板，需要包含头文件 algorithm。下面的程序演示了这三个函数模板的 用法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">//要使用操作迭代器的函数模板，需要包含此文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    list &lt;<span class="type">int</span>&gt; <span class="built_in">lst</span>(a, a+<span class="number">5</span>);</span><br><span class="line">    list &lt;<span class="type">int</span>&gt;::iterator p = lst.<span class="built_in">begin</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">advance</span>(p, <span class="number">2</span>);  <span class="comment">//p向后移动两个元素，指向3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1)&quot;</span> &lt;&lt; *p &lt;&lt; endl;  <span class="comment">//输出 1)3</span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">advance</span>(p, <span class="number">-1</span>);  <span class="comment">//p向前移动一个元素，指向2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2)&quot;</span> &lt;&lt; *p &lt;&lt; endl;  <span class="comment">//输出 2)2</span></span><br><span class="line">  </span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator q = lst.<span class="built_in">end</span>();</span><br><span class="line">  </span><br><span class="line">    q--;  <span class="comment">//q 指向 5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3)&quot;</span> &lt;&lt; <span class="built_in">distance</span>(p, q) &lt;&lt; endl;  <span class="comment">//输出 3)3</span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">iter_swap</span>(p, q); <span class="comment">//交换 2 和 5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;4)&quot;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (p = lst.<span class="built_in">begin</span>(); p != lst.<span class="built_in">end</span>(); ++p)</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是：<br>\1) 3<br>\2) 2<br>\3) 3<br>\4) 1 5 3 4 2</p><h4 id="返回-随机访问迭代器中某个元素的-位置-序号-下标"><a href="#返回-随机访问迭代器中某个元素的-位置-序号-下标" class="headerlink" title="返回 随机访问迭代器中某个元素的 位置(序号)(下标)"></a>返回 随机访问迭代器中某个元素的 位置(序号)(下标)</h4><p>方法1⃣️用循环，从第1个元素开始找，直到找到对应的元素，返回下标</p><p>方法2⃣️利用<a href="http://c.biancheng.net/view/7489.html">find函数</a>，找到对应元素的迭代器，利用<a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%88%86%E7%B1%BB">“两个随机访问迭代器相减，返回值是两个迭代器对应的元素的序号(下标)之差”</a>，用该元素的迭代器减去容器首元素迭代器，返回值就是该元素的下标</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span><span class="comment">//std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span><span class="comment">//std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span><span class="comment">//std::find()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; temp = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>(), <span class="number">5</span>);<span class="comment">//value为要查找的值，该函数返回一个指向对应元素的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时it对应的元素下标为</span></span><br><span class="line"><span class="type">int</span> index = it - temp.<span class="built_in">begin</span>();</span><br><span class="line">cout &lt;&lt; index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>find函数是algorithm的库函数</p><p>find() 函数本质上是一个模板函数，用于在指定范围内查找和目标元素值相等的第一个元素。</p><p>如下为 find() 函数的语法格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InputIterator <span class="title">find</span> <span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，first 和 last 为输入迭代器，[first, last) 用于指定该函数的查找范围；value 为要查找的目标元素。</p><blockquote><p>正因为 first 和 last 的类型为输入迭代器，因此该函数适用于所有的序列式容器。</p></blockquote><p>该函数会<strong>返回</strong>一个<u>输入迭代器</u>，当 find() 函数查找成功时，其指向的是在 [first, last) 区域内查找到的第一个目标元素；如果查找失败，则该迭代器的指向和 last 相同。</p><blockquote><p>例如查找vector的元素时，first是vector.begin()，end是vector.end()</p><blockquote><p> vector.end()是指向容器的最后一个元素之后的&#x2F;0</p></blockquote></blockquote><p>值得一提的是，find() 函数的底层实现，其实就是用<code>==</code>运算符将 val 和 [first, last) 区域内的元素逐个进行比对。这也就意味着，[first, last) 区域内的元素必须支持<code>==</code>运算符。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::find</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//find() 函数作用于普通数组</span></span><br><span class="line"><span class="type">char</span> stl[] = <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line"><span class="comment">//调用 find() 查找第一个字符 &#x27;c&#x27;</span></span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">find</span>(stl, stl + <span class="built_in">strlen</span>(stl), <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="comment">//判断是否查找成功</span></span><br><span class="line"><span class="keyword">if</span> (p != stl + <span class="built_in">strlen</span>(stl))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//find() 函数作用于容器</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">it = <span class="built_in">find</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myvector.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;查找成功：&quot;</span> &lt;&lt; *it;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;查找失败&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.biancheng.net/stl/</span><br><span class="line">查找成功：30</span><br></pre></td></tr></table></figure><p>可以看到，find() 函数除了可以作用于序列式容器，还可以作用于普通数组(因为在C++中普通数组也是容器)</p><blockquote><p>补充：find() 函数的底层实现，C++ 标准库中给出了参数代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (first != last)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*first == val) <span class="keyword">return</span> first;</span><br><span class="line">++first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="迭代器的好处"><a href="#迭代器的好处" class="headerlink" title="迭代器的好处"></a>迭代器的好处</h4><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212031252529.png" alt="截屏2022-12-03 12.51.56"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="编程日志" scheme="https://chunyujin.top/categories/%E7%BC%96%E7%A8%8B%E6%97%A5%E5%BF%97/"/>
    
    <category term="C&amp;C++" scheme="https://chunyujin.top/categories/%E7%BC%96%E7%A8%8B%E6%97%A5%E5%BF%97/C-C/"/>
    
    
    <category term="C++" scheme="https://chunyujin.top/tags/C/"/>
    
    <category term="C++STL" scheme="https://chunyujin.top/tags/C-STL/"/>
    
  </entry>
  
  <entry>
    <title>C++_模板</title>
    <link href="https://chunyujin.top/chunyujin/a0e18b05.html"/>
    <id>https://chunyujin.top/chunyujin/a0e18b05.html</id>
    <published>2022-12-03T08:36:00.000Z</published>
    <updated>2023-01-02T04:45:23.927Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h6 id="x3D-x3D-模板参数分为三类-x3D-x3D"><a href="#x3D-x3D-模板参数分为三类-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;模板参数分为三类&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>模板参数分为三类</strong>&#x3D;&#x3D;</h6><ol><li>类型参数</li></ol><blockquote><p>通过 关键字 typename 或者 class 引入(两者基本上是等价的)</p></blockquote><ol start="2"><li>非类型参数</li></ol><blockquote><p>模板参数不局限于类型，类型的值也可以作为模板参数，通过 关键字 值的类型 引入</p><p>目前C++只支持 <u>整形</u> &#x2F; <u>枚举类型</u> &#x2F; <u>指针类型</u>(可以是原始数据类型的指针、派生数据类型的指针、对象的指针、对象的成员的指针) &#x2F; <u>引用类型</u>(可以是原始数据类型的引用、派生数据类型的引用、对象的引用)</p></blockquote><ol start="3"><li>模板型模板参数</li></ol><h6 id="x3D-x3D-模板参数支持缺省-x3D-x3D"><a href="#x3D-x3D-模板参数支持缺省-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;模板参数支持缺省&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>模板参数支持缺省</strong>&#x3D;&#x3D;</h6><blockquote><p>但是要注意的是，缺省参数的使用不要忘了按照规范形式，比如在类或函数声明时加了缺省值，在实现时就不要加了</p><p>(缺省值在声明时添加，在实现时就不添加了)</p><p>还有，缺省要从右往左缺省</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212031014022.png" alt="截屏2022-12-03 10.14.22"></p></blockquote><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221202104949903.png" alt="image-20221202104949903"></p><p><a href="https://blog.csdn.net/zhizhengguan/article/details/115869685">https://blog.csdn.net/zhizhengguan/article/details/115869685</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="编程日志" scheme="https://chunyujin.top/categories/%E7%BC%96%E7%A8%8B%E6%97%A5%E5%BF%97/"/>
    
    <category term="C&amp;C++" scheme="https://chunyujin.top/categories/%E7%BC%96%E7%A8%8B%E6%97%A5%E5%BF%97/C-C/"/>
    
    
    <category term="C++" scheme="https://chunyujin.top/tags/C/"/>
    
  </entry>
  
</feed>
