<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/chunyujin/0.html"/>
      <url>/chunyujin/0.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CLion-Linux远程开发</title>
      <link href="/chunyujin/e6f97f8c.html"/>
      <url>/chunyujin/e6f97f8c.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CLion利用远程Linux开发有两种方式：</p><ol><li>远程连接Linux，利用CLion远程窗口直接操纵Linux。</li><li>将CLion本地项目部署并映射到Linux目录下，基于本地CLion进行开发，构建时选择使用本地或远程Linux环境。</li></ol><p>本教程使用的是方法2，原因如下：</p><ol><li>方法1需要远程Linux机器下载CLion引用，并占用较大的资源，对于小型Linux服务器支持不太好；方法2无需远程机器安装CLion。</li><li>方法1一套代码，只能在Linux上运行，因为本质就是ssh连接到远程Linux服务器，只是界面借用了CLion；方法2可以实现同一套代码，通过切换编译环境，在不同环境下构建和运行，并支持同时部署到多个环境&#x2F;机器下，在测试时比较方便。</li><li>方法2可以及时进行本地与远程项目上传、下载、差看版本修改以进行同步等。</li></ol><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><ul><li>Linux环境下安装cmake、g++。</li><li>Linux环境下安装好openssh，并开启远程服务，以Ubuntu为例：<ul><li>在终端中输入: sudo apt-get install openssh-server 安装<a href="https://zhida.zhihu.com/search?content_id=556037211&content_type=Answer&match_order=2&q=openssh&zhida_source=entity">openssh</a>。</li><li>在终端输入sudo ps -e|grep ssh 回车，有sshd 阐明ssh服务现已发动；如果未发动，输入sudo service ssh start 回车ssh服务。</li></ul></li><li>Windows环境(Mac环境同样适用)下安装好CLion、一款支持远程ssh的轻量化软件(如vscode、xshell、finalshell等)。</li></ul><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>基本思路</p><blockquote><p>以单个项目为基本单位，将Windows本地项目部署到Linux服务器，并在其环境下进行构建、运行，并利用Clion功能进行代码版本同步。</p></blockquote><h3 id="Windows本地创建项目"><a href="#Windows本地创建项目" class="headerlink" title="Windows本地创建项目"></a>Windows本地创建项目</h3><p>创建或打开任意想要部署在Linux上的项目</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023135251610.png" alt="image-20241023135251610" /><h3 id="工具链中添加远程主机"><a href="#工具链中添加远程主机" class="headerlink" title="工具链中添加远程主机"></a>工具链中添加远程主机</h3><p>点击左上角四条横杠，选择“文件”——“设置”——“构建、执行、部署”——“工具链”</p><p>点击工具链界面中左上角加号，添加远程主机，在“凭据”一栏点击设置，添加ssh配置，按照Linux服务器主机、用户名、密码等进行填写。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/tset.png" alt="tset" /><p>添加远程主机后回到工具链界面，发现远程Linux主机下cmake版本等已经被自动识别</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023140432230.png" alt="image-20241023140432230" style="zoom: 67%;" /><p>点击“应用”保存即可。</p><h3 id="部署中设置路径映射"><a href="#部署中设置路径映射" class="headerlink" title="部署中设置路径映射"></a>部署中设置路径映射</h3><p>点击设置栏中的”部署“，发现之前添加的主机已经存在了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023141905311.png" alt="image-20241023141905311" style="zoom:80%;" /><p>在这个页面中，”根路径“就是映射远程主机的起始路径，可以是”&#x2F;“，也可以是用户的”&#x2F;home&#x2F;用户”路径等，此处的根目录更改，后面”映射“的相对路径也要更改。</p><p>点击页面上的”映射“，”本地路径“就是项目位于本地的位置，”部署目录“就是需要我们填写的映射到Linux远程的路径。因为前面”根目录“我设置的是”&#x2F;“，因此这里填写想要放置的位置的绝对路径即可。</p><p>Web路径可以不写。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023142157741.png" alt="image-20241023142157741" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023142343427.png" alt="image-20241023142343427" style="zoom:80%;" /><blockquote><p>需要注意的是：</p><p>路径应该是项目文件夹到项目文件夹的，建议在映射的时候，在远端新建一个用来存放映射项目的单独文件夹，防止映射到上层文件夹，破坏目录结构。</p><p>另外，CLion没有创建Linux远端新目录的权限，因此需要用户手动创建新目录。</p></blockquote><p>完成后点击应用。</p><blockquote><p>到这一步，已经完成了本地与远程的映射，后续设置debug配置等之后，执行构建时会自动进行上传。</p><p>现阶段可以使用如下方法进行测试：</p><p>1.CLion窗口最下方，点击”&lt;无默认服务器&gt;”，选择部署好的远程主机（此步骤不影响部署，只是设定一个默认选项，减少后续设置）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023143023020.png" alt="image-20241023143023020" style="zoom:80%;" /><p>2.右击项目文件夹，或选择菜单栏的工具，找到”部署“</p><p>可以看到关于”上传到远程主机“、”从远程主机下载“等操作，点击”上传到远程主机“</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023143426328.png" alt="image-20241023143426328" style="zoom:80%;" /><p>确认上传后等待执行完毕</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023143655915.png" alt="image-20241023143655915" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023143648276.png" alt="image-20241023143648276" style="zoom:80%;" /><p>可以看到远端对应路径下确实被部署了项目</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023143801196.png" alt="image-20241023143801196" style="zoom:80%;" /><p>(如果没有在第1步中设置默认服务器，会是下面这个样子，但是点击上传之后，会弹出服务器选项，效果一样的)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023144011243.png" alt="image-20241023144011243" style="zoom:80%;" /></blockquote><h3 id="配置本地调用远程环境构建"><a href="#配置本地调用远程环境构建" class="headerlink" title="配置本地调用远程环境构建"></a>配置本地调用远程环境构建</h3><p>点击CLion窗口右上角”Debug“，选择”编辑CMake配置文件“，在打开的设置界面中选择加号，创建新的配置文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023144304626.png" alt="image-20241023144304626" style="zoom:80%;" /><p>更改名称、构建类型、工具链、生成器等，工具链选择远程Linux下的构建工具</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023144425935.png" alt="image-20241023144425935" style="zoom:80%;" /><p>完成后选择确定，等待cmake项目加载</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023144503759.png" alt="image-20241023144503759" style="zoom:80%;" /><blockquote><p>期间可能会报错，因为远端cmake版本低于CMakeList.txt最低版本要求，更改一下CMakeList.txt中最低版本限制即可。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023144614089.png" alt="image-20241023144614089" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023144628325.png" alt="image-20241023144628325" style="zoom:80%;" /><p>右击CMakeList.txt选择”重新加载CMake项目“，或者点击窗口左下角”重新加载CMake项目“的图标，等待CMake加载完成。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023144733359.png" alt="image-20241023144733359" style="zoom:80%;" /></blockquote><p>更改完成后，发现右上角CMake配置中多了一个选项，这个就是调用的远程Linux环境下的CMake，至此设置完成。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023144932723.png" alt="image-20241023144932723" style="zoom:80%;" /><h3 id="CLion下生成构建系统、构建、执行过程"><a href="#CLion下生成构建系统、构建、执行过程" class="headerlink" title="CLion下生成构建系统、构建、执行过程"></a>CLion下生成构建系统、构建、执行过程</h3><p>Linux下，生成构建、构建、执行都是需要一系列命令行进行操作的，CLion远程连接Linux之后，将命令行操作转化为了图形化界面的操作，用点击代替了命令行。</p><h4 id="生成构建系统："><a href="#生成构建系统：" class="headerlink" title="生成构建系统："></a>生成构建系统：</h4><p>CMakeList.txt为构建管理文件，通过该文件配合cmake命令行工具，可以生成不同平台下的构建系统。如通过CMakeList.txt，CMake可以生成Linux下的构建系统-makefile，Windows下也会生成对应的一个构建系统。</p><p>在CLion中，想要执行一个程序，需要先使用CMakeList.txt执行CMake项目的加载，生成不同平台下的构建系统：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023151229746.png" alt="image-20241023151229746" style="zoom:80%;" /><p>执行CMake构建之后，远程Linux环境下映射目录中也同步到了构建系统：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023154614984.png" alt="image-20241023154614984" style="zoom:80%;" /><p>CLion中对于cmake执行之后生成的build目录命名是依据：<code>cmake-build-配置文件名</code>，配置文件名即为之前设置的：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023151420854.png" alt="image-20241023151420854" style="zoom:80%;" /><p>在上面构建目录中，可以发现，两个环境下的构建目录中都没有可执行程序，因为cmake的作用<mark>只是生成不同环境下的构建系统</mark>，而构建系统因平台而异，可执行程序是如何利用构建系统构建出来的，不归cmake管了，这也是为什么cmake跨平台：只负责到生成构建系统，不负责具体的构建。</p><p>具体的构建过程，是由不同平台下执行自己的构建工具，如Linux下使用make命令，执行makefile文件中的自动化构建过程，而makefile类似于一种脚本，集合了gcc、g++、rm等命令，进行包括编译、链接、打包等的构建。</p><h4 id="构建："><a href="#构建：" class="headerlink" title="构建："></a>构建：</h4><p>选择一个配置文件，点击右侧小锤子，执行“构建”</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023154635927.png" alt="image-20241023154635927" style="zoom:80%;" /><p>发现产生了可执行程序(选择的本地构建，生成的Windows下的.exe)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023154936490.png" alt="image-20241023154936490" style="zoom:80%;" /><p>执行远程的配置文件的构建：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023155210618.png" alt="image-20241023155210618" style="zoom:80%;" /><p>发现本地CLion项目下没有可执行程序，远程Linux项目下存在可执行程序。</p><p>猜想：</p><blockquote><p>因为本地Windows并不具备Linux编译运行环境，因此在本地执行的操作，仅仅是<mark>使用CMake生成构建系统，并上传部署到远端Linux映射目录中，本地用户执行”构建“操作时，CLion命令远端Linux，在远程Linux下进行构建，生成可执行程序。后续可执行程序的执行，也是在远程Linux下执行可执行程序(毕竟本地Windows不具备运行环境)，然后将执行结果返回并打印到本地Windows下CLion终端。</mark></p></blockquote><blockquote><p>如果没有生成构建系统，直接执行构建，则会因为没有构建系统目录而报错：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023155938447.png" alt="image-20241023155938447" style="zoom:80%;" /></blockquote><h4 id="执行："><a href="#执行：" class="headerlink" title="执行："></a>执行：</h4><p>CLion下执行包括了构建。所以可以直接跳过构建这一步，直接执行。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023154635927.png" alt="image-20241023154635927" style="zoom:80%;" /><p>配置文件中选择”Debug“，执行本地的exe可执行程序；选择”remote-debug“等远程环境的配置文件，执行远程Linux下的可执行程序。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023160144043.png" alt="image-20241023160144043" style="zoom:80%;" /><blockquote><p>本地执行结果：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023160445835.png" alt="image-20241023160445835" style="zoom:80%;" /><p>远端执行结果：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023160558425.png" alt="image-20241023160558425" style="zoom:80%;" /><p>从蓝色字体可以看出，一个执行的本地exe，一个执行的远端.out可执行程序，证实了前面的猜想。</p></blockquote><h2 id="其余功能介绍"><a href="#其余功能介绍" class="headerlink" title="其余功能介绍"></a>其余功能介绍</h2><h3 id="部署中上传下载设置屏蔽文件"><a href="#部署中上传下载设置屏蔽文件" class="headerlink" title="部署中上传下载设置屏蔽文件"></a>部署中上传下载设置屏蔽文件</h3><p>在设置–部署–”排除的路径“，可以查看当前上传下载中被排除的路径，CLion会自动设置排除掉构建系统目录：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023160908483.png" alt="image-20241023160908483" style="zoom:80%;" /><p>可以新增一个屏蔽，将部署路径(远端Linux)下的<code>.clion.source.upload.marker</code>文件排除掉，该文件是Clion添加到部署路径中，关于文件上传下载标记的，没有必要下载回本地项目中。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023161101328.png" alt="image-20241023161101328" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023161223807.png" alt="image-20241023161223807" style="zoom:80%;" /><h3 id="部署中进行版本同步"><a href="#部署中进行版本同步" class="headerlink" title="部署中进行版本同步"></a>部署中进行版本同步</h3><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023161303444.png" alt="image-20241023161303444" style="zoom:80%;" /><p>在项目修改前后，可以通过这个进行版本同步，查看本地与远端代码的版本差异，从而选择将本地上传到远程，还是远程下载到本地。</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241023161959762.png" alt="image-20241023161959762"></p><p>通常，CLion本地修改，保存之后，会自动进行上传，因此下载、版本同步功能，多用于远程手动修改代码之后，同步到本地。</p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> IDE </category>
          
          <category> JetBrains </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JetBrains </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11-智能指针</title>
      <link href="/chunyujin/15763eb7.html"/>
      <url>/chunyujin/15763eb7.html</url>
      
        <content type="html"><![CDATA[<h4 id="内存安全-部分内容"><a href="#内存安全-部分内容" class="headerlink" title="内存安全(部分内容)"></a>内存安全(部分内容)</h4><h5 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h5><p>在内存中申请了空间，但是并没有在合适的时机释放它，就会造成内存泄露。</p><p>内存泄露本质上就是对内存的使用“只增不减”，内存的可用空间一点点减少、泄露出去，像是一个只漏水但是不进水的杯子。</p><p><strong>在内存中申请空间之后，并不会自动释放掉这块内存，内存的释放分两种情况：</strong></p><ol><li><u>开发者使用<code>delete</code>或<code>析构函数</code>进行手动释放。</u>(通常，内置类型delete，自定义类型使用析构。对自定义类型使用delete，也是会调用其析构函数)</li><li><u>程序结束后操作系统自动释放。</u><br>值得注意的是，等待程序结束后由操作系统自动释放，其实已经无关”安全”了，因为操作系统并不关系程序运行时内存究竟是如何分配的，它要做的就是在程序结束后将所有内存全部收回。</li></ol><p><strong>内存有必要手动释放吗？为什么不能等待操作系统自动回收呢？</strong></p><p>考虑一下边界&#x2F;极端情况：<br>使用工厂模式生产对象时，如果工厂一直生产对象，但是并不释放已使用完毕的对象，会造成内存的不断泄露。</p><p><mark>内存泄露的危害</mark></p><p>  <strong>1、频繁GC</strong>：系统分配给每个应用的内存资源都是有限的，内存泄漏导致其他组件可用的内存变少后，一方面会使得GC的频率加剧，再发生GC的时候，所有进程都必须等待，GC的频率越高，用户越容易感应到卡顿。另一方面内存变少，可能使得系统额外分配给该对象一些内存，而影响整个系统的运行情况。</p><p>  <strong>2、导致程序运行崩溃</strong>：一旦内存不足以为某些对象分配所需要的空间，将会导致程序崩溃，造成体验差。</p><h5 id="数组越界、指针越界、野指针"><a href="#数组越界、指针越界、野指针" class="headerlink" title="数组越界、指针越界、野指针"></a>数组越界、指针越界、野指针</h5><p><strong>数组越界、指针越界、野指针</strong>的原理与现象是比较类似的：</p><p>访问到了操作系统并未开辟的内存空间(一说“垃圾内存”)。</p><blockquote><p> 在初始化变量、申请内存空间的时候，操作系统除了将数据写入对应的内存，还有一个行为，就是设置该内存块的访问权限。</p></blockquote><p><mark>危害</mark></p><p>访问未分配访问权限的内存本身就是违法的，该内存中保存的数据又是未知的，因此这种情况下，根本不知道内存情况，是一种极其危险的状态。</p><p><strong>数组越界：</strong></p><blockquote><p>对于数组的访问，超过了其变量范围。<br>如通过下标访问时，下标超过了数组设定的大小；++或–操作时，超过了数组的最大、最小范围。</p></blockquote><p><strong>指针越界：</strong></p><blockquote><p>指针指向了超出其变量的作用范围。<br>如：</p><p>父类指针指向子类对象时，访问子类新增成员或方法或访问重写的方法(不允许，但是是否是由于指针越界引起，存疑)(只允许静态联翩)。</p><p>且对于子类重写了的方法的调用，会根据指针类型来判断，父类指针指向子类对象，调用的还是父类指针的成员函数实现方法，而非子类重写之后的方法。</p><p>解决方法：</p><ol><li>强制类型转换(可能失败，且不安全) </li><li>动态转换，dynamic_cast（安全）</li><li>对于访问重写的方法，可以提前设置为虚函数，此时执行的是重写后的。</li></ol></blockquote><p><strong>野指针：</strong></p><blockquote><p>指向了没有访问权限的内存的指针。通常见于：delete一块空间之后，指向该空间的指针没有置空，该指针就成为了野指针。</p></blockquote><p><mark>为了避免以上现象，程序员需要养成良好的编程习惯。</mark></p><h4 id="C-11智能指针"><a href="#C-11智能指针" class="headerlink" title="C++11智能指针"></a>C++11智能指针</h4><p>为了解决上述 因为申请内存空间而可能造成的<mark>内存泄露</mark>、<mark>野指针</mark>等问题，C++11新特性中，智能指针应运而生。</p><blockquote><p>智能指针对于内存的管理，是利用对象的生命周期进行的。</p><p>当智能指针离开作用域时，会自动正确地销毁动态分配的内存对象，防止出现内存泄露。</p></blockquote><h5 id="C-库中的智能指针"><a href="#C-库中的智能指针" class="headerlink" title="C++库中的智能指针"></a>C++库中的智能指针</h5><blockquote><p>头文件<code>#include &lt;memory&gt;</code></p></blockquote><h6 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h6><p>独占式指针，同一时刻只能有一个指针指向同一个对象。因此不允许unique_ptr之间进行拷贝，只能通过转移构造函数进行转移。</p><p>使用该指针管理独占性资源</p><blockquote><p>常用方法介绍：</p><ol><li><p><code>unique_ptr::get()</code> 获取其保存的原生指针，尽量不要使用</p></li><li><p><code>unique_ptr::bool()</code> 判断是否拥有指针</p></li><li><p><code>unique_ptr::release()</code> 释放所管理指针的所有权，返回原生指针。但并不销毁原生指针。通常用来初始化另一个智能指针。</p></li><li><p><code>unique_ptr::reset()</code> 释放并销毁原生指针。如果参数为一个新指针，将管理这个新指针。</p></li><li><p><code>unique_ptr::swap()</code>交换两个智能指针所指向的对象</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;A&gt; <span class="title">a1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">A *origin_a = a1.<span class="built_in">get</span>();<span class="comment">//错误示例：尽量不要暴露原生指针</span></span><br><span class="line"><span class="keyword">if</span>(a1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// a1 拥有指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;A&gt; <span class="title">a2</span><span class="params">(a1.release())</span></span>;<span class="comment">//常见用法，转义拥有权</span></span><br><span class="line">a2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">A</span>());<span class="comment">//释放并销毁原有对象，持有一个新对象</span></span><br><span class="line">a2.<span class="built_in">reset</span>();<span class="comment">//释放并销毁原有对象，等同于下面的写法</span></span><br><span class="line">a2 = <span class="literal">nullptr</span>;<span class="comment">//释放并销毁原有对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>初始化方法：</p><ol><li>直接初始化：<code>unique&lt;T&gt; myPtr(new T);</code> 可以， 但<strong>不能通过隐式转换来构造</strong>，如<code>unique&lt;T&gt; myPtr = new T()</code> 因为unique_ptr构造函数被声明为explicit。</li><li>移动构造：<code>unique&lt;T&gt; myOtherPtr = std::move(myPtr);</code> 但不允许复制构造，如<code>unique&lt;T&gt; myOther = myPtr</code>; 因为unique是个只移动类型。只允许承接，不允许复制。(只能通过右值引用的方式交接管理权，不能进行拷贝)</li><li>通过 <code>make_unique</code> 构造：<code>unique&lt;T&gt; myPtr = std::make_unique&lt;T&gt;();</code> &#x2F;&#x2F;C++14支持的语法。但是 make 都<strong>不支持添加删除器，或者初始化列表</strong>。</li><li>通过reset重置：如 <code>std::unique_ptr up; up.reset(new T())</code>;</li></ol></blockquote><h6 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h6><p>共享式指针，同一时刻可以有多个指针指向同一个对象</p><p><code>std::shared_ptr</code> 共同确保对象在不被需要时被销毁， 没有哪个特定的 <code>std::shared_ptr</code> 拥有该对象， 它的实现机制是引用计数，内部包含一个指向资源的裸指针，另一个指向该资源的引用计数 （控制块）的裸指针。</p><p>使用该指针管理共享型资源</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;A&gt; <span class="title">a1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">std::shared_ptr&lt;A&gt; a2 = a1;<span class="comment">//编译正常，允许所有权的共享</span></span><br></pre></td></tr></table></figure><blockquote><p>常用方法介绍：</p><ol><li><code>shared_ptr::get()</code>获取其保存的原生指针，尽量不要使用</li><li><code>shared_ptr::bool()</code> 判断是否拥有指针</li><li><code>shared_ptr::reset()</code> 释放并销毁原生指针。如果参数为一个新指针，将管理这个新指针</li><li><code>shared_ptr::unique()</code> 如果引用计数为 1，则返回 true，否则返回 false</li><li><code>shared_ptr::use_count()</code> 返回引用计数的大小</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;A&gt; <span class="title">a1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">std::shared_ptr&lt;A&gt; a2 = a1;<span class="comment">//编译正常，允许所有权的共享</span></span><br><span class="line"></span><br><span class="line">A *origin_a = a1.<span class="built_in">get</span>();<span class="comment">//错误示范：尽量不要暴露原生指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// a1 拥有指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a1.<span class="built_in">unique</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果返回true，引用计数为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> a1_use_count = a1.<span class="built_in">use_count</span>();<span class="comment">//引用计数数量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用<code>shared_ptr</code>可能会带来的问题：<mark>互相引用时会造成死锁，最终导致内存泄露</mark></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">A</span>()</span><br><span class="line">     &#123;</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ~<span class="built_in">A</span>()</span><br><span class="line">     &#123;</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">setB</span><span class="params">(std::shared_ptr&lt;B&gt; sp)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>-&gt;sp = sp;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     std::shared_ptr&lt;B&gt; sp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">B</span>()</span><br><span class="line">     &#123;</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ~<span class="built_in">B</span>()</span><br><span class="line">     &#123;</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">setA</span><span class="params">(std::shared_ptr&lt;A&gt; sp)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>-&gt;sp = sp;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     std::shared_ptr&lt;A&gt; sp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">std::shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line"> std::shared_ptr&lt;B&gt; pb = std::<span class="built_in">make_shared</span>&lt;B&gt;(); <span class="comment">//两种智能指针的创建方式</span></span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;pa count:&quot;</span> &lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;pb count:&quot;</span> &lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"> pa.<span class="built_in">reset</span>();</span><br><span class="line"> pb.<span class="built_in">reset</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241021151052851.png" alt="image-20241021151052851" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241021145916509.png" alt="image-20241021145916509" style="zoom:80%;" /><p>使用setA、setB设定好互相引用之后：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241021150011885.png" alt="image-20241021150011885" style="zoom:80%;" /><p>手动释放或者等待智能指针自动释放的时候，出对象A、B作用域之后，pa、pb执行释放，但是count的值为2，因此只能先断掉pa、pb并置空，并不会释放掉A、B的内存</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241021151136660.png" alt="image-20241021151136660" style="zoom:80%;" /><p>而失去了对于A、B的连接，直到程序结束前，都无法通过地址找到A、B了，内存泄露</p></blockquote></blockquote><h6 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h6><p>用来解决shared_ptr相互引用导致的死锁问题</p><blockquote><p>weak_ptr是一个弱指针，它是与shared_ptr配合使用的。</p><p>所谓弱指针，主要体现在，当使用weak_ptr指向一个对象时，并不会增加该对象的引用计数，同样的，weak_ptr无法直接调用原生指针的方法，必须将其转化为一个shared_ptr才可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;A&gt; <span class="title">a1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">std::weak_ptr&lt;A&gt; weak_a1 = a1;<span class="comment">//不增加引用计数</span></span><br></pre></td></tr></table></figure><p>weak_ptr最大的意义就在于解决了shared_ptr在相互引用时内存泄露的问题。</p><p>将循环引用的一方改为weak_ptr，解决内存泄露。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改上述代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">setB</span><span class="params">(std::weak_ptr&lt;B&gt; sp)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>-&gt;sp = sp;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     std::weak_ptr&lt;B&gt; sp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">setA</span><span class="params">(std::weak_ptr&lt;A&gt; sp)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>-&gt;sp = sp;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     std::weak_ptr&lt;A&gt; sp;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241021153601781.png" alt="image-20241021153601781" style="zoom:80%;" /></blockquote><h6 id="智能指针是如何避免野指针问题的？"><a href="#智能指针是如何避免野指针问题的？" class="headerlink" title="智能指针是如何避免野指针问题的？"></a><mark>智能指针是如何避免野指针问题的？</mark></h6><blockquote><p>首先，智能指针本身就是一个”智能“指针了，不需要用户去手动释放(delete)，而置空是delete的后续操作，因此从根本上来说，智能指针就不需要置空。没有前提，哪儿来的后续？</p><p>其次，如果想要手动主动释放智能指针，可以调用<code>reset()</code>方法，当参数为空时，认定为释放原内存，并将智能指针置空；如果参数为一个新的内存，则释放原内存，并接管新的内存。或者直接给智能指针置空，这一行为默认释放原内存、置空智能指针。</p></blockquote><h4 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h4><p>此处为之前做的一些笔记，关于智能指针的前置内容</p><blockquote><p><strong>当在堆内存中new出一块空间时：</strong></p><blockquote><ol><li>操作系统会在堆内存中申请一块空间，并将其设置为可用</li><li>在栈空间创建一个指针变量，承接堆内存申请的这块空间的地址</li></ol></blockquote><p><strong>当手动delete该空间时：</strong></p><blockquote><ol><li>操作系统会将该内存释放掉，本质上就是将使用权限回收，将该区域设置为不可用</li><li>此时，之前的指针指向的这块空间就是不可用的了，指针指向了一块不可用的指针，成为”野指针”</li><li>因此在delete之后，需要手动将指针置空，防止出现野指针。</li></ol></blockquote><p>当在堆内存开辟空间之后，只要不进行手动释放(delete)，内存一直会被占用，直到程序结束，释放所有空间。</p><blockquote><p>手动释放与程序结束自动释放存在区别：</p><p>自动释放：程序结束时，操作系统并不关心程序运行时到底进行了怎样的内存分配，要做的只是将所有的内存全部回收。</p><p>手动释放：在程序运行时，为了更合理利用内存空间(内存空间是有限的)，需要手动释放掉一些已创建但使用完毕、后续不会使用的内存。</p></blockquote><p>通常来看，只要能确保内存不会溢出，就算不进行手动释放(delete)，等待程序结束时，让操作系统自动释放程序内存，也是可以的吧？</p><p>可以，但是存在很大的安全隐患！</p><p>此前我们学习了“工厂模式”，简单来讲就是一个不断生产各种对象的工厂结构。<br>当这种工厂运作起来的时候，可能会源源不断生成对象，如果这个过程中，只进行new新空间，而不delete就空间，那么内存很快就会爆满，等不到程序正常退出，内存就已经溢出了。</p><p>没有delete，你可能是忘了，也可能是故意的，但是结构就是内存溢出。</p><p>就算没有溢出，也会占用大量的内存资源，从而引发其他可能的问题。</p><p>所以为了杜绝以上现象，程序员必须：有new就有delete。</p><blockquote><p>然而，delete了也不一定就确保了安全了：</p><ol><li>delete之后要记得将指针置空。</li><li>可能存在多个指向同一内存的指针，在某个指针delete之后，其余指针都变成野指针了，但是程序员可能不知道，在其他的地方使用其余指针进行了delete：delete的前提是需要用指针访问到想要销毁的内存空间，因此通过野指针访问未授权的空间，本身就是非法行为，程序直接就会崩溃。</li></ol><blockquote><p>问题出现在野指针，delete行为本身是正常的，比如多次delete一个空指针，是不会报错的。</p></blockquote></blockquote><p>智能指针主要解决的问题就是内存泄漏相关</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_迭代器&amp;范围for的本质</title>
      <link href="/chunyujin/874d4093.html"/>
      <url>/chunyujin/874d4093.html</url>
      
        <content type="html"><![CDATA[<h3 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器(iterator)"></a><a href="http://c.biancheng.net/view/338.html">迭代器(iterator)</a></h3><h4 id="什么是迭代器"><a href="#什么是迭代器" class="headerlink" title="什么是迭代器"></a>什么是迭代器</h4><p>迭代器与容器的关系，相当于指针与数组的关系</p><p>因为容器是封装起来的，不知道内部是如何实现的，所以通过在内存中的地址的原理访问和遍历容器，一般来说是不实际的</p><p>要访问容器(顺序容器、关联容器)中的元素，就需要通过迭代器进行；就如同访问数组中的元素需要通过指针进行一样</p><p>用迭代器访问元素的操作也和用指针访问数组的操作很像</p><p>迭代器按照定义方式分成以下四种</p><blockquote><ol><li><p>正向迭代器，定义方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容器类名::iterator 迭代器名;</span><br></pre></td></tr></table></figure></li><li><p>常量正向迭代器，定义方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容器类名::const_iterator 迭代器名;</span><br></pre></td></tr></table></figure></li><li><p>反向迭代器，定义方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容器类名::reverse_iterator 迭代器名;</span><br></pre></td></tr></table></figure></li><li><p>常量反向迭代器，定义方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容器类名::const_reverse_iterator 迭代器名;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="迭代器用法示例"><a href="#迭代器用法示例" class="headerlink" title="迭代器用法示例"></a>迭代器用法示例</h4><p>通过迭代器可以读取它指向的元素，<code>*迭代器名</code>就表示迭代器指向的元素。通过非常量迭代器还能修改其指向的元素。</p><p>迭代器都可以进行<code>++</code>操作。反向迭代器和正向迭代器的区别在于：</p><ul><li>对正向迭代器进行<code>++</code>操作时，迭代器会指向容器中的后一个元素；</li><li>而对反向迭代器进行<code>++</code>操作时，迭代器会指向容器中的前一个元素。</li></ul><p>下面的程序演示了如何通过迭代器<mark>遍历一个 vector 容器</mark>中的所有元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;  <span class="comment">//v是存放int类型变量的可变长数组，开始时没有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n&lt;<span class="number">5</span>; ++n)</span><br><span class="line">        v.<span class="built_in">push_back</span>(n);  <span class="comment">//push_back成员函数在vector容器尾部添加一个元素</span></span><br><span class="line">  </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator i;  <span class="comment">//定义正向迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i) <span class="comment">//用迭代器遍历容器</span></span><br><span class="line">    &#123;  </span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//*i 就是迭代器i指向的元素</span></span><br><span class="line">        *i *= <span class="number">2</span>;  <span class="comment">//每个元素变为原来的2倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//用反向迭代器遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::reverse_iterator j = v.<span class="built_in">rbegin</span>(); j != v.<span class="built_in">rend</span>(); ++j)</span><br><span class="line">        cout &lt;&lt; *j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>程序的输出结果是：<br>0 1 2 3 4<br>8 6 4 2 0</p><p>第 6 行，vector 容器有多个构造函数，如果用无参构造函数初始化，则容器一开始是空的。</p><p>第 10 行，begin 成员函数返回指向容器中第一个元素的迭代器。++i 使得 i 指向容器中的下一个元素。end 成员函数返回的不是指向最后一个元素的迭代器，而是指向最后一个元素后面的位置的迭代器，因此循环的终止条件是<code>i != v.end()</code>。</p><p>第 16 行定义了反向迭代器用以遍历容器。反向迭代器进行<code>++</code>操作后，会指向容器中的上一个元素。rbegin 成员函数返回指向容器中最后一个元素的迭代器，rend 成员函数返回指向容器中第一个元素前面的位置的迭代器，因此本循环实际上是从后往前遍历整个数组。</p><p>如果迭代器指向了容器中最后一个元素的后面或第一个元素的前面，再通过该迭代器访问元素，就有可能导致程序崩溃，这和访问 NULL 或未初始化的指针指向的地方类似。</p><p>第 10 行和第 16 行，写<code>++i</code>、<code>++j</code>相比于写<code>i++</code>、<code>j++</code>，程序的执行速度更快。</p><p>回顾<code>++</code>被重载成前置和后置运算符的例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CDemo CDemo::<span class="keyword">operator</span>++ ()</span><br><span class="line">&#123;  <span class="comment">//前置++</span></span><br><span class="line">    ++n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">CDemo CDemo::<span class="keyword">operator</span> ++(<span class="type">int</span> k)</span><br><span class="line">&#123;  <span class="comment">//后置++</span></span><br><span class="line">    <span class="function">CDemo <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;  <span class="comment">//记录修改前的对象</span></span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span> tmp;  <span class="comment">//返回修改前的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后置<code>++</code>要多生成一个局部对象 tmp，因此执行速度比前置的慢。同理，迭代器是一个对象，<a href="http://c.biancheng.net/stl/">STL</a> 在重载迭代器的<code>++</code>运算符时，后置形式也比前置形式慢。在次数很多的循环中，<code>++i</code>和<code>i++</code>可能就会造成运行时间上可观的差别了。因此，本教程在前面特别提到，对循环控制变量i，要养成写<code>++i</code>、不写<code>i++</code>的习惯。</p></blockquote><p>注意，容器适配器 stack、queue 和 priority_queue 没有迭代器。容器适配器有一些成员函数，可以用来对元素进行访问。</p><h4 id="迭代器的功能分类"><a href="#迭代器的功能分类" class="headerlink" title="迭代器的功能分类"></a>迭代器的功能分类</h4><p>不同容器的迭代器，其功能强弱有所不同。容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。例如，排序算法需要通过随机访问迭代器来访问容器中的元素，因此有的容器就不支持排序算法。</p><p>常用的迭代器按功能强弱分为输入、输出、正向、双向、随机访问五种，这里只介绍常用的三种。</p><blockquote><ol><li><p>正向迭代器。假设 p 是一个正向迭代器，则 p 支持以下操作：++p，p++，*p。此外，两个正向迭代器可以互相赋值，还可以用<code>==</code>和<code>!=</code>运算符进行比较。</p></li><li><p>双向迭代器。双向迭代器具有正向迭代器的全部功能。除此之外，若 p 是一个双向迭代器，则<code>--p</code>和<code>p--</code>都是有定义的。<code>--p</code>使得 p 朝和<code>++p</code>相反的方向移动。</p></li><li><p>随机访问迭代器。随机访问迭代器具有双向迭代器的全部功能。若 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p></li></ol><ul><li>p+&#x3D;i：使得 p 往后移动 i 个元素。</li><li>p-&#x3D;i：使得 p 往前移动 i 个元素。</li><li>p+i：返回 p 后面第 i 个元素的迭代器。</li><li>p-i：返回 p 前面第 i 个元素的迭代器。</li><li>p[i]：返回 p 后面第 i 个元素的引用。</li></ul><p>此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 运算符进行比较。<code>p1&lt;p2</code>的含义是：p1 经过若干次（至少一次）<code>++</code>操作后，就会等于 p2。其他比较方式的含义与此类似。</p><p>&#x3D;&#x3D;对于两个随机访问迭代器 p1、p2，表达式<code>p2-p1</code>也是有定义的，其返回值是 p2 所指向元素和 p1 所指向元素的序号(下标)之差（也可以说是 p2 和 p1 之间的元素个数减一）。&#x3D;&#x3D;</p><blockquote><p>例如在vector中返回某个元素的下标</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span><span class="comment">//std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span><span class="comment">//std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; temp = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = temp.<span class="built_in">begin</span>();</span><br><span class="line">it += <span class="number">2</span>;<span class="comment">//p+=i</span></span><br><span class="line"><span class="comment">//此时it对应的元素下标为</span></span><br><span class="line"><span class="type">int</span> index = it - temp.<span class="built_in">begin</span>();<span class="comment">//p2-p1</span></span><br><span class="line">cout &lt;&lt; index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出2</p></blockquote></blockquote><p>不同容器的迭代器的功能:</p><table><thead><tr><th>容器</th><th>迭代器功能</th></tr></thead><tbody><tr><td>vector</td><td>随机访问</td></tr><tr><td>deque</td><td>随机访问</td></tr><tr><td>list</td><td>双向</td></tr><tr><td>set &#x2F; multiset</td><td>双向</td></tr><tr><td>map &#x2F; multimap</td><td>双向</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr><tr><td>priority_queue</td><td>不支持迭代器</td></tr></tbody></table><blockquote><p>vector 的迭代器是随机迭代器，因此<mark>遍历 vector 容器</mark>有以下几种做法。下面的程序中，每个循环演示了一种做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//v被初始化成有100个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; v.<span class="built_in">size</span>() ; ++i) <span class="comment">//size返回元素个数</span></span><br><span class="line">        cout &lt;&lt; v[i]; <span class="comment">//像普通数组一样使用vector容器</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator i;</span><br><span class="line">    <span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span> (); ++i) <span class="comment">//用 != 比较两个迭代器</span></span><br><span class="line">        cout &lt;&lt; * i;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span> ();++i) <span class="comment">//用 &lt; 比较两个迭代器</span></span><br><span class="line">        cout &lt;&lt; * i;</span><br><span class="line">  </span><br><span class="line">    i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(i &lt; v.<span class="built_in">end</span>()) &#123; <span class="comment">//间隔一个输出</span></span><br><span class="line">        cout &lt;&lt; * i;</span><br><span class="line">        i += <span class="number">2</span>; <span class="comment">// 随机访问迭代器支持 &quot;+= 整数&quot;  的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>list 容器的迭代器是双向迭代器。</p><p>假设 v 和 i 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure><p>则以下代码是合法的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=v.<span class="built_in">begin</span>(); i!=v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">  cout &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p>以下代码则不合法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=v.<span class="built_in">begin</span>(); i&lt;v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">  cout &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p>因为双向迭代器不支持用 “&lt;” 进行比较。以下代码也不合法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">  cout &lt;&lt; v[i];</span><br></pre></td></tr></table></figure><p>因为 list 不支持随机访问迭代器的容器，也不支持用下标随机访问其元素。</p></blockquote><p><strong>&#x3D;&#x3D;在 <a href="http://c.biancheng.net/cplus/">C++</a> 中，数组也是容器。数组的迭代器就是指针，而且是随机访问迭代器。例如，对于数组 int a[10]，int * 类型的指针就是其迭代器。则 a、a+1、a+2 都是 a 的迭代器。&#x3D;&#x3D;</strong></p><h4 id="迭代器的辅助函数-好用"><a href="#迭代器的辅助函数-好用" class="headerlink" title="迭代器的辅助函数(好用)"></a>迭代器的辅助函数(好用)</h4><p>STL 中有用于操作迭代器的三个函数模板</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">advance</span>(p, n) </span><br></pre></td></tr></table></figure><p>使迭代器 p 向前或向后移动 n 个元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">distance</span>(p, q)</span><br></pre></td></tr></table></figure><p>计算两个迭代器之间的距离，即迭代器 p 经过多少次 + + 操作后和迭代器 q 相等。如果调用时 p 已经指向 q 的后面，则这个函数会陷入死循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">iter_swap</span>(p, q)</span><br></pre></td></tr></table></figure><p>用于交换两个迭代器 p、q 指向的值</p></blockquote><p>要使用上述模板，需要包含头文件 algorithm。下面的程序演示了这三个函数模板的 用法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">//要使用操作迭代器的函数模板，需要包含此文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    list &lt;<span class="type">int</span>&gt; <span class="built_in">lst</span>(a, a+<span class="number">5</span>);</span><br><span class="line">    list &lt;<span class="type">int</span>&gt;::iterator p = lst.<span class="built_in">begin</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">advance</span>(p, <span class="number">2</span>);  <span class="comment">//p向后移动两个元素，指向3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1)&quot;</span> &lt;&lt; *p &lt;&lt; endl;  <span class="comment">//输出 1)3</span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">advance</span>(p, <span class="number">-1</span>);  <span class="comment">//p向前移动一个元素，指向2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2)&quot;</span> &lt;&lt; *p &lt;&lt; endl;  <span class="comment">//输出 2)2</span></span><br><span class="line">  </span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator q = lst.<span class="built_in">end</span>();</span><br><span class="line">  </span><br><span class="line">    q--;  <span class="comment">//q 指向 5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3)&quot;</span> &lt;&lt; <span class="built_in">distance</span>(p, q) &lt;&lt; endl;  <span class="comment">//输出 3)3</span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">iter_swap</span>(p, q); <span class="comment">//交换 2 和 5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;4)&quot;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (p = lst.<span class="built_in">begin</span>(); p != lst.<span class="built_in">end</span>(); ++p)</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是：<br>\1) 3<br>\2) 2<br>\3) 3<br>\4) 1 5 3 4 2</p><h4 id="返回-随机访问迭代器中某个元素的-位置-序号-下标"><a href="#返回-随机访问迭代器中某个元素的-位置-序号-下标" class="headerlink" title="返回 随机访问迭代器中某个元素的 位置(序号)(下标)"></a>返回 随机访问迭代器中某个元素的 位置(序号)(下标)</h4><p>方法1⃣️用循环，从第1个元素开始找，直到找到对应的元素，返回下标</p><p>方法2⃣️利用<a href="http://c.biancheng.net/view/7489.html">find函数</a>，找到对应元素的迭代器，利用<a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%88%86%E7%B1%BB">“两个随机访问迭代器相减，返回值是两个迭代器对应的元素的序号(下标)之差”</a>，用该元素的迭代器减去容器首元素迭代器，返回值就是该元素的下标</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span><span class="comment">//std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span><span class="comment">//std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span><span class="comment">//std::find()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; temp = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>(), <span class="number">5</span>);<span class="comment">//value为要查找的值，该函数返回一个指向对应元素的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时it对应的元素下标为</span></span><br><span class="line"><span class="type">int</span> index = it - temp.<span class="built_in">begin</span>();</span><br><span class="line">cout &lt;&lt; index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>find函数是algorithm的库函数</p><p>find() 函数本质上是一个模板函数，用于在指定范围内查找和目标元素值相等的第一个元素。</p><p>如下为 find() 函数的语法格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InputIterator <span class="title">find</span> <span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，first 和 last 为输入迭代器，[first, last) 用于指定该函数的查找范围；value 为要查找的目标元素。</p><blockquote><p>正因为 first 和 last 的类型为输入迭代器，因此该函数适用于所有的序列式容器。</p></blockquote><p>该函数会<strong>返回</strong>一个<u>输入迭代器</u>，当 find() 函数查找成功时，其指向的是在 [first, last) 区域内查找到的第一个目标元素；如果查找失败，则该迭代器的指向和 last 相同。</p><blockquote><p>例如查找vector的元素时，first是vector.begin()，end是vector.end()</p><blockquote><p> vector.end()是指向容器的最后一个元素之后的&#x2F;0</p></blockquote></blockquote><p>值得一提的是，find() 函数的底层实现，其实就是用<code>==</code>运算符将 val 和 [first, last) 区域内的元素逐个进行比对。这也就意味着，[first, last) 区域内的元素必须支持<code>==</code>运算符。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::find</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//find() 函数作用于普通数组</span></span><br><span class="line"><span class="type">char</span> stl[] = <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line"><span class="comment">//调用 find() 查找第一个字符 &#x27;c&#x27;</span></span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">find</span>(stl, stl + <span class="built_in">strlen</span>(stl), <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="comment">//判断是否查找成功</span></span><br><span class="line"><span class="keyword">if</span> (p != stl + <span class="built_in">strlen</span>(stl))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//find() 函数作用于容器</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">it = <span class="built_in">find</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myvector.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;查找成功：&quot;</span> &lt;&lt; *it;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;查找失败&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.biancheng.net/stl/</span><br><span class="line">查找成功：30</span><br></pre></td></tr></table></figure><p>可以看到，find() 函数除了可以作用于序列式容器，还可以作用于普通数组(因为在C++中普通数组也是容器)</p><blockquote><p>补充：find() 函数的底层实现，C++ 标准库中给出了参数代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (first != last)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*first == val) <span class="keyword">return</span> first;</span><br><span class="line">++first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="迭代器的好处"><a href="#迭代器的好处" class="headerlink" title="迭代器的好处"></a>迭代器的好处</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212031252529.png" alt="截屏2022-12-03 12.51.56" /><h4 id="迭代器可以使用auto，更简便"><a href="#迭代器可以使用auto，更简便" class="headerlink" title="迭代器可以使用auto，更简便"></a>迭代器可以使用auto，更简便</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line">string::iterator it1 = s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> it2 = s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//二者是等同的</span></span><br></pre></td></tr></table></figure><h4 id="C-11范围for本质上就是替代了范围for"><a href="#C-11范围for本质上就是替代了范围for" class="headerlink" title="C++11范围for本质上就是替代了范围for"></a>C++11范围for本质上就是替代了范围for</h4><p>从汇编上就可以看出来</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E8%8C%83%E5%9B%B4for%E6%9C%AC%E8%B4%A8%E4%B8%8A%E5%B0%B1%E6%98%AF%E6%9B%BF%E4%BB%A3%E4%BA%86%E8%BF%AD%E4%BB%A3%E5%99%A8(%E4%BB%8E%E6%B1%87%E7%BC%96%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%87%BA%E6%9D%A5).png" alt="范围for本质上就是替代了迭代器(从汇编就可以看出来)" />]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static放置的位置</title>
      <link href="/chunyujin/5583cd64.html"/>
      <url>/chunyujin/5583cd64.html</url>
      
        <content type="html"><![CDATA[<p>在声明函数时，如果需要用静态关键字static，应该放到函数类型前面还是后面？</p><blockquote><p>通义千问的回答：<strong>建议放到返回类型的前面</strong><br>在C++中，<code>static</code>关键字可以用于多种上下文，包括函数声明。当用于类的成员函数时，<code>static</code>的位置（放在返回类型前面还是后面）并不会改变其语义，但通常有约定俗成的放置位置。</p><h3 id="放置位置"><a href="#放置位置" class="headerlink" title="放置位置"></a>放置位置</h3><ul><li><p><strong>放在返回类型前面</strong>：这是最常见的用法，也是推荐的做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">myStaticFunction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>放在返回类型后面</strong>：虽然语法上是允许的，但这样做并不常见，并且可能会降低代码的可读性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="type">static</span> <span class="title">myStaticFunction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="语义上的区别"><a href="#语义上的区别" class="headerlink" title="语义上的区别"></a>语义上的区别</h3><p>无论<code>static</code>放在哪里，它都表示该成员函数属于类本身而不是类的任何特定对象。这意味着：</p><ul><li>你不需要创建类的实例就可以调用静态成员函数。</li><li>静态成员函数不能访问非静态成员变量或非静态成员函数，因为它没有隐式的<code>this</code>指针。</li><li>静态成员函数只能访问静态成员变量和其他静态成员函数。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>尽管从技术角度来看，<code>static</code>关键字放在返回类型前面或后面都不会影响编译器对其的理解，但从编码风格和可读性的角度来看，通常建议将<code>static</code>放在返回类型之前。这符合大多数C++程序员的习惯，也使得代码更加清晰易懂。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QString与QByteArray的区别与用途</title>
      <link href="/chunyujin/3167b709.html"/>
      <url>/chunyujin/3167b709.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>通义千问的回答：</p><p><code>QByteArray</code> 和 <code>QString</code> 都是 Qt 框架中用于处理文本和二进制数据的类，但它们的设计目的和服务的场景有所不同。</p><h3 id="QByteArray"><a href="#QByteArray" class="headerlink" title="QByteArray"></a>QByteArray</h3><ul><li><strong>类型</strong>：<code>QByteArray</code> 用来存储原始字节（raw bytes），可以包含任意二进制数据。</li><li><strong>编码</strong>：它不假定任何特定的字符编码。你可以使用它来处理任何类型的二进制数据，包括图像、音频文件或网络协议中的数据包等。</li><li><strong>性能</strong>：由于直接操作内存中的字节，对于需要高效处理的数据，<code>QByteArray</code> 提供了较高的性能。</li><li><strong>API</strong>：提供了许多与 C 字符串兼容的方法，比如 <code>data()</code> 返回一个指向内部数组的指针，使得它可以方便地与其他C API进行交互。</li><li><strong>用途</strong>：适合于网络编程、文件I&#x2F;O、图像处理等需要处理非文本数据的情况。</li></ul><h3 id="QString"><a href="#QString" class="headerlink" title="QString"></a>QString</h3><ul><li><strong>类型</strong>：<code>QString</code> 是专门设计来处理文本字符串的类。</li><li><strong>编码</strong>：默认情况下，<code>QString</code> 使用 UTF-16 编码（在某些平台上可能使用 UTF-8）来存储文本，这意味着它可以有效地处理 Unicode 文本，支持多种语言和特殊符号。</li><li><strong>功能</strong>：提供了丰富的字符串操作方法，如搜索、替换、分割、连接等。</li><li><strong>国际化</strong>：非常适合于构建国际化的应用程序，因为它能够很好地处理多语言环境下的文本。</li><li><strong>内存管理</strong>：自动处理内存分配和释放，避免了常见的内存泄漏问题。</li><li><strong>安全性</strong>：提供了一些安全特性，例如防止缓冲区溢出。</li><li><strong>用途</strong>：主要用于用户界面元素的标签、消息框的内容、配置文件的读写等涉及文本的地方。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>当你需要处理的是纯文本，尤其是当文本包含多语言字符时，应该使用 <code>QString</code>。</li><li>如果你正在处理二进制数据或者需要直接控制底层数据表示，那么 <code>QByteArray</code> 会是更好的选择。</li><li>在某些情况下，你可能需要在这两者之间进行转换。例如，从网络接收的数据可能是 <code>QByteArray</code> 形式，但在显示给用户之前，你可能需要将其转换为 <code>QString</code> 来正确显示文本内容。Qt 提供了便捷的方法来进行这种转换，如 <code>QString::fromUtf8(const QByteArray &amp;)</code> 和 <code>QByteArray::fromRawData(const char *unicode, int size)</code>、<code>QByteArray::fromStdString(const QString &amp;)</code> 等。</li></ul></blockquote><p>后需要补充的内容：在des加密算法中对于QString和QByteArray的应用说明</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora+PicGo图床+阿里云OSS配置</title>
      <link href="/chunyujin/e9887bd.html"/>
      <url>/chunyujin/e9887bd.html</url>
      
        <content type="html"><![CDATA[<p>首先购买阿里云OSS服务</p><p>完成之后，打开RAM访问控制</p><p>点击 用户-创建用户</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230314101800121.png" alt="image-20230314101800121" style="zoom: 67%;" /><p>创建用户登录名称和显示名称</p><p>完成进入相关用户</p><p>点击“创建AccseeKey”</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303122001920.png" alt="截屏2023-03-12 20.01.28" style="zoom: 33%;" /><p>将信息保存下来</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303122002839.png" alt="IMG_0538" style="zoom: 33%;" /><p>之后点击 权限管理-新增授权</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303122000574.png" alt="ss" style="zoom:50%;" /><p>选择 整个云账号-授权主体</p><p>在“系统策略”里选择以下内容</p><p>点击确认，完成</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303122000150.png" alt="qq" style="zoom:50%;" /><p>打开Typora</p><p>打开设置，选择”插入图片时……”</p><p>按照一下进行勾选</p><p>在“上传服务设定”中选择PicGo，如果没有安装则进行下载，并在Typora中配置好路径</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303122007419.png" alt="截屏2023-03-12 20.06.58" style="zoom:33%;" /><p>打开PicGo</p><p>按照如下进行配置，前两项是在阿里云创建的AccessKey给出的信息</p><p>三四项根据阿里云OSS存储中自己设定好的的Bucket和存储区域来，或者直接按实例进行填写</p><p>存储路径按照阿里云OSS中填写</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303122008334.png" alt="截屏2022-09-14 11.41.25" style="zoom:50%;" /><p>回到Typora刚才的页面，点击“验证图片上传选项”</p><p>返回结果为成功则说明配置完成</p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Typora </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo自动化提交-gulp压缩静态资源</title>
      <link href="/chunyujin/49b78e.html"/>
      <url>/chunyujin/49b78e.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">gulp  #进行css压缩</span><br><span class="line">hexo deploy 或 hexo server</span><br></pre></td></tr></table></figure><h1 id="关于gulp"><a href="#关于gulp" class="headerlink" title="关于gulp"></a>关于gulp</h1><p>gulp可以对于网站静态文件进行压缩，缩小网站静态体积，加快加载速度</p><p><a href="https://chunyujin.top/chunyujin/9dba5c90">Hexo-gulp压缩静态资源加快加载速度 | 浴巾的贼船 (chunyujin.top)</a></p><h1 id="命令精简"><a href="#命令精简" class="headerlink" title="命令精简"></a>命令精简</h1><p>使用了gulp时候，构建发布需要四个命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">gulp</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><h1 id="自动化-很好用"><a href="#自动化-很好用" class="headerlink" title="自动化-很好用"></a>自动化-很好用</h1><p>这四个命令，可以都写在package.json。直接替换文件中对应位置的代码即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; gulp&quot;,</span><br><span class="line">  &quot;deploy&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo deploy&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建只需要执行<code>npm run build</code>，构建发布只需要执行<code>npm run deploy</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Butterfly环境搭建</title>
      <link href="/chunyujin/db7f9dc7.html"/>
      <url>/chunyujin/db7f9dc7.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ol><li><p>本教程只是环境搭建，并不涉及网站部署等，只涉及到电脑本地环境的创建。因为博主此前已经构建过一个基于Hexo-Butterfly主题的博客了，现在需求为在不同电脑搭建出网站部署环境，将网站源码上传到git上，实现在不同电脑上都可以更新网站的需求。</p></li><li><p>本教程基于Windows操作系统，macOS、Linux系统操作上都是大同小异，搭建方式基本都是从官网或终端进行软件的下载和安装。与Windows不同的是，macOS和Linux对于环境变量等的管理比较简单，所以比Windows操作系统下搭建环境更加简单一些。</p></li></ol><h3 id="终端工具的选择"><a href="#终端工具的选择" class="headerlink" title="终端工具的选择"></a>终端工具的选择</h3><p>Windows：有两个终端工具</p><ul><li>Windows Terminal。微软在win10后期新推出的终端工具。支持Windows命令，部分.ned和Linux shell命令。</li><li>”命令行提示符“cmd。比较古早的终端，只支持Windows命令。</li></ul><p>建议选择Windows powershell。因为后期可能会涉及到需要管理员权限的操作，届时直接使用管理员模式打开powershell即可。</p><blockquote><p>这里其实也可以使用cmd，快捷打开管理员模式的方法：</p><ol><li>win+r打开“运行”</li><li>输入cmd，不要点击回车</li><li>Ctrl+Shift+Enter打开cmd</li></ol><p>Windows  </p></blockquote><p>macOS、Linux：直接使用自带终端。可以随时进入root模式，很方便。</p><p>后期安装好之后，都会改为使用vscode中的终端。</p><p>前期Windows下不使用vscode的原因：软件安装时涉及到下载目录、管理员模式运行终端或者涉及到环境变量的配置等，需要一个灵活的终端窗口，且Windows终端的很多操作都是与当前工作目录强相关的，vscode就没那么灵活了，毕竟Windows的终端并不像mac和Linux一样那么全能。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li><p>Node。Node.js 是一个开源的、跨平台的 JavaScript 运行时环境。<a href="https://nodejs.cn/">Node.js 中文网 (nodejs.cn)</a></p></li><li><p>nvm。(Node Version Manager)是 Nodejs 版本管理器，它能让我们方便的对 Node.js 的版本进行切换。</p></li><li><p>npm。(Node Package Manager)，Node.js 的包管理器，安装 Node.js 之后自带 npm，无需单独安装</p></li><li><p>Hexo。一个由Node.js驱动的博客简单强大的博客框架。<a href="https://hexo.io/zh-cn/">Hexo</a></p></li><li><p>vscode。</p></li></ul><p>教程推荐：</p><ul><li><a href="https://www.cnblogs.com/qianguyihao/p/8492713.html">Node.js介绍和环境配置（含NVM、NPM、NVM的安装） - 千古壹号 - 博客园 (cnblogs.com)</a></li><li><a href="https://segmentfault.com/a/1190000011114680">node.js - 安装npm，nvm，node - 个人文章 - SegmentFault 思否</a></li></ul><h4 id="nvm安装"><a href="#nvm安装" class="headerlink" title="nvm安装"></a>nvm安装</h4><p><a href="https://github.com/coreybutler/nvm-windows/releases">Windows版安装地址 · Releases · coreybutler&#x2F;nvm-windows (github.com)</a>)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010151855178.png" alt="image-20241010151855178" /><p>下载之后解压到本地软件安装目录中</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010151944766.png" alt="image-20241010151944766" /><p>双击运行，开始安装</p><p>安装之后，会被自动添加到环境变量中。</p><p>在终端中测试安装是否成功：</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010152154711.png" alt="image-20241010152154711"></p><p>配置环境变量：</p><blockquote><p>正常来说，nvm安装之后会自动配置好环境变量：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010161247200.png" alt="image-20241010161247200" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010161331585.png" alt="image-20241010161331585" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010161411700.png" alt="image-20241010161411700" style="zoom:80%;" /></blockquote><h4 id="Node、npm安装"><a href="#Node、npm安装" class="headerlink" title="Node、npm安装"></a>Node、npm安装</h4><p><a href="https://www.nodejs.com.cn/download.html">Node.js 中文网 (nodejs.com.cn)</a></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241022150735487.png" alt="image-20241022150735487" style="zoom:67%;" /><p>下载.msi安装包，然后进行安装，设置安装目录，在安装中，会自动将node添加到环境变量，node安装完成，npm也安装完成了。</p><p><mark>需要注意的是，如果想使用node或者npm，需要在管理员模式下启用终端，否则会error</mark></p><p>测试node和npm安装成功：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010162147431.png" alt="image-20241010162147431" style="zoom:80%;" /><h4 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h4><p>需要将hexo使用npm安装到指定目录，因此先进入指定路径</p><h5 id="通过管理员模式进入指定目录的方法"><a href="#通过管理员模式进入指定目录的方法" class="headerlink" title="通过管理员模式进入指定目录的方法"></a>通过管理员模式进入指定目录的方法</h5><blockquote><p> 方法有很多，无非就是先用管理员模式打开终端，然后cd进入要安装的目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010162818276.png" alt="image-20241010162818276"  /><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010162847131.png" alt="image-20241010162847131"></p><p>注意如果路径有空格，需要用<code>&quot;&quot;</code>将路径包裹起来</p></blockquote><p>安装Hexo环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h5 id="更换npm源或安装cnpm"><a href="#更换npm源或安装cnpm" class="headerlink" title="更换npm源或安装cnpm"></a>更换npm源或安装cnpm</h5><blockquote><p>如果下载时卡住：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010163300272.png" alt="image-20241010163300272" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010163719938.png" alt="image-20241010163719938" /><p>原因：npm源在国外</p><p><strong>解决方案一：可以换为国内淘宝镜像源：</strong></p><p><a href="https://blog.csdn.net/XueZePeng18729875380/article/details/129519153">npm 使用淘宝镜像及切换回官方源_npm 淘宝源-CSDN博客</a></p><p>注意淘宝镜像源可能会有更新，网址会发生改变，请自己百度最新的镜像源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npmmirror.com/</span><br></pre></td></tr></table></figure><p>更换之后进行测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><p>返回结果为<code>https://registry.npm.taobao.org</code>则说明配置成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS D:\software\Hexo&gt; npm config set registry https://registry.npmmirror.com/</span><br><span class="line">PS D:\software\Hexo&gt; npm config get registry</span><br><span class="line">https://registry.npmmirror.com/</span><br></pre></td></tr></table></figure><p><strong>解决方案二：安装 cnpm 来替代 npm，cnpm是淘宝团队创建的为国内用户使用的npm替代品：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">注册模块镜像</span></span><br><span class="line"> npm set registry https://registry.npmmirror.com  </span><br><span class="line"> </span><br><span class="line"> // node-gyp 编译依赖的 node 源码镜像  </span><br><span class="line"> npm set disturl https://npmmirror.com/dist </span><br><span class="line"> </span><br><span class="line"> // 清空缓存  </span><br><span class="line"> npm cache clean --force  </span><br><span class="line"> </span><br><span class="line"> // 安装cnpm  </span><br><span class="line"> npm install -g cnpm --registry=https://registry.npmmirror.com </span><br></pre></td></tr></table></figure><p>安装完后最好查看其版本号cnpm -v或关闭命令提示符重新打开，安装完直接使用可能会出现错误</p><p>cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm</p><p><strong>npm 切换回官方源：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config delete registry</span><br></pre></td></tr></table></figure><p>或者直接修改为原本的源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npmjs.org/</span><br></pre></td></tr></table></figure></blockquote><p>书接上回，安装Hexo：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010171928006.png" alt="image-20241010171928006" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010171939117.png" alt="image-20241010171939117" style="zoom:80%;" /><p>安装之后可能又会发现新的问题：vscode或者Windows terminal的poweshell下使用<code>hexo -v</code>检查hexo安装，发现无法识别命令。而cmd执行则可以：</p><blockquote><p><strong>powershell不行</strong></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010172429032.png" alt="image-20241010172429032"></p><p><strong>cmd可以</strong></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010172513371.png" alt="image-20241010172513371"></p></blockquote><p>这个问题也可以描述为：powershell中无法执行命令&#x2F;脚本：<a href="https://zhuanlan.zhihu.com/p/553911329">命令行在cmd中能执行但是在PowerShell中报错 - 知乎 (zhihu.com)</a></p><p>在powershell中运行命令行查看系统权限：<code>Get-ExecutionPolicy -List</code></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010172720088.png" alt="image-20241010172720088" style="zoom:80%;" /><p>通过这个命令发现CurrentUser的权限是Undefined，那么就是权限的问题，就可以通过增加权限解决了</p><h5 id="增加Windows-terminal-powershell中CurrentUser权限以解决无法执行命令-x2F-脚本的问题："><a href="#增加Windows-terminal-powershell中CurrentUser权限以解决无法执行命令-x2F-脚本的问题：" class="headerlink" title="增加Windows terminal powershell中CurrentUser权限以解决无法执行命令&#x2F;脚本的问题："></a>增加Windows terminal powershell中CurrentUser权限以解决无法执行命令&#x2F;脚本的问题：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser</span><br></pre></td></tr></table></figure><p>之后执行<code>Get-ExecutionPolicy -List</code>再次查看权限：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010172937214.png" alt="image-20241010172937214" style="zoom:80%;" /><p>之后使用<code>hexo -v</code>检查一下安装：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010173004341.png" alt="image-20241010173004341" style="zoom:67%;" /><p>安装完成</p><h3 id="拉取仓库-最后配置"><a href="#拉取仓库-最后配置" class="headerlink" title="拉取仓库-最后配置"></a>拉取仓库-最后配置</h3><p>创建一个新的空文件夹用来存放博客项目，<code>git init</code>一下，将网站工程从git远端仓库上下拉回来</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010173558750.png" alt="image-20241010173558750"></p><p>因为博客是使用的GitHub运行的，因此还需要执行最后一步：</p><p>将本地ssh公钥添加到GitHub中</p><p>获取公钥：<a href="https://chunyujin.top/chunyujin/b51810cf">Git！从零开始连接远程仓库 | 浴巾的贼船 (chunyujin.top)</a></p><blockquote><p>如果本地没有产生过公钥，执行，下面命令，以前生成过，直接跳过这一步即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>然后一路回车。</p><p>获取本地公钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></blockquote><p>打开GitHub，登录进去，点击右上角头像，进入设置：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010174412262.png" alt="image-20241010174412262" /><p>点击右上角New SSH Key</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010174523081.png" alt="image-20241010174523081" /><p>创建一个标题，并将ssh key复制进下面：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010174624863.png" alt="image-20241010174624863" /><p>点击Add SSH key，然后输入GitHub密码进行确定</p><p>然后可以看到新添加上的了：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010174731187.png" alt="image-20241010174731187" /><p>如果绑定邮箱了，还会收到邮箱提示。</p><p>测试一下是否成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010174933309.png" alt="image-20241010174933309" /><p>现在就可以在vscode中打开项目根目录了</p><h4 id="关于初始化"><a href="#关于初始化" class="headerlink" title="关于初始化"></a>关于初始化</h4><p>博客项目只有在创建的时候进行一下初始化就可以，因为我这个博客很久之前就创建好了，并且初始化文件都会保存在一起放入了根目录，所以不需要再初始化，直接就可以使用了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【node_modules】：依赖包</span><br><span class="line">【scaffolds】：生成文章的一些模板</span><br><span class="line">【source】：用来存放你的文章</span><br><span class="line">【themes】：主题</span><br><span class="line">【.npmignore】：发布时忽略的文件（可忽略）</span><br><span class="line">【_config.landscape.yml】：主题的配置文件</span><br><span class="line">【_config.yml】：博客的配置文件</span><br><span class="line">【package.json】：项目名称、描述、版本、运行和开发等信息</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010175206195.png" alt="image-20241010175206195" /><p>直接vscode打开，就可以进行提交三板斧等操作了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010175404122.png" alt="image-20241010175404122" /><p>之后就可以发布项目到GitHub上进行运行了</p><h4 id="如果项目文件夹下报错“ERROR-Cannot-find-module-‘hexo’-from-”"><a href="#如果项目文件夹下报错“ERROR-Cannot-find-module-‘hexo’-from-”" class="headerlink" title="如果项目文件夹下报错“ERROR Cannot find module ‘hexo’ from ”"></a>如果项目文件夹下报错“ERROR Cannot find module ‘hexo’ from ”</h4><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010175951865.png" alt="image-20241010175951865"></p><p>根据最后一行的信息，说明没有安装相关的moudle，安装上即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --force</span><br></pre></td></tr></table></figure><blockquote><p>侧面反映了shell中解毒草药就在五步之内</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010180311742.png" alt="image-20241010180311742" /><p>执行一条hexo命令试试：</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010180425268.png" alt="image-20241010180425268"></p><p>完美！</p><p>最后还有一点：</p><h4 id="配置gulp压缩静态资源"><a href="#配置gulp压缩静态资源" class="headerlink" title="配置gulp压缩静态资源"></a>配置gulp压缩静态资源</h4><p><a href="https://chunyujin.top/chunyujin/9dba5c90">Hexo-gulp压缩静态资源加快加载速度 | 浴巾的贼船 (chunyujin.top)</a></p><h3 id="切记每次修改前git-pull，修改完之后git-push一下，保持同步，防止出错"><a href="#切记每次修改前git-pull，修改完之后git-push一下，保持同步，防止出错" class="headerlink" title="切记每次修改前git pull，修改完之后git push一下，保持同步，防止出错"></a>切记每次修改前git pull，修改完之后git push一下，保持同步，防止出错</h3>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-gulp压缩静态资源加快加载速度</title>
      <link href="/chunyujin/9dba5c90.html"/>
      <url>/chunyujin/9dba5c90.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章来源：<a href="https://akilar.top/posts/49b73b87/">使用gulp压缩博客静态资源 | Akilarの糖果屋</a></p></blockquote><p>1.安装Gulp插件：在博客根目录打开终端，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --global gulp-cli #全局安装gulp指令集</span><br><span class="line">npm install gulp --save #安装gulp插件</span><br></pre></td></tr></table></figure><p>2.安装各个下属插件以实现对各类静态资源的压缩：</p><ul><li>压缩HTML：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp-htmlclean --save-dev</span><br><span class="line">npm install gulp-html-minifier-terser --save-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用gulp-html-minifier-terser可以压缩HTML中的ES6语法</span></span><br></pre></td></tr></table></figure><ul><li>压缩CSS：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp-clean-css --save-dev</span><br></pre></td></tr></table></figure><ul><li>压缩JS：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp-terser --save-dev</span><br></pre></td></tr></table></figure><ul><li>压缩字体包：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp-fontmin --save-dev</span><br></pre></td></tr></table></figure><p>3.为Gulp创建<code>gulpfile.js</code>任务脚本。在博客根目录下新建<code>gulpfile.js</code><strong>并打开</strong>，输入以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">//用到的各个插件</span><br><span class="line">var gulp = require(&#x27;gulp&#x27;);</span><br><span class="line">var cleanCSS = require(&#x27;gulp-clean-css&#x27;);</span><br><span class="line">var htmlmin = require(&#x27;gulp-html-minifier-terser&#x27;);</span><br><span class="line">var htmlclean = require(&#x27;gulp-htmlclean&#x27;);</span><br><span class="line">var fontmin = require(&#x27;gulp-fontmin&#x27;);</span><br><span class="line">// gulp-tester</span><br><span class="line">var terser = require(&#x27;gulp-terser&#x27;);</span><br><span class="line">// 压缩js</span><br><span class="line">gulp.task(&#x27;compress&#x27;, async() =&gt;&#123;</span><br><span class="line">  gulp.src([&#x27;./public/**/*.js&#x27;, &#x27;!./public/**/*.min.js&#x27;])</span><br><span class="line">    .pipe(terser())</span><br><span class="line">    .pipe(gulp.dest(&#x27;./public&#x27;))</span><br><span class="line">&#125;);</span><br><span class="line">//压缩css</span><br><span class="line">gulp.task(&#x27;minify-css&#x27;, () =&gt; &#123;</span><br><span class="line">    return gulp.src([&#x27;./public/**/*.css&#x27;])</span><br><span class="line">        .pipe(cleanCSS(&#123;</span><br><span class="line">            compatibility: &#x27;ie11&#x27;</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&#x27;./public&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line">//压缩html</span><br><span class="line">gulp.task(&#x27;minify-html&#x27;, () =&gt; &#123;</span><br><span class="line">    return gulp.src(&#x27;./public/**/*.html&#x27;)</span><br><span class="line">        .pipe(htmlclean())</span><br><span class="line">        .pipe(htmlmin(&#123;</span><br><span class="line">            removeComments: true, //清除html注释</span><br><span class="line">            collapseWhitespace: true, //压缩html</span><br><span class="line">            collapseBooleanAttributes: true,</span><br><span class="line">            //省略布尔属性的值，例如：&lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt;</span><br><span class="line">            removeEmptyAttributes: true,</span><br><span class="line">            //删除所有空格作属性值，例如：&lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt;</span><br><span class="line">            removeScriptTypeAttributes: true,</span><br><span class="line">            //删除&lt;script&gt;的type=&quot;text/javascript&quot;</span><br><span class="line">            removeStyleLinkTypeAttributes: true,</span><br><span class="line">            //删除&lt;style&gt;和&lt;link&gt;的 type=&quot;text/css&quot;</span><br><span class="line">            minifyJS: true, //压缩页面 JS</span><br><span class="line">            minifyCSS: true, //压缩页面 CSS</span><br><span class="line">            minifyURLs: true  //压缩页面URL</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&#x27;./public&#x27;))</span><br><span class="line">&#125;);</span><br><span class="line">//压缩字体</span><br><span class="line">function minifyFont(text, cb) &#123;</span><br><span class="line">  gulp</span><br><span class="line">    .src(&#x27;./public/fonts/*.ttf&#x27;) //原字体所在目录</span><br><span class="line">    .pipe(fontmin(&#123;</span><br><span class="line">      text: text</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(&#x27;./public/fontsdest/&#x27;)) //压缩后的输出目录</span><br><span class="line">    .on(&#x27;end&#x27;, cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gulp.task(&#x27;mini-font&#x27;, (cb) =&gt; &#123;</span><br><span class="line">  var buffers = [];</span><br><span class="line">  gulp</span><br><span class="line">    .src([&#x27;./public/**/*.html&#x27;]) //HTML文件所在目录请根据自身情况修改</span><br><span class="line">    .on(&#x27;data&#x27;, function(file) &#123;</span><br><span class="line">      buffers.push(file.contents);</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(&#x27;end&#x27;, function() &#123;</span><br><span class="line">      var text = Buffer.concat(buffers).toString(&#x27;utf-8&#x27;);</span><br><span class="line">      minifyFont(text, cb);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">// 运行gulp命令时依次执行以下任务</span><br><span class="line">gulp.task(&#x27;default&#x27;, gulp.parallel(</span><br><span class="line">  &#x27;compress&#x27;, &#x27;minify-css&#x27;, &#x27;minify-html&#x27;,&#x27;mini-font&#x27;</span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>4.在每次运行完<code>hexo generate</code>生成静态页面后，运行<code>gulp</code>对其进行压缩。指令流程如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">gulp</span><br><span class="line">hexo server 或 hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt-qrc机制</title>
      <link href="/chunyujin/43f5e4df.html"/>
      <url>/chunyujin/43f5e4df.html</url>
      
        <content type="html"><![CDATA[<h2 id="Qt导入照片等资源的三种方式"><a href="#Qt导入照片等资源的三种方式" class="headerlink" title="Qt导入照片等资源的三种方式"></a>Qt导入照片等资源的三种方式</h2><ol><li><p>绝对路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">QIcon <span class="title">icon</span><span class="params">(<span class="string">&quot;D:/document/code/QT/LEARNING/QWidget_7/143894.jpg&quot;</span>)</span></span>;<span class="comment">//直接在栈上创建，而不是在堆上</span></span><br><span class="line">    <span class="comment">//之前推荐在堆上创建，主要是因为要确保当前空间的生命周期是足够的，要通过Qt对象树来释放对象。</span></span><br><span class="line">    <span class="comment">//QIcon自身是一个比较小的对象，创建出来了之后，就是要设置到某个QWidget里面，QIcon对象本身是否释放，都不影响最后的显示</span></span><br><span class="line">    <span class="comment">//另一方面，QIcon不支持对象树</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowIcon</span>(icon);</span><br><span class="line">    <span class="comment">//setWindoewIcon和setWindowTitle一样，也是顶层窗口设置才有效</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913150322120.png" alt="image-20240913150322120"></p></li><li><p>相对路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function">QIcon <span class="title">icon</span><span class="params">(<span class="string">&quot;../QWidget_7/143894.jpg&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//通过绝对路径的方式进行引用，是不科学的</span></span><br><span class="line">    <span class="comment">//因为写的程序最后是要发布到用户的电脑上的，无法确保，开发机上图片的路径和用户电脑上的路径完全一致</span></span><br><span class="line">    <span class="comment">//因此，相比于使用绝对路径的方式，使用相对路径是更好的</span></span><br><span class="line">    <span class="comment">//另外还需要注意，此处使用的./是可执行程序的路径，并不是项目工程的路径，因为程序运行时的工作路径，是可执行程序所在路径，并非工程所在的路径</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowIcon</span>(icon);</span><br><span class="line">    <span class="comment">//setWindoewIcon和setWindowTitle一样，也是顶层窗口设置才有效</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>qrc机制</p></li></ol><h3 id="qrc机制"><a href="#qrc机制" class="headerlink" title="qrc机制"></a>qrc机制</h3><p>​Qt引入qrc机制，从根本上解决两个问题：</p><ol><li>图片所在路径不一定在用户机上也存在 (绝对路径的缺点)</li><li>图片可能会在用户机上丢失 (相对路径的缺点)</li></ol><blockquote><p>原理：给Qt项目引入了一个额外的xml文件（后缀为.qrc），在这个xml中将要使用的图片资源导入进来，并且在xml中进行记录。Qt在编译项目的时候，会根据qrc中的图片信息，找到图片中的内容，提取出里面的二进制数据，将二进制数据转化为C++代码，最终编译到exe中。</p></blockquote><p>​qrc的缺点：无法导入太大的资源。</p><h4 id="qrc的用法"><a href="#qrc的用法" class="headerlink" title="qrc的用法"></a>qrc的用法</h4><h5 id="1-新建项目"><a href="#1-新建项目" class="headerlink" title="1.新建项目"></a>1.新建项目</h5><p>选择Qt -&gt; Qt Resource File，创建名称之后一致next即可。此处取名”resource“。</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913150531802.png" alt="image-20240913150531802"></p><p>创建完成后可以看到左侧项目列表中多了一个<code>Resources/resource.qrc</code></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913150750840.png" alt="image-20240913150750840"></p><p>双击之后进入界面</p><h5 id="2-新建前缀-Add-Prefix"><a href="#2-新建前缀-Add-Prefix" class="headerlink" title="2.新建前缀(Add Prefix)"></a>2.新建前缀(Add Prefix)</h5><p>前缀可以理解为Qt创建的一个虚拟目录</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913152038144.png" alt="image-20240913152038144"></p><p>自定义一下前缀的名称，然后在qrc文本编辑下就可以看到这个新建的虚拟目录了</p><h5 id="3-导入文件-Add-Files"><a href="#3-导入文件-Add-Files" class="headerlink" title="3.导入文件(Add Files)"></a>3.导入文件(Add Files)</h5><p>导入文件，即将文件放入刚创建好的前缀中。需要注意的是，文件必须来自于qrc文件同级目录下或同级目录下的子目录中，即必须先将需要导入的文件放入工程目录中才行。</p><p>点击Qt编辑区(Qt Editor)的<code>/test</code>，选择<code>Add Files</code>，选中要导入的文件</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913152625084.png" alt="image-20240913152625084"></p><p>导入完成后，可以看到&#x2F;test新增了刚导入的文件，选择该文件，可以设置别名，后去就可以直接用别名调用此文件了，十分方便</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913152802022.png" alt="image-20240913152802022"></p><p>保存一下qrc文件，可以看到左侧项目栏中增加了内容</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913152844830.png" alt="image-20240913152844830"></p><p>此时qrc文件已经变成了列表，双击没有办法对qrc进行编辑了。右击qrc文件，可以执行Add Prefix等操作，右击前缀，可以执行添加文件等操作。</p><p>右击qrc文件，还可以选择在编辑区中打开(Open in Editor)，此时又可以通过跟上面一样的操作来编辑qrc文件了。</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913153158610.png" alt="image-20240913153158610"></p><h5 id="4-引用文件"><a href="#4-引用文件" class="headerlink" title="4.引用文件"></a>4.引用文件</h5><p>在引用文件的时候，语法与绝对路径，相对路径一样，只是前面要加上冒号”:”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QIcon <span class="title">icon</span><span class="params">(<span class="string">&quot;:/test/Asuka&quot;</span>)</span></span>;<span class="comment">//使用qrc的时候，格式为&quot;: + 虚拟路径&quot;</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setWindowIcon</span>(icon);</span><br></pre></td></tr></table></figure><h6 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h6><p>前缀名可以加”&#x2F;“可以不加，因为qrc会自动补全</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913153615833.png" alt="image-20240913153615833"></p><p>前缀名也可以为空，同样，qrc也会自动补全”&#x2F;“</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913153702520.png" alt="image-20240913153702520"></p><p>引用文件的时候，前缀为空，就直接不用写了</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913153729525.png" alt="image-20240913153729525"></p><h4 id="探究qrc"><a href="#探究qrc" class="headerlink" title="探究qrc"></a>探究qrc</h4><p>进入可执行程序目录，会看到多了一个文件：qrc_resource.cpp</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913154911371.png" alt="image-20240913154911371"></p><p>qrc中导入文件资源，就会被转化成qrc_resource.cpp中的代码</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913155337482.png" alt="image-20240913155337482"></p><p>当Qt项目进行编译的时候，该cpp文件就被一起编译到exe中了，当exe程序运行的时候，上述图片的数据也就被加载到内存中了</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt信号与槽</title>
      <link href="/chunyujin/96fd26bb.html"/>
      <url>/chunyujin/96fd26bb.html</url>
      
        <content type="html"><![CDATA[<h2 id="信号与槽"><a href="#信号与槽" class="headerlink" title="信号与槽"></a>信号与槽</h2><p><code>信号源</code>发出(某种类型的)<code>信号</code>，由<code>槽</code>接收信号，并执行对应的<code>信号处理方式</code></p><p>步骤：</p><ol><li>将槽与信号关联起来</li><li>编写好对于信号的响应行为&#x2F;处理方式(槽)</li><li>触发信号，槽接收到，执行设定好的处理方式</li></ol><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>QObject提供的静态的成员函数，用于将信号和槽进行关联</p><blockquote><p>Qt中提供的这些类，本身是存在一定的继承关系的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/81ec1050ac35b96bb35ca8981980404.jpg" alt="81ec1050ac35b96bb35ca8981980404" style="zoom:80%;" /></blockquote><p>原型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(<span class="type">const</span> QObject *sender,</span><br><span class="line">       <span class="type">const</span> <span class="type">char</span> *signal,</span><br><span class="line">       <span class="type">const</span> QObject *receiver,</span><br><span class="line">       <span class="type">const</span> <span class="type">char</span> *method,</span><br><span class="line">       Qt::ConnectionType type = Qt::AutoConnection)</span><br><span class="line"><span class="comment">//sender:信号源，信号是由那个空间发送出来的</span></span><br><span class="line"><span class="comment">//signal:发送的信号(信号函数)；函数指针</span></span><br><span class="line"><span class="comment">//receiver:槽，也就是信号接收对象，处理信号的对象(控件)</span></span><br><span class="line"><span class="comment">//method:接收信号的槽函数，处理信号的对象提供的处理方式(成员函数)；函数指针</span></span><br><span class="line"><span class="comment">//type:用于指定关联方式，通常不需要手动指定，有默认关联方式</span></span><br></pre></td></tr></table></figure><p>example：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//创建一个pushbutton对象，并初始化挂到对象树上，指明父对象是this</span></span><br><span class="line"></span><br><span class="line">    button-&gt;<span class="built_in">setText</span>(<span class="string">&quot;关闭&quot;</span>);</span><br><span class="line">    button-&gt;<span class="built_in">move</span>(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(button, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;Widget::close);</span><br><span class="line">    <span class="comment">//第二、四个参数应该是函数指针，成员函数取地址，得到的就是函数的指针了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ol><li><p>connect中第二个参数，是信号发出的信号，必须是信号源类(或其父类)中的成员函数(信号函数)，不能是无关类的成员函数。</p><p>本例中，信号源设置为了<code>QPushButton</code>类对象<code>button</code>，因此信号函数必须是<code>QPushButton</code>类(或其父类)中的成员函数，不能是别的类</p></li><li><p>connect中第三个参数，是槽，即接收信号的对象</p><p>此处设置为<code>this</code>，即<code>Widget</code>本身</p></li><li><p>connect中第四个参数，是槽函数，必须是槽(或其父类)中的成员函数(槽函数)，不能是无关类的成员函数</p><p>本例中，槽为<code>this</code>，即<code>Widget</code>，因此槽函数必须是<code>Widget</code>类(或其父类)中的成员函数。<code>close</code>为<code>QWidget</code>内置的槽函数，<code>Widget</code>继承自<code>QWidget</code>，也就继承了父类的槽函数</p></li><li><p><code>QPushButton::click</code>和<code>QPushButton::clicked</code>的区别：</p><ol><li><p><code>click</code>是模拟’’按钮点击’’的动作，<code>clicked</code>是接收’’按钮点击’’这一行为。</p><p>在本例中，我们是想要在”按钮被点击后，执行关闭窗口的行为”，也就是说要捕获到“按钮被点击了”这一行为，然后发出信号，进而被槽接收，在执行对应的处理行为。所以说应该用<code>clicked</code>。</p></li><li><p><code>click</code>是槽函数，<code>clicked</code>是信号函数。前者是用于执行动作的，后者适用于捕捉动作和行为、发出信号的。这也是槽函数和信号函数的不同的作用和用途。</p></li><li><p>tips：在Qt Creator中，可以通过查看代码补全时左侧的小图标来得知函数是 信号函数 还是 槽函数。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807135314848.png" alt="image-20240807135314848" style="zoom:80%;" /><blockquote><p>信号函数：图标很像是(遥控器)发送信号(电波)的样子</p><p>槽函数：图标上有凹槽</p></blockquote></li></ol></li><li><p>三个问题：</p><ol><li><p>怎么知道控件类里面有什么槽函数什么信号函数的？Qt里都提供了哪些内置的信号和槽可以让用户直接使用呢？</p><p><strong>多看文档！！</strong></p><p>在翻阅文档的时候，如果在当前类中没有找到对应的线索，不妨看看这个类的父类（的父类的父类…）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807141156575.png" alt="image-20240807141156575" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807141553836.png" alt="image-20240807141553836" style="zoom:80%;" /><p>QPushButton中没有找到click和clicked，去看看它的父类</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807141339271.png" alt="image-20240807141339271" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807141348894.png" alt="image-20240807141348894"  /><p>查阅文档的信号的时候，最重点的就是关注信号的发送时机（用户进行了啥样的操作，就能产生这个信号）</p></li><li><p>为什么<code>connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection)</code>原型中，函数指针是char*？不应该是根据函数不同，而设置不同的指针类型吗？</p><p>因为这个写法是Qt5之前的写法，在以前书写的时候，需要在信号函数指针和槽函数指针之前加上宏，将其转化为char*，长下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(button, <span class="built_in">SIGNAL</span>(&amp;QPushButton::clicked), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(&amp;Widget::close));</span><br></pre></td></tr></table></figure><p>Qt5开始，对上述写法进行了简化，不需要写SIGNAL和SLOT宏了，给connect提供了重载版本，在崇拜版本中，第二、四个参数变成了泛型参数，允许转入任意类型的<u>函数指针</u>了</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240808092507878.png" alt="image-20240808092507878"></p><blockquote><p>画横线的地方，是Qt封装的类型萃取器，</p></blockquote></li><li><p>信号函数和槽函数不取地址可以吗？</p><p>函数名取地址之后就是函数指针了。</p><p>在C中，如果要使用函数指针，可以直接用函数名，也可以取地址，尽管两个类型是不同的，但是地址值都是函数的首地址。</p><p>但是在C++和Qt中，强调了指针的类型了，函数名和函数指针的类型是不同的（如果函数类型为<code>void (int)</code>的话，那么对应的函数指针类型就是<code>void (*)(int)）</code>，尽管两个保存的地址值都相同，但是C++和Qt对类型加了限制，所以是不能通过的，必须取地址才可以。</p><blockquote><p>详细可以参考C++下的文章<a href="https://chunyujin.top/chunyujin/f389ecbc">C-指针进阶</a></p></blockquote></li></ol></li></ol></blockquote><h3 id="自定义信号和槽"><a href="#自定义信号和槽" class="headerlink" title="自定义信号和槽"></a>自定义信号和槽</h3><h5 id="自定义槽"><a href="#自定义槽" class="headerlink" title="自定义槽"></a>自定义槽</h5><p>两种方式：</p><blockquote><ol><li><p>手动编写声明定义</p><p>在头文件的类中加入槽的声明，在源文件中进行定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT<span class="comment">//某个类中如果要使用信号槽，那么类的开始必须要写上这个宏（Qt中的硬性规定，否则类在编译时会出错）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleMySignal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//自定义的槽的声明；slots为Qt中的关键字，用于说明下面的函数为槽函数；</span></span><br><span class="line">    <span class="comment">//slots前面可以根据情况添加public或private</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.cpp</span></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;Widget::handleMySignal);</span><br><span class="line"><span class="comment">//将ui界面中创建的对象&quot;pushButton&quot;的clicked信号与当前对象(widget)的自定义槽手动关联起来</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::handleMySignal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;自定义槽已经接收到了信号！！&quot;</span>);</span><br><span class="line">    <span class="comment">//自定义槽的定义</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在ui界面中自动生成某控件对象的信号转到的自定义槽</p><p>在ui界面中右击控件对象，弹出”转到槽“，点击之后进入选择界面</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240815135908956.png" alt="image-20240815135908956" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240815135929008.png" alt="image-20240815135929008" style="zoom:80%;" /><p>这个界面含义是”为下面的信号生成相关的自定义槽“，如：选择了<code>QAbstractButton</code>类的<code>clicked()</code>，则自动生成一个自定义槽，与此信号<mark>自动关联</mark>起来，此信号一发出，自定义槽则响应。</p><p>选择之后，头文件和源文件中自动生成了该自定义槽：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240815140813601.png" alt="image-20240815140813601" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240815141508087.png" alt="image-20240815141508087" style="zoom:80%;" /><blockquote><p>通过ui界面的方式自动生成的槽，是与ui控件对象的信号自动关联的，所以不需要再使用<code>connect</code>进行手动关联了</p></blockquote></li></ol></blockquote><p><strong>Qt中也允许自定义信号，但是槽函数作为响应，会更倾向于自定义，但是信号的触发一般就固定的几种（在GUI中，用户能进行哪些操作，是可以穷举的~），所以自定义信号相对较少</strong></p><h5 id="自定义信号"><a href="#自定义信号" class="headerlink" title="自定义信号"></a>自定义信号</h5><p>自定义信号用户只需要声明就可以了，自定义信号要放在关键字<code>signals</code>之下，这样Qt自动认为该函数为信号，并在内部自动生成函数定义(元编程)，用户无需干涉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT<span class="comment">//某个类中如果要使用信号槽，那么类的开始必须要写上这个宏（Qt中的硬性规定，否则类在编译时会出错）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line"></span><br><span class="line">signals:<span class="comment">//Qt自己扩展出来的关键字，会自动认为下面包含的函数为信号，并自动生成函数定义</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySignal</span><span class="params">()</span></span>;<span class="comment">//自定义信号，只需声明，无需实现，剩下的交给Qt来做</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于是自定义信号，并不是和Qt自带信号一样将行为与触发绑定起来(例如<code>PushButton类</code>自带的<code>clicked</code>信号，识别到按钮被点击，<code>clicked</code>信号就被自动发送出去)，所以自定义信号需要借助其他的方式进行”发射&#x2F;触发”，比如将自定义信号在函数中进行发射。在信号前面添加<code>emit</code>关键字，即可手动发射信号。</p><blockquote><ol><li><p>由于自定义信号并非Qt自带的信号，因此无法通过ui界面自动生成自定义槽函数，所以只能手动使用<code>connect</code>与槽进行关联。</p></li><li><p>信号与槽通过<code>connect</code>进行关联，只是建立了连接，使二者“产生了关系”，不代表信号已经发出来了。</p></li><li><p><code>emit</code> 手动发出信号，不止适用于自定义信号。<br>其实Qt5中<code>emit</code>什么都没做，真正的操作已经都包含在信号函数内部自动生成的定义中了；即使不写<code>emit</code>，函数也能发射出去。<br>即使如此，在实际开发中，还是建议加上<code>emit</code>，增加代码的可读性，可以明显地标识出：这里是发射自定义信号</p></li></ol></blockquote><p>下面一个例子：通过ui界面生成了一个<code>pushButton</code>对象的<code>clicked</code>信号转到的自定义槽，自定义槽执行的行为是发送一个自定义信号，该自定义信号再与另一个自定义槽手动关联起来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.cpp</span></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;Widget::mySignal, <span class="keyword">this</span>, &amp;Widget::handleMySignal);</span><br><span class="line">    <span class="comment">//建立连接，不代表信号已经发出来了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_pushButton_clicked</span><span class="params">()</span><span class="comment">//ui界面生成的转到槽，关联的信号是pushButton的clicked</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">mySignal</span><span class="params">()</span></span>;<span class="comment">//发送信号的行为可以在任意合适的代码中，不只可以在构造函数中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::handleMySignal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;自定义槽已经接收到自定义信号了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>pushButton</code>被点击之后，发送<code>clicked</code>信号，<code>on_pushButton_clicked</code>槽接收之后，执行发送<code>mySignal</code>信号的行为；<code>handleMySignal</code>槽接收到<code>mySignal</code>信号之后，更改窗口标题。</p></blockquote><h3 id="信号与槽的关联是多对多的"><a href="#信号与槽的关联是多对多的" class="headerlink" title="信号与槽的关联是多对多的"></a>信号与槽的关联是多对多的</h3><p>一个信号可以关联多个槽，一个槽也可以响应多个信号</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240815155439479.png" alt="image-20240815155439479" style="zoom:80%;" /><h3 id="带参数的信号和槽"><a href="#带参数的信号和槽" class="headerlink" title="带参数的信号和槽"></a>带参数的信号和槽</h3><p>信号和槽是可以带参数的，Qt自带的一些信号和槽是可以传参的；自定义信号和槽也是可以传参。</p><p>信号的参数列表会直接传递到connect关联的槽的参数列表，通过这种机制，就实现了从信号向槽传输数据</p><blockquote><p>在使用带信号信号和槽时，要确保：</p><ol><li>关联的信号和槽参数类型一致</li><li>关联的信号和槽参数数量可以不一样，但一定要确保信号参数&gt;&#x3D;槽参数，反之不行<br>&#x2F;&#x2F;为什么：因为槽可能会绑定多个信号，允许信号参数多于槽参数，使得槽可以兼容多个信号<br>&#x2F;&#x2F;个数不一致时，槽会根据参数顺序，拿到信号的前N个参数；至少会确保槽函数的每个参数都是有值的</li></ol></blockquote><p>更改一下上面的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.cpp</span></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;Widget::mySignal, <span class="keyword">this</span>, &amp;Widget::handleMySignal);</span><br><span class="line">    <span class="comment">//建立连接，不代表信号已经发出来了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_pushButton_clicked</span><span class="params">()</span><span class="comment">//ui界面生成的转到槽，关联的信号是pushButton的clicked</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">mySignal</span><span class="params">(<span class="string">&quot;&quot;</span>自定义槽已经接收到自定义信号了<span class="string">&quot;， &quot;</span>hello<span class="string">&quot;);</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function"></span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">void Widget::handleMySignal(QString text)//槽函数参数可以少于关联的信号参数，槽根据顺序取前N个</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">&#123;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">    this-&gt;setWindowTitle(text);</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function"></span></span></span></span><br></pre></td></tr></table></figure><h3 id="disconnect"><a href="#disconnect" class="headerlink" title="disconnect"></a>disconnect</h3><p>虽然说信号和槽可以多对多，但是有些场景下，多个信号和多个槽同时关联，可能会造成一些混乱，因此可以在适当的时机断开先前的关联，进而再创建新的关联</p><blockquote><p>主动断开，往往就是为了新的绑定</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;Widget::handlemyclick1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::handlemyclick1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;现在按钮1关联的槽1&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;slot1 works&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::handlemyclick2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;现在按钮1关联的槽2&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;slot2 works&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_pushButton_2_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">disconnect</span>(ui-&gt;pushButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;Widget::handlemyclick1);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;Widget::handlemyclick2);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><blockquote><p><code>on_pushButton_2_clicked()</code>为<code>pushButton2</code>的<code>clicked</code>信号（简称信号2）转到槽，作用是断开<code>pushButton1</code>的<code>clicked</code>信号（简称信号1）与<code>handlemyclick1</code>槽（简称槽1）的连接，将<code>pushButton1</code>的<code>clicked</code>信号（简称信号2）与<code>handlemyclick2</code>槽（简称槽2）连接。这样的话，下次点击<code>pushButton1</code>，就是槽2响应，而不是槽1响应了。</p><p>最开始，信号1与槽1关联，点击按钮1，槽1响应；信号2与其转到槽关联，点击按钮2，转到槽响应，断开了信号1与槽1，关联了信号1与槽2；因此第二次点击按钮1时，信号1发出，槽2响应。</p><blockquote><p>如果不断开信号1与槽1，则信号1发出时，槽1与槽2都会响应，会很混乱，特别是涉及到同一种行为的，窗口标题不知道到底是按照槽1显示，还是按照槽2显示</p></blockquote><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/test1.gif" alt="test1"></p><p>点击button1，显示”关联槽1”，点击button2之后，断开了button1与槽1的连接，将button1与槽2连接，此时点击button1，显示”关联槽2“，并且槽2会断开button1与自己的连接，将button1与槽1连接；再点击button1，显示“关联槽1”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt-解决MSVC下编码警告&amp;中文输入乱码</title>
      <link href="/chunyujin/f7d3dfd8.html"/>
      <url>/chunyujin/f7d3dfd8.html</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>如果MSVC编译时，</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240813162138097.png" alt="image-20240813162138097" style="zoom:80%;" /><p>或者</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240819130658443.png" alt="image-20240819130658443"></p><p>在pro文件最下面加入：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">msvc</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">QMAKE_CFLAGS</span> <span class="string">+= /utf-8</span></span><br><span class="line">    <span class="attr">QMAKE_CXXFLAGS</span> <span class="string">+= /utf-8</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240813162216747.png" alt="image-20240813162216747" style="zoom:80%;" /><p>然后“重新构建”（一定要进行这步）即可</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows将大写锁定键设置为中英文切换</title>
      <link href="/chunyujin/679ac598.html"/>
      <url>/chunyujin/679ac598.html</url>
      
        <content type="html"><![CDATA[<img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-12%20210205.png" alt="屏幕截图 2024-08-12 210205" style="zoom:80%;" /><ol><li>在“设置-时间和语言-语言”选择中文语言的选项</li></ol><p>​<img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812202640052.png" alt="image-20240812202640052" style="zoom:80%;" /></p><p>进入后点击微软输入法的选项</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812202720965.png" alt="image-20240812202720965" style="zoom:80%;" /><p>进入后在“按键”中确保选择了“ctrl+空格”进行大小写切换</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812202921875.png" alt="image-20240812202921875" style="zoom:80%;" /><ol start="2"><li><p>下载脚本工具<a href="https://www.autohotkey.com/">AutoHotkey</a>，本次教程的核心就是使用这个脚本，使CapsLock键映射为ctrl+空格，并判定长按的时间，超过一定时间就判定为按下大写锁定键，从而实现mac上一样的效果；将写好的脚本放在开机目录，开机自启动。</p><blockquote><p>顾名思义，autohotkey是一款热键管理管理脚本工具</p></blockquote></li><li><p>下载好之后进行安装，安装好之后就如下图，不用管，关闭就好</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812203552535.png" alt="image-20240812203552535" style="zoom:80%;" /></li><li><p>方法一：</p><p>新建一个记事本，命名一个比较贴近的名称</p><p>里面内容设置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">NoEnv</span></span><br><span class="line"></span><br><span class="line">SetCapsLockState, Alwaysoff</span><br><span class="line">SetStoreCapsLockMode, Off</span><br><span class="line"></span><br><span class="line">CapsLock::</span><br><span class="line">KeyWait, CapsLock, T0.3</span><br><span class="line">If ErrorLevel &#123;</span><br><span class="line">  Send, &#123;CapsLock&#125;</span><br><span class="line">  KeyWait, CapsLock</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  Send, &#123;Ctrl down&#125;&#123;Space down&#125;&#123;Space up&#125;&#123;Ctrl up&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>分析一下：如果大写锁定键按下时间小于0.3s，则映射为ctrl+空格，否则为大写锁定</p></blockquote><p>然后选择文件-另存为，选择类型为所有文件，然后更改文件后缀为.ahk（autohotkey的后缀）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812204406303.png" alt="image-20240812204406303" style="zoom:80%;" /></li></ol><p>​方法二：</p><p>​安装好autohotkey之后，在鼠标右键的新建里，已经可以看到可以新建autohotkey文件.ahk了，直接创建，然后填入上述代码即可</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812204526727.png" alt="image-20240812204526727" style="zoom:80%;" /><ol start="5"><li><p>点击运行这个文件，发现没有什么反应，并且按键也没有替换掉。</p><p>稍等片刻，弹出如下安装提醒AutoHotKey v1，这个软件就是自动化运行的关键</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812204749668.png" alt="image-20240812204749668" style="zoom:80%;" /></li></ol><p>​点击“是”之后，等待片刻，安装成功</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812204901843.png" alt="image-20240812204901843" style="zoom:80%;" /><ol start="6"><li><p>再次点击刚才创建的.ahk文件，运行成功，右下角菜单状态栏多了一个autohotkey v1正在运行的标志</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812205035150.png" alt="image-20240812205035150" style="zoom:80%;" /></li><li><p>现在将这个文件添加到开机自动文件夹中：<br>win+r打开“运行”，输入<strong>shell:startup</strong>，打开了启动文件夹（一般为C:\Users&lt;UserName&gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup）</p></li></ol><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812205301748.png" alt="image-20240812205301748" style="zoom:80%;" /><p>​将.ahk文件复制或者移动到这个目录下，开机的时候就会自动启动了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812205425257.png" alt="image-20240812205425257" style="zoom:80%;" /><blockquote><p>ps：如果这个目录下有你不想要开机自启动的东西，那就直接删掉他！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows Terminal好处多多</title>
      <link href="/chunyujin/5f48e093.html"/>
      <url>/chunyujin/5f48e093.html</url>
      
        <content type="html"><![CDATA[<p>1. </p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812203736635.png" alt="image-20240812203736635" style="zoom: 80%;" /><p>Windows的新终端Windows terminal比原来的命令行工具好用很多，直接就是上位替代</p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_NULL和nullptr的区别</title>
      <link href="/chunyujin/f7a38933.html"/>
      <url>/chunyujin/f7a38933.html</url>
      
        <content type="html"><![CDATA[<h1 id="NULL和nullptr的区别"><a href="#NULL和nullptr的区别" class="headerlink" title="NULL和nullptr的区别"></a>NULL和nullptr的区别</h1><p>简单来说，C++中引入了&#96;&#96;nullptr<code>来专门用于指针的置空，解决了C语言中</code>NULL&#96;的二义性问题。</p><p>也就是说，以后要给指针赋予空，用<code>nullptr</code>就对了</p><p>详细参考链接：<a href="https://blog.csdn.net/qq_18108083/article/details/84346655">C++中NULL和nullptr的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C-指针进阶知识</title>
      <link href="/chunyujin/f389ecbc.html"/>
      <url>/chunyujin/f389ecbc.html</url>
      
        <content type="html"><![CDATA[<h2 id="C-指针进阶知识"><a href="#C-指针进阶知识" class="headerlink" title="C-指针进阶知识"></a>C-指针进阶知识</h2><h4 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p1;</span><br><span class="line"><span class="type">int</span> p2[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>* p3[<span class="number">5</span>];<span class="comment">//</span></span><br><span class="line"><span class="built_in">int</span> (*p4)[<span class="number">5</span>] = p3;<span class="comment">//数组指针</span></span><br></pre></td></tr></table></figure><blockquote><ol><li><p>*与变量名p结合的优先程度是最弱的， * 会优先与前面的类型参数进行结合，而变量又会先与后面的方括号、括号结合，所以如果想说明变量是指针，且变量后又有其他符号跟随，就必须用括号将 *和变量括起来，变成 ( *p )的形式。</p></li><li><p>p1是int类型的变量</p></li><li><p>p2的变量类型是<code>int [5]</code>，是一个数组，保存int类型的元素</p></li><li><p>p3的变量类型是<code>int* [5]</code>，是一个数组，保存int*类型的元素</p></li><li><p>p4先与* 结合，p4的变量类型是<code>int (*)[5]</code>，是一个指针。指向的是<code>int [5]</code>类型，即包含五个int类型元素的数组；即p4存储的是包含5个int类型元素的数组的地址。p4是数组指针</p><p>数组指针p4的值虽然和数组名p3一样，都是数组的起始地址，不过前者是”数组p3这个对象“的起始地址，后者是数组p3内首元素“的起始地址，它们的值完全相同，但是表示的范围跨度就不一样了，从现象上来看，数组指针是以一整个数组的空间为跨度，而数组首地址则是一个元素的空间为跨度</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807170034054.png" alt="image-20240807170034054" style="zoom:80%;" /></li></ol><p>*的本意：解引用</p></blockquote><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">void</span> (*add2)(<span class="type">int</span>);</span><br></pre></td></tr></table></figure><blockquote><ol><li>add1的变量类型是<code>void (int)</code>，是一个函数，特征为参数类型是int，返回值类型为void</li><li>add2的变量类型是<code>void (*)(int)</code>，是一个指针，指向特征为：参数类型是int，返回值类型为void 的函数</li></ol><p>函数指针使用时，一般写作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*add2)(<span class="type">int</span>) = add1;</span><br><span class="line"><span class="comment">//add2是一个函数指针，解引用后就是一个函数，所以解引用后用来承接一个函数</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="built_in">void</span> (*add2)(<span class="type">int</span>);</span><br><span class="line">add2 = &amp;add1;</span><br><span class="line"><span class="comment">//add2是一个函数指针，所以add2用来承接一个函数的地址（函数取地址了）</span></span><br></pre></td></tr></table></figure></blockquote><p>void (* test)()的test 不等于 void* test()的test<br>前者test是一个指向返回值为空、无参数的函数的指针；后者test是一个返回值为void*、无参数的函数</p><h6 id="add1与-amp-add1"><a href="#add1与-amp-add1" class="headerlink" title="add1与&amp;add1"></a>add1与&amp;add1</h6><blockquote><p><mark><code>add1</code>和<code>add2</code>（也就是<code>&amp;add1</code>）的值一样，都是函数的起始地址，但是类型不一样，含义也不太相同。</mark><br><mark><code>add1</code>的值是函数的首地址，它的类型是<code>void  (int)</code></mark><br><mark><code>add2</code>（也就是<code>&amp;add1</code>）表示的是一个指向函数<code>add1</code>这个对象的指针，它的类型是<code>void (*)(int)</code></mark><br><mark><code>add1</code>和<code>add2</code>（即<code>&amp;add1</code>）所代表的地址值是一样的，但是类型不一样</mark></p><p>为什么要强调这一点？</p><p>因为在一些语言或者框架下，对于类型有比较严格的要求（比如Qt的connect函数），函数指针就必须是函数名取地址(&amp;add1这种)，确保是诸如void (*)(int)这种类型，否则会报错。</p><p>C语言中要求没有这么严格，add和&amp;add可以混用，比如add就可以作为下面函数指针数组的元素使用。</p></blockquote><h4 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*p[<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure><blockquote><p>p的变量类型是<code>void (*[5])(int, int)</code>，是一个数组，保存的元素的类型为<code>void (*)(int, int)</code>，是指向<code>void (int, int)</code>类型的指针，即指向返回值为空、两个参数为int的函数。</p><p>函数指针数组的使用：转移表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如用转移表来写一个计算器</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> input = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> (*p[<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>) = &#123;<span class="number">0</span>, add, sub, mul, div&#125;;<span class="comment">//转移表</span></span><br><span class="line">    <span class="comment">//注意这里使用了add(int (int,int)类型)，而不是&amp;add即int(*)(int,int)类型</span></span><br><span class="line">    <span class="comment">//因为C语言对于这个不是很严格</span></span><br><span class="line">    <span class="keyword">while</span> (input)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>( <span class="string">&quot;*************************\n&quot;</span> );</span><br><span class="line">         <span class="built_in">printf</span>( <span class="string">&quot;  1:add           2:sub  \n&quot;</span> );</span><br><span class="line">         <span class="built_in">printf</span>( <span class="string">&quot;  3:mul           4:div  \n&quot;</span> );</span><br><span class="line">         <span class="built_in">printf</span>( <span class="string">&quot;*************************\n&quot;</span> );</span><br><span class="line">         <span class="built_in">printf</span>( <span class="string">&quot;请选择：&quot;</span> );</span><br><span class="line">         <span class="built_in">scanf</span>( <span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">         <span class="keyword">if</span> ((input &lt;= <span class="number">4</span> &amp;&amp; input &gt;= <span class="number">1</span>))</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">printf</span>( <span class="string">&quot;输入操作数：&quot;</span> );</span><br><span class="line">             <span class="built_in">scanf</span>( <span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">             ret = (*p[input])(x, y);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         <span class="built_in">printf</span>( <span class="string">&quot;输入有误\n&quot;</span> );</span><br><span class="line">         <span class="built_in">printf</span>( <span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">      &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="指向函数指针数组的指针"><a href="#指向函数指针数组的指针" class="headerlink" title="指向函数指针数组的指针"></a>指向函数指针数组的指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*(*p)[<span class="number">5</span>]) (<span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>p是一个指针，指向类型为<code>int (*[5]) (int)</code>的对象，该对象是一个数组，存储的元素类型为<code>int (*)(int)</code>，即函数指针。所以p是指向函数指针数组的指针</p><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>如果一个函数B，其指针作为另一个函数A的参数，并再A中被调用了，那么B就称为回调函数。</p><blockquote><p>回调函数不是直接就使用的，而是由其他函数作为参数传入后，在某个时期（比如放在顺序执行的某个位置或者满足某个特定的事件、条件）被这个函数调用的。也就是说，调用方先执行自己的语句，回过头来再调用这个函数，所以这个函数叫做“回调函数”</p></blockquote><p>基本结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Callback)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//回调函数类型名称重命名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">claculateSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b,Callback cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> sum = a + b;</span><br><span class="line">  <span class="built_in">cb</span>(sum);</span><br><span class="line">  <span class="comment">//调用回调函数，将结果传递给回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">printSum</span><span class="params">(<span class="type">int</span> sum)</span><span class="comment">//定义回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;计算结果为：%d\n&quot;</span>,sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;回调函数已调用\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> *ret = <span class="built_in">caluculateSum</span>(<span class="number">6</span>, <span class="number">2</span>, printSum);</span><br><span class="line">  <span class="comment">//调用calculateSum函数，并将printSum函数作为回调函数传递</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">预期结果：</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">回调函数已调用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="typedef的用法"><a href="#typedef的用法" class="headerlink" title="typedef的用法"></a>typedef的用法</h5><p>typedef用来为某个类型起别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> CHAR;</span><br><span class="line"><span class="comment">//为char类型起别名CHAR，这样就可以用CHAR来声明变量了</span></span><br><span class="line">CHAR c = <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>typedef一次可以为一个类型起多个别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> antelope, bagel, mushroom;</span><br><span class="line"><span class="comment">//typedef为int取了三个别名</span></span><br><span class="line">bagel i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>typedef可以为数组起别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> array[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//typedef为int [5]类型的数组取别名</span></span><br><span class="line">array nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>由此可以看到，使用typedef取别名的时候，别名的位置就在变量名的位置上</strong></p><p>typedef为函数指针取别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*func)</span> <span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//为void (*)(int,int)类型取别名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printAdd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func = &amp;printAdd;</span><br></pre></td></tr></table></figure><blockquote><p>typedef的主要好处</p><ol><li><p>更好的代码可读性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* STRING;</span><br><span class="line"></span><br><span class="line">STRING name = <span class="string">&quot;chenyujin&quot;</span>;</span><br></pre></td></tr></table></figure><p>用<code>STRING</code>声明变量的时候，就可以轻易辨别该变量是字符串</p></li><li><p>为struct、union、enum等命令定义复杂的数据结构创建别名，从而便于引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">treenode</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">treenode</span>* TreeNode;</span><br></pre></td></tr></table></figure><p><code>TreeNode</code>为<code>struct treenode*</code>的别名</p><p>也可以在struct定义数据写在一起</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">treenode</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; *TreeNode;</span><br></pre></td></tr></table></figure><p><code>TreeNode</code>为<code>struct treenode*</code>的别名</p></li><li><p>方便以后为变量更改类型</p></li><li><p>可移植性</p><p>某一个值在不同计算机上的类型，可能是不一样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i = 100000;</span><br></pre></td></tr></table></figure><p>上面代码在32位整数的计算机没有问题，但是在16位整数的计算机就会出错。</p><p>C 语言的解决办法，就是提供了类型别名，在不同计算机上会解释成不同类型，比如<code>int32_t</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int32_t i = 100000;</span><br></pre></td></tr></table></figure><p>上面示例将变量<code>i</code>声明成<code>int32_t</code>类型，保证它在不同计算机上都是32位宽度，移植代码时就不会出错。</p><p>这一类的类型别名都是用 typedef 定义的。下面是类似的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef long int ptrdiff_t;typedef unsigned long int size_t;typedef int wchar_t;</span><br></pre></td></tr></table></figure><p>这些整数类型别名都放在头文件<code>stdint.h</code>，不同架构的计算机只需修改这个头文件即可，而无需修改代码。</p><p>因此，<code>typedef</code>有助于提高代码的可移植性，使其能适配不同架构的计算机。</p></li><li><p>简化类型声明</p><p>C 语言有些类型声明相当复杂，比如下面这个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char (*(*x(void))[5])(void);</span><br></pre></td></tr></table></figure><p>typedef 可以简化复杂的类型声明，使其更容易理解。首先，最外面一层起一个类型别名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef char (*Func)(void);Func (*x(void))[5];</span><br></pre></td></tr></table></figure><p>这个看起来还是有点复杂，就为里面一层也定义一个别名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef char (*Func)(void);typedef Func Arr[5];Arr* x(void);</span><br></pre></td></tr></table></figure><p>上面代码就比较容易解读了。</p><ul><li><code>x</code>是一个函数，返回一个指向 Arr 类型的指针。</li><li><code>Arr</code>是一个数组，有5个成员，每个成员是<code>Func</code>类型。</li><li><code>Func</code>是一个函数指针，指向一个无参数、返回字符值的函数。</li></ul></li></ol><p>该部分参考自<a href="https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-typedef.md">typedef 命令 - 《阮一峰《C 语言教程》》 - 书栈网 · BookStack</a></p></blockquote><h5 id="void-的用法"><a href="#void-的用法" class="headerlink" title="void*的用法"></a>void*的用法</h5><ol><li><p><code>void*</code>表示”任意类型的指针“，它可以接收任意类型的指针，而不必进行强制类型转换，经常用于作为回调函数中的参数类型，因为这样可以接受任何类型的指针了，包括各种类型的函数指针</p></li><li><p>当然，<code>void*</code> 不只可以用于回调函数，不知用于承接各种函数指针，void* 可以承接各种类型的指针，用于任何你想用的地方</p></li><li><p><code>void*</code>可以直接和其他类型的指针比较存放的地址值是否相同</p></li><li><p>当要使用<code>void*</code>的时候，必须要进行强制类型转换，否则不知道这个指针究竟是什么类型的</p><blockquote><p>这里要补充的是，<code>承接</code>和<code>使用</code>不同，一个是被赋值，一个是用与进行操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d_num = <span class="number">3.145</span>;</span><br><span class="line"><span class="type">void</span> * d_point = &amp;d_num;<span class="comment">//承接</span></span><br><span class="line">cout &lt;&lt; *(<span class="type">double</span>*)d_point &lt;&lt; endl;<span class="comment">//使用，此处是打印d_point指向的对象的值</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><code>void*</code>和其他所有指针一样，可以通过NULL或nullptr来初始化，表示一个空指针</p><blockquote><p>NULL和nullptr的区别，请见“编程日志”的C++目录下的“NULL和nullptr的区别”<a href="https://chunyujin.top/chunyujin/f7a38933">C++_NULL和nullptr的区别</a></p></blockquote></li><li><p>当<code>void*</code>作为函数的输入和输出时，表示可以接受和输出任意类型的指针</p><p>如果函数的参数或返回值可以是任意类型的指针，那么应声明其类型为<code>void*</code></p><blockquote><p>这里是不是和模版有点类似，模版是泛型编程，模版参数也是可以表示任意类型，只不过在使用的时候需要显式表明</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt代码格式化-使用astyle插件</title>
      <link href="/chunyujin/3a989153.html"/>
      <url>/chunyujin/3a989153.html</url>
      
        <content type="html"><![CDATA[<p>具体配置请见下面文章<a href="https://www.cnblogs.com/hhddd-1024/p/17812399.html">天上人间 (cnblogs.com)</a></p><blockquote><p>其他参考文章：<br><a href="https://www.jianshu.com/p/e91ed18d4cfd">QT 代码格式化 | 配置Beautifier - 简书 (jianshu.com)</a><br><a href="https://blog.csdn.net/okpfsje123/article/details/107933946">qt creator 代码格式化工具Astyle的配置_qt creater 配置astyle-CSDN博客</a></p><p><a href="https://blog.csdn.net/zzs0829/article/details/83933747">Qt Creator 代码格式化的高级配置_qt creator代码格式化-CSDN博客</a></p></blockquote><h2 id="以下是补充说明："><a href="#以下是补充说明：" class="headerlink" title="以下是补充说明："></a>以下是补充说明：</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807094452154.png" alt="image-20240807094452154" style="zoom:80%;" /><blockquote><p>红色部分是astyle可执行程序的路径</p><p>蓝色部分是用户自定义的模块：<br>点击“Add”为添加新设置，“Edit”对于当前模块进行更改</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807094707645.png" alt="image-20240807094707645" style="zoom:80%;" /><blockquote><p>模块的设置基本框架为：<br>Name可以自定义<br>Value部分：</p><p>​必须先使用<code>--style=</code>添加一个astyle的固定风格，该风格是astyle插件中预先设置好的诸多风格之一，可以在[astyle官方文档](<a href="https://astyle.sourceforge.net/astyle.html">Artistic Style (sourceforge.net)</a>)进行查看，也可以在astyle安装目录子文件夹file下查看有哪些预定风格：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807095017257.png" alt="image-20240807095017257" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807095005956.png" alt="image-20240807095005956" style="zoom:80%;" /><p>需要注意的是，在自定义Value部分时，必须要先设定好这样一个风格，否则会报错如：<br>Failed to format: The command “D:\software\astyle-3.5.2-x64\astyle.exe” terminated with exit code 1..<br>Error in Beautifier: Cannot open documentation file “C:&#x2F;Users&#x2F;30297&#x2F;AppData&#x2F;Roaming&#x2F;QtProject&#x2F;qtcreator&#x2F;beautifier&#x2F;documentation&#x2F;artisticstyle.xml”.<br>等</p><p>另外就是自定义部分，下面是一个基于allman格式的自定义模板：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--style=allman</span><br><span class="line">indent=spaces=4# 缩进采用4个空格</span><br><span class="line">indent-switches# -S  设置 switch 整体缩进</span><br><span class="line">indent-cases# -K  设置 cases 整体缩进</span><br><span class="line">indent-namespaces# -N  设置 namespace 整体缩进</span><br><span class="line">indent-preproc-block# -xW 设置预处理模块缩进</span><br><span class="line">indent-preproc-define   # -w  设置宏定义模块缩进</span><br><span class="line">pad-oper                # -p  操作符前后填充空格</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">delete-empty-lines      <span class="comment"># -xe 删除多余空行</span></span></span><br><span class="line">add-braces              # -j  单行语句加上大括号</span><br><span class="line">align-pointer=name      # *、&amp;这类字符靠近变量名字</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">align-pointer=<span class="built_in">type</span></span></span><br></pre></td></tr></table></figure><p>如果自定义配置格式书写有问题，也会出现上述报错。即上述报错一般都源自于自定义配置模块编写出错，仔细检查对照一下即可。</p></blockquote></blockquote><h3 id="设置保存文件时自动格式化"><a href="#设置保存文件时自动格式化" class="headerlink" title="设置保存文件时自动格式化"></a>设置保存文件时自动格式化</h3><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807095404788.png" alt="image-20240807095404788" style="zoom: 67%;" /><p>“Enable auto format on file save”</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt如何使用第三方库</title>
      <link href="/chunyujin/5a0ef924.html"/>
      <url>/chunyujin/5a0ef924.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202408041147279.png" alt="截屏2024-08-04 11.46.25"></p><h2 id="1-获取库的-dll和-lib-或-a"><a href="#1-获取库的-dll和-lib-或-a" class="headerlink" title="1.获取库的.dll和.lib(或.a)"></a>1.获取库的.dll和.lib(或.a)</h2><h3 id="在资源管理器中找到对应库的-dll和-lib-或-a"><a href="#在资源管理器中找到对应库的-dll和-lib-或-a" class="headerlink" title="在资源管理器中找到对应库的.dll和.lib(或.a)"></a>在资源管理器中找到对应库的.dll和.lib(或.a)</h3><h4 id="如果第三方库不是Qt生成的："><a href="#如果第三方库不是Qt生成的：" class="headerlink" title="如果第三方库不是Qt生成的："></a>如果第三方库不是Qt生成的：</h4><p>通常比较规范的第三方库，有<code>lib</code>和<code>include</code>两个文件夹。<code>lib</code>文件夹就是包含的库文件。<code>include</code>则包含头文件。</p><h4 id="如果第三方库是Qt生成的："><a href="#如果第三方库是Qt生成的：" class="headerlink" title="如果第三方库是Qt生成的："></a>如果第三方库是Qt生成的：</h4><p>（通过Qt创建库的方法请见另一篇文章）</p><p>第三方库的构建时可以选择构建套件(Kit)：</p><blockquote><p>使用的<code>MSVC</code>编译：编译后会生成<code>.dll</code>和<code>.lib</code>两个文件。<code>.dll</code>在运行应用程序时调用，<code>.lib</code>在应用程序隐式调用动态链接库时使用<br>使用<code>MinGW</code>编译：编译后会生成<code>.dll</code>和<code>.a</code>两个文件，<code>.dll</code>在运行应用程序时调用，<code>.a</code>在应用程序隐式调用动态链接库时使用</p><p><mark>注意，如果一个项目中使用了第三方库，构建项目时使用的套件，必须与使用的第三方库构建使用的套件一致，否则会报错”link1104“错误</mark></p><blockquote><p>即如果第三方库用的MinGW编译，项目中添加的库文件是.a，那么项目构建的时候，也是用MinGW编译才可以通过</p></blockquote></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803102506454.png" alt="image-20240803102506454" style="zoom: 80%;" /><p>构建时可以选择套件、构建的位置，如果选择了Debug，则应该到中间文件目录的Debug文件夹下去找构建后的库：<br>中间文件目录会生成到项目文件的同级目录下：</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803103351534.png" alt="image-20240803103351534"></p><h2 id="2-获取库的头文件"><a href="#2-获取库的头文件" class="headerlink" title="2.获取库的头文件"></a>2.获取库的头文件</h2><h3 id="在资源管理器中找到对应库的头文件"><a href="#在资源管理器中找到对应库的头文件" class="headerlink" title="在资源管理器中找到对应库的头文件"></a>在资源管理器中找到对应库的头文件</h3><h4 id="如果第三方库不是Qt生成的：-1"><a href="#如果第三方库不是Qt生成的：-1" class="headerlink" title="如果第三方库不是Qt生成的："></a>如果第三方库不是Qt生成的：</h4><p>一般就存在于第三方库的<code>include</code>文件夹下</p><h4 id="如果第三方库是Qt生成的：-1"><a href="#如果第三方库是Qt生成的：-1" class="headerlink" title="如果第三方库是Qt生成的："></a>如果第三方库是Qt生成的：</h4><p>头文件存在于项目目录下</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240804110803753.png" alt="image-20240804110803753" style="zoom:80%;" /><h2 id="3-在项目中添加该库文件-及-相关头文件"><a href="#3-在项目中添加该库文件-及-相关头文件" class="headerlink" title="3.在项目中添加该库文件 及 相关头文件"></a>3.在项目中添加该库文件 及 相关头文件</h2><h4 id="方法一：不拷贝（推荐）"><a href="#方法一：不拷贝（推荐）" class="headerlink" title="方法一：不拷贝（推荐）"></a>方法一：不拷贝（推荐）</h4><h5 id="添加库"><a href="#添加库" class="headerlink" title="添加库"></a>添加库</h5><p>右击项目，选择“添加库”</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803163413609.png" alt="image-20240803163413609" style="zoom:80%;" /><p>或者打开.pro文件，在空白处右击鼠标，选择添加库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803163448944.png" alt="image-20240803163448944" style="zoom: 80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803164247193.png" alt="image-20240803164247193" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803164401963.png" alt="image-20240803164401963" style="zoom:80%;" /><p>点击库文件的“浏览”，库的.a文件。如果库是Qt生成的，则找到对应的中间文件目录的debug目录或者release目录，找到对应的.a文件。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803164505781.png" alt="image-20240803164505781" style="zoom: 80%;" /><h5 id="添加库的头文件路径"><a href="#添加库的头文件路径" class="headerlink" title="添加库的头文件路径"></a>添加库的头文件路径</h5><p>点击“包含路径”后面的“浏览”</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240804111413939.png" alt="image-20240804111413939" style="zoom:80%;" /><p>找到库的项目目录（如果库是Qt构建的），选中，然后点击右下角选择文件夹</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240804111523486.png" alt="image-20240804111523486" style="zoom:80%;" /><blockquote><p>因为Qt的头文件在项目目录下</p></blockquote><p>完成之后，确定剩余的勾选项，然后一直下一步，直到结束</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240804111646721.png" alt="image-20240804111646721" style="zoom:80%;" /><blockquote><p>关于勾选项：<br><code>平台</code>：如果不是Linux和mac平台，可以只选Windows<br><code>链接</code>：根据需求选择，可以直接选动态<br><code>Windows</code>下的选项：<br>            因为当前使用的库并不是存在于中间文件目录的debug或release子目录下，而是复制到了工程目录下，所以不勾选<br>            “为debug版本添加’d’作为后缀”建议不勾选（勾选了之后在.pro文件中会在库名后加一个d，构建时容易报错“找不到库文件”，如果勾选上，在.pro将d删除即可</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803112021251.png" alt="image-20240803112021251" style="zoom:80%;" /><p>​“移除release版本中的’d’后缀”不勾选</p></blockquote><p>此处可以查看一下项目的<code>.pro</code>文件，里面有和库有关的配置信息：<br>在添加完库之后，<code>.pro</code>文件中会新生成几行：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240804112017650.png" alt="image-20240804112017650" style="zoom:80%;" /><blockquote><p>其中<code>LIBS</code>是确定库的所在位置（-L），以及库名（-l）</p><p><code>INCLUDEPATH</code>是指定头文件的搜索路径</p><p><code>DEPENDPATH</code>用于指定项目中的源文件所依赖的头文件的搜索路径</p><p>（二者区别见<a href="https://blog.csdn.net/weixin_45650767/article/details/129740691">Qt构建中DEPENDPATH和INCLUDEPATH区别</a>）</p></blockquote><h5 id="使用库"><a href="#使用库" class="headerlink" title="使用库"></a>使用库</h5><p>现在就可以使用库了，本例中使用的<code>des.h</code>即为库中的头文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240804112409882.png" alt="image-20240804112409882" style="zoom:80%;" /><h4 id="方法二：拷贝"><a href="#方法二：拷贝" class="headerlink" title="方法二：拷贝"></a>方法二：拷贝</h4><h5 id="将库文件拷贝到当前项目下，新建目录"><a href="#将库文件拷贝到当前项目下，新建目录" class="headerlink" title="将库文件拷贝到当前项目下，新建目录"></a>将库文件拷贝到当前项目下，新建目录</h5><p>在工程目录下创建一个新的文件夹(此处取名<code>lib</code>，随意)，将库的<code>.dll</code>和<code>.a</code>复制进去(此处以.a为例)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803105505302.png" style="zoom:80%;" /><h5 id="将库的头文件拷贝到当前项目下，新建目录"><a href="#将库的头文件拷贝到当前项目下，新建目录" class="headerlink" title="将库的头文件拷贝到当前项目下，新建目录"></a>将库的头文件拷贝到当前项目下，新建目录</h5><p>在项目目录下新建文件夹（此处取名<code>include</code>，随意），将库头文件拷贝进来（如果多个头文件，建议全部拷贝，因为可能互相包含）。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803170601334.png" alt="image-20240803170601334" style="zoom:80%;" /><p>在Qt Creator中，右击项目中的Header文件夹，点击“Add Existing Directory”（也可以选择“添加现有文件”但是是单文件添加，效率低）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803170832859.png" alt="image-20240803170832859" style="zoom:80%;" /><p>选择当前项目目录下的<code>include</code>文件夹</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803171320095.png" alt="image-20240803171320095" style="zoom:80%;" /><p>稍等片刻，项目中就添加完成了，同时<code>.pro</code>文件中也更新了配置</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803171509008.png" alt="image-20240803171509008" style="zoom:80%;" /><h5 id="添加库和头文件路径"><a href="#添加库和头文件路径" class="headerlink" title="添加库和头文件路径"></a>添加库和头文件路径</h5><p>在Qt Creator中右击项目名，点击添加库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803110136850.png" alt="image-20240803110136850" style="zoom:80%;" /><p>或者，打开项目的<code>.pro</code>文件，右击空白处，点击添加库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803110224689.png" alt="image-20240803110224689" style="zoom:80%;" /><p>选择“外部库”</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803110249815.png" alt="image-20240803110249815" style="zoom:80%;" /><p>点击“库文件”右侧“浏览”</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803110445314.png" alt="image-20240803110445314" style="zoom:80%;" /><p>找到刚在工程目录下创建的lib文件夹下的<code>.a</code>文件，选中打开即可</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803110701026.png" alt="image-20240803110701026" style="zoom:67%;" /><p>完成后会发现“包含路径”一栏已经自动填充，而且是自动选择了项目目录下的include目录，即刚才拷贝过来的库头文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240804113021433.png" alt="image-20240804113021433" style="zoom:80%;" /><p>关于勾选框，左下如果没有特别情况，只勾选Windows即可。右侧Windows中，“debug或release子目录下的库”，如果是Qt生成的库，可以选上。“为debug版本添加’d‘作为后缀”不勾选。（详细看方法一此处介绍）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240804113716498.png" alt="image-20240804113716498" style="zoom:80%;" /><p>之后一路点击“下一步”即可。</p><h5 id="使用库-1"><a href="#使用库-1" class="headerlink" title="使用库"></a>使用库</h5><p>此时就可以使用库了，在引入头文件的时候，可以写相对路径，也可以不写</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803172511304.png" alt="image-20240803172511304" style="zoom:80%;" /><p>构建一下，通过，可以正常使用</p><h4 id="方法三：其他方式（不太推荐）"><a href="#方法三：其他方式（不太推荐）" class="headerlink" title="方法三：其他方式（不太推荐）"></a>方法三：其他方式（不太推荐）</h4><p>比如不在添加库时指定头文件目录，而是添加库后，在项目中添加现有文件夹（Add Existing Directory），在调用使用头文件时，使用绝对路径的方式</p><p>在Qt Creator中，右击项目中的<code>Headers</code>文件夹，选择“Add Existing Directory”（也可以选择“添加现有文件”但是是单文件添加，效率低）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803173247613.png" alt="image-20240803173247613" style="zoom:80%;" /><p>点击“浏览”，找到库（如果是Qt库，则找到该项目文件夹），选择（而不是进入），点击“选择文件夹</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803173420793.png" alt="image-20240803173420793" style="zoom:80%;" /><p>然后点击”Start Parsing“，更新目录范围，点击三角图标，展开目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803173614776.png" alt="image-20240803173614776" style="zoom:80%;" /><p>然后在下面栏中使用通配符*进行筛选，点击Apply Filters，即可选中所有.h文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803175409005.png" alt="image-20240803175409005" style="zoom:80%;" /><p>按下OK，即可添加完毕<br>项目的.pro文件中也更新了配置</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803175507117.png" alt="image-20240803175507117" style="zoom:80%;" /><p>在使用时，不能直接引用头文件原名，否则查找不到：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803175641151.png" alt="image-20240803175641151" style="zoom:80%;" /><p>需要写上绝对路径或者相对路径，相对路径写法可以参考.pro文件中的：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803175859426.png" alt="image-20240803175859426" style="zoom:80%;" /><p>构建一下，通过，可以正常使用</p><h2 id="4-写在后面："><a href="#4-写在后面：" class="headerlink" title="4.写在后面："></a>4.写在后面：</h2><p>还是老生常谈的问题：</p><p><mark>如果一个项目中使用了第三方库，构建项目时使用的套件，必须与使用的第三方库构建使用的套件一致，否则会报错”link1104“错误</mark></p><blockquote><p>即如果第三方库用的<code>MinGW</code>编译，生成的库文件包含的是<code>.a</code>，项目中添加的库文件是<code>.a</code>，那么项目构建的时候，也是用<code>MinGW</code>编译才可以通过</p><p>如果第三方库用的<code>MSVC</code>编译，生成的库文件包含的是<code>.lib</code>，项目中添加的库文件是<code>.lib</code>，那么项目构建的时候，也是用<code>MSVC</code>编译才可以通过</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_范围for</title>
      <link href="/chunyujin/d5cdc759.html"/>
      <url>/chunyujin/d5cdc759.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-范围for"><a href="#C-范围for" class="headerlink" title="C++_范围for"></a>C++_范围for</h1><p>通常遍历STL的方式有三种：</p><ol><li>通过下标+循环 （只适用于顺序存储结构）</li><li>迭代器iterator（STL容器都自带）</li><li>范围for</li></ol><p>下面讲解一下范围for：<br>范围for的实现逻辑实际上就是调用了迭代器iterator，通过查看汇编就可以看出来</p><p>范围for是遍历STL中的每一个元素</p><blockquote><p>这里不要和迭代器搞混，迭代器是访问的元素的地址，然后再解引用迭代器，访问到的元素</p><p>范围for使用时变量直接就是获取到的元素（也就是包含了用迭代器获取地址+迭代器解引用）</p></blockquote><p>下面是一个使用案例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//范围for</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">char</span> ch : s)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器iterator</span></span><br><span class="line">string::iterator it = s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it!= s.<span class="built_in">end</span>())<span class="comment">//注意要使用不等号而不是小于号，因为某些数据结构地址空间不一定是连续的</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it;</span><br><span class="line">    it++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当然，使用auto更为简便</span></span><br><span class="line"><span class="comment">//范围for</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> ch : s)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="keyword">auto</span> it = s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it != s.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it;</span><br><span class="line">    it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL_数据库备份与还原</title>
      <link href="/chunyujin/642648e5.html"/>
      <url>/chunyujin/642648e5.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h1><h2 id="备份命令在shell命令行进行"><a href="#备份命令在shell命令行进行" class="headerlink" title="备份命令在shell命令行进行"></a>备份命令在shell命令行进行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mysqldump [-P端口号] -u用户名 -p密码 [-B] 数据库名 &gt; 备份后的名称.bak.sql</span></span><br></pre></td></tr></table></figure><blockquote><p>[ ]内的是可以省略的</p><p>-u和用户名、-p和密码之间可以加空格，可以不加</p><p>-B和数据库名之间必须有空格（如果-B没有省略的话）</p><p>端口号可能是3306，取决于数据库有没有指定端口</p><p>备份后的文件要具体到路径，否则认为当前工作路径（同其他shell命令一样）</p></blockquote><p>eg1：<code>mysqldump -uroot -p0295 test2 &gt; ../test2.bak.sql</code>备份到了父目录</p><p>eg2：<code>mysqldump -P3306 -uroot -p0295 test2 &gt; test2.bak.sql</code>备份到了当前目录</p><p><strong>可以多个数据库同时备份</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mysqldump [-P端口号] -u用户名 -p密码 [-B] 数据库1 数据库2 &gt; 备份后的名称.bak.sql</span></span><br></pre></td></tr></table></figure><p>eg：<code>mysqldump -uroot -p0295 -B test2 test_mysql &gt; test.back.sql</code>两个数据库备份到了一个备份文件上</p><p><strong>也可以只进行数据库中表的备份</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mysqldump [-P端口号] -u用户名 -p密码 数据库名 表1 表2 &gt; 备份后的名称.bak.sql</span></span><br></pre></td></tr></table></figure><blockquote><p>备份表的时候不能加-B，因为-B是专用于数据库的，否则会把表名当成数据库名</p></blockquote><p>eg：<code>mysqldump -uroot -p0295 test2 test2_table1 &gt; test_table1.back.sql</code></p><blockquote><p>》 本文为<a href="https://blog.musnow.top/posts/2109090510/%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%8E%E8%A1%A5%E5%85%85%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%81%E7%BD%AE%E9%A1%B6%E9%93%BE%E6%8E%A5">https://blog.musnow.top/posts/2109090510/的总结与补充其他知识点详见置顶链接</a></p></blockquote><h2 id="还原命令在mysql中执行"><a href="#还原命令在mysql中执行" class="headerlink" title="还原命令在mysql中执行"></a>还原命令在mysql中执行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; source 备份文件路径</span><br></pre></td></tr></table></figure><p>eg：<code>source /yj/test2.bak.sql</code></p><p>数据库中的内容和原来数据库中的内容是相同的</p><p>mysql备份的时候，会将里面的语句智能化简</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL_库和表的使用（部分未完</title>
      <link href="/chunyujin/8db1a874.html"/>
      <url>/chunyujin/8db1a874.html</url>
      
        <content type="html"><![CDATA[<h1 id="库和表的使用操作小记"><a href="#库和表的使用操作小记" class="headerlink" title="库和表的使用操作小记"></a>库和表的使用操作小记</h1><blockquote><p>记录的是基础用法，有很多细节省略了，详细请看课件或者完整笔记</p></blockquote><p>MySQL的SQL语句分为以下三类</p><blockquote><ol><li><p>DDL 【数据定义语句】</p><p>用来维护存储数据的整体结构，比如库和表的创建、修改、删除、备份与还原、查看</p><p>代表命令<code>create</code>,<code>alter</code>,<code>drop</code>,<code>source</code>,<code>show</code></p></li><li><p>DML【数据操纵语句】</p><p>用来操作表中的具体数据，比如插入数据、查询数据、删除数据</p><p>代表命令<code>insert</code>,<code>select</code>,<code>delete</code>,<code>update</code></p></li><li><p>DLC【数据控制语句】</p><p>负责权限管理和事务</p><p>代表命令<code>grant</code>,<code>revoke</code>,<code>commit</code></p></li></ol></blockquote><h2 id="登录mysql"><a href="#登录mysql" class="headerlink" title="登录mysql"></a>登录mysql</h2><p>有两种方式：</p><p>指明端口</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415225508111.png" alt="image-20230415225508111" style="zoom:80%;" /><p>不指明端口，使用默认的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415225657207.png" alt="image-20230415225657207" style="zoom:80%;" /><blockquote><p>-p的作用是不显式地输入密码，我并没有设置root账户的密码，直接按回车即可</p><p>-u和root之间可以有空格可以没有</p></blockquote><h1 id="DDL【数据定义语句】"><a href="#DDL【数据定义语句】" class="headerlink" title="DDL【数据定义语句】"></a>DDL【数据定义语句】</h1><h2 id="查看mysql所有库"><a href="#查看mysql所有库" class="headerlink" title="查看mysql所有库"></a>查看mysql所有库</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415225821594.png" alt="image-20230415225821594" style="zoom:80%;" /><blockquote><p> 注意mysql语句要用分号结尾</p></blockquote><h2 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415230014631.png" alt="image-20230415230014631" style="zoom:80%;" /><p>或者“如果这个库不存在的话，就创建”（创建表的时候也一样）：</p><blockquote><p>注意，关于库、表的名称，最好使用反引号&#96;&#96; &#96;括起来，这个符号是电脑esc键下面的键，半角状态打出</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415230515065.png" alt="image-20230415230515065"></p><p>也可以不括起来，但是如果名称和mysql内部一些名称冲突的话，会报错</p></blockquote><h2 id="查看创建库的记录-查看库结构"><a href="#查看创建库的记录-查看库结构" class="headerlink" title="查看创建库的记录(查看库结构)"></a>查看创建库的记录(查看库结构)</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407140912098.png" alt="截屏2024-07-14 09.11.54" style="zoom:50%;" /><blockquote><ol><li>只能查看已创建的库</li><li>本质上是查看创建库的所有语句，这些语句保存在了一个文件中，这个文件可以用于库的备份（见另一篇文章）</li></ol></blockquote><h2 id="删除库"><a href="#删除库" class="headerlink" title="删除库"></a>删除库</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415230810279.png" alt="image-20230415230810279" style="zoom:80%;" /><h2 id="进入-x2F-使用库"><a href="#进入-x2F-使用库" class="headerlink" title="进入&#x2F;使用库"></a>进入&#x2F;使用库</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415231043861.png" alt="image-20230415231043861" style="zoom:80%;" /><h2 id="查看当前所在库"><a href="#查看当前所在库" class="headerlink" title="查看当前所在库"></a>查看当前所在库</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415231150871.png" alt="image-20230415231150871" style="zoom:80%;" /><h2 id="退出库"><a href="#退出库" class="headerlink" title="退出库"></a>退出库</h2><p>严格来说也不是退出，而是返回到最初的库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141519106.png" alt="截屏2024-07-14 15.19.42" style="zoom: 50%;" /><p>当然，是没有必要退出的，因为在其他数据库的时候，还是可以使用<code>show databases;</code>命令查看所有数据库，并使用<code>use 数据库名;</code>直接进入其他数据库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141520652.png" alt="截屏2024-07-14 15.20.56" style="zoom:50%;" /><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table 表名 (</span><br><span class="line">    field1 datatype,</span><br><span class="line">    field2 datatype,</span><br><span class="line">    field3 datatype</span><br><span class="line">) character set 字符集 collate 校验规则 engine 存储引擎;</span><br></pre></td></tr></table></figure><blockquote><p>最下面一行后面的内容可以省略</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415232123861.png" alt="image-20230415232123861" style="zoom:80%;" /><blockquote><ol><li><p>可以换行可以不换</p><blockquote><p>换行更美观，但是换行之后之前输入的内容无法修改，所以写代码要准确</p></blockquote></li><li><p>Sno、Sname、Sage之类的就是列属性，就是列名</p></li><li><p>Sno它们后面跟的是这一列数据的数据类型</p></li><li><p>comment是给这个列加备注，可以加可以不加</p></li><li><p>if not exists 可加可不加，意思是如果Student这个表之前不存在的话，就创建，存在的话就不创建，在前面的库的创建和删除中，以及在后面的表的删除中，也是可加可不加</p></li></ol></blockquote><h2 id="查看表的属性"><a href="#查看表的属性" class="headerlink" title="查看表的属性"></a>查看表的属性</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415232523386.png" alt="image-20230415232523386" style="zoom:80%;" /><h2 id="查看库中的所有表"><a href="#查看库中的所有表" class="headerlink" title="查看库中的所有表"></a>查看库中的所有表</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415232555462.png" alt="image-20230415232555462" style="zoom: 80%;" /><h2 id="查看创建表的记录-查看表结构"><a href="#查看创建表的记录-查看表结构" class="headerlink" title="查看创建表的记录(查看表结构)"></a>查看创建表的记录(查看表结构)</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416084512253.png" alt="image-20230416084512253" style="zoom:80%;" /><blockquote><ol><li>只能查看已存在的表</li><li>本质上是打印出来创建表的时候执行的所有语句</li></ol></blockquote><p>省略长横线：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416085136345.png" alt="image-20230416085136345" style="zoom:80%;" /><h2 id="新增列（新增字段）"><a href="#新增列（新增字段）" class="headerlink" title="新增列（新增字段）"></a>新增列（新增字段）</h2><p>在SC表中的Cno列后面新增一列Grade</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416091642802.png" alt="image-20230416091642802" style="zoom:80%;" /><blockquote><ol><li>如果不加after，默认加在最后一列</li><li>新增一列之后，此列的数据默认为NULL</li></ol></blockquote><p>查看一下表结构，发现列信息被加入进去了：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416092018226.png" alt="image-20230416092018226" style="zoom:80%;" /><h2 id="新增列-字段-时设置默认数据填充"><a href="#新增列-字段-时设置默认数据填充" class="headerlink" title="新增列(字段)时设置默认数据填充"></a>新增列(字段)时设置默认数据填充</h2><p>由于一般新增列的时候，默认该列的数据都为空NULL，但是有些场景需要指定默认数据</p><p>创建新列时设置默认填充数据：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141551171.png" alt="截屏2024-07-14 15.51.15" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141551670.png" alt="截屏2024-07-14 15.51.23" style="zoom:50%;" /><h2 id="设置主键"><a href="#设置主键" class="headerlink" title="设置主键"></a>设置主键</h2><p>主键用于标定一张表中一条数据的唯一性的的列。主键不为空、数据值不能重复，因此可以标定一条数据的唯一性。</p><p>一张表中只能有一个主键，但是主键可以是由一列构成，也可以由多列复合而成（复合主键），只要复合主键中并不是每一列的数据都是相同的，那么这个数据就是唯一的。</p><p>一般选择int类型字段作为主键（比如ID之类）</p><h3 id="新建表时创建主键"><a href="#新建表时创建主键" class="headerlink" title="新建表时创建主键"></a>新建表时创建主键</h3><p>方法一：在设置字段的时候设置上主键</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141608651.png" alt="截屏2024-07-14 16.05.39" style="zoom:50%;" /><p>方法二：在最后设置主键</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141608331.png" alt="截屏2024-07-14 16.07.42" style="zoom:50%;" /><blockquote><ol><li>两种方式都会用到</li><li>主键本身就不能为空，因此可以省略<code>not null</code></li></ol></blockquote><h3 id="取消主键"><a href="#取消主键" class="headerlink" title="取消主键"></a>取消主键</h3><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141616380.png" alt="截屏2024-07-14 16.15.01" style="zoom:50%;" /><h3 id="设置现有列-字段-为主键"><a href="#设置现有列-字段-为主键" class="headerlink" title="设置现有列(字段)为主键"></a>设置现有列(字段)为主键</h3><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141616311.png" alt="截屏2024-07-14 16.15.20" style="zoom:50%;" /><h3 id="在添加新字段时设置为主键"><a href="#在添加新字段时设置为主键" class="headerlink" title="在添加新字段时设置为主键"></a>在添加新字段时设置为主键</h3><blockquote><p>前提是表中没有主键</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141618994.png" alt="截屏2024-07-14 16.18.24" style="zoom:50%;" /><h3 id="设置复合主键"><a href="#设置复合主键" class="headerlink" title="设置复合主键"></a>设置复合主键</h3><h4 id="创建新表时设置"><a href="#创建新表时设置" class="headerlink" title="创建新表时设置"></a>创建新表时设置</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141622536.png" alt="截屏2024-07-14 16.20.57" style="zoom:50%;" /><blockquote><p>不能用第一种方式创建</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141623459.png" alt="截屏2024-07-14 16.22.59" style="zoom:50%;" /><p>会报错“定义了重复主键”</p></blockquote><h4 id="设置现有字段为复合主键"><a href="#设置现有字段为复合主键" class="headerlink" title="设置现有字段为复合主键"></a>设置现有字段为复合主键</h4><blockquote><p>此前表中没有主键</p></blockquote><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141625503.png" alt="截屏2024-07-14 16.24.41"></p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>关于主键、默认值(default)、唯一键、外键等SQL字段约束相关知识，在<a href="https://blog.musnow.top/posts/4138950838/">慕雪的寒舍-SQL字段约束</a></p><h2 id="修改列的数据类型"><a href="#修改列的数据类型" class="headerlink" title="修改列的数据类型"></a>修改列的数据类型</h2><p>将SC表中的Sno的数据类型由int(11)改为int(20)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416092343137.png" alt="image-20230416092343137" style="zoom:80%;" /><p>查看一下表结构：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416092422560.png" alt="image-20230416092422560" style="zoom:80%;" /><blockquote><p>说明修改表的某一列是用新的列覆盖掉旧的列</p><ol><li><p>将同类型缩小，要确保原数据不会溢出</p></li><li><p>不同类型之间转换的时候，要确保这两种数据之间是能双向转化的</p></li></ol></blockquote><h2 id="修改列名"><a href="#修改列名" class="headerlink" title="修改列名"></a>修改列名</h2><p>将表SC的Grade列改名为NianJi</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416093816455.png" alt="image-20230416093816455" style="zoom:80%;" /><blockquote><p>注意，在改列名的时候，必须还要重新指定该列的数据类型，可以保留原来的，也可以修改，但必须都要写出。</p><p>这里我顺便修改成新的数据类型，还可以加注释。</p><p>所以说修改列名是包含了修改修改数据类型的</p><p>修改列名使用change而不是rename</p><ol><li>rename留给了修改表名使用</li><li>修改列名的时候不只是修改了列名，还有加上该列的数据类型（无论是否更改），因此用change更合理</li></ol></blockquote><p>查看一下表结构：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416094024996.png" alt="image-20230416094024996" style="zoom:80%;" /><h2 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416093110524.png" alt="image-20230416093110524" style="zoom:80%;" /><blockquote><p>凡是涉及到删除的操作，都要慎重</p><p>如果表中只剩下一列，不能删除列了，只能删除整张表</p></blockquote><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141509358.png" alt="截屏2024-07-14 15.09.43" style="zoom:50%;" /><h2 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416094152571.png" alt="image-20230416094152571" style="zoom:80%;" /><h2 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h2><p><a href="https://blog.musnow.top/posts/2109090510/">https://blog.musnow.top/posts/2109090510/</a></p><h3 id="备份命令在shell命令行进行"><a href="#备份命令在shell命令行进行" class="headerlink" title="备份命令在shell命令行进行"></a>备份命令在shell命令行进行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mysqldump [-P端口号] -u用户名 -p密码 [-B] 数据库名 &gt; 备份后的名称.bak.sql</span></span><br></pre></td></tr></table></figure><blockquote><p>[ ]内的是可以省略的</p><p>-u和用户名、-p和密码之间可以加空格，可以不加</p><p>-B和数据库名之间必须有空格（如果-B没有省略的话）</p><p>端口号可能是3306，取决于数据库有没有指定端口</p><p>备份后的文件要具体到路径，否则认为当前工作路径（同其他shell命令一样）</p></blockquote><p>eg1：<code>mysqldump -uroot -p0295 test2 &gt; ../test2.bak.sql</code>备份到了父目录</p><p>eg2：<code>mysqldump -P3306 -uroot -p0295 test2 &gt; test2.bak.sql</code>备份到了当前目录</p><p><strong>可以多个数据库同时备份</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mysqldump [-P端口号] -u用户名 -p密码 [-B] 数据库1 数据库2 &gt; 备份后的名称.bak.sql</span></span><br></pre></td></tr></table></figure><p>eg：<code>mysqldump -uroot -p0295 -B test2 test_mysql &gt; test.back.sql</code>两个数据库备份到了一个备份文件上</p><p><strong>也可以只进行数据库中表的备份</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mysqldump [-P端口号] -u用户名 -p密码 数据库名 表1 表2 &gt; 备份后的名称.bak.sql</span></span><br></pre></td></tr></table></figure><blockquote><p>备份表的时候不能加-B，因为-B是专用于数据库的，否则会把表名当成数据库名</p></blockquote><p>eg：<code>mysqldump -uroot -p0295 test2 test2_table1 &gt; test_table1.back.sql</code></p><blockquote><p>其他知识点详见置顶链接</p></blockquote><h3 id="还原命令在mysql中执行"><a href="#还原命令在mysql中执行" class="headerlink" title="还原命令在mysql中执行"></a>还原命令在mysql中执行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; source 备份文件路径</span><br></pre></td></tr></table></figure><p>eg：<code>source /yj/test2.bak.sql</code></p><p>数据库中的内容和原来数据库中的内容是相同的</p><p>mysql备份的时候，会将里面的语句智能化简</p><h2 id="MySQL通过system执行shell命令"><a href="#MySQL通过system执行shell命令" class="headerlink" title="MySQL通过system执行shell命令"></a>MySQL通过system执行shell命令</h2><p>eg：<code>mysql&gt; system clear</code>执行清理屏幕功能</p><h2 id="DDL命令操作表时要加table固定写法"><a href="#DDL命令操作表时要加table固定写法" class="headerlink" title="DDL命令操作表时要加table固定写法"></a>DDL命令操作表时要加<code>table</code>固定写法</h2><p>比如<code>alter</code>, <code>drop</code>等等，后面都需要加<code>table</code>, 然后才能跟表名</p><p>而下面的DML在指定表名的时候不需要写<code>table</code>, 直接用表名就可以</p><p>这是因为DDL是操作表的</p><p>而DML是操作数据的</p><h1 id="DML【数据修改语句】"><a href="#DML【数据修改语句】" class="headerlink" title="DML【数据修改语句】"></a>DML【数据修改语句】</h1><h2 id="向表中插入数据（insert）"><a href="#向表中插入数据（insert）" class="headerlink" title="向表中插入数据（insert）"></a>向表中插入数据（insert）</h2><h3 id="单行插入"><a href="#单行插入" class="headerlink" title="单行插入"></a>单行插入</h3><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416085917365.png" alt="image-20230416085917365" style="zoom:80%;" /><blockquote><p>Sno、Sname等字段可以不写，如果不写的话就默认为数据为空(前提是该字段允许为空，或已设置defalut值)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416090914765.png" alt="image-20230416090914765" style="zoom:80%;" /><p>如果字段名全部省略，就默认为所有的数据都要填上，所有数据都要填充，且要按照表中字段顺序填入</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416090326238.png" alt="image-20230416090326238" style="zoom:80%;" /></blockquote><h3 id="多行指定列插入"><a href="#多行指定列插入" class="headerlink" title="多行指定列插入"></a>多行指定列插入</h3><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407161507059.png" alt="截屏2024-07-16 15.06.41" style="zoom:50%;" /><blockquote><p>同单行插入一样，字段名可以省略（但是数据插入要按字段顺序）；</p><p>部分字段名可以不写，默认为空（前提是该字段允许为空，或者有default值）</p></blockquote><h3 id="插入否则更新（on-duplicate-update）"><a href="#插入否则更新（on-duplicate-update）" class="headerlink" title="插入否则更新（on duplicate update）"></a>插入否则更新（on duplicate update）</h3><p>如果要插入的数据，其主键或唯一键，与表中现存数据重合，则插入数据失败。此时我们可以选择更新现有数据。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407161510864.png" alt="截屏2024-07-16 15.02.38" style="zoom:50%;" /><blockquote><p>在test表中插入数据Sno、Sage（Sno必填，因为是主键），如果填入的内容与主键发生重复冲突，则更新<code>update</code>语句后面指定字段中的内容</p><blockquote><p>示例中是，如果发生主键&#x2F;唯一键冲突，则将该主键&#x2F;唯一键对应的数据中Sno字段数据改为21</p></blockquote></blockquote><h3 id="插入否则替换（replace）"><a href="#插入否则替换（replace）" class="headerlink" title="插入否则替换（replace）"></a>插入否则替换（replace）</h3><p>与更新update不同，更新是只更新数据中原有的部分字段，替换replace则是先删除原数据（所有字段），然后根据要填入的value再插入。</p><p>要插入的数据的主键&#x2F;唯一键与现有数据冲突时，replace将现有数据所有字段删除，将要插入的数据重新插入。即replace在遇到冲突时，是先删除，后插入。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407161544052.png" alt="截屏2024-07-16 15.42.16" style="zoom:50%;" /><blockquote><ol><li>replace在无冲突时，相当于普通的insert</li><li>replace在冲突时，将原有数据删除后，原有数据不保留，只会插入replace语句中表明要插入的values</li><li>与insert一样，允许省略全部字段名，或者省略部分允许为空或已设定好default值的字段名</li></ol><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407161544449.png" alt="截屏2024-07-16 15.44.09" style="zoom:50%;" /><blockquote><p>从这里可以看出，数据是先删除后插入</p></blockquote></blockquote><h2 id="查看表中的数据"><a href="#查看表中的数据" class="headerlink" title="查看表中的数据"></a>查看表中的数据</h2><p>基本写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    [DISTINCT] &#123;* | &#123;column [, column] ...&#125;</span><br><span class="line">    [FROM table_name]</span><br><span class="line">    [WHERE ...]</span><br><span class="line">    [ORDER BY column [ASC | DESC], ...]</span><br><span class="line">    LIMIT ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="全列查询"><a href="#全列查询" class="headerlink" title="全列查询"></a>全列查询</h3><p><code>*</code>为通配符</p><p>查看Student所有数据：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416090348697.png" alt="image-20230416090348697" style="zoom:80%;" /><p>查看Course所有数据：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416094630308.png" alt="image-20230416094630308" style="zoom:80%;" /><blockquote><ol><li>NULL表示没有数据，和’’不同，’’是有数据，数据是空字符串。</li><li>一般情况下不建议使用全列查询<ol><li>查询到的数据越多，数据传输量越大</li><li>可能会影响索引的使用</li></ol></li></ol></blockquote><h3 id="按列查询"><a href="#按列查询" class="headerlink" title="按列查询"></a>按列查询</h3><p>查询指定字段的数据，并汇聚成一张表呈现出来</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407161602312.png" alt="截屏2024-07-16 16.00.58" style="zoom:50%;" /><h3 id="表达式查询"><a href="#表达式查询" class="headerlink" title="表达式查询"></a>表达式查询</h3><p>所以可以看出来，select到from之间的这部分，实际上就是规定了查询结果的字段。而MySQL支持将查询结果通过表达式进行展示</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407161636807.png" alt="截屏2024-07-16 16.36.19" style="zoom:50%;" /><h4 id="为表达式查询结果设置别名"><a href="#为表达式查询结果设置别名" class="headerlink" title="为表达式查询结果设置别名"></a>为表达式查询结果设置别名</h4><p>这样可以增强查询结果的可读性</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407161638672.png" alt="截屏2024-07-16 16.38.00" style="zoom:50%;" /><h3 id="查询结果去重（select-distinct）"><a href="#查询结果去重（select-distinct）" class="headerlink" title="查询结果去重（select distinct）"></a>查询结果去重（select distinct）</h3><p>有些使用场景下可能需要用到去重，比如上面，只是想知道总体上都是有哪几种总分，因此可以对结果进行去重。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407161641448.png" alt="截屏2024-07-16 16.41.27" style="zoom:50%;" /><blockquote><p>注意去重只是去掉所有字段都重复的数据，所以结果中，就算有一个字段存在重复的数据，但是其他字段不重复，该数据也不会被去掉</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407161643905.png" alt="截屏2024-07-16 16.43.05" style="zoom:50%;" /></blockquote><h3 id="条件查询（where）【重要】"><a href="#条件查询（where）【重要】" class="headerlink" title="条件查询（where）【重要】"></a>条件查询（where）【重要】</h3><p>基本用法就是在表名后加<code>where</code>，后面是查询条件</p><p>where语句支持比较运算符和逻辑运算符</p><table><thead><tr><th>比较运算符</th><th>说明</th></tr></thead><tbody><tr><td><code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code></td><td></td></tr><tr><td><code>=</code></td><td>等于，<code>NULL</code> 不安全，<code>NULL=NULL</code> 的结果是 <code>NULL</code></td></tr><tr><td><code>&lt;=&gt;</code></td><td>等于，<code>NULL</code> 安全，<code>NULL&lt;=&gt;NULL</code> 的结果是 <code>TRUE(1)</code></td></tr><tr><td><code>!=</code>, <code>&lt;&gt;</code></td><td>不等于</td></tr><tr><td><code> BETWEEN a AND b</code></td><td>范围匹配，闭区间，如果 <code>a &lt;= value &lt;= b</code> 返回 <code>TRUE(1)</code></td></tr><tr><td><code>IN (option, ..., ...)</code></td><td>如果是 <code>option</code> 中的任意一个，则返回 <code>TRUE(1)</code></td></tr><tr><td><code>IS NULL</code></td><td>是 <code>NULL</code></td></tr><tr><td><code>IS NOT NULL</code></td><td>不是 <code>NULL</code></td></tr><tr><td><code>LIKE</code></td><td>模糊匹配，<code>%</code> 表示任意多个（包括 0 个）字符；<code>_</code>表示任意一个字符；</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>说明</th></tr></thead><tbody><tr><td>AND</td><td>与，相当于 cpp 中的 <code>&amp;&amp;</code>，全真为 1，有假为 0</td></tr><tr><td>OR</td><td>或，相当于 cpp 中的 &#96;</td></tr><tr><td>NOT</td><td>逻辑取反，条件为 <code>TRUE(1)</code> 的时候结果为 <code>FALSE(0)</code></td></tr></tbody></table><h4 id="使用比较和逻辑运算符："><a href="#使用比较和逻辑运算符：" class="headerlink" title="使用比较和逻辑运算符："></a>使用比较和逻辑运算符：</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407170930132.png" alt="截屏2024-07-17 09.29.54" style="zoom:50%;" /><h4 id="使用BETWEEN…AND…进行区间筛选："><a href="#使用BETWEEN…AND…进行区间筛选：" class="headerlink" title="使用BETWEEN…AND…进行区间筛选："></a>使用BETWEEN…AND…进行区间筛选：</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407170934772.png" alt="截屏2024-07-17 09.34.30" style="zoom:50%;" /><h4 id="配合逻辑运算符，使用相等筛选："><a href="#配合逻辑运算符，使用相等筛选：" class="headerlink" title="配合逻辑运算符，使用相等筛选："></a>配合逻辑运算符，使用相等筛选：</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407170944005.png" alt="截屏2024-07-17 09.44.01" style="zoom:50%;" /><h4 id="使用IN也可以实现相同效果："><a href="#使用IN也可以实现相同效果：" class="headerlink" title="使用IN也可以实现相同效果："></a>使用IN也可以实现相同效果：</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407170949565.png" alt="截屏2024-07-17 09.49.34" style="zoom:50%;" /><h4 id="使用LIKE进行字符匹配："><a href="#使用LIKE进行字符匹配：" class="headerlink" title="使用LIKE进行字符匹配："></a>使用LIKE进行字符匹配：</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407170952036.png" alt="截屏2024-07-17 09.51.53" style="zoom:50%;" /><h4 id="计算后筛选-amp-设置别名："><a href="#计算后筛选-amp-设置别名：" class="headerlink" title="计算后筛选&amp;设置别名："></a>计算后筛选&amp;设置别名：</h4><p>需要注意的是，where只是进行条件筛选，起别名的工作并不是通过where语句完成的，而是select本身</p><p>并且起别名本质是在表示结果的时候更换一下结果表的字段名，并不影响查询过程，所以where是不认识别名的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407171012192.png" alt="截屏2024-07-17 10.12.10" style="zoom:50%;" /><h4 id="使用IS-NULL-或者-IS-NOT-NULL查询："><a href="#使用IS-NULL-或者-IS-NOT-NULL查询：" class="headerlink" title="使用IS NULL 或者 IS NOT NULL查询："></a>使用IS NULL 或者 IS NOT NULL查询：</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407171025330.png" alt="截屏2024-07-17 10.25.04" style="zoom:50%;" /><h4 id="where查询条件不一定必须存在于select要查询的字段中："><a href="#where查询条件不一定必须存在于select要查询的字段中：" class="headerlink" title="where查询条件不一定必须存在于select要查询的字段中："></a>where查询条件不一定必须存在于select要查询的字段中：</h4><p>使用<code>where</code>时设置条件的字段，可以与select查询要获取的结果集字段无关，而是可以根据原有表中任意字段进行筛选</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407171026255.png" alt="截屏2024-07-17 10.26.41" style="zoom:50%;" /><h3 id="结果排序（order-by）"><a href="#结果排序（order-by）" class="headerlink" title="结果排序（order by）"></a>结果排序（order by）</h3><h4 id="按单字段升序【默认】-x2F-降序【后加DESC】-显示"><a href="#按单字段升序【默认】-x2F-降序【后加DESC】-显示" class="headerlink" title="按单字段升序【默认】&#x2F; 降序【后加DESC】 显示"></a>按单字段升序【默认】&#x2F; 降序【后加<code>DESC</code>】 显示</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407171030912.png" alt="截屏2024-07-17 10.29.21" style="zoom:50%;" /><p>降序在字段后加<code>EDSC</code></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407171031288.png" alt="截屏2024-07-17 10.30.52" style="zoom:50%;" /><h4 id="按多字段排序"><a href="#按多字段排序" class="headerlink" title="按多字段排序"></a>按多字段排序</h4><p>按照书写先后确定排序优先级</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407171052900.png" alt="截屏2024-07-17 10.51.57" style="zoom:50%;" /><blockquote><p>先按照数学将序排序，相等时，就再参考语文的升序，如果还是相等，参考英语的升序</p></blockquote><h4 id="按求和结果排序"><a href="#按求和结果排序" class="headerlink" title="按求和结果排序"></a>按求和结果排序</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407171056363.png" alt="截屏2024-07-17 10.55.36" style="zoom:50%;" /><blockquote><p>排序的时候可以使用别名，说明排序只是对于查询后的结果表进行排序，而不同于where（在查询时按条件筛选）</p></blockquote><h4 id="where-order-by"><a href="#where-order-by" class="headerlink" title="where + order by"></a><code>where</code> + <code>order by</code></h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407171058835.png" alt="截屏2024-07-17 10.58.41" style="zoom:50%;" /><blockquote><p>查询语文成绩大于70分的学生的id、姓名、数学成绩</p><p>并将查询结果按照语文成绩，降序排列</p><ol><li>where查询条件不一定必须存在于select要查询的字段中，而是可以根据原有表中任意字段进行筛选</li><li>排序也不一定按照select查询结果的字段进行排序，而是可以按照原有表中任意字段排序</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++连接与使用MySQL</title>
      <link href="/chunyujin/aa4b6d26.html"/>
      <url>/chunyujin/aa4b6d26.html</url>
      
        <content type="html"><![CDATA[<p>连接mysql首先要下载好devel开发库才行</p><p><a href="https://blog.csdn.net/look_outs/article/details/132520929">「MySQL-04」Linux环境下使用C&#x2F;C++连接并操纵MySQL_linux c++ mysql-CSDN博客</a></p><p>否则会提示找不到库</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL_关系的码，关系的完整性</title>
      <link href="/chunyujin/f5c3e6a.html"/>
      <url>/chunyujin/f5c3e6a.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h3 id="关系的码"><a href="#关系的码" class="headerlink" title="关系的码"></a>关系的码</h3><h4 id="候选码"><a href="#候选码" class="headerlink" title="候选码"></a>候选码</h4><blockquote><p>候选码是能够唯一标识关系中某一个元组的一个属性或属性集，也叫候选键<br>如：</p><ul><li>学生关系中，学号可以唯一标识学生，班级+姓名也可以唯一标识一个学生，学号和（班级，姓名）都是候选码</li></ul></blockquote><p>候选码需要满足：</p><ol><li>唯一性：唯一标识一个元组(注意不是说候选码只有一个)</li><li>最小性：构成候选码的属性个数最少，比如前面的（班级，姓名），再添加一个学号或其他属性就多此一举了</li></ol><h4 id="主码"><a href="#主码" class="headerlink" title="主码"></a>主码</h4><blockquote><p>主码是从候选键中选着一个作为查询、插入、删除元组操作的操作变量，也叫主键、主码、关系键、关键字<br>简单来说就是从候选码中选出的一个最具代表性的</p></blockquote><ul><li>主属性：包含在<strong>任何一个</strong>候选码的各个属性称为主属性（也就是说，之前的（班级，姓名）中，班级和姓名都是主属性）</li><li>非主属性：不包含在任何候选码中的属性</li></ul><h4 id="外码"><a href="#外码" class="headerlink" title="外码"></a>外码</h4><blockquote><p>关系R1,R2,其中属性集X是R1的非主码属性，但X是R2的主码，则称X是R1的外码（也叫外键、外部关系键），R1为参照关系，R2为被参照关系</p><ul><li>外码的取值是由被参照的关系的主码的域决定的，也就是外码的域来自“那个”主码的域（R1的外码和R2的主码必须在同一个域上）</li></ul></blockquote><p>注意一个地方，外码 只是 不是主码，不代表外码不能是主属性，通过下面的例子来对候选码、主码、外码进行说明：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230326145358454.png" style="zoom:67%;" /><p>如上三个关系表，分别为<br>学生（<mark>学号</mark>，姓名，性别，专业，年龄）<br>课程（<mark>课程号</mark>，课程名，学分）<br>选课（<mark>学号</mark>，<mark>课程号</mark>，成绩）<br>黄色标记的是主码，可以看见的是，选课关系中主码由学号和课程号两个属性组成<br>而单个学号或者课程号是无法做到唯一标识的<br>因此学号或课程号不能单独作为主码<br>而学号和课程号分别是学生和课程的主码，则选课关系中，学号和课程号都是外码，并且学号和课程号是选课关系中的主属性</p><h3 id="关系的完整性"><a href="#关系的完整性" class="headerlink" title="关系的完整性"></a>关系的完整性</h3><blockquote><p>为了维护关系数据库中数据与现实的一致性（完整性），需要对数据操作进行一定的约束。</p></blockquote><p>有如下三类</p><ol><li>实体完整性：主码的值不能为空或部分为空</li><li>参照完整性：外码来自被参照关系的主码，且可以为空，但作为被参考的关系的主码不能为空(外码可以为空时，外码通常是非主属性)</li><li>用户自定义完整性：针对某一具体关系数据的约束条件，比如规定取值范围</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>关系的码对于后面创建数据库很重要，尤其是外码这一块很容易出错<br>在寻找主码时通常选择最具代表性的</p><ul><li>假设姓名没有重复，姓名学号都可以作为主码，这个时候还是选择学号方便，第一这样比较通性，第二，在构建选课关系用学号更便捷</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>友链位置</title>
      <link href="/chunyujin/a0d6528f.html"/>
      <url>/chunyujin/a0d6528f.html</url>
      
        <content type="html"><![CDATA[<p>友链位置</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202405191740206.png" alt="截屏2024-05-19 17.39.46"></p><p>友链界面</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202405191743202.png" alt="截屏2024-05-19 17.43.15"></p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly设置自定义的ICP</title>
      <link href="/chunyujin/289adb50.html"/>
      <url>/chunyujin/289adb50.html</url>
      
        <content type="html"><![CDATA[<p>Butterfly设置自定义的ICP</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202404221604800.png" alt="Butterfly设置自定义的ICP"></p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL&amp;string&amp;模拟实现</title>
      <link href="/chunyujin/9840a6e5.html"/>
      <url>/chunyujin/9840a6e5.html</url>
      
        <content type="html"><![CDATA[<h1 id="STL简介"><a href="#STL简介" class="headerlink" title="STL简介"></a>STL简介</h1><p>STL(standard template library-标准模板库)：是C++标准库的重要组成部分，不仅是一个可以复用的库，而且是一个包罗数据结构与算法的软件框架。</p><h2 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h2><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240315082116261.png" alt="image-20240315082116261"></p><h1 id="string解析"><a href="#string解析" class="headerlink" title="string解析"></a>string解析</h1><p>string严格来说不属于STL，它的创建时间比STL更早</p><h2 id="头文件-amp-命名空间"><a href="#头文件-amp-命名空间" class="headerlink" title="头文件&amp;命名空间"></a>头文件&amp;命名空间</h2><p>头文件<code>#include &lt;string&gt;</code><br>但是有引入头文件<code>&lt;iostream&gt;</code>的时候，不引用头文件<code>&lt;string&gt;</code>也可以</p><p>命名空间<code>std</code></p><h2 id="构造函数string-string"><a href="#构造函数string-string" class="headerlink" title="构造函数string::string"></a>构造函数string::string</h2><p>三种常用的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>();<span class="comment">//default</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp; str);<span class="comment">//使用一个string拷贝构造，是深拷贝</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span>* s);<span class="comment">//使用char数组拷贝构造，是深拷贝</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch[] = <span class="string">&quot;hello&quot;</span></span><br><span class="line">    </span><br><span class="line">string str1;<span class="comment">//默认构造函数</span></span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;<span class="comment">//使用string拷贝构造</span></span><br><span class="line"><span class="function">string <span class="title">str3</span><span class="params">(ch)</span></span>;<span class="comment">//使用char数组拷贝构造</span></span><br><span class="line"><span class="function">string <span class="title">str4</span><span class="params">(str2)</span></span>;<span class="comment">//使用string拷贝构造</span></span><br></pre></td></tr></table></figure><h2 id="成员变量string-nops"><a href="#成员变量string-nops" class="headerlink" title="成员变量string::nops"></a>成员变量string::nops</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> npos = <span class="number">-1</span>; <span class="comment">//C+中的定义</span></span><br></pre></td></tr></table></figure><p>这是一个值为-1的<code>size_t</code>类型的静态常变量。很明显，<code>size_t</code>不可能取负值，因此这个变量常表示用于一些特殊的表示：</p><ol><li>表示<code>string</code>这个类型的最大容量(大约4亿多字节)，是<code>max_size()</code>的返回值。</li><li>常用来作为<code>string一些成员函数</code>的返回值，表示“未找到”“不存在”等。例如<code>find()</code>查找字符&#x2F;字符串查找无果时。</li></ol><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="string-operator-，访问string中的字符"><a href="#string-operator-，访问string中的字符" class="headerlink" title="string::operator[]，访问string中的字符"></a>string::operator[]，访问string中的字符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[] (<span class="type">size_t</span> pos);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[] (<span class="type">size_t</span> pos) <span class="type">const</span>;</span><br><span class="line"><span class="comment">//第一个const表示返回值也是const类型。因为返回值为引用，所以必须设置为const类型，防止通过返回值更改元素</span></span><br><span class="line"><span class="comment">//此处第二个const表示指明该函数所处的对象是一个const对象，避免权限放大</span></span><br><span class="line"><span class="comment">//相当于 const char&amp; opeartor[] (size_t pos, const *this);</span></span><br></pre></td></tr></table></figure><blockquote><p>pos为字符的下标</p></blockquote><p><mark>通过[]获取到的字符就是string的字符的引用，可读可写</mark></p><p>通常标准库对于一些函数都会提供两个版本，一个是非const版本，一个是const版本，供不同情况使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string str_const = <span class="string">&quot;hello China&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str_const.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">  cout&lt;&lt;str_const[i]&lt;&lt;endl;<span class="comment">//str_const是const类型的，只能调用const类型的[]重载</span></span><br><span class="line">&#125;</span><br><span class="line">str = <span class="string">&quot;hello my friend&quot;</span>;<span class="comment">//str为非const，具有写的权限</span></span><br><span class="line">cout&lt;&lt;str&lt;&lt;endlp;</span><br></pre></td></tr></table></figure><p>权限是不允许放大的，如果<code>str_const</code>调用的是非const类型的成员函数，那么就属于权限放大了。</p><blockquote><ol><li>非const类型的成员函数并未指明自己所属的对象是一个const类型的对象，则认定为this对象为非cosnt。因此属于通过非const成员函数将自己的对象权限放大了</li><li>非const类型的成员函数并未指定返回值为const类型，而返回值又使用了引用，因此可以通过返回值更改string对象的元素，对一个只有读权限的const对象来说，这也是权限放大，是不合法的。</li></ol></blockquote><hr><p>传统的数组的越界检查是一个抽查行为，不一定每次程序编译都会检查出来<br>而string越界一定会检查出来，因此[]重载时给出了越界断言检查<code>assert(pos&lt;size)</code></p><hr><h3 id="string-opeartor-x3D-，string对象赋值"><a href="#string-opeartor-x3D-，string对象赋值" class="headerlink" title="string::opeartor&#x3D;，string对象赋值"></a>string::opeartor&#x3D;，string对象赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string s1;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line">string s3 = <span class="string">&quot;defined by operator =&quot;</span>;</span><br><span class="line"><span class="type">const</span> string s4 = <span class="string">&quot;a const string&quot;</span>;<span class="comment">//const类型的对象，必须在声明的时候就初始化(定义)、</span></span><br><span class="line"></span><br><span class="line">s1 = s2;</span><br><span class="line">s3 = <span class="string">&quot;changed&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="string-operator-x3D-，拼接字符-x2F-字符串"><a href="#string-operator-x3D-，拼接字符-x2F-字符串" class="headerlink" title="string::operator+&#x3D;，拼接字符&#x2F;字符串"></a>string::operator+&#x3D;，拼接字符&#x2F;字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot; world&quot;</span>;</span><br><span class="line">s1 += s2;</span><br><span class="line">string s3 = s1 + s2;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;s1&lt;&lt;endl;<span class="comment">//&quot;hello world&quot;</span></span><br><span class="line">cout&lt;&lt;s3&lt;&lt;endl;<span class="comment">//&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><h3 id="opeartor-lt-lt-，流插入运算符重载"><a href="#opeartor-lt-lt-，流插入运算符重载" class="headerlink" title="opeartor&lt;&lt;，流插入运算符重载"></a>opeartor&lt;&lt;，流插入运算符重载</h3><p>这个重载运算符并非string的成员函数</p><p>实现了可以将string对象插入到IO流中</p><h2 id="string-c-str"><a href="#string-c-str" class="headerlink" title="string::c_str"></a>string::c_str</h2><p>获取string的C类型的字符串，本质就是返回该string的<code>char*</code></p><p>意义就是可以很好的跟C语言的一些接口配合</p><p>operator&lt;&lt;的重载就运用了这个函数，获取到string的C字符串，即可实现重载</p><h2 id="迭代器iterator的使用"><a href="#迭代器iterator的使用" class="headerlink" title="迭代器iterator的使用"></a>迭代器iterator的使用</h2><p>迭代器iterator是一个额外的、独立数据结构，存在于STL库中。专门用于访问STL中各个数据结构中的元素。</p><p>(可以朴素地认为迭代器就是指针)</p><blockquote><p>使用迭代器访问元素，和使用方括号[]加下标的效果一样，<mark>都是获取元素的引用</mark>，可读可写</p><p>但是方括号是对象本身的数据结构自带的(通过重构)，而迭代器是不属于被访问的对象的，一个单独的数据结构</p><blockquote><p> 当一个对象为const时，为只可读的，此时还是可以通过方括号下标访问(因为通常会重构一个const类型的方括号)，只要不对访问到的元素进行修改即可<br>但是已经不能使用普通迭代器访问了，因此使用迭代器访问元素，本质上是使用一个数据结构A(iterator)访问另一个数据结构B(被访问的对象)中的元素，而非数据结构B直接调用自己的成员函数访问自己</p><p>因此就算数据结构B设置为const，但是外部的迭代器仍有写的权限，这是不合理的。此处应使用const_iterator</p></blockquote></blockquote><h3 id="迭代器的使用方法"><a href="#迭代器的使用方法" class="headerlink" title="迭代器的使用方法"></a>迭代器的使用方法</h3><ol><li>使用迭代器的时候要指明被访问的数据结构类型</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处以string对象为例</span></span><br><span class="line">string::iterator ite;</span><br></pre></td></tr></table></figure><ol start="2"><li>STL中的数据结构，都具有相关的成员函数，获取到自己元素的迭代器</li></ol><p>以<code>string</code>为例：</p><p><code>string::begin()</code>获取首字符的迭代器</p><p><code>string::end()</code>获取最后一个有效字符的下一个字符(即结束字符，也就是’\0’)的迭代器</p><blockquote><p>STL的各个数据结构都有<code>begin()</code>和<code>end()</code>函数，而且都是<mark>左闭右开</mark></p><p>即begin()获取首元素的迭代器，end()获取最后一个有效元素的下一个元素的迭代器</p><p>这样便于遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;helle world&quot;</span>;<span class="comment">//即h、e、l、l、o、 、w、o、r、l、d、\0</span></span><br><span class="line">string::iterator it_left = s1.<span class="built_in">begin</span>();<span class="comment">//获取的是h的迭代器</span></span><br><span class="line">string::iterator it_right = s1.<span class="built_in">end</span>();<span class="comment">//获取的是\0的迭代器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历方式1</span></span><br><span class="line"><span class="keyword">while</span>(it_left != it_right)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;*it_left&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//访问迭代器对应的元素，就是解引用</span></span><br><span class="line">it_left++;<span class="comment">//迭代器可以加减，就是后移/前移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历方式2</span></span><br><span class="line"><span class="keyword">while</span>(it_left != s1.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;*it_left&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">it_left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历方式3</span></span><br><span class="line"><span class="keyword">for</span>(; it_left != it_right; it_left++;)</span><br><span class="line">&#123;</span><br><span class="line">  cout&lt;&lt;*it_left&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历方式4</span></span><br><span class="line"><span class="keyword">for</span>(; it_left != s1.<span class="built_in">end</span>(); it_left++;)</span><br><span class="line">&#123;........&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="注意！迭代器遍历要使用-x3D-，不能使用-lt-，因为地址空间不一定连续"><a href="#注意！迭代器遍历要使用-x3D-，不能使用-lt-，因为地址空间不一定连续" class="headerlink" title="注意！迭代器遍历要使用!&#x3D;，不能使用&lt;，因为地址空间不一定连续"></a>注意！迭代器遍历要使用!&#x3D;，不能使用&lt;，因为地址空间不一定连续</h3><blockquote><p>顺序存储类型的数据结构，地址空间连续，如string&#x2F;vector出了使用迭代器访问元素，还可以通过方括号[]结合下标来访问。</p><p>但非顺序存储类型的数据结构，地址空间不连续，如list，则只能使用迭代器访问</p></blockquote><p>但是<code>iterator++</code>或i<code>tertor+=n</code>意味着迭代器指向下一个&#x2F;后面第n个元素，是逻辑上的指向下一个</p><h3 id="四大常用迭代器"><a href="#四大常用迭代器" class="headerlink" title="四大常用迭代器"></a>四大常用迭代器</h3><p><strong>普通正向迭代器 iterator</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string::iterator it_left = s1.<span class="built_in">begin</span>();<span class="comment">//获取首元素</span></span><br><span class="line">string::iterator it_right = s1.<span class="built_in">end</span>();<span class="comment">//获取最后一个有效字符的后一个字符，即结束字符\0</span></span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202403161112920.png" alt="截屏2024-03-16 11.08.56" style="zoom: 33%;" /><p><strong>普通反向迭代器 reverse_iterator</strong></p><p>与正向迭代器的起点、终点、移动方向正好相反</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string::reverse_iterator re_it_left = s1.<span class="built_in">rbegin</span>();<span class="comment">//获取最后一个有效元素</span></span><br><span class="line">string::reverse_iterator re_it_right = s1.<span class="built_in">rend</span>();<span class="comment">//获取首元素的前一个位置</span></span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202403161112768.png" alt="截屏2024-03-16 11.09.50" style="zoom:33%;" /><p>const正向迭代器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string::const_iterator con_it_left = s1.<span class="built_in">begin</span>();<span class="comment">//还使用begin()获取，因为string中对此重载了</span></span><br></pre></td></tr></table></figure><p><strong>const反向迭代器</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string::const_reverse_iterator con_re_it_left = s1.<span class="built_in">rbegin</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//还是使用rbegin()获取，因为string对此重载了</span></span><br></pre></td></tr></table></figure><p><mark>不知道对象是不是const的？auto登场</mark></p><h2 id="string-size-x2F-string-length"><a href="#string-size-x2F-string-length" class="headerlink" title="string::size &#x2F; string::length"></a>string::size &#x2F; string::length</h2><p>获取string的有效长度，即有效字符的数量。<mark>不包括结束字符\0</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//C++98中是这样定义的</span></span><br></pre></td></tr></table></figure><p>注意返回值类型是<code>size_t</code>，因此最小值就是0</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> _size = s1.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span>(_size &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">_size--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//会造成无限循环。因为size_t类型，最小值就是0，即使已经等于0了，--之后还是0。所以会无尽循环</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="string-capacity"><a href="#string-capacity" class="headerlink" title="string::capacity"></a>string::capacity</h2><p>获取string的容量，即已开辟的string的总空间</p><p>一般情况下，容量capacity肯定是比大小&#x2F;长度size大的，因为要预留一部分空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//C++98中是这样定义的</span></span><br></pre></td></tr></table></figure><h2 id="string-empty"><a href="#string-empty" class="headerlink" title="string::empty"></a>string::empty</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//C++定义，判断string是非为空串</span></span><br></pre></td></tr></table></figure><h2 id="string的三种遍历方式"><a href="#string的三种遍历方式" class="headerlink" title="string的三种遍历方式"></a>string的三种遍历方式</h2><p>[下标]<br>迭代器<br>范围for</p><h3 id="下标"><a href="#下标" class="headerlink" title="[下标]"></a>[下标]</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">  cout&lt;&lt; s[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> it_left = s.<span class="built_in">begin</span>();<span class="comment">//此处使用了智能指针</span></span><br><span class="line"><span class="keyword">while</span>(it_left != s.<span class="built_in">end</span>())<span class="comment">//注意要使用不等号而不是小于号，因为某些数据结构地址空间不一定是连续的</span></span><br><span class="line">&#123;</span><br><span class="line">  cout&lt;&lt; *it_left &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  it_left += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">for</span>(string::iterator it_left = s.<span class="built_in">begin</span>(); it_left != s.<span class="built_in">end</span>(); it_left++)</span><br><span class="line">&#123;</span><br><span class="line">  cout&lt;&lt; *it_left &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="范围for，C-11新引入，原理：替换成迭代器"><a href="#范围for，C-11新引入，原理：替换成迭代器" class="headerlink" title="范围for，C++11新引入，原理：替换成迭代器"></a>范围for，C++11新引入，原理：替换成迭代器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> ch : s)</span><br><span class="line">&#123;</span><br><span class="line">  cout&lt;&lt; ch &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>范围for的实现逻辑实际上就是调用了迭代器iterator，通过查看汇编就可以看出来</p><p>范围for是遍历STL中的每一个元素</p><blockquote><p>这里不要和迭代器搞混，迭代器是访问的元素的地址，然后再解引用迭代器，访问到的元素</p><p>范围for使用时变量直接就是获取到的元素（也就是包含了用迭代器获取地址+迭代器解引用）</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202403161616750.png" alt="范围for本质上就是替代了迭代器(从汇编就可以看出来)" style="zoom: 30%;" /><h2 id="string扩容"><a href="#string扩容" class="headerlink" title="string扩容"></a>string扩容</h2><p>string会自动扩容，每当string被填满(size &#x3D;&#x3D; capacity)的时候，就会自动进行扩容</p><p>扩容：开新空间，拷贝，释放旧空间</p><blockquote><p>出了初始化时(第一次扩容)：Windows的vs下每次扩容约为原来的1.5倍，Linux下约为2倍</p><p>创建一个空string也是有容量的，因为要存放’\0’</p></blockquote><h3 id="string-reserve"><a href="#string-reserve" class="headerlink" title="string::reserve"></a>string::reserve</h3><p>扩大容量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span> <span class="params">(<span class="type">size_t</span> n = <span class="number">0</span>)</span></span>;<span class="comment">//C++定义</span></span><br></pre></td></tr></table></figure><blockquote><p>只能扩，不能缩</p><p>只增加<code>capacity</code>，不更改<code>size/length</code></p></blockquote><p>可以提前扩容（增加单次扩容的空间），减少单次扩容的次数（因为扩容也是费时间的）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string s1;</span><br><span class="line">string s2.<span class="built_in">reserve</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  s1 += <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">  s2 += <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//与s2相比，s1要扩容很多次，而s2提前开好了空间，不用每次都扩容了</span></span><br></pre></td></tr></table></figure><h3 id="string-resize"><a href="#string-resize" class="headerlink" title="string::resize"></a>string::resize</h3><p>更改大小&#x2F;长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span> <span class="params">(<span class="type">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span> <span class="params">(<span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>;</span><br><span class="line"><span class="comment">//将字符串大小调整为n个字符的长度。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果n小于当前字符串长度，则当前值缩短为第一个n个字符，删除n个字符。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果n大于当前字符串长度，则通过在末尾插入尽可能多的字符来扩展当前内容，以达到n的大小。如果指定了c，则新元素将初始化为c的副本，否则，它们是值初始化字符（空字符，即&#x27;\0&#x27;）。</span></span><br></pre></td></tr></table></figure><blockquote><p>更改的是<code>size</code>，既能扩，也能缩，并且会进行初始化</p><p>扩容的时候，可能会间接影响capacity，例如如果当前capacity小于n，则capacity也会被扩充</p><blockquote><p>本质是通过影响<code>size(长度)</code>来影响<code>capacity(容量)</code>，因为<code>capacity</code>始终要略大于<code>size</code></p></blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string s1.= <span class="string">&quot;a&quot;</span>;<span class="comment">//size=1,capacity&gt;1(因为保存&#x27;\0&#x27;，再加上要内存对齐)</span></span><br><span class="line">s1.<span class="built_in">reserve</span>(<span class="number">10</span>);<span class="comment">//size=1,capacity=10</span></span><br><span class="line">s1.<span class="built_in">resize</span>(<span class="number">20</span>,<span class="string">&#x27;x&#x27;</span>);<span class="comment">//size=20,capacity&gt;20(因为保存&#x27;\0&#x27;，再加上要内存对齐)</span></span><br><span class="line"><span class="comment">//s1:&quot;axxxxxxxxxxxxxxxxxxxx&quot;一个a，19个x</span></span><br><span class="line">s1.<span class="built_in">resize</span>(<span class="number">10</span>);<span class="comment">//size=10,capacity保持不变</span></span><br><span class="line"><span class="comment">//s1:&quot;axxxxxxxxx&quot;一个a，9个x</span></span><br><span class="line">string s2;<span class="comment">//size=0,capacity&gt;=1</span></span><br><span class="line">s2.<span class="built_in">resize</span>(<span class="number">10</span>);<span class="comment">//size=10,capacty&gt;10</span></span><br><span class="line"><span class="comment">//s2:&quot;\0\0\0\0\0\0\0\0\0\0&quot;10个&#x27;\0&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="二者的区别与联系"><a href="#二者的区别与联系" class="headerlink" title="二者的区别与联系"></a>二者的区别与联系</h3><p><code>reserve</code>：开空间。本质只影响<code>capacity(容量)</code><br><code>resize</code>：开空间+初始化。本质是通过影响<code>size(长度)</code>来影响<code>capacity(容量)</code></p><p>扩容时：<br>如果string中没有数据，<code>resize</code>会出初始化，填上指定字符或者’\0’<br>如果string已经存在数据了，<code>reserve</code>只扩容，不改变字符串；<code>resize</code>会在原有字符串后面填上指定字符或者’\0’</p><p>缩小时：<br><code>reserve</code>不会缩小容量、大小，只能扩，不能缩<br><code>resize</code>不会缩小容量，只会减小长度。将多余的字符删掉。因为resize影响的是size<br>二者都不会缩小capacity（注意，是一般情况下、某一版本的STL下。VS下是这样的，其他版本下，不好说）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202403161541802.png" alt="截屏2024-03-16 15.40.15" style="zoom: 25%;" /><p>二者的常规用途就是：扩容</p><blockquote><p>不初始化，就用<code>reserve</code></p><p>初始化，就用<code>resize</code></p></blockquote><p>扩容都会多扩出一点，因为内存是要对齐的</p><h2 id="尾插"><a href="#尾插" class="headerlink" title="尾插"></a>尾插</h2><h3 id="string-push-back尾插字符"><a href="#string-push-back尾插字符" class="headerlink" title="string::push_back尾插字符"></a>string::push_back尾插字符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span> <span class="params">(<span class="type">char</span> c)</span></span>;<span class="comment">//C++定义</span></span><br></pre></td></tr></table></figure><h3 id="string-append尾插字符串-x2F-字符串对象"><a href="#string-append尾插字符串-x2F-字符串对象" class="headerlink" title="string::append尾插字符串&#x2F;字符串对象"></a>string::append尾插字符串&#x2F;字符串对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++98定义</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span> <span class="params">(<span class="type">const</span> string&amp; str)</span></span>;</span><br><span class="line"><span class="comment">//尾插string</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span> <span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> subpos, <span class="type">size_t</span> sublen)</span></span>;</span><br><span class="line"><span class="comment">//尾插string，规定从该字符串的起始下标subpos，长度sublen，若sublet大于该字符串的size，则直接用npos</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span></span>;</span><br><span class="line"><span class="comment">//尾插C字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>;</span><br><span class="line"><span class="comment">//尾插C字符串指针的前n个字符</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span> <span class="params">(<span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>;</span><br><span class="line"><span class="comment">//尾插n个相同的字符c</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;   <span class="function">string&amp; <span class="title">append</span> <span class="params">(InputIterator first, InputIterator last)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="x3D-既可以尾插字符，也可以尾插字符串！"><a href="#x3D-既可以尾插字符，也可以尾插字符串！" class="headerlink" title="+&#x3D;既可以尾插字符，也可以尾插字符串！"></a>+&#x3D;既可以尾插字符，也可以尾插字符串！</h3><h2 id="string-insert"><a href="#string-insert" class="headerlink" title="string::insert"></a>string::insert</h2><p>从任意位置插入字符&#x2F;字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++98定义</span></span><br><span class="line"> <span class="function">string&amp; <span class="title">insert</span> <span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> string&amp; str)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function">string&amp; <span class="title">insert</span> <span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> string&amp; str, <span class="type">size_t</span> subpos, <span class="type">size_t</span> sublen)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function">string&amp; <span class="title">insert</span> <span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> <span class="type">char</span>* s)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function">string&amp; <span class="title">insert</span> <span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"> string&amp; <span class="title">insert</span> <span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>;    </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">(iterator p, <span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(iterator p, <span class="type">char</span> c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;  <span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">(iterator p, InputIterator first, InputIterator last)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>()+<span class="number">3</span>, <span class="string">&#x27;y&#x27;</span>);<span class="comment">//&quot;helylo world&quot;</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">3</span>, <span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>);<span class="comment">//&quot;helyyylo world&quot;</span></span><br><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>(), <span class="string">&quot;hello &quot;</span>);<span class="comment">//&quot;hello helyyylo world&quot;</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">3</span>, <span class="string">&quot;world&quot;</span>);<span class="comment">//&quot;helworldlo helyyylo world&quot;</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">0</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">3</span>, <span class="number">3</span>)<span class="comment">//&quot;lo helworldlo helyyylo world&quot;</span></span><br></pre></td></tr></table></figure><h2 id="string-earse"><a href="#string-earse" class="headerlink" title="string::earse"></a>string::earse</h2><p>删除string内的某段子串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">erase</span> <span class="params">(<span class="type">size_t</span> pos = <span class="number">0</span>, <span class="type">size_t</span> len = npos)</span></span>;</span><br><span class="line"><span class="comment">//全缺省，清空整个字符串</span></span><br><span class="line"><span class="comment">//缺省第二个，从某个下标位置开始往后全部删除</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(iterator p)</span></span>;</span><br><span class="line"><span class="comment">//从开始位置一直到迭代器p的位置，都删除</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(iterator first, iterator last)</span></span>;</span><br><span class="line"><span class="comment">//开始位置迭代器，结束为止迭代器</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">s.<span class="built_in">earse</span>(s.<span class="built_in">begin</span>()+<span class="number">1</span>);<span class="comment">//迭代器，从第二个元素开始往后全部删除</span></span><br><span class="line">s.<span class="built_in">earse</span>(s.<span class="built_in">begin</span>() + <span class="number">1</span>, s.<span class="built_in">end</span>() <span class="number">-1</span>);<span class="comment">//删除从第二个元素到最后一个元素</span></span><br><span class="line">s.<span class="built_in">earse</span>(<span class="number">0</span>, s.<span class="built_in">size</span>()<span class="number">-4</span>);<span class="comment">//删除从下标0开始到倒数第4个位置的全部元素（s.size()的值是有效元素个数，作为下标就是最后一个有效字符的下一个位置）</span></span><br><span class="line">s.<span class="built_in">earse</span>(<span class="number">3</span>);<span class="comment">//第二个参数缺省，缺省值为npos，nops=-1，即从下标3开始往后全部删除</span></span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="string-clear"><a href="#string-clear" class="headerlink" title="string::clear"></a>string::clear</h2><p>清空字符串，size&#x3D;0，capacity不变</p><h2 id="swap-交换"><a href="#swap-交换" class="headerlink" title="swap 交换"></a>swap 交换</h2><h3 id="string-swap"><a href="#string-swap" class="headerlink" title="string::swap"></a>string::swap</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span> <span class="params">(string&amp; str)</span></span>;<span class="comment">//C++定义</span></span><br><span class="line"><span class="comment">//eg:</span></span><br><span class="line">string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">s1.<span class="built_in">swap</span>(s2);</span><br></pre></td></tr></table></figure><p>实现方法，交换两个string的指针</p><h3 id="STL的全局函数std-swap"><a href="#STL的全局函数std-swap" class="headerlink" title="STL的全局函数std::swap"></a>STL的全局函数std::swap</h3><p>STL库中存在一个全局函数swap，在命名空间std中，支持任意两个相同类型的对象进行交换</p><p>实现方法，深拷贝</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>string::swap效率高（交换指针）<br>swap效率低（深拷贝交换）</p><h2 id="string-find"><a href="#string-find" class="headerlink" title="string::find()"></a>string::find()</h2><p>查找字符&#x2F;字符串，从前向后正向找，找到最先匹配的字符&#x2F;字符串，返回<code>size_t</code>类型的</p><blockquote><p>被查找的(字符串的首)字符的下标 【找到了】</p><p>npos 【没找到】</p></blockquote><h3 id="string-rfind"><a href="#string-rfind" class="headerlink" title="string::rfind()"></a>string::rfind()</h3><p>从后向前找，或者说找到最后匹配的字符&#x2F;字符串，返回<code>size_t</code>类型的</p><blockquote><p>被查找的(字符串的首)字符的下标 【找到了】</p><p>npos 【没找到】</p></blockquote><h2 id="string-substr"><a href="#string-substr" class="headerlink" title="string::substr"></a>string::substr</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">substr</span> <span class="params">(<span class="type">size_t</span> pos = <span class="number">0</span>, <span class="type">size_t</span> len = npos)</span> <span class="type">const</span></span>;<span class="comment">//C++定义</span></span><br></pre></td></tr></table></figure><p>从某个位置(pos)开始，取出长度为len的子串。不会影响远来的字符串，因为有<code>const *this</code>，规定了当前对象为const。</p><h1 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h1><h2 id="模拟实现拷贝构造函数"><a href="#模拟实现拷贝构造函数" class="headerlink" title="模拟实现拷贝构造函数"></a>模拟实现拷贝构造函数</h2><p>默认的拷贝构造函数是浅拷贝（值拷贝），会出现的问题是：1. 同一块空间会析构两次 2.其中一个改变会影响另外一个</p><blockquote><p>一块空间只能析构一次</p></blockquote><p>因此应完成深拷贝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s2(s1)</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp; s)</span><br><span class="line">  :_str(<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s._str)+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">      <span class="built_in">strcpy</span>(_str,s._str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么要<code>strlen(s._str) + 1</code>，因为strlen只获取字符串的有效字符个数，不获取字符串结尾符号<code>\0</code><br>但是<code>strcpy</code>函数会把被拷贝的字符串<code>s._str</code>全部字符拷贝到<code>_str</code>，包括<code>\0</code>，因此要多开一位，避免造成<code>_str</code>容量不够，无法接纳<code>\0</code></p></blockquote><p>同理，赋值<code>=</code>的重定义也应该使用深拷贝</p><h2 id="模拟实现赋值-x3D-运算符重载"><a href="#模拟实现赋值-x3D-运算符重载" class="headerlink" title="模拟实现赋值&#x3D;运算符重载"></a>模拟实现赋值&#x3D;运算符重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s1(&quot;hello world&quot;);</span></span><br><span class="line"><span class="comment">//s3(&quot;111111111&quot;);</span></span><br><span class="line"><span class="comment">//s1 = s3;</span></span><br><span class="line"><span class="comment">//面临的可能存在的问题：</span></span><br><span class="line"><span class="comment">//s3比s1小</span></span><br><span class="line"><span class="comment">//s3比s1大的太多了，以至于拷贝了s1之后s3剩余很多空间，浪费</span></span><br><span class="line">string&amp; <span class="keyword">operator</span> = (<span class="type">const</span> string&amp; s) <span class="comment">//引用返回</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//先判断一下是不是自己给自己赋值，如果自己给自己赋值，就不能delete自己了，因为清空之后要拷贝给自己清空后的自己</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;s._str)<span class="comment">//&amp;为取地址</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//所以，先将原来的字符串的空间释放掉，就避免了原字符串过大或过小的问题</span></span><br><span class="line">      <span class="keyword">delete</span>[] _str;</span><br><span class="line">      _str = <span class="keyword">new</span> <span class="type">char</span>[(<span class="built_in">strlen</span>(s._str) + <span class="number">1</span>];</span><br><span class="line">      <span class="built_in">strcpy</span>(_str, s._str);</span><br><span class="line">    &#125;                             </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么选择引用返回：<br>传值返回：拷贝要返回的变量的值，返回拷贝出的临时变量。并且出了函数作用域，这个变量就失效了。</p><p>引用返回则是直接返回原本的这个变量本身，简单。<br>此处引用返回的是<code>*this</code>，this是指向当前对象的指针，*this就是当前对象，返回的是当前对象本身。<br>如果此处使用传值返回，那么需要先拷贝一个string对象，这个值是自定义的string类型，而自定义的拷贝是深拷贝，代价太大。<br>使用引用拷贝相当于直接对本对象进行修改然后返回本对象，不需要经过修改-拷贝一个临时对象-将临时对象赋值给当前对象的过程。</p><p>当然，返回类型应该也可以是void，不需要返回值，直接修改完当前对象即可。</p></blockquote><p>与malloc不同，new动态开辟空间后不需要手动检查开辟是否成功，失败时new会自动抛出异常</p><p>清空<code>_str</code>写在了在开辟新空间之前，此处有一个小问题，如果new开辟空间失败，不仅无法成功拷贝，反而还先把原来的字符串<code>s1</code>清空了</p><p>针对这个问题，有人提出了改进，更改了一下代码的顺序，先new新对象并赋值给一个中间变量<code>p</code>，将被拷贝的字符串<code>s._str</code>拷贝给中间变量<code>p</code>，再清空原来的<code>_str</code>，最后将中间变量赋值给<code>_str</code><br>这样如果开空间失败，会抛出异常终止程序执行，这一步会赶在清空原字符串之前</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span> = (<span class="type">const</span> string&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;s._str)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span>* p = <span class="keyword">new</span> <span class="type">char</span>[(<span class="built_in">strlen</span>(s._str) + <span class="number">1</span>];<span class="comment">//先开空间</span></span><br><span class="line">      <span class="built_in">strcpy</span>(p, s._str);<span class="comment">//拷贝给中间变量</span></span><br><span class="line">      <span class="keyword">delete</span>[] _str;<span class="comment">//再清空</span></span><br><span class="line">      _str = p;<span class="comment">//最后赋值</span></span><br><span class="line">    &#125;                             </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准库里面resize()扩容的时候，capacity会多扩一些，因为涉及到内存对齐，比如扩容之后内存应该是是2的整数倍，则capacity为这个值-1(因为capacity是有效字符存储空间容量，不包含\0，而内存最后一个为\0)</p><h2 id="模拟实现范围for"><a href="#模拟实现范围for" class="headerlink" title="模拟实现范围for"></a>模拟实现范围for</h2><p>范围for本质就是底层被替换为迭代器以及其中的begin()和end()函数</p><p>就算是自己模拟实现的迭代器也是可以的。只要容器支持迭代器，就支持范围for</p><p>范围for在遍历的时候，如果不指明获取的元素为引用，则默认是迭代器的解引用的拷贝，即原string里面的元素的拷贝，更改这个值不影响原字符串<br>如果指明获取的元素为引用，则获取到的则是迭代器解引用的引用，更改这个值影响原字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="comment">//范围for不指明元素为引用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> ch : s1) <span class="comment">//此处auto智能匹配的是char</span></span><br><span class="line">&#123;</span><br><span class="line">    ch -= <span class="number">1</span>;<span class="comment">//更改一下获取到的元素的值</span></span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;<span class="comment">//s1的值没有改变</span></span><br><span class="line"><span class="comment">//范围for指明遍历的元素为引用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : s1)</span><br><span class="line">&#123;</span><br><span class="line">    ch -= <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;<span class="comment">//s1的值改变了</span></span><br></pre></td></tr></table></figure><p><mark><strong>C++传参如果没有特殊需求，尽量使用引用传参，减少拷贝，如果要防止参数被修改，就加上const</strong></mark></p><p>权限只能缩小或保持不变，不能放大</p><blockquote><p>比如一个函数定义时形参写的是const，那么调用传参的时候，实参可以是加了const的也可以是不加const的<br>但是如果一个函数定义时形参写的是不加const的，调用的时候，实参就不能是const类型的，因为权限放大了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">const</span> <span class="type">char</span> s)</span><span class="comment">//参数要求是const类型的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;const in&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(<span class="type">char</span> s)</span><span class="comment">//参数没要求是const类型的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> s1 = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> s2 = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fun1</span>(s1);<span class="comment">//正确，权限缩小</span></span><br><span class="line">    <span class="built_in">fun1</span>(s2);<span class="comment">//正确，权限保持不变</span></span><br><span class="line">    <span class="built_in">fun2</span>(s1);<span class="comment">//正确，权限保持不变</span></span><br><span class="line">    <span class="built_in">fun2</span>(s2);<span class="comment">//错误，权限由const变成了一般，权限放大了</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>所以有一些函数会提供两个版本，一个是const版本的，一个是没有const版本的。供不同情况下调用。<br>例如STL的string的标准库中，运算符<code>[]</code>重载函数就提供了两个版本:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[] (<span class="type">size_t</span> pos);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> pos) <span class="type">const</span>;</span><br></pre></td></tr></table></figure><blockquote><p>前一个const指明返回值类型为const，后一个const指明此函数所在的对象是一个const类型的对象<br>相当于<code>const char&amp; operator[](size_t pos, const string&amp; *this)</code></p></blockquote><p>比如当创建了一个const类型的string对象时，因为该对象不能被修改，因此在使用重载运算符[]的时候，就只能使用const版本的，否则会发生权限放大</p><p><mark>const对象不能调用非const的成员函数</mark></p><h2 id="模拟实现-lt-lt-流插入运算符重载"><a href="#模拟实现-lt-lt-流插入运算符重载" class="headerlink" title="模拟实现&lt;&lt;流插入运算符重载"></a>模拟实现<code>&lt;&lt;</code>流插入运算符重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> string&amp; s)</span><br><span class="line">&#123; </span><br><span class="line">   <span class="comment">//第一种写法</span></span><br><span class="line">   <span class="comment">/* out &lt;&lt; s.c_str();</span></span><br><span class="line"><span class="comment">    return out; */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二种写法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ch : s)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第一中写法是获取string的char*格式的字符串，然后打印<br>第二种写法是遍历整个string，然后逐个打印</p></blockquote><p>第一种方式在遍历C格式的字符串的时候，遇到<code>\0</code>就会终止，认为字符串已经结束<br>第二种方式会遍历整个string</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">s.<span class="built_in">push_back</span>(<span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">s.<span class="built_in">push_back</span>(<span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">s.<span class="built_in">push_bach</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br></pre></td></tr></table></figure><blockquote><p>如果是第一种写法的话，打印出来只能打印<code>hello world</code>，因为后面遇到了<code>\0</code>，C字符串认定为终结符</p><p>第二种写法则会打印出<code>hello world    x</code>，因为是对于string整体做了一个遍历</p></blockquote><h2 id="模拟实现-gt-gt-流提取运算符重载"><a href="#模拟实现-gt-gt-流提取运算符重载" class="headerlink" title="模拟实现&gt;&gt;流提取运算符重载"></a>模拟实现<code>&gt;&gt;</code>流提取运算符重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, string&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="comment">//in &gt;&gt; ch;</span></span><br><span class="line">    ch = in.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch != <span class="string">&#x27; &#x27;</span> &amp;&amp; ch != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s += ch;<span class="comment">//复用的模拟实现的+=重定向</span></span><br><span class="line">        <span class="comment">//in &gt;&gt; ch;</span></span><br><span class="line">        ch = in.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>此处从缓冲区获取字符的时候，使用的是<code>in.get()</code>而不是<code>in&gt;&gt;</code>，因为字符的流提取符<code>&gt;&gt;</code>将空格和换行认定为终结符，因此如果从通过<code>in&gt;&gt;</code>读取到缓冲区中读取到终结符，就终止读取了，ch获取不到这个终结符。<br>而<code>in.get()</code>是获取缓冲区中的(任何)一个字符，无论是不是终结符。这样就能确保ch拿到缓冲区里面的每一个字符，然后再判断时候终止循环。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; s1;</span><br><span class="line">cin &gt;&gt; s2;</span><br><span class="line"><span class="comment">//假设从键盘上键入&quot;hello world&quot;，按下回车</span></span><br><span class="line"><span class="comment">//如果采用in&gt;&gt;的方式，程序会继续等待输入，因为ch没有获取到终结符</span></span><br><span class="line"><span class="comment">//如果采用in.get()，s1获取的是hello，s2获取的是world，因为hello和world之间的空格作为终结符被读取到了。这是正确的</span></span><br></pre></td></tr></table></figure><h4 id="优化1："><a href="#优化1：" class="headerlink" title="优化1："></a><mark>优化1：</mark></h4><p>如果键入的字符太多，当字符串s满了的时候，s+&#x3D;每次都要扩一下容，效率不高</p><p>创建一个字符数组buff，先把获取到的字符放到字符数组中，等字符数组满了或者字符获取结束后，再将字符数组(其实就是C字符串) +&#x3D; 到字符串s里面去。如果字符数组满了，将内容放到字符串s之后，清空或重新初始化自己的内容，准备继续承接字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp; in, string&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch = in.<span class="built_in">get</span>();</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">128</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;<span class="comment">//假设先给定空间是128，先都初始化成\0</span></span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;<span class="comment">//记录buff里面元素的个数</span></span><br><span class="line">    <span class="keyword">while</span>(ch != <span class="string">&#x27; &#x27;</span> &amp;&amp; ch != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buff[i++] = ch;<span class="comment">//先使用字符数组承接缓冲区获取到的字符</span></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">127</span>) <span class="comment">//等于127因为最后一个位置要留一个\0作为字符串的结束符号</span></span><br><span class="line">        &#123;</span><br><span class="line">            s += buff;<span class="comment">//当字符数组满了，就将里面的内容加到字符串s中去</span></span><br><span class="line">            <span class="built_in">memset</span>(buff, <span class="string">&#x27;\0&#x27;</span>, <span class="number">128</span>);<span class="comment">//重新初始化(使用memset函数填充128个\0)</span></span><br><span class="line">            i = <span class="number">0</span>;<span class="comment">//准备进行下一轮的承接</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s += buff;<span class="comment">//可能buff没满，最后要把buff加到s后面去</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这样就避免了string字符串s频繁进行<code>+=</code>操作，减少了扩容次数，提高了效率</p></blockquote><p>模拟实现<code>getline()</code>就是将上面while循环里面的空格判断删除，只让换行符作为终结符</p><h4 id="优化2："><a href="#优化2：" class="headerlink" title="优化2："></a><mark>优化2</mark>：</h4><p>STL中的string在流提取时，如果原string有内容，则会被新获取的内容覆盖掉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">std::cin &gt;&gt; s;</span><br><span class="line"><span class="comment">//如果输入world</span></span><br><span class="line">std::cout &lt;&lt; s &lt;&lt; endl;<span class="comment">//此处输出的是world</span></span><br></pre></td></tr></table></figure><p>因此模拟实现中也要先将原来的字符串清空一下才可以</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _str[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//清空很简单，把终结符放最前面，然后有效字符个数至0即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp; in, string&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    s.<span class="built_in">clear</span>();</span><br><span class="line">   .....</span><br><span class="line">   .....</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="现代写法"><a href="#现代写法" class="headerlink" title="现代写法"></a>现代写法</h2>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模版template</title>
      <link href="/chunyujin/b742e110.html"/>
      <url>/chunyujin/b742e110.html</url>
      
        <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>模板可用应用于函数，也可应用于类。<br>应用于函数的为函数模板，应用于类的为类模板。</p><h3 id="模板参数–很多地方和函数参数类似"><a href="#模板参数–很多地方和函数参数类似" class="headerlink" title="模板参数–很多地方和函数参数类似"></a>模板参数–很多地方和函数参数类似</h3><p>函数参数：传递的是对象值</p><p>模板参数：传递的是类型</p><h3 id="函数模板的类型一般是编译器根据实参传递给形参的类型推演出来的，但是也有推演不出来的时候："><a href="#函数模板的类型一般是编译器根据实参传递给形参的类型推演出来的，但是也有推演不出来的时候：" class="headerlink" title="函数模板的类型一般是编译器根据实参传递给形参的类型推演出来的，但是也有推演不出来的时候："></a>函数模板的类型一般是编译器根据实参传递给形参的类型推演出来的，但是也有推演不出来的时候：</h3><p>例1:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt;</span><br><span class="line"><span class="function">T *<span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> T[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>推到不出来模板参数T的类型，因为模板参数应用在了返回值类型上<br>没有办法通过传参判断出来模板参数的类型</p></blockquote><h4 id="此时应显式指定模板参数类型，“函数模板显式实例化”："><a href="#此时应显式指定模板参数类型，“函数模板显式实例化”：" class="headerlink" title="此时应显式指定模板参数类型，“函数模板显式实例化”："></a>此时应显式指定模板参数类型，“函数模板显式实例化”：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p1 = <span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="type">double</span> *p2 = <span class="built_in">func</span>&lt;<span class="type">double</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类似于使用vector的时候，需要显式指定vector元素的类型</span></span><br></pre></td></tr></table></figure><p>例2:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(<span class="type">const</span> T &amp;left, <span class="type">const</span> T &amp;right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="type">double</span> b = <span class="number">1.0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">Add</span>(a,b);<span class="comment">//报错，因为无法推演出模版参数T到底是什么类型，到底是int还是double</span></span><br><span class="line">  <span class="comment">//解决方式1，显式实例化</span></span><br><span class="line">  <span class="built_in">Add</span>&lt;<span class="type">int</span>&gt;(a,b);<span class="comment">//其实上面一行的实例化方式就是隐式实例化</span></span><br><span class="line">  <span class="comment">//解决方式2，强制类型转换</span></span><br><span class="line">  <span class="built_in">Add</span>(a,(<span class="type">int</span>)b);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板参数也可以缺省-用的比较少-："><a href="#模板参数也可以缺省-用的比较少-：" class="headerlink" title="模板参数也可以缺省(用的比较少)："></a>模板参数也可以缺省(用的比较少)：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span> = <span class="type">char</span>&gt; <span class="comment">//缺省值为char</span></span><br><span class="line">T *<span class="built_in">func</span>(<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> T[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">func</span>(<span class="string">&#x27;1&#x27;</span>);<span class="comment">//此时不用函数模板显式实例化也可以了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模版的声明、定义可以分离"><a href="#模版的声明、定义可以分离" class="headerlink" title="模版的声明、定义可以分离"></a>模版的声明、定义可以分离</h2><p>但是每个定义、声明前都要重新规定一下模版参数(的名称)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T a)</span></span>;<span class="comment">//声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">N</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(N a)</span><span class="comment">//定义的时候要重新规定一下模版参数，模版参数名可以和声明时不一样</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; a &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="《但是模版不支持声明和定义分离到两个文件！！》"><a href="#《但是模版不支持声明和定义分离到两个文件！！》" class="headerlink" title="《但是模版不支持声明和定义分离到两个文件！！》"></a>《但是模版不支持声明和定义分离到两个文件！！》</h3><p><mark>会报编译错误</mark></p><blockquote><p>此种情况都是对于分离式编译来说的</p><p>通常来讲，分离式编译有三类文件，包含程序入口main函数的文件(暂且称之为main文件)、包含自定义对象和函数声明的自定义头文件(暂且称之为头文件)、实现头文件中的对象和函数的cpp文件(暂且称之为实现文件)</p><p>一般是main文件和实现文件都包含头文件，然后通过实现文件实现头文件。最后链接到一起。</p><blockquote><p> 当然，main文件不要包含实现文件，否则不叫分离编译了</p><p>若实现文件被包含在了main文件中，展开后还是都在了main文件，最后结果还是声明、实现都在同一个文件也就是main文件中，并没有分离开来</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202403142102014.png" alt="截屏2024-03-14 21.01.44" style="zoom:50%;" /></blockquote><p>此处指的声明和定义分离，就是指声明在头文件中，实现&#x2F;定义在实现文件中。</p></blockquote><p><strong>为什么模版的声明和定义分离到2个文件中就会报编译错误？</strong></p><p>符号表找不到（编译原理会提到）</p><blockquote><p>程序编译的过程：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202403142108822.png" alt="截屏2024-03-14 21.07.22" style="zoom: 33%;" /><p>而模版参数只有在实例化的时候，才能借由实参传递形参推演出来参数类型，故在链接之前，负责模版实现的.cpp文件无法单独推演出模版参数（因为模版实例化是在main.cpp中进行的，此时都处在链接之前，都是分别独立处理的），因此负责实现的.cpp文件无法编译通过</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202403142117386.png" alt="截屏2024-03-14 21.16.26" style="zoom: 67%;" /></blockquote><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><h4 id="方案一-比较挫-：在用于实现模版的-cpp中针对main中要使用的模版类型显式实例化"><a href="#方案一-比较挫-：在用于实现模版的-cpp中针对main中要使用的模版类型显式实例化" class="headerlink" title="方案一(比较挫)：在用于实现模版的.cpp中针对main中要使用的模版类型显式实例化"></a>方案一(比较挫)：在用于实现模版的.cpp中针对main中要使用的模版类型显式实例化</h4><p>比如已知main.cpp中调用了函数模版，并且实例化参数为char</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> a = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">  <span class="built_in">func</span>(a);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就在实现的.cpp中显式实例化一个出一个char类型的模版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">func</span>&lt;<span class="type">char</span>&gt; (<span class="type">char</span> a);<span class="comment">//在此显式实例化一下（注意上一行中要加上template，这是固定格式</span></span><br></pre></td></tr></table></figure><h4 id="方案二：声明和定义不分离，将模版的实现写在声明的头文件里，文件后缀命名为-hpp-建议"><a href="#方案二：声明和定义不分离，将模版的实现写在声明的头文件里，文件后缀命名为-hpp-建议" class="headerlink" title="方案二：声明和定义不分离，将模版的实现写在声明的头文件里，文件后缀命名为.hpp(建议)"></a>方案二：声明和定义不分离，将模版的实现写在声明的头文件里，文件后缀命名为.hpp(建议)</h4><p>后缀名建议更改，并不是强制更改，文件名后缀本质上对于文件没有任何影响，.cpp .h .hpp没有本质上的区别</p><p><a href="ttps://chunyujin.top/chunyujin/7c16d58">头文件和源文件的区别</a></p><p>.hpp 只是寓意更好，是.h和.cpp拼接成的，也就是“既有定义又有实现”的意思</p><h2 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h2><p>在调用函数&#x2F;实例化对象的时候，如果有已定义好的、(参数类型)更精确的，先调用已定义好的</p><p>没有，才调用模版，进行推演</p><p>若就是想强制指定调用模版，则调用时使用显式实例化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Add</span>&lt;<span class="type">int</span>&gt;(a,b);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命名空间&amp;作用域限定符</title>
      <link href="/chunyujin/e3051e77.html"/>
      <url>/chunyujin/e3051e77.html</url>
      
        <content type="html"><![CDATA[<h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>命名空间要定义在全局，不能定义在局部</p><p>同一个域里面的同名的命名空间的内容会被合并</p><p>命名空间可以嵌套</p><p>命名空间通常放在头文件</p><p>命名空间不影响生命周期</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cyj&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">test</span>&#123;</span><br><span class="line">        string name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> bit&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> second)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first+second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> bit;</span><br><span class="line"><span class="comment">//1.使用命名空间内定义的变量时，可以提前将命名空间展开，然后直接使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">add</span>(cyj::a, a); <span class="comment">// ::域作用限定符</span></span><br><span class="line">    <span class="comment">//2.若不展开，也可以用域作用限定符来表示这是某个命名空间内定义的变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:: 为域作用限定符，作用是说明符号右侧的变量是符号左侧的空间域里定义的那一个</p><p>比如<code>cyj::a</code>就是说这个a是命名空间域cyj里定义的变量a（而不是其他域比如bit命名空间域或者某个局部域里面定义的变量a</p><blockquote><p>比如两个叫浴巾的人，一个来自山东，一个来自广东，在同一家公司工作，称呼他们的时候，为了防止重名，会叫“山东来的浴巾”或者“广东来的浴巾”</p></blockquote><p>内嵌在一个外部命名空间的内部命名空间，在使用<code>using namespace</code>进行展开时，要先展开外部命名空间，再展开内部命名空间，否则找不到内部命名空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cyj&#123;</span><br><span class="line">    <span class="keyword">namespace</span> yj&#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">namespace</span> test&#123;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cyj::test;<span class="comment">//也可以通过域作用限定符直接展开外部命名空间里面的命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#using namespace yj;<span class="comment">//不能先展开，要先展开外部的</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cyj;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> yj;<span class="comment">//先展开外部命名空间，再展开内部的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器iterator</title>
      <link href="/chunyujin/1261762c.html"/>
      <url>/chunyujin/1261762c.html</url>
      
        <content type="html"><![CDATA[<h2 id="迭代器iterator的使用"><a href="#迭代器iterator的使用" class="headerlink" title="迭代器iterator的使用"></a>迭代器iterator的使用</h2><p>迭代器iterator是一个额外的、独立数据结构，存在于STL库中。专门用于访问STL中各个数据结构中的元素。</p><p>(可以朴素地认为迭代器就是指针)</p><blockquote><p>使用迭代器访问元素，和使用方括号[]加下标的效果一样，<mark>都是获取元素的引用</mark>，可读可写</p><p>但是方括号是对象本身的数据结构自带的(通过重构)，而迭代器是不属于被访问的对象的，一个单独的数据结构</p><blockquote><p> 当一个对象为const时，为只可读的，此时还是可以通过方括号下标访问(因为通常会重构一个const类型的方括号)，只要不对访问到的元素进行修改即可<br> 但是已经不能使用普通迭代器访问了，因此使用迭代器访问元素，本质上是使用一个数据结构A(iterator)访问另一个数据结构B(被访问的对象)中的元素，而非数据结构B直接调用自己的成员函数访问自己</p><p> 因此就算数据结构B设置为const，但是外部的迭代器仍有写的权限，这是不合理的。此处应使用const_iterator</p></blockquote></blockquote><h3 id="迭代器的使用方法"><a href="#迭代器的使用方法" class="headerlink" title="迭代器的使用方法"></a>迭代器的使用方法</h3><ol><li>使用迭代器的时候要指明被访问的数据结构类型</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处以string对象为例</span></span><br><span class="line">string::iterator ite;</span><br></pre></td></tr></table></figure><ol start="2"><li>STL中的数据结构，都具有相关的成员函数，获取到自己元素的迭代器</li></ol><p>以<code>string</code>为例：</p><p><code>string::begin()</code>获取首字符的迭代器</p><p><code>string::end()</code>获取最后一个有效字符的下一个字符(即结束字符，也就是’\0’)的迭代器</p><blockquote><p>STL的各个数据结构都有<code>begin()</code>和<code>end()</code>函数，而且都是<mark>左闭右开</mark></p><p>即begin()获取首元素的迭代器，end()获取最后一个有效元素的下一个元素的迭代器</p><p>这样便于遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;helle world&quot;</span>;<span class="comment">//即h、e、l、l、o、 、w、o、r、l、d、\0</span></span><br><span class="line">string::iterator it_left = s1.<span class="built_in">begin</span>();<span class="comment">//获取的是h的迭代器</span></span><br><span class="line">string::iterator it_right = s1.<span class="built_in">end</span>();<span class="comment">//获取的是\0的迭代器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历方式1</span></span><br><span class="line"><span class="keyword">while</span>(it_left != it_right)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;*it_left&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//访问迭代器对应的元素，就是解引用</span></span><br><span class="line">it_left++;<span class="comment">//迭代器可以加减，就是后移/前移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历方式2</span></span><br><span class="line"><span class="keyword">while</span>(it_left != s1.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;*it_left&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">it_left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历方式3</span></span><br><span class="line"><span class="keyword">for</span>(; it_left != it_right; it_left++;)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;*it_left&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历方式4</span></span><br><span class="line"><span class="keyword">for</span>(; it_left != s1.<span class="built_in">end</span>(); it_left++;)</span><br><span class="line">&#123;........&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="注意！迭代器遍历要使用-x3D-，不能使用-lt-，因为地址空间不一定连续"><a href="#注意！迭代器遍历要使用-x3D-，不能使用-lt-，因为地址空间不一定连续" class="headerlink" title="注意！迭代器遍历要使用!&#x3D;，不能使用&lt;，因为地址空间不一定连续"></a>注意！迭代器遍历要使用!&#x3D;，不能使用&lt;，因为地址空间不一定连续</h3><blockquote><p>顺序存储类型的数据结构，地址空间连续，如string&#x2F;vector出了使用迭代器访问元素，还可以通过方括号[]结合下标来访问。</p><p>但非顺序存储类型的数据结构，地址空间不连续，如list，则只能使用迭代器访问</p></blockquote><p>但是<code>iterator++</code>或i<code>tertor+=n</code>意味着迭代器指向下一个&#x2F;后面第n个元素，是逻辑上的指向下一个</p><h3 id="四大常用迭代器"><a href="#四大常用迭代器" class="headerlink" title="四大常用迭代器"></a>四大常用迭代器</h3><p><strong>普通正向迭代器 iterator</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string::iterator it_left = s1.<span class="built_in">begin</span>();<span class="comment">//获取首元素</span></span><br><span class="line">string::iterator it_right = s1.<span class="built_in">end</span>();<span class="comment">//获取最后一个有效字符的后一个字符，即结束字符\0</span></span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202403161625553.png" alt="截屏2024-03-16 11.08.56" style="zoom: 33%;" /><p><strong>普通反向迭代器 reverse_iterator</strong></p><p>与正向迭代器的起点、终点、移动方向正好相反</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string::reverse_iterator re_it_left = s1.<span class="built_in">rbegin</span>();<span class="comment">//获取最后一个有效元素</span></span><br><span class="line">string::reverse_iterator re_it_right = s1.<span class="built_in">rend</span>();<span class="comment">//获取首元素的前一个位置</span></span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202403161625631.png" alt="截屏2024-03-16 11.09.50" style="zoom:33%;" /><p>const正向迭代器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string::const_iterator con_it_left = s1.<span class="built_in">begin</span>();<span class="comment">//还使用begin()获取，因为string中对此重载了</span></span><br></pre></td></tr></table></figure><p><strong>const反向迭代器</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string::const_reverse_iterator con_re_it_left = s1.<span class="built_in">rbegin</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//还是使用rbegin()获取，因为string对此重载了</span></span><br></pre></td></tr></table></figure><p><mark>不知道对象是不是const的？auto登场</mark></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教师监考系统开发记录</title>
      <link href="/chunyujin/3a3cef60.html"/>
      <url>/chunyujin/3a3cef60.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="开发规划："><a href="#开发规划：" class="headerlink" title="开发规划："></a>开发规划：</h1><ol><li>实现无界面的系统，编写可以独立完成所有功能的后端代码<ol><li>提高代码的复用性，减少重复的字段，解耦合。<br>将功能封装为函数，函数值完成执行，获取值，返回值，不进行打印等额外功能，将函数功能化。调用函数的代码负责对函数返回值进行处理。提高易用性。</li><li>抽象化，将同类功能函数抽象为同一类，并加入必要的成员变量，隐藏信息、保护数据、便于代码移植。</li></ol></li><li>实现有界面的系统，采用B&#x2F;S 浏览器&#x2F;服务器 结构<ol><li>前端通过浏览器展示，采用html展示页面结构，css进行html美化，js用于控制html上组件的行为，并内联ajax，将某些组件的响应作为请求，与参数一起打包发送，并等待后端响应，获取参数，然后执行相应的操作</li><li>后端，先移植后端代码与数据库到Linux云服务器。升级cmake和gcc。安装httplib c++库，用来监听指定端口下的网络请求，执行后端代码，将结果作为参数传回前端。</li><li>将移植后的后端代码进行更改，将接口的参数和返回值，进行更改，比如将变量进行JSON序列话和反序列化，用于网络通信时参数传递。</li></ol></li></ol><h1 id="技术栈："><a href="#技术栈：" class="headerlink" title="技术栈："></a>技术栈：</h1><p>后端：<code>C/C++ C++11</code>，<code>STL</code>，<code>准标准库JsonCpp</code>，<code>准标准库cpp-httplib</code>，<code>准标准库mysql</code></p><p>前端：<code>前端三大件（HTML5，CSS，JS），此处使用jQuery替代JS，学习成本较低</code>；<code>Ajax，在JS中插入，用于向服务器发送请求，实现前后端交互</code></p><h1 id="项目环境："><a href="#项目环境：" class="headerlink" title="项目环境："></a>项目环境：</h1><p><code>Centos7 云服务器</code>，<code>vim/gcc(g++)/Makefile</code>，<code>Clion</code>，<code>vscode</code>，<code>MySQL80</code></p><h1 id="开发流程："><a href="#开发流程：" class="headerlink" title="开发流程："></a>开发流程：</h1><h2 id="后端开发："><a href="#后端开发：" class="headerlink" title="后端开发："></a>后端开发：</h2><h3 id="1-本地开发，基本功能实现"><a href="#1-本地开发，基本功能实现" class="headerlink" title="1.本地开发，基本功能实现"></a>1.本地开发，基本功能实现</h3><p>开发环境：CLion，本地MySQL</p><p>使用CLion进行开发，使用Cpp通过MySQL原生自带API连接MySQL中相关数据库</p><ul><li>MySQL的API存在于mysql.h头文件中，需要在CLion的CmakeLists文件中添加相关的动态链接，才能在引用时可以找到对应的头文件。<br><a href="https://blog.csdn.net/weixin_49730048/article/details/124353156">C&#x2F;C++ 使用 MySQL API 操作 数据库 （API讲解 、案例分享）_mysql c api有什么用-CSDN博客</a><br><a href="https://blog.csdn.net/Szyangc/article/details/122096343">Clion 连接 MySQL 配置教程 C++操作数据库程序 附数据库sql语句_clion 操作mysql++.h-CSDN博客</a></li><li>学习MySQL相关API的使用</li></ul><h4 id="需求分析："><a href="#需求分析：" class="headerlink" title="需求分析："></a><strong>需求分析</strong>：</h4><blockquote><p>监考管理查询系统</p><p>系统分为管理员和教师两种角色。</p><p><mark>管理员：</mark><br>导入监考信息（考试科目、监考人员（可多人监考一门考试）、时间、地点）。<br>监考信息管理（增删改查）。<br>教师管理（增删改查）</p><p><mark>教师：</mark><br>查看监考信息。</p></blockquote><h4 id="设计数据库："><a href="#设计数据库：" class="headerlink" title="设计数据库："></a><strong>设计数据库：</strong></h4><p>初步设计：</p><blockquote><p>设计三个表，管理员信息（root）、教师信息（teacher）、监考信息（proctoring_information）</p><p>root (ID, passwd)，其中ID为主键，ID与passwd均不能为空</p><p>teacher (ID, name)，其中ID为主键，ID与name均不能为空</p><p>proctoring_information (proctoringID, proctoringName, teacherID, teacherName, startTime, endTime, allTime, access)，其中proctoringID和teacherID为主键</p><p>数据类型均为varchar</p></blockquote><p>此数据库各表都只遵循了第二范式<br>虽然满足了“一个考试可以允许有多个监考老师”的要求，但是数据原子性太强，数据中的依赖性强，数据冗余过大，牵一发而动全身，一个数据更改之后，其余数据必须更改，麻烦费力</p><p>完善设计：<br>将proctoring_Information拆分为proctoring_Information和exam_Information</p><blockquote><p>proctoring_Information (proctoringID, teacherID)，其中proctroingID和teacherID均为主键</p><p>exam_Information (proctoringID, proctoringName, startTime, endTime, allTime, access)，proctoringID为主键</p><p>proctoring_Information(proctoringID, teacherID)，proctoringID和teacherID为主键</p><p>数据类型均为varchar</p></blockquote><p>满足第三范式</p><h4 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a><strong>算法实现：</strong></h4><ol><li><p>身份选择：<br>分为教师登陆和管理员登陆，进入登陆界面后，用户先进行身份选择，选择后会留下身份记录，进入到对应的登陆界面</p></li><li><p>登陆：<br>教师登陆，只需要输入教师编号（ID）即可<br>管理员登陆，输入管理员编号和管理员密码<br>根据步骤1中留下的身份记录，若是教师，则将输入的教师编号，去数据库teacher表中比对，若找到相应信息，则登陆成功；若为管理员，则将输入的管理员编号和管理员密码，去数据库root表中比对，若用户名和密码同时符合，则登陆成功。登陆成功，进入对应的服务界面，</p></li><li><p>教师服务：<br>教师登陆后，程序根据之前教师输入的教师编号，去数据库proctoring_Information表中查找教师ID对应的考试ID，然后根据考试ID去数据库exam_Information表中查找对应的考试信息，将两个表中的查询结果合并起来(SQL语句实现)，并将查询结果使用对应数据结构保存起来(在纯后端中使用的是对应的对象，在前后端交互中是JSON序列化后的string)，并返回给调用函数的代码段，代码段负责将结果打印或者传递给前端。</p></li><li><p>管理员服务：</p><ol><li><p>考试信息导入<br>输入要增加的考试信息的编号、名称、开始时间、结束时间、考试地点。<br>获取后，后端会进行检查：</p><ol><li>考试编号是否已存在，若已存在，会返回对应通知</li><li>开始时间、结束时间是否符合正常时间规范，如月份不能超过12，每月天数规范，时分界限等</li><li>考试时间必须设置在当前时间的将来（调用time库文件，与当前时间比对）</li><li>考试的结束时间比如晚于考试的开始时间</li></ol><p>若检查无误，则会将根据开始时间与结束时间计算出考试总时长（将开始时间结束时间由字符串转换成为整型数据，然后相减，再将结果转化为字符串）</p></li><li><p>考试信息管理<br>在涉及到信息的增删改时，会将所有信息显示在最底侧，供增删改信息时查看比对</p><ol><li>增加监考信息<br>需要输入新增的监考信息的考试编号和教师编号，会进行监考是否重复存在、考试是否存在、教师是否存在的检查</li><li>删除考试信息<br>需要输入要删除的考试信息的考试编号，会进行考试是否存在的检查。同时由于考试信息被删除，对应的监考信息也应被删除。在执行之前会告知用户并询问是否继续。将信息传递给后端，后端调用数据库接口，执行对应SQL语句，删除之后会查找应被删除的考试信息，若查找结果为空，说明考试信息删除成功。</li><li>删除监考信息<br>需要输入考试编号和教师编号。逻辑同上。</li><li>更改考试信息<br>输入要更改的考试信息的考试编号。会进行考试是否存在的检查。需要更改某项信息，则在对应的一栏填写更改后的数据，不需要更改的信息不用填写。若考试信息的考试编号被更改，对应的监考信息也应被更改。在执行之前会告知用户并询问是否继续。将信息传递给后端，后端调用数据库接口，执行对应SQL语句，更改之后会查找应更改后的考试信息，若查找到对应的结果，说明考试信息更改成功。<br>在执行更改后查找的过程中，若考试信息的考试编号被更改，会使用更改后的考试编号进行查找。</li><li>更改监考信息<br>输入要更改的监考信息的考试编号和教师编号。逻辑同上。</li><li>查看信息<ol><li>查看全部考试信息</li><li>查看全部监考信息</li><li>查看全部安排了监考的考试信息<br>查询所有的监考信息，并将结果中的考试编号和教师编号分别作为考试信息表和教师信息表的查找条件，将三个表的查询结果合并，然后返回。</li><li>按条件查找考试信息<br>给出考试信息各元素的输入框，要根据哪几个信息查询，就在对应的框中输入信息。</li><li>按条件查找监考信息</li><li>按条件查找安排了监考的考试信息</li></ol></li></ol></li><li><p>教师信息管理，逻辑同上</p><ol><li>增加教师信息</li><li>删除教师信息</li><li>更改教师信息</li><li>查看全部教师信息</li><li>按条件查找教师信息</li></ol></li></ol></li></ol><h3 id="2-代码移植云服务器，并搭建相应环境"><a href="#2-代码移植云服务器，并搭建相应环境" class="headerlink" title="2.代码移植云服务器，并搭建相应环境"></a>2.代码移植云服务器，并搭建相应环境</h3><h4 id="环境搭建："><a href="#环境搭建：" class="headerlink" title="环境搭建："></a><strong>环境搭建：</strong></h4><ul><li>Linux MySQL安装<ul><li>安装MySQL<br><a href="https://blog.csdn.net/Yetao1996/article/details/124745730">CentOS7 下 C++ 连接 Mysql 数据库的环境配置以及常用API测试_centos7下:vs code如何配置c++与mysql数据库连接</a><br>也可以查看比特的mysql安装文档</li><li>安装mysql-devel实现cpp可以连接MySQL（可能不需要）</li></ul></li><li>httplib库安装<ul><li>CentOS7 cmake版本升级<br><a href="https://blog.csdn.net/llwy1428/article/details/95473542">记一次 Centos7 cmake 版本升级（由 v2.8.12.2 升级至 v3.14.5）</a></li><li>gcc版本升级，并设置为开启bash自动启动</li><li>安装httplib c++<br><a href="https://www.twle.cn/t/19375">C++ HTTP 库 cpp-httplib 使用(1) - 安装 - 简单教程，简单编程 (twle.cn)</a><br><a href="https://blog.csdn.net/m0_67470729/article/details/133562431">【Linux】【网络】工具：httplib 库的安装与简单使用_httplib使用</a></li></ul></li><li>jsoncpp库安装<br><a href="https://blog.csdn.net/Worthy_Wang/article/details/107045013">linux环境下开源库jsoncpp使用教程</a></li><li>本地vscode、xftps下载，便于编写代码、远程ssh连接服务器、向服务器传输数据</li></ul><h2 id="前端开发-amp-前后端交互："><a href="#前端开发-amp-前后端交互：" class="headerlink" title="前端开发&amp;前后端交互："></a>前端开发&amp;前后端交互：</h2><blockquote><p>前言：本人不精通前端技术，只是为实现此次程序现学现卖，也只了解到一些基础以及一些开发使用到的技术，若有笔误，请指正</p></blockquote><p>页面结构搭建：html<br>页面美化：css<br>页面控制、前后端交互：JS</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a><strong>思路：</strong></h3><p>在后端程序所在目录中新建一个前端文件夹，存放前端文件，cpp中设置将路径的根目录映射到前端文件目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202401071551829.png" alt="截屏2024-01-07 15.50.06" style="zoom: 38%;" /><p>在前端中，设置index.html、TeacherLogin.html、RootLogin.html三个页面，index.html为初始页面，选择登陆身份，选择教师则跳转到TeacherLogin，选择管理员跳转到RootLogin</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202401071602870.png" alt="截屏2024-01-07 16.00.29" style="zoom:25%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202401071602252.png" alt="截屏2024-01-07 16.00.36" style="zoom: 25%;" /><h3 id="前后端交互实现："><a href="#前后端交互实现：" class="headerlink" title="前后端交互实现："></a><strong>前后端交互实现：</strong></h3><ul><li><p>身份选择：在前端中添加JS控制段，获取”教师登陆“与”管理员登陆“按钮被单击的事件，编写函数，实现页面跳转</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202401071748577.png" alt="截屏2024-01-07 17.46.42" style="zoom: 50%;" /></li><li><p>登陆：在前端中添加JS控制段。编写函数，在”登陆”按钮被单击时，获取输入框中的内容，并提交表格。同时，通过AJAX，向指定路径发送网络请求。在后端中，cpp借助httplib库，监听特定端口下制定路径的请求，接受网络请求及传来的参数，进行后端操作，并将结果通过参数的形式响应给前端发送请求的AJAX。</p><div><center><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202401071752498.png" alt="截屏2024-01-07 17.52.26" style="zoom:50%;" /><br>JS前端代码示例</center></div><div><center><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202401071754330.png" alt="截屏2024-01-07 17.52.45" style="zoom:50%;" /><br>cpp后端代码示例</center></div><blockquote><p>此处AJAX传递参数的时候<br>可以选择上例中的，在url链接中拼接参数，采用健值对，第一个健值对与链接之间必须加上<code>?</code>，剩余健值对之间通过<code>&amp;</code><br>也可以采用JSON传递，在AJAX中增加一个data项，内容为JSON格式数据，在增加一个dataType项，用来表示数据采用的数据结构为JSON</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202401071802491.png" alt="截屏2024-01-07 18.01.35" style="zoom:50%;" /><p>前一种方式比较简便，但是当传递参数数目过多时，在前端经常报错。而JSON作为专用的网络传递数据结构，在网络传参中有十分优秀的性能，当要传递参数数目多时，要采用第二种方式。</p><p><a href="https://blog.csdn.net/yiguang_820/article/details/117988198">jQuery - $.ajax() data{} 传参三种常见写法及ajax()方法参数详解</a></p></blockquote></li><li><p>其余各中功能的前后端交互，都是基于上述模式。</p></li></ul><h3 id="界面元素显示与隐藏："><a href="#界面元素显示与隐藏：" class="headerlink" title="界面元素显示与隐藏："></a><strong>界面元素显示与隐藏</strong>：</h3><p>JS可以控制html元素的显示与隐藏，由此实现在不刷新界面、不跳转到其他界面情况下，页面内容动态更改的效果。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202401071810962.png" alt="截屏2024-01-07 18.10.24" style="zoom:50%;" /><h3 id="表格table的动态生成："><a href="#表格table的动态生成：" class="headerlink" title="表格table的动态生成："></a><strong>表格table的动态生成：</strong></h3><p>每次在后端获取到JSON类型的数据库查询结果后，相应的表格都需要动态刷新（本质是清空原表单、动态生成新表单）。借助JS功能实现。详细请见源码。或见此处<a href="https://blog.csdn.net/weixin_42579348/article/details/109992409">JavaScript(JS)网页–动态生成表格_js调用服务器接口,html实现网页表格</a></p><h3 id="设定input输入框输入，提交表单form后，html不刷新："><a href="#设定input输入框输入，提交表单form后，html不刷新：" class="headerlink" title="设定input输入框输入，提交表单form后，html不刷新："></a><strong>设定input输入框输入，提交表单form后，html不刷新：</strong></h3><p>默认情况下，当在input输入框输入后，点击提交submit，会将输入框所在的表单进行提交，同时html页面会刷新。由于此次采用的JS控制html元素来动态展示页面，因此页面刷新后会回到初始状态，不利于处理。需要更改成为，点击提交submit后不刷新html，同时还可以成功提交表单数据。<a href="https://blog.csdn.net/weixin_44999830/article/details/93495122">form表单的submit不重新刷新当前页面</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;Teacher_del_rfFrame&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Teacher_del_rfFrame&quot;</span> <span class="attr">src</span>=<span class="string">&quot;about:blank&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在html中，form元素结束位置下，添加如上代码，id、name自定义</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202401071825578.png" alt="截屏2024-01-07 18.21.49" style="zoom: 50%;" /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#root_Teacher_del&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;target&quot;</span>, <span class="string">&quot;Teacher_del_rfFrame&quot;</span>);</span><br></pre></td></tr></table></figure><p>在JS中，需要进行表单提交操作的函数中，加入上述代码，控制器中的id更换成对应表单的id，attr中第二个参数更改为之前html中添加的iframe元素的id，第一个参数保持不变。</p><h3 id="添加html网页中上传excel文件，并读取文件内容，转化为json供后端使用，转化为csv供前端展示："><a href="#添加html网页中上传excel文件，并读取文件内容，转化为json供后端使用，转化为csv供前端展示：" class="headerlink" title="添加html网页中上传excel文件，并读取文件内容，转化为json供后端使用，转化为csv供前端展示："></a>添加html网页中上传excel文件，并读取文件内容，转化为json供后端使用，转化为csv供前端展示：</h3><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202401082026858.png" alt="截屏2024-01-08 15.40.10" style="zoom:40%;" /><p><a href="https://blog.csdn.net/girl_Xiaomin/article/details/104490049">使用JavaScript实现纯前端读取excel文件并与后台进行交互_html 读excel?</a></p><p>上述方法中，将excel中内容读取，并转化为json数组（因为excel中结构是：第一行中各列为表头，其余行为表头对应的值，就看作为一个json数组），同时也转化为csv格式<br>上述方法中包括了将csv格式展现为表格并在页面中显示<br>关键是在使用AJAX传参时，如何传递JSON数组。一般情况下JSON传参是普通的JSON对象，即写成string类型就是左右一个大括号{}，里面为健值对。而此次获取的JSON数组，为[]中包含的一个个普通JSON对象，正常情况下无法通过AJAX传参。需要将JSON数组转化为JSON字符串，并作为AJAX传参的JSON对象健值对中的一个值。<a href="https://blog.csdn.net/bug_producter/article/details/114108250">Ajax传递数组</a></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202401082032829.png" alt="截屏2024-01-08 20.31.14" style="zoom: 40%;" /><p>后端接收到前端传递的JSON对象，通过键，找到对应的值，这个值就是JSON字符串化后的excel JSON数组。<br>注意，此时获取的只是一个字符串，并不是JSON数组类型，因此应先将字符串序列化为JSON类型，然后获取里面的值。<a href="https://www.cnblogs.com/wxmdevelop/p/4625208.html">Jsoncpp 数组的使用</a></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202401082033968.png" alt="截屏2024-01-08 20.33.01" style="zoom:50%;" /><h3 id="makefile编写："><a href="#makefile编写：" class="headerlink" title="makefile编写："></a>makefile编写：</h3><p>此项目的编译，设计多文件编程、mysql连接使用、httplib库连接使用、cppjson库连接使用</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test: test.o teacherProctoringSystem.o</span></span><br><span class="line">g++  -Wall -o test test.o teacherProctoringSystem.o  -L/usr/lib64/mysql -lmysqlclient -lpthread -ldl -lssl -lcrypto -lresolv -lm -lrt  -L /usr/local/lib /usr/local/lib/libjsoncpp.a</span><br><span class="line"><span class="section">test.o: test.cpp teacherProctoringSystem.h</span></span><br><span class="line">g++ -Wall -std=c++11 -c test.cpp -L/usr/lib64/mysql -lmysqlclient -lpthread -ldl -lssl -lcrypto -lresolv -lm -lrt  -L /usr/local/lib /usr/local/lib/libjsoncpp.a</span><br><span class="line"><span class="section">teacherProctoringSystem.o: teacherProctoringSystem.cpp teacherProctoringSystem.h </span></span><br><span class="line">g++ -Wall -std=c++11 -c teacherProctoringSystem.cpp -L/usr/lib64/mysql -lmysqlclient -lpthread -ldl -lssl -lcrypto -lresolv -lm -lrt  -L /usr/local/lib /usr/local/lib/libjsoncpp.a</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f test</span><br><span class="line">rm -f *.o</span><br></pre></td></tr></table></figure><p>在编译时要注意和相应的库要建立起动态链接，因此g++命令之后需要添加参数</p><p>使用<code>XXX_config</code>指令查看需要添加的参数</p><p>例如想要查看makefile时链接mysql时，g++后需要加什么参数，使用<code>mysql_config</code>指令，然后寻找-lib或-libs对应的即可</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202401071850128.png" alt="截屏2024-01-07 18.46.05" style="zoom:50%;" /><p><a href="https://blog.csdn.net/Yetao1996/article/details/124745730">CentOS7 下 C++ 连接 Mysql 数据库的环境配置以及常用API测试_centos7下:vs code如何配置c++与mysql数据库连接-CSDN博客</a></p><h3 id="项目部署Linux后台-amp-终止项目运行："><a href="#项目部署Linux后台-amp-终止项目运行：" class="headerlink" title="项目部署Linux后台&amp;终止项目运行："></a>项目部署Linux后台&amp;终止项目运行：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./test &amp;</span><br></pre></td></tr></table></figure><p>此条指令，是将当前工作目录下的可执行文件test启动（注意是可执行文件，因此必须要先编译过，生成可执行文件），并在允许在后台运行。关闭会话后，test进程也会一直在后台运行。</p><p>同时，会在当前工作目录生成<code>nohub.out</code>文件，用来保存test可执行程序中输出的值，例如cout输出的值，此时就会输入到<code>nohub.out</code>文件中。输入到的文件是可以自己指定的，默认为<code>nohub.out</code>。另外可以结合日志文件，将日志输出进去。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -axj |grep test</span><br></pre></td></tr></table></figure><p>查看当前正在运行的test进程，如下图，可以找到当前正在执行的test进程，第一行就是。第二列中的数字为该进程的PID</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202401071904900.png" alt="截屏2024-01-07 19.03.52" style="zoom:67%;" /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill 13187</span><br></pre></td></tr></table></figure><p>使用<code>kill</code>指令杀掉进程，后面的参数为要杀掉的进程的PID</p><h1 id="常见问题-amp-解决方案："><a href="#常见问题-amp-解决方案：" class="headerlink" title="常见问题&amp;解决方案："></a>常见问题&amp;解决方案：</h1><h3 id="SSH连接远程服务器缓慢："><a href="#SSH连接远程服务器缓慢：" class="headerlink" title="SSH连接远程服务器缓慢："></a>SSH连接远程服务器缓慢：</h3><p>在连接时，输入ssh指令后，没有反应，如要等待很久。或者输入密码之后很久才进入。</p><p>有可能是服务器内存、CPU占用过高，无法响应。可以登陆服务器官网如阿里云等，重启服务器实例。</p><p>也可能是链接中的问题：[SSH连接缓慢解决方法_ssh连接慢-CSDN博客](<a href="https://blog.csdn.net/tainyu/article/details/124317063#:~:text=%E4%B8%8B%E9%9D%A2%E8%AF%B4%E4%B8%8B%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E6%A0%B7%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E6%9C%80%E4%B8%BA%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E5%9B%A0%E4%B8%BAserver%E7%9A%84sshd%E4%BC%9A%E5%8E%BBDNS%E6%9F%A5%E6%89%BE%E8%AE%BF%E9%97%AE">https://blog.csdn.net/tainyu/article/details/124317063#:~:text=下面说下如何解决这样的问题，最为常见的原因是因为server的sshd会去DNS查找访问</a> client IP的hostname，如果DNS不可用或者没有相关记录，就会耗费大量时间。 1、在server上%2Fetc%2Fhosts文件中把你本机的ip和hostname加入配置文件中 [root@oral8 ],%23 cat %2Fetc%2Fhosts 192.168.1.55 oral8 2、在server上%2Fetc%2Fssh%2Fsshd_config文件中修改或加入UseDNS%3Dno，GSSAPIAuthentication no)</p><h3 id="g-internal-compiler-error-Killed-program-cc1plus-："><a href="#g-internal-compiler-error-Killed-program-cc1plus-：" class="headerlink" title="g++: internal compiler error: Killed (program cc1plus)："></a>g++: internal compiler error: Killed (program cc1plus)：</h3><p>内存不足，在程序make编译时，g++被后台杀死。</p><p>原因往往是内存不足，被操作系统杀掉。比如我的云服务器为2G2核，使用vscode远程连接时，vscode远程连接服务会占用很多内存，mysql数据库也会占用很多内存。</p><p>解决方法：</p><ul><li><p>方法一：设置swap交换分区（在物理机安装Linux系统时经常会需要进行配置，比如安装arch时）<br>可以先使用<code>free -m</code>指令查看一下内存分配情况。里面有物理内存，和swap分区内存，云服务器往往没有设置swap分区，此时需要我们手动设置。<br><a href="https://blog.csdn.net/weixin_41803041/article/details/79496016">g++: internal compiler error: Killed (program cc1plus) 解决办法-CSDN博客</a><br><a href="https://blog.csdn.net/zangba9624/article/details/118678416">gcc编译出现internal compiler error: Killed (program cc1plus)</a></p></li><li><p>方法二：使用<code>top</code>指令查看所有进程信息，然后在查看时使用<code>-k</code>加PID，终止进程，或者退出查看后<code>kill</code>掉进程。</p></li></ul><h3 id="执行g-或gcc时抱错找不到指令，或安装了更高版本gcc但使用时还是使用的低版本的："><a href="#执行g-或gcc时抱错找不到指令，或安装了更高版本gcc但使用时还是使用的低版本的：" class="headerlink" title="执行g++或gcc时抱错找不到指令，或安装了更高版本gcc但使用时还是使用的低版本的："></a>执行g++或gcc时抱错找不到指令，或安装了更高版本gcc但使用时还是使用的低版本的：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++ --version</span><br><span class="line">或</span><br><span class="line">g++ -V</span><br></pre></td></tr></table></figure><p>查看一下gcc或者g++版本</p><p>若抱错<code>command not found</code>等，说明gcc服务没有启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scl enable devstoolset-7 bash</span><br></pre></td></tr></table></figure><p>启动g++服务（enable后的参数根据个人g++版本等不同）</p><p>注意，通过这种方式启动后，只在本次会话中生效，一旦会话关闭，g++又会不可用</p><p>解决方法，设置每次打开会话时自动启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><p>更改shell的配置文件（此处我是用的是bash shell，若使用的zsh shell，则是更改~&#x2F;.zsh_profile）</p><p>打开后将<code>scl enable devtoolset-7 bash</code>添加到最后一行，保存后退出。这样每次启动会话shell都会自动启动g++。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>最后是配置文件生效</p><h3 id="启动mysql服务-amp-设置mysql开机自启动："><a href="#启动mysql服务-amp-设置mysql开机自启动：" class="headerlink" title="启动mysql服务&amp;设置mysql开机自启动："></a>启动mysql服务&amp;设置mysql开机自启动：</h3><p>启动mysql服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld.service</span><br></pre></td></tr></table></figure><p>设置mysql服务自启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable mysqld</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>附加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stl restart mysqld.service 重启mysql</span><br></pre></td></tr></table></figure><p>注：</p><blockquote><p><code>scl</code>指令就是<code>systemctl</code>指令的缩写，二者是一个功能</p><p>全称systemcontrol</p></blockquote><h1 id="源码Gitee链接-amp-个人博客链接-amp-教师监考管理系统网址："><a href="#源码Gitee链接-amp-个人博客链接-amp-教师监考管理系统网址：" class="headerlink" title="源码Gitee链接&amp;个人博客链接&amp;教师监考管理系统网址："></a>源码Gitee链接&amp;个人博客链接&amp;教师监考管理系统网址：</h1><p><a href="https://gitee.com/c-yujin/teacherproctoringsystem/tree/master/">项目源码地址</a></p><p><a href="https://chunyujin.top/">个人博客:🏴‍☠️浴巾的贼船🏴‍☠️ (chunyujin.top)</a></p><p>教师监考管理系统网站：8.130.72.133:8081</p>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch试玩</title>
      <link href="/chunyujin/ca75e8e2.html"/>
      <url>/chunyujin/ca75e8e2.html</url>
      
        <content type="html"><![CDATA[<p>等待折腾and更新中—</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Arch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Arch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode中设置工作台颜色</title>
      <link href="/chunyujin/525df755.html"/>
      <url>/chunyujin/525df755.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于远程Linux服务器的oh-my-zsh主体文字颜色在主题中不好更改，此处采用更改vscode本地终端主体文字颜色的方法，实现远程连接Linux时，自定义主体文字颜色</p></blockquote><p>通过将以下内容添加到用户设置中：<br>ctrl + , 并搜索 workbench（工作台)【或者在设置中找到工作台】，进入“外观”，找到“Color Customization”，然后点击「Edit in settings.json」（在settings.json中编辑）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202312080943844.png" alt="截屏2023-12-08 09.43.04" style="zoom:50%;" /><p>在最后加上如下语句:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//终端颜色配置</span></span><br><span class="line"><span class="attr">&quot;workbench.colorCustomizations&quot;</span> <span class="punctuation">:</span> </span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="comment">//可以将鼠标放到下面的色号上根据自己的偏好进行选择</span></span><br><span class="line"><span class="attr">&quot;terminal.foreground&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;#37FF13&quot;</span><span class="punctuation">,</span> <span class="comment">//主体文字颜色，此处设置的绿色</span></span><br><span class="line"> <span class="attr">&quot;terminal.background&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;#2b2424&quot;</span> <span class="comment">//背景颜色，可以不设置，保持与主题一致</span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>更改前后：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202312081023546.png" alt="截屏2023-12-08 10.20.07" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202312081024865.png" alt="截屏2023-12-08 10.20.17" style="zoom:50%;" /><p>另外还可以进行字体以及字体大小修改<br>“terminal.integrated.cursorBlinking”: true,<br>“terminal.integrated.lineHeight”: 1.2,<br>“terminal.integrated.letterSpacing”: 0.1,<br>“terminal.integrated.fontSize”: 15, &#x2F;&#x2F;字体大小设置<br>“terminal.integrated.fontFamily”: “Lucida Console”, &#x2F;&#x2F;字体设置<br>“terminal.integrated.shell.linux”: “&#x2F;bin&#x2F;zsh”,</p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>item2更改主体文字颜色</title>
      <link href="/chunyujin/dfcd45c4.html"/>
      <url>/chunyujin/dfcd45c4.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于远程连接的Linux服务器配置好oh-my-zsh之后，本地的现实也会改变，但是更改主体文字颜色等操作比较繁琐，因此通过更改本地终端，此处是item2，来更改本地的主体文字颜色，更简单</p></blockquote><p>打开设置中的颜色设置</p><p>此处foreground（前景）即为主体文字颜色，默认为白色</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202312081014893.png" alt="截屏2023-12-08 10.12.01" style="zoom: 50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202312081015832.png" alt="截屏2023-12-08 10.13.13" style="zoom:50%;" /><p>更改为与右侧表中ansi color的bright green一致</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202312081015583.png" alt="截屏2023-12-08 10.13.26" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202312081015237.png" alt="截屏2023-12-08 10.13.30" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac上更改鼠标指针外观</title>
      <link href="/chunyujin/cfd78e0.html"/>
      <url>/chunyujin/cfd78e0.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mac上更改鼠标指针外观"><a href="#Mac上更改鼠标指针外观" class="headerlink" title="Mac上更改鼠标指针外观"></a>Mac上更改鼠标指针外观</h1><p>前言：</p><blockquote><p>此教程在Mac上更改鼠标外观，是基于Mac上mousecape软件来进行的</p><p>需要的鼠标外观材料来源于Windows的鼠标指针文件(.ani后缀)，将其先转化成每一帧的gif文件，再借助PS将gif文件拼接成为竖版长png，最后导入mousecape进行设置</p><p>另外，mousecape只能生效更改后的图标，如果一些指针图标并未设置，是不会显示的，这也是本人后期放弃使用的原因（即不实用，我还是老实选择了原生指针，这一点上Windows自定义做的真好）</p></blockquote><p><a href="https://github.com/alexzielenski/Mousecape/releases">mousecape下载地址_GitHub</a></p><h2 id="1-ani文件分帧转化为gif文件"><a href="#1-ani文件分帧转化为gif文件" class="headerlink" title="1.ani文件分帧转化为gif文件"></a>1.ani文件分帧转化为gif文件</h2><p>选择想要更改的鼠标指针文件，此处使用的是<a href="https://www.bilibili.com/video/BV12Q4y1J791/?spm_id_from=333.999.0.0">【无职转生】艾莉丝动态鼠标指针 by:夹心酱のATM_</a>（在此感谢up主，本文章声明不会用于商用）</p><p>下载好之后，解压并打开，里面包含为一些.ani文件和Windows上的指针安装程序，此处我们只需要.ani文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202311291753855.png" alt="截屏2023-11-29 17.53.04" style="zoom:33%;" /><p>进入网站<a href="https://ezgif.com/ani-to-gif">https://ezgif.com/ani-to-gif</a></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202311291755202.png" alt="截屏2023-11-29 17.55.06" style="zoom:33%;" /><p>点击“选取文件”，选择一个ani文件，然后点击“Upload”</p><blockquote><p>此处注意，Mac上的指针只有部分支持修改外观，具体可以查看Apple官方文档</p><p>此处借助<a href="https://www.cnblogs.com/xuanyu-10-18/p/12901954.html%E7%9A%84%E5%9B%BE%E7%89%87%EF%BC%9A">https://www.cnblogs.com/xuanyu-10-18/p/12901954.html的图片：</a></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202311291758617.png" alt="截屏2023-11-29 17.57.39" style="zoom:50%;" /></blockquote><p>等待文件上传到网站，完成后如下图所示，点击“Convert to GIF”进行转化：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202311291800624.png" alt="截屏2023-11-29 17.59.53" style="zoom: 25%;" /><p>完成后可以在下方输出栏中看到，然后选择“split”，将git分帧</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202311291802083.png" alt="截屏2023-11-29 18.01.50" style="zoom: 25%;" /><p>点击图示选项，下载文件图集压缩包</p><blockquote><p>建议对于压缩包进行重命名，并且命名中包含下图中的“frames”对应的值，此为gif图片原本的帧，也是转化后的git图片的个数，数值需要在后续mousecape中设置使用</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202311291803245.png" alt="截屏2023-11-29 18.03.10" style="zoom: 33%;" /><p>按照以上方式，将其余的ani文件转化为gif即可</p><h2 id="2-将gif文件拼接成长png"><a href="#2-将gif文件拼接成长png" class="headerlink" title="2.将gif文件拼接成长png"></a>2.将gif文件拼接成长png</h2><p>选择一个gif系列中的gif文件，选择通过ps打开（此处我是在Windows上操作的，Mac同理）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202311291815353.png" alt="屏幕截图 2023-11-29 171625" style="zoom:60%;" /><p>选择右上角的搜索，输入“RGB”，选择“RGB颜色”</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202311291819008.png" alt="屏幕截图 2023-11-29 171647" style="zoom:60%;" /><p>选择左上角“图像”，更改画布大小，更改纵向的大小，设置为单张gif的长度 ✖️ gif数</p><blockquote><p>注意，由于mousecape软件的问题，不支持帧大于15（否则显示的时候会出现上一帧部分画面保留到下一帧之类的bug），因此在设置gif数的时候要注意抽取出一些不关键的帧，防止超出15帧</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202311291832097.png" alt="屏幕截图 2023-11-29 171724" style="zoom:60%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202311291832280.png" alt="屏幕截图 2023-11-29 171711" style="zoom:60%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202311291832583.png" alt="屏幕截图 2023-11-29 171746" style="zoom:60%;" /><p>然后开始按照序号从小到大从上到下排列，将gif拖入</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202311291834941.png" alt="屏幕截图 2023-11-29 171853" style="zoom:50%;" /><p>完成后，点击左上角“文件”，选择“导出”，“快速导出为PNG”</p><h2 id="3-在mousecape中进行设置"><a href="#3-在mousecape中进行设置" class="headerlink" title="3.在mousecape中进行设置"></a>3.在mousecape中进行设置</h2><p>打开mousecape，左上角选择file-&gt;new cape，创建一个新的项目</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202311291845583.png" alt="截屏2023-11-29 18.45.12" style="zoom:50%;" /><p>右击项目，选择edit</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202311291907950.png" alt="截屏2023-11-29 19.07.06" style="zoom:50%;" /><p>点击左下角加号，创建新的指针图标</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202311291908097.png" alt="截屏2023-11-29 19.08.02" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202311291909454.png" alt="截屏2023-11-29 19.09.01" style="zoom:50%;" /><p>Type为指针类型，在步骤一中给出了mac支持修改的指针类型，选择时只能选择支持修改的类型，否则修改了也不生效</p><p>然后将步骤2中生成的对应的png图像拉入下面1x、2x、5x、10x中的任意一个即可（此处为预览框，预览修改结果）</p><p>然后对于具体内容进行配置：<br>Frames：刷新帧率，即步骤二中合成png使用的gif的数量，要填写一致，比如拖入的png帧为17，此处就为17</p><p>Frame Duration：每帧的更新速度，个人建议设置为0.1～0.2之间体验较好，具体数值依据实际情况修改即可</p><p>Hot Spot：指针的标识点，即有效点击的位置，以png图片最左上角为原点的坐标，此处本人设置为{4,4}，会在预览框中以红点的形式标识出来</p><p>Size：实际大小，即光标的大小，依据实际情况自己修改即可，但要注意Size中的长宽设置一致</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202311291916693.png" alt="截屏2023-11-29 19.16.38" style="zoom:50%;" /><p>全部设置完成后，右击项目选择“Apply”即可</p><p>项目以“.cape“文件的形式保存，右击项目，选择“show in finder“可查看finder中的cape，可以用来跟别人分享。使用别人分享的cape时，直接打开cape文件即可将项目写入到mousecape。</p><h2 id="4-附上制作完成的无职转生-艾莉丝像素指针文件，以及mousecape软件安装包"><a href="#4-附上制作完成的无职转生-艾莉丝像素指针文件，以及mousecape软件安装包" class="headerlink" title="4.附上制作完成的无职转生-艾莉丝像素指针文件，以及mousecape软件安装包"></a>4.附上制作完成的无职转生-艾莉丝像素指针文件，以及mousecape软件安装包</h2><p>指针文件中包含成品’.cape’文件，和用于制作的png、gif文件，可自定义或直接使用成品</p><p>百度网盘：</p><p>[无职转生-艾莉丝像素指针文件](链接: <a href="https://pan.baidu.com/s/1baDFom6mYrJTTVEYqwjvZg?pwd=wr23">https://pan.baidu.com/s/1baDFom6mYrJTTVEYqwjvZg?pwd=wr23</a> ) ，提取码: wr23</p><p>[mousecape软件](链接: <a href="https://pan.baidu.com/s/1Uj1JcDYjJByna0H-ef-j5g?pwd=eqx2">https://pan.baidu.com/s/1Uj1JcDYjJByna0H-ef-j5g?pwd=eqx2</a> )，提取码: eqx2</p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>butterfly修改白天模式下主界面字体颜色</title>
      <link href="/chunyujin/4307f2c8.html"/>
      <url>/chunyujin/4307f2c8.html</url>
      
        <content type="html"><![CDATA[<h2 id="修改标题和副标题文字颜色："><a href="#修改标题和副标题文字颜色：" class="headerlink" title="修改标题和副标题文字颜色："></a>修改标题和副标题文字颜色：</h2><p>打开文件themes&#x2F;butterfly&#x2F;source&#x2F;css&#x2F;_layout&#x2F;head.styl</p><p>在大约第37和44行开始</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202311081121958.png" alt="截屏2023-11-08 11.17.41" style="zoom:50%;" /><p>在“color”这一行中更改里面的颜色</p><p>修改前：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202310102242968.png" alt="截屏2023-10-10 22.18.54" style="zoom:67%;" /><p>修改后：（只关注文字颜色，背景颜色因为更换了背景图片所以不同</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202311081122714.png" alt="截屏2023-11-08 11.17.54" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202310102243451.png" alt="截屏2023-10-10 22.18.59" style="zoom:67%;" /><blockquote><p>43行的颜色参数与网站左上角标题遮罩相关，白色为透明，在移动端表现明显，如果设置为黑色，则会看到黑色方形遮罩，此处仍设置为白色</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202311081047401.jpeg" alt="IMG_2032" style="zoom: 25%;" /></blockquote><h2 id="修改顶部菜单文字颜色："><a href="#修改顶部菜单文字颜色：" class="headerlink" title="修改顶部菜单文字颜色："></a>修改顶部菜单文字颜色：</h2><p>打开文件themes&#x2F;butterfly&#x2F;source&#x2F;css&#x2F;_layout&#x2F;head.styl</p><p>在大约第268行开始</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202310102244840.png" alt="截屏2023-10-10 22.36.06" style="zoom:50%;" /><p>在“color”这一行中更改里面的颜色</p><p>修改前：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202310102245862.png" alt="截屏2023-10-10 22.36.22" style="zoom:50%;" /><p>修改后：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202310102245932.png" alt="截屏2023-10-10 22.36.37" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202310102246548.png" alt="截屏2023-10-10 22.46.10" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>butterfly修改白天模式下主界面封面亮度</title>
      <link href="/chunyujin/b26ad9ce.html"/>
      <url>/chunyujin/b26ad9ce.html</url>
      
        <content type="html"><![CDATA[<p>打开文件themes&#x2F;butterfly&#x2F;source&#x2F;css&#x2F;_layout&#x2F;head.styl</p><p>在大约第10行开始</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202310102153242.png" alt="截屏2023-10-10 21.07.43" style="zoom:67%;" /><p>在“background-color”这一行中可以调整小数值的大小，来控制页脚图片颜色深度，小数值越大，颜色越深</p><p>修改前：</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202310102155486.png" alt="截屏2023-10-10 21.50.03"></p><p>修改后：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202310102154700.png" alt="截屏2023-10-10 21.49.48" style="zoom:67%;" /><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202310102155325.png" alt="截屏2023-10-10 21.50.09"></p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim批量注释/删除注释</title>
      <link href="/chunyujin/ebc9f1b9.html"/>
      <url>/chunyujin/ebc9f1b9.html</url>
      
        <content type="html"><![CDATA[<h1 id="vim批量注释-x2F-删除注释"><a href="#vim批量注释-x2F-删除注释" class="headerlink" title="vim批量注释&#x2F;删除注释"></a>vim批量注释&#x2F;删除注释</h1><p>注释：</p><ol><li><p>control + v 进入 V-BLOCK模式（可视化块模式）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202309241717010.png" alt="1" style="zoom: 33%;" /></li><li><p>使用上下（k、j）移动选定要注释的行【左右（h、l）则是选择列】</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202309241717087.png" alt="2" style="zoom: 33%;" /></li><li><p>shift + i （大写i）进入插入模式</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202309241717530.png" alt="3" style="zoom:33%;" /></li><li><p>输入注释符 &#x2F;&#x2F; 或 #</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202309241718984.png" alt="4" style="zoom:33%;" /></li><li><p>连续按两次ESC，完成</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202309241718806.png" alt="5" style="zoom:33%;" /></li></ol><p>删除注释：</p><ol><li><p>control + v 进入 V-BLOCK模式（可视化块模式）</p></li><li><p>使用上下（k、j）移动选定要注释的行，如果注释为 &#x2F;&#x2F;，则使用左右（h、l）选择两列</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202309241718058.png" alt="6" style="zoom:33%;" /></li><li><p>d，删除注释</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202309241718849.png" alt="7" style="zoom:33%;" /></li></ol>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下gdb使用gdb命令时显示找不到文件</title>
      <link href="/chunyujin/174f5f3e.html"/>
      <url>/chunyujin/174f5f3e.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux下gdb使用gdb命令时显示找不到文件"><a href="#Linux下gdb使用gdb命令时显示找不到文件" class="headerlink" title="Linux下gdb使用gdb命令时显示找不到文件"></a>Linux下gdb使用gdb命令时显示找不到文件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">报错信息如下：</span><br><span class="line">No symbol table is loaded.  Use the &quot;file&quot; command.</span><br></pre></td></tr></table></figure><p>原因：在编译时没有使用对应选项生成可调试文件</p><p>解决方法：在编译时，在依赖文件前加入 -g选项</p><p>更改前makefile的部分内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">process: process.c</span><br><span class="line">gcc -o process process.c</span><br></pre></td></tr></table></figure><p>更改后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">process: process.c</span><br><span class="line">gcc -g process.c -o process</span><br></pre></td></tr></table></figure><blockquote><p>注意事项，关于 gcc 命令后面文件的顺序问题</p><ol><li>-o 选项没有明确要求依赖文件和目标文件的前后顺序，因为在第一行中已经指出了依赖文件和目标文件。所以-o、目标文件、依赖文件三者何种顺序都可以</li><li>-g 选项唯一要求就是后面紧跟依赖文件，其他无要求</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回车vs换行</title>
      <link href="/chunyujin/70e96f28.html"/>
      <url>/chunyujin/70e96f28.html</url>
      
        <content type="html"><![CDATA[<h1 id="回车vs换行"><a href="#回车vs换行" class="headerlink" title="回车vs换行"></a>回车vs换行</h1><p>回车和换行都只是一个单纯的动作</p><p>回车：光标移动到当前行的最开始 \r</p><p>换行：光标保持当前位置，仅向下平移一行 \n</p><blockquote><p>回车：</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202309071656179.gif" alt="Sep-07-2023 16-55-14"></p><p>换行：</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202309071656462.gif" alt="Sep-07-2023 16-55-51"></p></blockquote><p>我们平时说的“回车”或者“换行”，以及C语言中的换行符“\n”，其实是 回车+换行   \r+\n</p><p>就是先回车后换行：先移动到当前行的最开始，再移动到下一行</p><p>或者先换行后回车：先移动到下一行，再移动到最开始</p><blockquote><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202309071658062.gif" alt="Sep-07-2023 16-58-34"></p></blockquote><p>C语言中\n会清空缓冲区</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个例子简单学习gcc、makefile、程序执行过程</title>
      <link href="/chunyujin/dbf58e01.html"/>
      <url>/chunyujin/dbf58e01.html</url>
      
        <content type="html"><![CDATA[<p>test.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>test.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">show();</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形成main.c的可执行程序hello：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello main.c test.c</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li>-o选项后面紧跟着的名称为可执行程序的名称，-o + ”可执行程序名称“可以出现在依赖对象的前面，也可以在后面。比如<code>gcc main.c test.c -o hello</code>也是可以的</li><li>gcc指令用于编译形成.c文件的可执行程序。g++指令用于编译形成.cpp或者.c文件的可执行程序。g++向下兼容，但是gcc只能编译.c文件。g++的大部分指令与gcc一致</li></ol></blockquote><p>这里可能会产生疑问：test.h里包含了show方法的声明，为什么不依赖这个头文件呢</p><p>因为头文件在预处理阶段已经在main.c 和test.c 里面展开了</p><p>makefile写法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">makefile</span></span><br><span class="line">hello:main.c test.c </span><br><span class="line">gcc main.c test.c -o hello #此处开头一定是缩进</span><br><span class="line"></span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">rm -f hello</span><br></pre></td></tr></table></figure><blockquote><ol><li>makefile文件是自顶向下执行的，只执行第一个行程目标文件的依赖方法</li><li>在makefile中，hello是目标文件，第一行的main.c 和test.c 为目标文件的依赖文件（依赖对象），<code>hello:main.c test.c </code>为二者的依赖关系，<code>gcc main.c test.c -o hello</code>为依赖方法</li><li>倒数第二行中，<code>clean:</code>也为一个依赖关系，依赖关系是可以没有依赖对象的，这个就没有。<code>.PHONY</code>为makefile里的一个关键字，作用是使后面的方法“总是被执行”<ol><li>每个文件都有三个时间：ACM时间<ol><li><p>A(ACCESS)：访问时间（读取时间）。在文件的操作中，读取是最频繁的（文件夹也属于文件），在Linux内核2.6、2.7之前，文件的每次访问都会刷新ACCESS时间，因此每次会消耗大量资源来复写文件ACCESS时间，效率极低。在更新之后，文件访问次数每次累计到一定值才会更新ACCESS时间为最后一次访问时间。</p></li><li><p>C(CHANGE)：改动时间。文件内容被修改的最后一次时间。</p></li><li><p>M(MODIFY)：更改时间。文件属性被修改的最后一次时间。文件大小、名称、权限等等都属于文件属性，所以文件内容的修改有时候也会影响文件属性，比如文件内容增多文件大小变大。</p></li><li><p>三个时间在系统下的显示顺序是A、M、C，指令<code>stat 文件</code>查看文件信息：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202309071221082.png" alt="截屏2023-09-07 12.20.28" style="zoom:50%;" /></li></ol></li><li>一定是源文件先存在，然后通过编译，形成可执行程序，因此源文件M时间一定早于可执行程序M时间。如果源文件M时间早于可执行程序M时间，此时再进行编译，是不会产生新的可执行程序覆盖原可执行程序的，因为认为源文件没有改动，没必要重新生成可执行程序。当源文件更改之后，M时间会更新，肯定比原可执行程序新，此时再次进行编译，系统比对两者M时间之后发现源文件更新，因此会生成新的可执行程序覆盖原可执行程序。</li><li>“总是被执行”的意义就在于，无论依赖对象的M时间是否早于目标文件，都会执行依赖方法。因此<code>.PHONY:clean</code>作用就是无论可执行程序hello的新旧、是否存在，总是会执行<code>rm -f hello</code>来删除掉hello</li></ol></li><li>指令<code>make</code>来执行makefile里的生成可执行程序的依赖方法。指令<code>make clean</code>来执行makefile里面删除hello的方法</li></ol></blockquote><p>c、cpp程序执行过程：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202309071236125.png" alt="截屏2023-09-07 12.35.10" style="zoom: 33%;" /><p>.c .h <strong>预处理</strong>（头文件展开等） 形成.i  </p><blockquote><p>gcc指令为<code>gcc -E test.h test.c</code>，可以加-o选项指定生成的名称，默认名称跟.c文件的名称一样，下同</p></blockquote><p><strong>编译</strong>形成 .s汇编文件</p><blockquote><p>gcc指令为<code>gcc -S test.i</code></p></blockquote><p><strong>汇编</strong>形成 .o二进制文件（目标文件）</p><blockquote><p>gcc指令为<code>gcc -c test.s</code></p><p>此处“目标文件”含义和上面makefile中的“目标文件”含义不同，makefile中的含义是目标要形成的文件，而此处的名字就叫做”目标文件“</p></blockquote><p>（与库文件）<strong>链接</strong>形成 -out可执行程序</p><blockquote><p>gcc指令为<code>gcc test.s</code>，默认生成文件名称为a.out，可以加-o选项指定名称，名称可不加.out后缀</p></blockquote><blockquote><p>文件后缀的记忆方法：iso </p><p>gcc指令的记忆方法：ESc，c是小写</p></blockquote><p>注意，gcc指令是的含义是”进行到这一步为止“，因此每步的gcc指令并不依赖上一步的生成的文件</p><p>比如可以直接令.c文件进行到汇编结束，生成.o文件<code>gcc -c test.c</code></p><p>或者直接.c文件生成可执行程序<code>gcc test.c</code></p><p>在一般的编译器下，会保留生成.o目标文件，然后将目标文件统一链接形成可执行文件</p><p>几个.c源文件就会生成几个.o目标文件</p><p>如果想要在makefile中，先形成.o目标文件，然后再链接形成可执行文件，写法为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hello:test.o main.o</span><br><span class="line">gcc test.o main.o -o hello</span><br><span class="line">test.o:test.c</span><br><span class="line">gcc -c test.c</span><br><span class="line">main.o:main.c</span><br><span class="line">gcc -c main.c</span><br><span class="line"></span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">rm -f *.o hello</span><br></pre></td></tr></table></figure><blockquote><ol><li>makefile自顶向下执行，在执行第一条的时候，找不到依赖的.o文件，会向下执行和寻找</li><li>clean此处使用了通配符*，删除当前目录下所有.o结尾的文件</li></ol></blockquote><p>更多内容查看<a href="https://chunyujin.top/chunyujin/81144cba">“Makefile初学指南”</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统作业：各大系统的区别</title>
      <link href="/chunyujin/fbd22043.html"/>
      <url>/chunyujin/fbd22043.html</url>
      
        <content type="html"><![CDATA[<p>试从技术架构、应用场景、开放性、用户界面、价格（包括但不限于） 等方面比较Windows、安卓、Linux. Mac os.鸿蒙操作系统。（第一行写明你采用何种方式完成该项作业）。</p><h1 id="技术架构："><a href="#技术架构：" class="headerlink" title="技术架构："></a>技术架构：</h1><h2 id="Windows系统架构："><a href="#Windows系统架构：" class="headerlink" title="Windows系统架构："></a>Windows系统架构：</h2><p>Windows系统架构采用分层架构，自下而上分为内核态和用户态，Windows的内核为混合内核（本质上为宏内核架构，并非微内核）。</p><p>内核态自下而上分为硬件抽象层（HAL）-&gt;内核和驱动层 -&gt;执行体，以及窗口管理系统。用户态主角是NTDLL抽象层，以及各种进程，如：底层的系统支持进程-&gt;服务进程-&gt;用户应用程序。如下图所示：<a href="https://blog.51cto.com/u_14207158/2353734#:~:text=%E4%BD%9C%E4%B8%BA%E6%9C%80%E6%B5%81%E8%A1%8C%E7%9A%84%E7%9A%84%E6%A1%8C%E9%9D%A2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8CWindows%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%9C%A8%E7%BB%8F%E5%8E%86%E6%95%B0%E6%AC%A1%E7%A1%AC%E4%BB%B6%E9%9D%A9%E5%91%BD%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%85%B6%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%B9%9F%E5%9F%BA%E6%9C%AC%E7%A8%B3%E5%AE%9A%EF%BC%8C%E5%BE%AE%E8%BD%AF%E5%8F%B7%E7%A7%B0Windows,10%E6%98%AF%E6%9C%80%E5%90%8E%E4%B8%80%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%B9%B6%E7%BB%9F%E4%B8%80%E4%BA%86Windows%E5%90%84%E7%89%88%E6%9C%AC%E7%9A%84%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84%E3%80%82%20Windows%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%88%86%E5%B1%82%E7%9A%84%E6%9E%B6%E6%9E%84%EF%BC%8C%E4%B8%BB%E8%A6%81%E5%88%86%E4%B8%BA%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81%EF%BC%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E5%88%86%E4%B8%BA%E7%A1%AC%E4%BB%B6%E6%8A%BD%E8%B1%A1%E5%B1%82%EF%BC%88HAL%EF%BC%89-%3E%E5%86%85%E6%A0%B8%E5%92%8C%E9%A9%B1%E5%8A%A8%E5%B1%82-%3E%E6%89%A7%E8%A1%8C%E4%BD%93%EF%BC%8C%E4%BB%A5%E5%8F%8A%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E3%80%82">图片来源：51CTO博客</a></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202309061524213.png" alt="截屏2023-09-06 15.23.24" style="zoom:50%;" /><p>Windows、Linux、macOS三大系统都基本是由Unix系统衍生而来的</p><p>Windows操作系统借鉴了Unix“树”的思想，Linux借鉴了Unix操作系统的思想，而macOS则是Unix的衍生系统之一，是苹果公司基于FreeBSD操作系统的改造，苹果操作系统只不过是UNIX的一个细小分支而已。</p><h2 id="Linux系统架构："><a href="#Linux系统架构：" class="headerlink" title="Linux系统架构："></a>Linux系统架构：</h2><p>Linux 只是指操作系统的核心, 并没有各种应用程序, 如网络工具、多媒体软件等。因此现在市场上有很多种Linux Kernel 为核心再集成搭配各式各样的系统程序或应用工具程序组成的一套完整的操作系统。</p><p>Linux是可以任意包装自由配置的东西。任何一个人，一家公司 都可以按照自己的想法，比如加一点功能，加中文支持，作一个Linux出来。这些 Linux虽然核心部分都一样，但是他们所带的各种软件，缺省的配置都不一样。</p><p><strong>Linux</strong> <strong>内核版本</strong>就是Linux的核心版本 由官网 <a href="http://www.kernel.org/">www.kernel.org</a> 发布</p><p><strong>Linux</strong> <strong>发行版本</strong>就是各个公司的在Linux核心版本上就行包装，添加想要的内容，这就衍生出非常多的发行版本，如下图所示。譬如的redhat, CentOS, 红旗、Ubuntu等，这些都是的Linux衍生操作系统。</p><p>Linux系统一般有4个主要部分：</p><p>内核、shell、文件系统和应用程序</p><p>内核、shell和文件系统一起形成了基本的操作系统结构，它们使得用户可以运行程序、管理文件并使用系统。</p><p>Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。如图：<a href="https://blog.csdn.net/hguisu/article/details/6122513">图片来源：CSDN博客</a></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202309061531516.png" alt="截屏2023-09-06 15.31.31" style="zoom:50%;" /><p> Linux系统将自身划分为两部分，一部分为核心软件，即是kernel，也称作<a href="http://baike.baidu.com/view/4271323.htm">内核空间</a>，另一部分为普通应用程序，这部分称为用户空间。</p><p>应用程序是无法直接访问硬件资源的，需要通过<strong>通过内核</strong>SCI 层提供的接口来访问硬件资源。<a href="https://blog.csdn.net/hguisu/article/details/6122513">图片来源：CSDN博客</a></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202309061535004.png" alt="截屏2023-09-06 15.35.06" style="zoom:50%;" /><p>Windows操作系统倾向于将更多的功能集成到操作系统内部，并将程序与内核相结合；而Linux不同于Windows，它的内核空间与用户空间有明显的界限。根据设计架构的不同，两者都可以使操作系统更加安全。</p><h2 id="macOS系统架构："><a href="#macOS系统架构：" class="headerlink" title="macOS系统架构："></a>macOS系统架构：</h2><p>苹果系统把其操作系统分为四个层次，分别为应用层，应用框架层、核心框架层，还有就是Darwin。如下图所示：<a href="https://blog.csdn.net/jyl_sh/article/details/105812487">图片来源：CSDN</a></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202309061630697.png" alt="截屏2023-09-06 16.30.01" style="zoom:33%;" /><p>核心架构为Darwin架构，其中EFI指的就是EFI在概念上非常类似于一个低阶的操作系统，并且具有操控所有硬件资源的能力</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202309061631384.png" alt="截屏2023-09-06 16.31.36" style="zoom: 33%;" /><p> Mac OS X的内核环境主要包括了Mach微内核和BSD内核，其中BSD部分主要来自FreeBSD。</p><h2 id="安卓系统架构："><a href="#安卓系统架构：" class="headerlink" title="安卓系统架构："></a>安卓系统架构：</h2><p>安卓系统是基于linux的宏内核设计：宏内核包含了操作系统绝大多数的功能和模块，而且这些功能和模块都具有最高的权限，只要一个模块出错，整个系统就会崩溃，这也是安卓系统容易崩溃的原因。好处就是系统开发难度低。<a href="https://zhuanlan.zhihu.com/p/26100298">图片来源：知乎</a></p><div>  <center>  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202309061615298.png" alt="截屏2023-09-06 16.14.27"        style="zoom:50%;" />    <br>    Android系统启动架构图    </center></div><p>自下向上分为：Loader层- &gt; Linux宏内核层 -&gt; 硬件抽象层HAL -&gt;  Android Runtime&amp;系统库 -&gt; Framework层 -&gt; App层</p><p>安卓系统是运行在Linux宏内核之上的Java虚拟机中的。</p><h2 id="鸿蒙系统架构："><a href="#鸿蒙系统架构：" class="headerlink" title="鸿蒙系统架构："></a>鸿蒙系统架构：</h2><p>鸿蒙操作系统是微内核设计：微内核仅包括了操作系统必要的功能模块（任务管理、内存分配等）处在核心地位具有最高权限，其他模块不具有最高权限，也就是说其他模块出现问题，对于整个系统的运行是没有阻碍的。</p><p>HarmonyOS整体遵从分层设计，从下向上依次为：内核层、系统服务层、框架层和应用层。系统功能按照“系统 &gt; 子系统 &gt; 功能&#x2F;模块”逐级展开，在多设备部署场景下，支持根据实际需求裁剪某些非必要的子系统或功能&#x2F;模块。HarmonyOS技术架构如下所示。<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/harmonyos-overview-0000000000011903">图片来源：华为开发者文档</a></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202309061624813.png" alt="截屏2023-09-06 16.24.23" style="zoom:50%;" /><p>鸿蒙OS也是运行在Linux内核之上，但是是运行在Linux微内核之上，且使用自研编译器取代Java虚拟机。因此理论上，性能、稳定性和安全性高于安卓。</p><h1 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h1><table><thead><tr><th>Windows</th><th>安卓</th><th>Linux</th><th>macOS</th><th>鸿蒙</th></tr></thead><tbody><tr><td>桌面级操作系统，家用 、个人、娱乐、企业、商业各个领域都有</td><td>移动终端操作系统，现已进入到每个人的生活中，手机、平板电脑、嵌入式家电</td><td>常用于服务器，移动端、云计算、AI技术以及嵌入式等各个领域</td><td>苹果Macintosh系列电脑上的操作系统，是苹果公司独有的封闭操作系统，所有应用需要苹果公司的审核。涉及桌面级操作系统各个领域</td><td>具有丰富移动终端、桌面终端的应用场景，号称“万物互联”，面向全场景的操作系统</td></tr></tbody></table><h1 id="用户界面："><a href="#用户界面：" class="headerlink" title="用户界面："></a>用户界面：</h1><table><thead><tr><th>Windows</th><th>安卓</th><th>Linux</th><th>macOS</th><th>鸿蒙</th></tr></thead><tbody><tr><td>优美丰富图形化界面</td><td>优美丰富图形化界面</td><td>发行版Linux系统会配备一定的图形化界面，但算不上丰富。所有功能的实现主要通过终端命令行实现</td><td>优美丰富图形化界面</td><td>优美丰富图形化界面</td></tr></tbody></table><h1 id="开放性："><a href="#开放性：" class="headerlink" title="开放性："></a>开放性：</h1><table><thead><tr><th>Windows</th><th>安卓</th><th>Linux</th><th>macOS</th><th>鸿蒙</th></tr></thead><tbody><tr><td>封闭</td><td>开源</td><td>开源</td><td>封闭</td><td>OpenHarmony为开源项目，鸿蒙OS为此开源项目的商用版本</td></tr></tbody></table><h1 id="价格："><a href="#价格：" class="headerlink" title="价格："></a>价格：</h1><table><thead><tr><th>Windows</th><th>安卓</th><th>Linux</th><th>macOS</th><th>鸿蒙</th></tr></thead><tbody><tr><td>收费<br />在购买安装Windows系统的电脑时，相关费用已经被计算进入总价中了</td><td>免费</td><td>免费</td><td>收费<br />价格已包含在苹果电脑售价中</td><td>OpenHarmony开源项目免费，商用鸿蒙OS收费</td></tr></tbody></table><h1 id="软件支持："><a href="#软件支持：" class="headerlink" title="软件支持："></a>软件支持：</h1><table><thead><tr><th>Windows</th><th>安卓</th><th>Linux</th><th>macOS</th><th>鸿蒙</th></tr></thead><tbody><tr><td>支持平台对应绝大部分软件，具有大量的软件供应，软件支持十分良好</td><td>支持平台对应绝大部分软件，具有大量的软件供应，软件支持十分良好</td><td>Linux为开源核心，软件支持十分自由，海量开源软件</td><td>支持平台部分软件，所有应用需要苹果公司的审核。具有独占软件，但也有很多软件不支持该操作系统。</td><td>支持平台大部分软件，目前各大软件平台不断开发适配鸿蒙OS的软件</td></tr></tbody></table><h1 id="安全性："><a href="#安全性：" class="headerlink" title="安全性："></a>安全性：</h1><table><thead><tr><th>Windows</th><th>安卓</th><th>Linux</th><th>macOS</th><th>鸿蒙</th></tr></thead><tbody><tr><td>用户量庞大，木马病毒生产量大，安全性相对低（对比Linux）</td><td>1. 基于Linux宏内核的Java虚拟机之上运行的，存在虚拟机逃逸。<br />2. 用户量庞大，安全性一般</td><td>1. 用户量相对少（对比windows），安全性相对较高<br />2. 开源系统，漏洞容易被发现和解决<br />3. 定期发布安全补丁<br />4. 开源社区庞大，安全专家和开发者多</td><td>封闭系统，审核严格，安全</td><td>1. 基于Linux的微内核架构，因此安全性理论相对安卓高<br />2. 开源系统，漏洞容易被发现和解决<br />3. 发展中的系统，现存用户量较少，安全性相对较强</td></tr></tbody></table><p>参考资料：</p><p>[1] <a href="https://techcommunity.microsoft.com/t5/windows-kernel-internals/one-windows-kernel/ba-p/267142">One Windows Kernel</a></p><p>[2] <a href="https://blog.csdn.net/zaishuiyifangxym/article/details/89202623">Windows系统、Linux系统 和 Mac OS操作系统 历史由来 与 区别？</a></p><p>[3] <a href="https://www.zhihu.com/tardis/zm/art/336634488?source_id=1005">对比安卓和鸿蒙的区别</a></p><p>[4] <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/harmonyos-overview-0000000000011903">华为开发者文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile初学指南</title>
      <link href="/chunyujin/81144cba.html"/>
      <url>/chunyujin/81144cba.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>C语言程序从代码到可执行文件（*.exe）需要经过预处理、编译、汇编和链接这几个步骤。每当修改源文件（*.c）或源文件所包含的头文件（*.h）后，我们都需要重新执行上述几个步骤，以得到修改后的程序。</p><blockquote><p>通常将预处理、编译和汇编这三个步骤统称为编译。</p></blockquote><p>一个项目通常有多个源文件，如果只修改其中一个，就对所有源文件重新执行编译、链接步骤，就太浪费时间了。因此十分有必要引入 Makefile 工具：Makefile 工具可以根据文件依赖，自动找出那些需要重新编译和链接的源文件，并对它们执行相应的动作。</p><div>    <center>        <img src = https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-05%20105603.png             style = "zoom:100%" />        <br>        编译链接过程    </center></div><h2 id="开始前的准备"><a href="#开始前的准备" class="headerlink" title="开始前的准备"></a>开始前的准备</h2><p>本文章目的在于帮助你理解和掌握Makefile的编写方法和编写技巧，在开始阅读和动手编写Makefile前，你可能需要准备一下环境。</p><p>本篇文章的示例运行在wsl2上（Windows Subsystem for Linux 2），我的系统信息如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/test$ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 22.04.1 LTS</span><br><span class="line">Release:        22.04</span><br><span class="line">Codename:       jammy</span><br></pre></td></tr></table></figure><p>可以看到，我使用Ubuntu系统，且系统发行版本是22.04。如果你是Windows系统，则可以在<code>启用或关闭 Windows 功能</code>中点击开启<code>适用于 Linux 的 Windows 子系统</code>，并在微软商店中下载和安装Ubuntu系统，以获得与我一致的代码编写环境。具体步骤可以参考：<a href="https://link.zhihu.com/?target=https://learn.microsoft.com/zh-cn/windows/wsl/install">安装 WSL</a>。</p><p>相比 <code>vim</code> 如果你更熟悉 <code>VSCode</code> 的操作，则可以参考：<a href="https://link.zhihu.com/?target=https://learn.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-vscode">开始通过 WSL 使用 VS Code</a> 来搭建自己熟悉的代码编写环境。</p><p>如果你在阅读或实践过程中遇到任何问题，欢迎在评论区中留下你的疑问，我们会尽力尝试解答。</p><h2 id="从代码编译开始"><a href="#从代码编译开始" class="headerlink" title="从代码编译开始"></a>从代码编译开始</h2><p>在开始编写 Makefile 前，我们先写一段简单的代码，并尝试使用编译工具链将代码变为可执行文件。</p><h3 id="编写简单的代码"><a href="#编写简单的代码" class="headerlink" title="编写简单的代码"></a>编写简单的代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello from main!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译得到可执行文件"><a href="#编译得到可执行文件" class="headerlink" title="编译得到可执行文件"></a>编译得到可执行文件</h3><p>编辑完文件后，回到终端，使用编译工具链将代码变为可执行文件：</p><blockquote><p>如果你在执行 <code>gcc main.c -o main</code> 时遇到问题，很有可能是没有安装 <code>gcc</code> 导致的，在终端中输入 <code>sudo apt-get install build-essential</code> 以安装所需的编译工具。</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ vim main.c</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ gcc main.c -o main</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ ls</span><br><span class="line">main  main.c</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ ./main</span><br><span class="line">Hello from main!</span><br></pre></td></tr></table></figure><p>可以看到，我们顺利得到了可执行文件，并且执行结果也符合预期。</p><p>上面所执行的几条命令中，<code>gcc main.c -o main</code> 这条命令负责调用编译工具链，将源文件 <code>main.c</code> 编译、链接为可执行文件 <code>main</code>。这里的GCC(GNU Compiler Collection)就是上文中提及的编译工具链，它是预处理、编译、汇编、链接所使用到的各种工具的集合，它们彼此搭配协作，才最终得到我们所需的可执行文件。</p><div>    <center>        <img src = https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230905105733339.png             style = "zoom:100%" />        <br>        编写简单的代码并得到可执行文件    </center></div><p>你可能会好奇<code>gcc</code> 命令中的 <code>-o</code> 选项的作用，它是用来指定输出文件的命名的，随后紧跟的参数就是所要指定的命名，在上面的示例中，我们将输出文件的命名指定为了 <code>main</code>。</p><h2 id="动手写简单的Makefile"><a href="#动手写简单的Makefile" class="headerlink" title="动手写简单的Makefile"></a>动手写简单的Makefile</h2><p>现在我们已经掌握了将代码编译、链接为可执行文件的方法，是时候开始写最简单的Makefile文件了：</p><h3 id="编写Makefile并执行make"><a href="#编写Makefile并执行make" class="headerlink" title="编写Makefile并执行make"></a>编写Makefile并执行make</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Makefile</span><br><span class="line">main : main.c</span><br><span class="line">        gcc main.c -o main</span><br></pre></td></tr></table></figure><p>编写好后回到终端，使用 <code>make</code> 来执行Makefile：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ vim Makefile</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ make</span><br><span class="line">make: &#x27;main&#x27; is up to date.</span><br></pre></td></tr></table></figure><p>可以看到 Makefile 给出了它的处理结果 <code>make: &#39;main&#39; is up to date.</code>，意思是 <code>main</code> 已经是最新的了，无需执行任何操作。此时我们的 <code>main.c</code> 没有做任何修改，也就是说即使重新编译、链接得到一个新的 <code>main</code>，它与旧的 <code>main</code> 也不会存在任何的不同，所以Makefile没有执行任何的步骤。</p><p>尝试修改 <code>main.c</code> 再执行 <code>make</code>，看看这次的结果会怎样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello from new main!\n&quot;</span>); <span class="comment">// &lt;- 多加了一个new</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到终端执行 <code>make</code>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ vim main.c</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ make</span><br><span class="line">gcc main.c -o main</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ ./main</span><br><span class="line">Hello from new main!</span><br></pre></td></tr></table></figure><p>可以看到，在修改了 <code>main.c</code> 后重新执行 <code>make</code>，Makefile会自动地执行 <code>gcc main.c -o main</code>，以得到新的可执行文件 <code>main</code>。从结果来看，代码中的修改确实反应到了可执行文件上。</p><h3 id="Makefile三要素"><a href="#Makefile三要素" class="headerlink" title="Makefile三要素"></a>Makefile三要素</h3><p>那么问题就来了，Makefile中的两行语句分别是什么意思呢？拆解来看，两行语句可以分为三部分，分别是目标（target）、依赖（prerequisite）和执行语句（recipe）：</p><blockquote><p>延伸思考：目标、依赖和执行语句，三者在Makefile中是否缺一不可？在不修改源文件的前提下尝试修改目标，再执行make时会得到怎样的结果？</p></blockquote><div>    <center>        <img src = https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230905105804134.png             style = "zoom:100%" />        <br>        简单Makefile语句解析    </center></div><p>上面的例子中，可执行文件 <code>main</code> 就是我们想要得到的目标，而 <code>main</code> 的生成依赖于 <code>main.c</code>，所以将 <code>main.c</code> 填写在依赖的位置。在发现目标文件不存在，或依赖的文件有所修改后，Makefile 就会执行下方的执行语句，其任务通常是生成目标文件。</p><blockquote><p><strong><a href="https://link.zhihu.com/?target=https://www.gnu.org/software/make/manual/make.html%23Rule-Introduction">延伸阅读</a></strong><br><a href="https://link.zhihu.com/?target=http://gnu.org">http://gnu.org</a>上关于三要素的描述如下：<br>A <em>target</em> is usually the name of a file that is generated by a program; examples of targets are executable or object files. A target can also be the name of an action to carry out, such as ‘clean’ (see <a href="https://link.zhihu.com/?target=https://www.gnu.org/software/make/manual/make.html%23Phony-Targets">Phony Targets</a>).<br>A <em>prerequisite</em> is a file that is used as input to create the target. A target often depends on several files.<br>A <em>recipe</em> is an action that <code>make</code> carries out. A recipe may have more than one command, either on the same line or each on its own line. <strong>Please note:</strong> you need to put a tab character at the beginning of every recipe line!</p></blockquote><h3 id="当增加源文件和修改源文件名称"><a href="#当增加源文件和修改源文件名称" class="headerlink" title="当增加源文件和修改源文件名称"></a>当增加源文件和修改源文件名称</h3><p>回看已经写好的Makefile，会发现其中的内容都是有具体指向的：<code>main</code>、<code>main.c</code>。试想这样一个场景：我们在文件夹中添加新的源文件 <code>bar.c</code>，并将 <code>main.c</code> 重命名为 <code>entry.c</code>，这时再执行 <code>make</code> 会得到怎样的结果呢？</p><blockquote><p>思考题：在函数 <em>Print_Progress_Bar</em> 中，数组 <code>bar</code> 的定义和赋值能否由 <code>char bar[] = PROGRESS_BAR</code> 改为 <code>char *bar = PROGRESS_BAR</code>。为什么？两者有什么不同？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bar.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROGRESS_BAR <span class="string">&quot;*************************&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入参数</span></span><br><span class="line"><span class="comment">// comp: 完成比例（0% ~ 100%）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Print_Progress_Bar</span><span class="params">(<span class="type">float</span> comp)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">char</span> bar[] = PROGRESS_BAR;</span><br><span class="line">        <span class="type">int</span> len_bar = <span class="keyword">sizeof</span>(PROGRESS_BAR) - <span class="number">1</span>;</span><br><span class="line">        comp = (comp &gt; <span class="number">1.0f</span>) ? <span class="number">1.0f</span> : comp;</span><br><span class="line">        comp = (comp &lt; <span class="number">0.0f</span>) ? <span class="number">0.0f</span> : comp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制进度条</span></span><br><span class="line">        <span class="type">int</span> end = comp * len_bar;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = end; i &lt; len_bar; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                bar[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;|%s|\n&quot;</span>, bar);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Print_Progress_Bar</span><span class="params">(<span class="type">float</span> comp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello from new main!\n&quot;</span>);</span><br><span class="line">        Print_Progress_Bar(<span class="number">33.0f</span>/<span class="number">100.0f</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完成后在终端执行 <code>make</code>，结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ vim bar.c</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ mv main.c entry.c</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ vim entry.c</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ make</span><br><span class="line">make: *** No rule to make target &#x27;main.c&#x27;, needed by &#x27;main&#x27;.  Stop.</span><br></pre></td></tr></table></figure><p>可以看到，<code>make</code> 提示“No rule to make target ‘main.c’, needed by ‘main’.”，并停止了执行。从提示中我们大致可以猜到，由于找不到依赖文件 <code>main.c</code>， <code>make</code> 停止了执行。解决问题的方法有两种，简单粗暴的做法是：直接根据新的文件命名修改 Makefile 文件：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Makefile</span><br><span class="line">main : entry.c bar.c</span><br><span class="line">        gcc entry.c bar.c -o main</span><br></pre></td></tr></table></figure><p>由于主函数调用了 <code>bar.c</code> 中定义的函数，所以在编译时我们需要将 <code>bar.c</code> 一起编译、链接到可执行文件里，同时别忘了把它加进依赖中。修改好后回到终端重新执行 <code>make</code>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ vim Makefile</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ make</span><br><span class="line">gcc entry.c bar.c -o main</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ ./main</span><br><span class="line">Hello from new main!</span><br><span class="line">|********                 |</span><br></pre></td></tr></table></figure><p>这一次 <code>make</code> 命令没有再报错。</p><p>想象一下，如果我们保持当前的 Makefile 写法，那么之后每次添加源文件，或者修改源文件名称时，都需要我们重新修改 Makefile 文件。当文件数量爆炸多的时候，这样的手动调整显然是十分麻烦的。所以我们迫切需要一种更为通用的写法，来免除这些“痛苦”。</p><h3 id="变量和通配符和wildcard函数"><a href="#变量和通配符和wildcard函数" class="headerlink" title="变量和通配符和wildcard函数"></a>变量和通配符和wildcard函数</h3><p>仔细观察源文件的命名 <code>main.c</code> 、 <code>bar.c</code>，我们会发现它们有着共同的模式（或称为规律）：都以 <code>.c</code> 结尾，这意味着可以用这种模式匹配所有源文件。在 Makefile 中我们可以使用 wildcard 函数（wildcard function）来达到这一目的。</p><h3 id="使用wildcard函数"><a href="#使用wildcard函数" class="headerlink" title="使用wildcard函数"></a>使用wildcard函数</h3><p>在 Makefile 中，<code>$(function arguments)</code> 的写法用于函数调用， wildcard 函数的使用方法如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(wildcard pattern…)</span><br></pre></td></tr></table></figure><p>如果我们想匹配当前目录下的所有源文件，就可以这样写：<code>$(wildcard *.c)</code>，其中通配符 <code>*</code> 用于匹配任意长度的任何字符，可以是 <code>main</code>、<code>bar</code>，也可以是其他任何你能想得到的字符组合，后面加上 <code>.c</code> 则是要求匹配的字符组合必须以 <code>.c</code> 结尾。</p><p>当前示例下，<code>$(wildcard *.c)</code> 展开后得到的结果就是： <code>bar.c entry.c</code>，所以我们的 <code>Makefile</code> 文件可以修改为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Makefile</span><br><span class="line">main : $(wildcard *.c)</span><br><span class="line">        gcc $(wildcard *.c) -o main</span><br></pre></td></tr></table></figure><p>修改后保存，再重新执行 <code>make</code>，得到的结果与之前一致：（这里我将进度条从进度33%改为了52%，以确保 <code>make</code> 执行编译命令）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ vim Makefile</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ vim entry.c</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ make</span><br><span class="line">gcc bar.c entry.c -o main</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ ./main</span><br><span class="line">Hello from new main!</span><br><span class="line">|*************            |</span><br></pre></td></tr></table></figure><h3 id="利用变量"><a href="#利用变量" class="headerlink" title="利用变量"></a>利用变量</h3><p>上面的 <code>Makefile</code> 还可以再优化一下可读性和效率，我们可以利用变量保存 wildcard 函数展开后的结果。Makefile 中变量定义的形式与C语言类似：<code>var := value</code>，调用则和函数调用类似：<code>$(var)</code>，所以 <code>Makefile</code> 可以进一步修改为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Makefile</span><br><span class="line">SRCS := $(wildcard *.c)</span><br><span class="line"></span><br><span class="line">main : $(SRCS)</span><br><span class="line">        gcc $(SRCS) -o main</span><br></pre></td></tr></table></figure><p>相比上面的 <code>Makefile</code>，进一步修改后的 <code>Makefile</code> 减少了一次函数调用，并且增加了可读性。</p><h3 id="变量的赋值和修改"><a href="#变量的赋值和修改" class="headerlink" title="变量的赋值和修改"></a>变量的赋值和修改</h3><p>我们在刚才的示例中使用到了赋值符号 <code>:=</code> ，该符号与C语言中的赋值符号 <code>=</code> 作用效果相同。以下是几个常用符号的简介：</p><ul><li><code>=</code> ：递归赋值<a href="https://link.zhihu.com/?target=https://www.gnu.org/software/make/manual/html_node/Recursive-Assignment.html">(Recursively Expanded Variable Assignment)</a>，使用变量进行赋值时，会优先展开引用的变量，示例如下：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo = $(bar)</span><br><span class="line">bar = $(ugh)</span><br><span class="line">ugh = Huh?</span><br><span class="line"></span><br><span class="line">all:;echo $(foo)</span><br><span class="line"># 打印的结果为 Huh?，$(foo)展开得到$(bar)，$(bar)展开得到$(ugh)，$(ugh)展开得到Huh?最终$(foo)展开得到Huh?</span><br></pre></td></tr></table></figure><ul><li><code>:=</code> ：简单赋值<a href="https://link.zhihu.com/?target=https://www.gnu.org/software/make/manual/html_node/Simple-Assignment.html">(Simply Expanded Variable Assignment)</a>，最常用的赋值符号：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := $(x) bar</span><br><span class="line">x := later</span><br><span class="line"># 等效于：</span><br><span class="line"># y := foo bar</span><br><span class="line"># x := later</span><br></pre></td></tr></table></figure><ul><li><code>+=</code> ：文本增添<a href="https://link.zhihu.com/?target=https://www.gnu.org/software/make/manual/html_node/Appending.html">(Appending)</a>，用于向已经定义的变量添加文本：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o foo.o bar.o utils.o</span><br><span class="line">objects += another.o</span><br><span class="line"># objects最终为main.o foo.o bar.o utils.o another.o</span><br></pre></td></tr></table></figure><ul><li><code>?=</code> ：条件赋值<a href="https://link.zhihu.com/?target=https://www.gnu.org/software/make/manual/html_node/Conditional-Assignment.html">(Conditional Variable Assignment)</a>，仅在变量没有定义时创建变量：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FOO ?= bar</span><br><span class="line"># FOO最终为bar</span><br><span class="line">foo := ugh</span><br><span class="line">foo ?= Huh?</span><br><span class="line"># foo最终为ugh</span><br></pre></td></tr></table></figure><h2 id="动手写进阶的Makefile"><a href="#动手写进阶的Makefile" class="headerlink" title="动手写进阶的Makefile"></a>动手写进阶的Makefile</h2><p>到目前为止，我们已经写出一个简单能用的Makefile了，它能应对不太复杂的场景，在没有多级目录的情况下已经足够使用。但我们实际面对的场景往往要复杂得多：源文件和头文件按照功能或层级区分，散落在一个个子文件夹下，这样做更容易管理工程文件，但也带来了两点小麻烦。</p><p>先让我们先改造一下当前的目录结构，使其更贴合实际应用场景：</p><blockquote><p><code>tree</code> 命令的作用是以树的形式展现目录结构，你可能无法直接使用该命令，尝试 <code>sudo apt install tree</code> 以安装和使用 <code>tree</code> 命令。</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ tree</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── bar.c</span><br><span class="line">├── entry.c</span><br><span class="line">└── main</span><br><span class="line"></span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ mkdir ./func</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ mv ./bar.c ./func/</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ vim ./func/bar.h</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ vim ./entry.c</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ tree</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── entry.c</span><br><span class="line">├── func</span><br><span class="line">│   ├── bar.c</span><br><span class="line">│   └── bar.h</span><br><span class="line">└── main</span><br></pre></td></tr></table></figure><p>这里我新建了目录 <code>func</code>，并将 <code>bar.c</code> 转移到了 <code>func</code> 目录下，同时在 <code>func</code> 目录下创建了头文件 <code>bar.h</code>。然后在 <code>entry.c</code> 中将手动声明函数改为了头文件包含：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.h</span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Print_Progress_Bar</span><span class="params">(<span class="type">float</span> comp)</span>;</span><br><span class="line"><span class="comment">// entry.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello from new main!\n&quot;</span>);</span><br><span class="line">        Print_Progress_Bar(<span class="number">52.0f</span>/<span class="number">100.0f</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在再让我们尝试执行 <code>make</code>，看看会发生什么：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ make</span><br><span class="line">gcc entry.c -o main</span><br><span class="line">entry.c:2:10: fatal error: bar.h: No such file or directory</span><br><span class="line">    2 | #include &lt;bar.h&gt;</span><br><span class="line">      |          ^~~~~~~</span><br><span class="line">compilation terminated.</span><br><span class="line">make: *** [Makefile:8: main] Error 1</span><br></pre></td></tr></table></figure><p>首先出现的问题是编译 <code>entry.c</code> 时提示找不到 <code>bar.h</code> 的头文件，这是编译时没有指定到哪些路径下寻找头文件导致的，解决办法是执行 <code>gcc</code> 命令时通过 <code>-I</code> 选项指定头文件所在路径：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Makefile</span><br><span class="line">INCS := -I./func</span><br><span class="line">SRCS := $(wildcard *.c)</span><br><span class="line"></span><br><span class="line">main : $(SRCS)</span><br><span class="line">        gcc $(INCS) $(SRCS) -o main</span><br></pre></td></tr></table></figure><p>再来执行make：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ vim Makefile</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ make</span><br><span class="line">gcc -I./func entry.c -o main                                    &lt;- 缺少bar.c</span><br><span class="line">/usr/bin/ld: /tmp/ccaX7UmM.o: in function `main&#x27;:</span><br><span class="line">entry.c:(.text+0x22): undefined reference to `Print_Progress_Bar&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">make: *** [Makefile:9: main] Error 1</span><br></pre></td></tr></table></figure><p>我们察觉到执行 <code>make</code> 时又发生了错误，提示主函数中调用了未定义的函数 <code>Print_Progress_Bar</code>，这个函数定义在 <code>bar.c</code> 中。仔细观察可以发现 <code>gcc</code> 的调用中缺少 <code>bar.c</code>，这就引发了我们遇到的问题。显然在 <code>bar.c</code> 装进 <code>./func</code> 目录后，<code>Makefile</code> 就找不到 <code>bar.c</code> 文件了，这就是我们在刚才提到的小麻烦。</p><h3 id="应对复杂的目录结构"><a href="#应对复杂的目录结构" class="headerlink" title="应对复杂的目录结构"></a>应对复杂的目录结构</h3><p>首先还是让我们来看一下 <code>make</code> 的报错问题如何解决。思路和方法很简单，使用 wildcard 函数在 <code>./func</code> 目录下也匹配一遍源文件，再把这些源文件一同添加到 <code>SRCS</code> 变量中就可以了：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Makefile</span><br><span class="line">INCS := -I./func</span><br><span class="line">SRCS := $(wildcard *.c)</span><br><span class="line">SRCS += $(wildcard ./func/*.c)</span><br><span class="line"></span><br><span class="line">main : $(SRCS)</span><br><span class="line">        gcc $(INCS) $(SRCS) -o main</span><br></pre></td></tr></table></figure><p>尝试执行下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ vim Makefile</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ make</span><br><span class="line">gcc -I./func entry.c ./func/bar.c -o main</span><br></pre></td></tr></table></figure><p>可以看到问题得到了解决。但这样的方案还是存在缺点的，它不够通用和直观，从中我们很难看出哪些路径得到了使用。或许还有什么办法能将 <code>Makefile</code> 写得更清晰一些。</p><p>如果你曾使用过一些 <code>IDE</code>，那你可能会对配置路径感到熟悉，这要求你将一些文件目录添加到工程文件配置中去。我们也可以效仿这样的做法，手动将目录添加到 <code>Makefile</code> 中去。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Makefile</span><br><span class="line">SUBDIR := .</span><br><span class="line">SUBDIR += ./func</span><br></pre></td></tr></table></figure><p>这里定义了变量 <code>SUBDIR</code>，我们将使用它来指定那些存放着源文件和头文件的目录。接下来我们将请出另一个功能强大的函数 foreach 来帮助我们完成一项复杂的功能。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(foreach var,list,text)</span><br></pre></td></tr></table></figure><p>foreach(for each)函数的功能与 Python 和C语言中的 for 循环类似，但会更接近 Python 的 for 循环。它的功能描述起来就是：从 <code>list</code> 中逐个取出元素，赋值给 <code>var</code>，然后再展开 <code>text</code>。下面是一个使用示例。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SUBDIR := .</span><br><span class="line">SUBDIR += ./func</span><br><span class="line"></span><br><span class="line">EXPANDED := $(foreach dir,$(SUBDIR),$(dir)/*.c)</span><br><span class="line"># 等效于EXPANDED := ./*.c ./func/*.c</span><br></pre></td></tr></table></figure><div>    <center>        <img src = https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230905105839627.png             style = "zoom:100%" />        <br>        foreach函数    </center></div><p>有了 foreach 函数，我们就能配合 wildcard 函数，通过指定路径来获取源文件，并指定头文件所在路径：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Makefile</span><br><span class="line">SUBDIR := .</span><br><span class="line">SUBDIR += ./func</span><br><span class="line"></span><br><span class="line">INCS := $(foreach dir,$(SUBDIR),-I$(dir))</span><br><span class="line">SRCS := $(foreach dir,$(SUBDIR),$(wildcard $(dir)/*.c))</span><br><span class="line"></span><br><span class="line">main : $(SRCS)</span><br><span class="line">        gcc $(INCS) $(SRCS) -o main</span><br></pre></td></tr></table></figure><p>在终端里试试效果（可以使用 <code>rm ./main</code> 移除可执行文件，来确保 <code>make</code> 会执行编译命令）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ vim ./Makefile</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ rm ./main</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ make</span><br><span class="line">gcc -I. -I./func ./entry.c ./func/bar.c -o main</span><br></pre></td></tr></table></figure><p>它可以正常工作，且效果与之前是一致的。现在来看，指定路径的做法较之前并没有太大的优势，我们要做的仍是手动指定目录，只是将获取源文件的任务交给了 foreach 函数来完成。在后面，我们会继续深入了解 Makefile，到时指定路径的优势会逐渐显现。</p><h3 id="分析编译过程"><a href="#分析编译过程" class="headerlink" title="分析编译过程"></a>分析编译过程</h3><p>到目前为止，我们的示例程序还保持着较短的编译、链接时间。但当源文件逐渐增多后，只改动其中一个源文件，我们还能在短时间内获得可执行文件吗？为了解答这个问题，我们先来回顾一下编译、链接的过程。</p><p>源文件和头文件需要经过四个步骤才能得到可执行文件，分别是预处理、编译、汇编和链接。</p><ul><li>预处理：预处理器将以字符 <code>#</code> 开头的命令展开、插入到原始的C程序中。比如我们在源文件中能经常看到的、用于头文件包含的 <code>#include</code> 命令，它的功能就是告诉预编译器，将指定头文件的内容插入的程序文本中。</li></ul><div>    <center>        <img src = https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230905105927431.png             style = "zoom:100%" />        <br>        预处理演示    </center></div><ul><li>编译阶段：编译器将文本文件 <code>*.i</code> 翻译成文本文件 <code>*.s</code>，它包含一个汇编语言程序。</li><li>汇编阶段：汇编器将 <code>*.s</code> 翻译成机器语言指令，把这些指令打包成可重定位目标程序（relocatable object program）的格式，并保存在 <code>*.o</code> 文件中。</li><li>链接阶段：在 <code>bar.c</code> 中我们定义了 <code>Print_Progress_Bar</code> 函数，该函数会保存在目标文件 <code>bar.o</code> 中。直到链接阶段，链接器才以某种方式将 <code>Print_Progress_Bar</code> 函数合并到 <code>main</code> 函数中去。在链接时如果没有指定 <code>bar.o</code>，链接器就无法找到 <code>Print_Progress_Bar</code> 函数，也就会提示找不到相关函数的定义。</li></ul><h3 id="保存-o-文件"><a href="#保存-o-文件" class="headerlink" title="保存 *.o 文件"></a>保存 *.o 文件</h3><p>从编译过程的分析中，我们能找到当前 <code>Makefile</code> 存在的两点问题：</p><ol><li>没有保存 <code>.o</code> 文件，这导致我们每次文件变动都要重新执行预处理、编译和汇编来得到目标文件，即使新得到的文件与旧文件完全没有差别（即编译用到的源文件没有任何变化，就跟<code>bar.c</code> 一样）。</li><li>有保存 <code>.o</code> 文件，则会遇到第二个问题，即依赖中没有指定头文件，这意味着只修改头文件的情况下，源文件不会重新编译得到新的可执行文件！</li></ol><div>    <center>        <img src = https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230905105947900.png             style = "zoom:100%" />        <br>        一开始的编译过程    </center></div><p>为了证明以上两个问题，我们对 <code>Makefile</code> 做一些改动：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INCS := -I. -I./func</span><br><span class="line"></span><br><span class="line">main : ./entry.o ./func/bar.o</span><br><span class="line">        gcc ./entry.o ./func/bar.o -o main</span><br><span class="line"></span><br><span class="line">./entry.o : ./entry.c</span><br><span class="line">        gcc -c $(INCS) ./entry.c -o ./entry.o</span><br><span class="line"></span><br><span class="line">./func/bar.o : ./func/bar.c</span><br><span class="line">        gcc -c $(INCS) ./func/bar.c -o ./func/bar.o</span><br></pre></td></tr></table></figure><p><code>gcc</code> 命令指定 <code>-c</code> 选项后，会只执行编译步骤，而不执行链接步骤，最后得到 <code>*.o</code> 文件。这里我们添加新的目标和依赖，目的是编译得到 <code>main.o bar.o</code>，最后再手动将它们链接为可执行文件 <code>main</code>。值得一提的是 Makefile 文件会自动匹配依赖和目标，如果依赖的依赖有更新，则目标文件也会得到更新。</p><p>现在让我们看看 <code>make</code> 执行的效果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ vim Makefile</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ rm main</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ make</span><br><span class="line">gcc -c -I. -I./func ./entry.c -o ./entry.o</span><br><span class="line">gcc -c -I. -I./func ./func/bar.c -o ./func/bar.o</span><br><span class="line">gcc ./entry.o ./func/bar.o -o main</span><br></pre></td></tr></table></figure><p><code>make</code> 执行了我们指定的每一个步骤。现在让我们修改 <code>entry.c</code>，手动删除 <code>bar.o</code> 后再执行 <code>make</code>。（模拟不保存 <code>*.o</code> 文件的情况）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Happy Birth Day!\n&quot;</span>);</span><br><span class="line">        Print_Progress_Bar(<span class="number">33.0f</span>/<span class="number">100.0f</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试验下执行 <code>make</code> 的效果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ vim entry.c</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ rm ./func/bar.o &lt;- 删除bar.o</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ make</span><br><span class="line">gcc -c -I. -I./func ./entry.c -o ./entry.o              &lt;- 重新编译entry.o</span><br><span class="line">gcc -c -I. -I./func ./func/bar.c -o ./func/bar.o        &lt;- 重新编译bar.o</span><br><span class="line">gcc ./entry.o ./func/bar.o -o main</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ ./main</span><br><span class="line">Happy Birth Day!</span><br><span class="line">|********                 |</span><br></pre></td></tr></table></figure><p>我们不仅重新编译了 <code>entry.o</code>，还重新编译了 <code>bar.o</code>，现在再试试保存 <code>bar.o</code> 的情况下执行 <code>make</code>。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ vim entry.c</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ make</span><br><span class="line">gcc -c -I. -I./func ./entry.c -o ./entry.o              &lt;- 仅重新编译entry.o</span><br><span class="line">gcc ./entry.o ./func/bar.o -o main</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ ./main</span><br><span class="line">保持开心！</span><br><span class="line">|********                 |</span><br></pre></td></tr></table></figure><p>可以发现，相较于不保存 <code>bar.o</code> 的情况，我们少执行了 <code>bar.o</code> 的编译步骤，这对于工程文件编译速度的提升，可能是巨大的！</p><p>现在再让我们尝试修改 <code>bar.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.h</span></span><br><span class="line"><span class="comment">// 注：#ifndef配合#define用于避免源文件重复包含同一头文件的内容</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _BAR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BAR_H</span></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Print_Progress_Bar</span><span class="params">(<span class="type">float</span> comp)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>执行 <code>make</code> ：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ vim ./func/bar.h</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ make</span><br><span class="line">make: &#x27;main&#x27; is up to date.</span><br></pre></td></tr></table></figure><p>不出所料，源文件果然没有重新编译。</p><h3 id="模式规则和自动变量"><a href="#模式规则和自动变量" class="headerlink" title="模式规则和自动变量"></a>模式规则和自动变量</h3><p>我们还是先来解决问题，首先是 <code>*.o</code> 文件的保存问题，这个问题其实在上面已经解决了，我们再来看一遍：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SUBDIR := .</span><br><span class="line">SUBDIR += ./func</span><br><span class="line"></span><br><span class="line">INCS := $(foreach dir,$(SUBDIR),-I$(dir))</span><br><span class="line">SRCS := $(foreach dir,$(SUBDIR),$(wildcard $(dir)/*.c))</span><br><span class="line"></span><br><span class="line">main : ./entry.o ./func/bar.o</span><br><span class="line">        gcc ./entry.o ./func/bar.o -o main</span><br><span class="line"></span><br><span class="line">./entry.o : ./entry.c</span><br><span class="line">        gcc -c $(INCS) ./entry.c -o ./entry.o</span><br><span class="line"></span><br><span class="line">./func/bar.o : ./func/bar.c</span><br><span class="line">        gcc -c $(INCS) ./func/bar.c -o ./func/bar.o</span><br></pre></td></tr></table></figure><p>通过手动添加目标和依赖，我们实现了 <code>*.o</code> 文件的保存，同时还确保了源文件在更新后，只会在最小限度内重新编译 <code>*.o</code> 文件。现在我们可以利用符号 <code>%</code> 和自动变量，来让 <code>Makefile</code> 变得更加通用。首先聚焦于编译过程：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./entry.o : ./entry.c</span><br><span class="line">        gcc -c $(INCS) ./entry.c -o ./entry.o</span><br><span class="line"></span><br><span class="line">./func/bar.o : ./func/bar.c</span><br><span class="line">        gcc -c $(INCS) ./func/bar.c -o ./func/bar.o</span><br></pre></td></tr></table></figure><p>上下比较 <code>./entry.o</code> 和 <code>./func/bar.o</code> 的目标依赖及执行，可以发现新添加的、用于生成 <code>*.o</code> 文件的目标和依赖，有着相同的书写模式，这意味着存在通用的写法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line">        gcc -c $(INCS) $&lt; -o $@</span><br></pre></td></tr></table></figure><div>    <center>        <img src = https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230905110004284.png             style = "zoom:100%" />        <br>        Makefile编译的通用写法    </center></div><p>这里我们用上了 <code>%</code> ，它的作用有些难以用语言概括，上述例子中， <code>%.o</code> 的作用是匹配所有以 <code>.o</code> 结尾的目标；而后面的 <code>%.c</code> 中 <code>%</code> 的作用，则是将 <code>%.o</code> 中 <code>%</code> 的内容原封不动的挪过来用。</p><p>更具体地例子是，<code>%.o</code> 可能匹配到目标 <code>./entry.o</code> 或 <code>./func/bar.o</code>，这样 <code>%</code> 的内容就会是 <code>./entry</code> 或 <code>./func/bar</code>，最后交给 <code>%.c</code> 时就变成了 <code>./entry.c</code> 或 <code>./func/bar.c</code>。</p><p>另外我们还使用到了自动变量 <code>$&lt; $@</code>，其中 <code>$&lt;</code> 指代依赖列表中的第一个依赖；而 <code>$@</code> 指代目标。注意自动变量与普通变量不同，它不使用小括号。</p><p>结合起来使用，我们就得到了通用的生成 <code>*.o</code> 文件的写法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Makefile</span><br><span class="line">SUBDIR := .</span><br><span class="line">SUBDIR += ./func</span><br><span class="line"></span><br><span class="line">INCS := $(foreach dir,$(SUBDIR),-I$(dir))</span><br><span class="line">SRCS := $(foreach dir,$(SUBDIR),$(wildcard $(dir)/*.c))</span><br><span class="line"></span><br><span class="line">main : ./entry.o ./func/bar.o</span><br><span class="line">        gcc ./entry.o ./func/bar.o -o main</span><br><span class="line"></span><br><span class="line">%.o : %.c</span><br><span class="line">        gcc -c $(INCS) $&lt; -o $@</span><br></pre></td></tr></table></figure><h3 id="patsubst-函数"><a href="#patsubst-函数" class="headerlink" title="patsubst 函数"></a>patsubst 函数</h3><p>接下来再让我们关注链接步骤，它需要指定 <code>*.o</code> 文件：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main : ./entry.o ./func/bar.o</span><br><span class="line">        gcc ./entry.o ./func/bar.o -o main</span><br></pre></td></tr></table></figure><p>这看起来十分眼熟，我们最初解决多文件编译问题时也是采用类似的写法，只有文件后缀不一样：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main : ./entry.c ./func/bar.c</span><br><span class="line">        gcc ./entry.c ./func/bar.c -o main</span><br></pre></td></tr></table></figure><p>这给了我们一点提示，是不是能够通过 wildcard 函数来实现通用的写法？可惜的是，在最开始我们是无法匹配到 <code>*.o</code> 文件的，因为起初我们只有 <code>*.c</code> 文件， <code>*.o</code> 文件是后来生成的。但转换一下思路，我们在获取所有源文件后，直接将 <code>.c</code> 后缀替换为 <code>.o</code>，不就能得到所有的 <code>.o</code> 文件了吗？正巧 patsubst 函数可以用于模式文本替换。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(patsubst pattern,replacement,text)</span><br></pre></td></tr></table></figure><p>patsubst 函数的作用是匹配 <code>text</code> 文本中与 <code>pattern</code> 模式相同的部分，并将匹配内容替换为 <code>replacement</code>。于是链接步骤可以改写为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SRCS := $(foreach dir,$(SUBDIR),$(wildcard $(dir)/*.c))</span><br><span class="line">OBJS := $(patsubst %.c,%.o,$(SRCS))</span><br><span class="line"></span><br><span class="line">main : $(OBJS)</span><br><span class="line">        gcc $(OBJS) -o main</span><br></pre></td></tr></table></figure><div>    <center>        <img src = https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230905110019095.png             style = "zoom:100%" />        <br>        Makefile中的patsubst函数    </center></div><p>这里我们先用 wildcard 函数获取所有的 <code>.c</code> 文件，并将结果保存在 <code>SRCS</code> 中，接着利用 patsubst 函数替换 <code>SRCS</code> 的内容，最后将所有的 <code>.c</code> 替换为 <code>.o</code> 以获得执行编译所得到的目标文件。</p><p>于是我们的 <code>Makefile</code> 就可以改写为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SUBDIR := .</span><br><span class="line">SUBDIR += ./func</span><br><span class="line"></span><br><span class="line">INCS := $(foreach dir,$(SUBDIR),-I$(dir))</span><br><span class="line">SRCS := $(foreach dir,$(SUBDIR),$(wildcard $(dir)/*.c))</span><br><span class="line">OBJS := $(patsubst %.c,%.o,$(SRCS))</span><br><span class="line"></span><br><span class="line">main : $(OBJS)</span><br><span class="line">        gcc $(OBJS) -o main</span><br><span class="line"></span><br><span class="line">%.o : %.c</span><br><span class="line">        gcc -c $(INCS) $&lt; -o $@</span><br></pre></td></tr></table></figure><p>试试效果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ rm main</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ rm ./func/bar.o</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ rm ./entry.o</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ make</span><br><span class="line">gcc -c -I. -I./func entry.c -o entry.o</span><br><span class="line">gcc -c -I. -I./func func/bar.c -o func/bar.o</span><br><span class="line">gcc ./entry.o ./func/bar.o -o main</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ ./main</span><br><span class="line">保持开心！</span><br><span class="line">|************************ |</span><br></pre></td></tr></table></figure><p>看起来没有太大问题（但仔细看还是会发现，编译时 <code>./</code> 被吃了）！至此我们解决了第一个问题，而第二个问题，我们留到后面再解决。现在先让我们看看 Makefile 还有哪些可以丰富和完善的功能。</p><h2 id="丰富完善Makefile的功能"><a href="#丰富完善Makefile的功能" class="headerlink" title="丰富完善Makefile的功能"></a>丰富完善Makefile的功能</h2><p>到目前为止，我们已经写出足够使用的 Makefile 文件了，接下来我们可以继续完善它的功能。</p><h3 id="指定-o文件的输出路径"><a href="#指定-o文件的输出路径" class="headerlink" title="指定*.o文件的输出路径"></a>指定*.o文件的输出路径</h3><p>细心的你可能会发现，目前编译得到的 <code>.o</code> 文件，都是放在与 <code>.c</code> 文件同一级目录下的，从代码编辑习惯考虑，这可能会导致我们无法方便地寻找源文件或头文件。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ tree</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── entry.c</span><br><span class="line">├── entry.o</span><br><span class="line">├── func</span><br><span class="line">│   ├── bar.c</span><br><span class="line">│   ├── bar.h</span><br><span class="line">│   └── bar.o</span><br><span class="line">└── main</span><br></pre></td></tr></table></figure><p>理想的做法是将 <code>*.o</code> 文件保存至指定目录，与源文件和头文件区分开：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ tree</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── entry.c</span><br><span class="line">├── func</span><br><span class="line">│   ├── bar.c</span><br><span class="line">│   └── bar.h</span><br><span class="line">├── main</span><br><span class="line">└── output</span><br><span class="line">    ├── entry.o</span><br><span class="line">    └── func</span><br><span class="line">        └── bar.o</span><br></pre></td></tr></table></figure><p>但应该如何实现呢？先来看一下单个 <code>.o</code> 文件怎么输出到指定文件夹：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./output/func/bar.o : ./func/bar.c</span><br><span class="line">        mkdir -p ./output/func</span><br><span class="line">        gcc -c $(INCS) ./func/bar.c -o ./output/func/bar.o</span><br></pre></td></tr></table></figure><p>我们解决问题的思路是：把输出目录下的 <code>.o</code> 文件作为编译目标，原始目录下的 <code>.c</code> 文件作为依赖，来编译得到目标文件。这里我们需要解决两个问题：1. 如何得到 <code>./output/func/bar.o</code> 这个路径；2. 如何保证 <code>./output/func</code> 目录存在。</p><p>问题1我们可以在执行 patsubst 函数时解决，就像这样：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT := ./output</span><br><span class="line">SRCS := $(foreach dir,$(SUBDIR),$(wildcard $(dir)/*.c))</span><br><span class="line">OBJS := $(patsubst %.c,$(OUTPUT)/%.o,$(SRCS))</span><br></pre></td></tr></table></figure><p>在替换 <code>.c</code> 的同时，在内容头部添加输出路径 <code>./output/</code>，这样 <code>./func/bar.c</code> 就会替换成 <code>./output/func/bar.o</code>。</p><p>接着问题2我们可以使用 mkdir 命令配合 dir 函数解决，dir 函数可以从文本中获得路径，配合 mkdir -p 命令创建目录，可以确保输出路径存在：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $(dir ./output/func/bar.o)</span><br></pre></td></tr></table></figure><p>dir 函数会把 <code>./output/func/bar.o</code> 修改成 <code>./output/func</code>，于是上面的命令就变为了：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ./func/func</span><br></pre></td></tr></table></figure><p>通过修改 Makefile 来一起解决两个问题：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SUBDIR := ./</span><br><span class="line">SUBDIR += ./func</span><br><span class="line"></span><br><span class="line">OUTPUT := ./output</span><br><span class="line"></span><br><span class="line">INCS := $(foreach dir,$(SUBDIR),-I$(dir))</span><br><span class="line">SRCS := $(foreach dir,$(SUBDIR),$(wildcard $(dir)/*.c))</span><br><span class="line">OBJS := $(patsubst %.c,$(OUTPUT)/%.o,$(SRCS))</span><br><span class="line"></span><br><span class="line">main : $(OBJS)</span><br><span class="line">        gcc $(OBJS) -o main</span><br><span class="line"></span><br><span class="line">$(OUTPUT)/%.o : %.c</span><br><span class="line">        mkdir -p $(dir $@)</span><br><span class="line">        gcc -c $(INCS) $&lt; -o $@</span><br></pre></td></tr></table></figure><p>这里我们还在 <code>%.o</code> 前面加了 <code>$(OUTPUT)/</code>，确保匹配到的目标是要生成在输出目录的目标。</p><p>测试一下，是可以使用的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ rm entry.o</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ rm ./func/bar.o</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ make</span><br><span class="line">mkdir -p output/.//</span><br><span class="line">gcc -c -I./ -I./func entry.c -o output/.//entry.o</span><br><span class="line">mkdir -p output/./func/</span><br><span class="line">gcc -c -I./ -I./func func/bar.c -o output/./func/bar.o</span><br><span class="line">gcc ./output/.//entry.o ./output/./func/bar.o -o main</span><br></pre></td></tr></table></figure><h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><p>在 Makefile 中我们可以利用目标执行某些动作。比如定义一个 <code>clean</code> 目标，用于清理编译生成的过程文件：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT := ./output</span><br><span class="line">clean:</span><br><span class="line">        rm -r $(OUTPUT)</span><br></pre></td></tr></table></figure><p>修改后执行 <code>make</code> 命令时传入参数 <code>clean</code> 就会执行 <code>clean</code> 目标下的语句：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ vim ./Makefile</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ make clean</span><br><span class="line">rm -r ./output</span><br></pre></td></tr></table></figure><p>在没有解决头文件依赖问题时，<code>clean</code> 后重新编译，也是一种临时解决方案。</p><p>但这样做存在隐患：当前目录下有与目标同名的文件时，在没有依赖的情况下，Makefile 会认为目标文件已经是最新的状态了，目标下的语句也就不再执行。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ tree</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── output</span><br><span class="line">└── clean</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ make clean</span><br><span class="line">make: &#x27;clean&#x27; is up to date.</span><br></pre></td></tr></table></figure><p>为解决这一问题，我们可以将 <code>clean</code> 声明为伪目标，表明其并非是文件的命名。向特殊内置目标 <code>.PHONY</code> 添加 <code>clean</code> 依赖以达成这一目的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line"></span><br><span class="line">OUTPUT := ./output</span><br><span class="line">clean:</span><br><span class="line">        rm -r $(OUTPUT)</span><br></pre></td></tr></table></figure><p>添加上 <code>.PHONY : clean</code> 后再执行 <code>make clean</code>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ make clean</span><br><span class="line">rm -r ./output</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ tree</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">└── clean</span><br></pre></td></tr></table></figure><p>可以看到 <code>clean</code> 目标下的 <code>rm -r $(OUTPUT)</code> 得到了执行。</p><h3 id="简化终端输出"><a href="#简化终端输出" class="headerlink" title="简化终端输出"></a>简化终端输出</h3><p>现在我们的 Makefile 所输出的内容会有些杂乱无章，我们很难直观看出哪条命令在编译哪个文件。所以我们常通过 <code>@</code> 符号，来禁止 Makefile 将执行的命令输出至终端上：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(OUTPUT)/%.o : %.c</span><br><span class="line">        mkdir -p $(dir $@)</span><br><span class="line">        @gcc -c $(INCS) $&lt; -o $@</span><br></pre></td></tr></table></figure><p>添加 <code>@</code> 符号后，编译命令 <code>gcc -c $(INCS) $&lt; -o $@</code> 就不会输出在终端上了：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ make</span><br><span class="line">mkdir -p output/.//</span><br><span class="line">mkdir -p output/./func/</span><br><span class="line">gcc ./output/.//entry.o ./output/./func/bar.o -o main</span><br></pre></td></tr></table></figure><p>同时你可能注意到 Makefile 中是可以使用终端命令的，所以我们可以用 echo 命令来拟定自己的输出信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">SUBDIR := ./</span><br><span class="line">SUBDIR += ./func</span><br><span class="line"></span><br><span class="line">OUTPUT := ./output</span><br><span class="line"></span><br><span class="line">INCS := $(foreach dir,$(SUBDIR),-I$(dir))</span><br><span class="line">SRCS := $(foreach dir,$(SUBDIR),$(wildcard $(dir)/*.c))</span><br><span class="line">OBJS := $(patsubst %.c,$(OUTPUT)/%.o,$(SRCS))</span><br><span class="line"></span><br><span class="line">main : $(OBJS)</span><br><span class="line">        @echo linking...</span><br><span class="line">        @gcc $(OBJS) -o main</span><br><span class="line">        @echo Complete!</span><br><span class="line"></span><br><span class="line">$(OUTPUT)/%.o : %.c</span><br><span class="line">        @echo compile $&lt;...</span><br><span class="line">        @mkdir -p $(dir $@)</span><br><span class="line">        @gcc -c $(INCS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        @echo try to clean...</span><br><span class="line">        @rm -r $(OUTPUT)</span><br><span class="line">        @echo Complete!</span><br></pre></td></tr></table></figure><p>这是修改 <code>Makefile</code> 后再次执行 <code>make</code> 时，终端的输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example$ make clean</span><br><span class="line">try to clean...</span><br><span class="line">Complete!</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example$ make</span><br><span class="line">compile entry.c...</span><br><span class="line">compile func/bar.c...</span><br><span class="line">linking...</span><br><span class="line">Complete!</span><br></pre></td></tr></table></figure><p>相比之前简洁了许多！</p><h3 id="自动生成依赖"><a href="#自动生成依赖" class="headerlink" title="自动生成依赖"></a>自动生成依赖</h3><p>还记得修改头文件后，包含该头文件的源文件不会重新编译的问题吗？现在让我们试试看解决这个问题。</p><p>问题的解决思路也很简单，就是将头文件一同加入到 *.o 文件的依赖中：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./entry.o : ./entry.c ./func/bar.h</span><br><span class="line">        gcc -c $(INCS) ./entry.c -o ./entry.o</span><br></pre></td></tr></table></figure><p>但这实现起来并不容易，我们需要在 Makefile 中为每个源文件单独添加头文件依赖，手动维护这些依赖关系会是一件极其痛苦的事情。幸运的是，gcc 提供了强大的自动生成依赖功能，仅需在编译时指定 <code>-MMD</code> 选项，就能得到记录有依赖关系的 *.d 文件。</p><blockquote><p><code>-MMD</code> 选项包含两个动作，一是生成依赖关系，二是保存依赖关系到 *.d 文件。与其类似的选项还有 <code>-MD</code>，其作用与 <code>-MMD</code> 相同，差别在于 <code>-MD</code> 选项会将系统头文件一同添加到依赖关系中。</p></blockquote><p>另外我们还可以指定 <code>-MP</code> 选项，这会为每个依赖添加一个没有任何依赖的伪目标。<code>-MP</code> 选项生成的伪目标，可以有效避免删除头文件时，Makefile 因找不到目标来更新依赖所报的错误：&#96;&#96;make: *** No rule to make target ‘dummy.h’, needed by ‘dummy.o’. Stop.&#96;。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gee@JiPing_Desktop:~/workspace/example_makefile$ gcc -MMD -MP -c -I. -I./func entry.c -o entry.o</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example_makefile$ ls</span><br><span class="line">Makefile  entry.c  entry.d  entry.o  func  main  output</span><br><span class="line">gee@JiPing_Desktop:~/workspace/example_makefile$ cat entry.d</span><br><span class="line">entry.o: entry.c func/bar.h   &lt;- 自动生成的依赖关系</span><br><span class="line">func/bar.h:                   &lt;- 没有任何依赖的伪目标</span><br></pre></td></tr></table></figure><p>接着我们还需要将 *.d 文件记录的依赖关系，手动包含到 Makefile 中，这样才能使其真正发挥作用。所以 Makefile 又可以修改为：</p><blockquote><p><code>-MMD</code> 选项生成的 <em>.d 文件保存在与</em> .o 文件相同的路径下。</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">SUBDIR := ./</span><br><span class="line">SUBDIR += ./func</span><br><span class="line"></span><br><span class="line">OUTPUT := ./output</span><br><span class="line"></span><br><span class="line">INCS := $(foreach dir,$(SUBDIR),-I$(dir))</span><br><span class="line">SRCS := $(foreach dir,$(SUBDIR),$(wildcard $(dir)/*.c))</span><br><span class="line">OBJS := $(patsubst %.c,$(OUTPUT)/%.o,$(SRCS))</span><br><span class="line">DEPS := $(patsubst %.o,%.d,$(OBJS))</span><br><span class="line"></span><br><span class="line">main : $(OBJS)</span><br><span class="line">        @echo linking...</span><br><span class="line">        @gcc $(OBJS) -o main</span><br><span class="line">        @echo Complete!</span><br><span class="line"></span><br><span class="line">$(OUTPUT)/%.o : %.c</span><br><span class="line">        @echo compile $&lt;...</span><br><span class="line">        @mkdir -p $(dir $@)</span><br><span class="line">        @gcc -MMD -MP -c $(INCS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        @echo try to clean...</span><br><span class="line">        @rm -r $(OUTPUT)</span><br><span class="line">        @echo Complete!</span><br><span class="line"></span><br><span class="line">-include $(DEPS)</span><br></pre></td></tr></table></figure><p>最后一行的 <code>include</code> 用于将指定文件的内容插入到当前文本中。初次编译，或者 make clean 后再次编译时，*.d 文件是不存在的，这通常会导致 include 操作报错。所以我们在 <code>include</code> 前加了 <code>-</code> 符号，其作用是指示 make 在 include 操作出错时忽略这个错误，不输出任何错误信息并继续执行接下来的操作。</p><h3 id="通用模板"><a href="#通用模板" class="headerlink" title="通用模板"></a>通用模板</h3><p>文章的末尾，放一个通用的 Makefile 模板吧！</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ROOT := $(shell pwd)</span><br><span class="line"></span><br><span class="line">SUBDIR := $(ROOT)</span><br><span class="line">SUBDIR += $(ROOT)/func</span><br><span class="line"></span><br><span class="line">TARGET := main</span><br><span class="line">OUTPUT := ./output</span><br><span class="line"></span><br><span class="line">INCS := $(foreach dir,$(SUBDIR),-I$(dir))</span><br><span class="line">SRCS := $(foreach dir,$(SUBDIR),$(wildcard $(dir)/*.c))</span><br><span class="line">OBJS := $(patsubst $(ROOT)/%.c,$(OUTPUT)/%.o,$(SRCS))</span><br><span class="line">DEPS := $(patsubst %.o,%.d,$(OBJS))</span><br><span class="line"></span><br><span class="line">$(TARGET) : $(OBJS)</span><br><span class="line">        @echo linking...</span><br><span class="line">        @gcc $(OBJS) -o $@</span><br><span class="line">        @echo complete!</span><br><span class="line"></span><br><span class="line">$(OUTPUT)/%.o : %.c</span><br><span class="line">        @echo compile $&lt;...</span><br><span class="line">        @mkdir -p $(dir $@)</span><br><span class="line">        @gcc -MMD -MP -c $(INCS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        @echo try to clean...</span><br><span class="line">        @rm -r $(OUTPUT)</span><br><span class="line">        @echo complete!</span><br><span class="line"></span><br><span class="line">-include $(DEPS)</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://link.zhihu.com/?target=https://developer.aliyun.com/article/766146">如何在 Ubuntu 20.04 上安装 GCC(build-essential)</a></li><li><a href="https://link.zhihu.com/?target=https://stackoverflow.com/questions/43164707/whats-the-meaning-of-gcc-c-and-gcc-o">linux - What’s the meaning of gcc ‘-c’ and gcc ‘-o’?</a></li><li><a href="https://link.zhihu.com/?target=https://www.gnu.org/software/make/manual/make.html%23Rule-Introduction">GNU make</a></li><li><a href="https://link.zhihu.com/?target=https://unix.stackexchange.com/questions/346322/what-does-symbol-in-makefile-mean">make - What does % symbol in Makefile mean</a></li><li><a href="https://link.zhihu.com/?target=https://stackoverflow.com/questions/3220277/what-do-the-makefile-symbols-and-mean">What do the makefile symbols $@ and $&lt; mean?</a></li><li><a href="https://link.zhihu.com/?target=https://stackoverflow.com/questions/14724315/what-does-the-c-option-do-in-gcc">What does the ‘-c’ option do in GCC?</a></li><li><a href="https://link.zhihu.com/?target=https://www.gnu.org/software/make/manual/html_node/Automatic-Prerequisites.html">Automatic Prerequisites (GNU make)</a></li><li><a href="https://link.zhihu.com/?target=https://codereview.stackexchange.com/questions/2547/makefile-dependency-generation">c++ - makefile dependency generation - Code Review Stack Exchange</a></li><li><a href="https://link.zhihu.com/?target=https://www.gnu.org/software/make/manual/html_node/Include.html">Include (GNU make)</a></li></ul><blockquote><p>文章名： 《写给初学者的Makefile入门指南》<br>作者： 吉平.集<br>写作日期： 2023.3.6 ~ 2023.3.30<br>发布日期： 2023.3.30</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS &amp; macOS终端配置</title>
      <link href="/chunyujin/6e2ea259.html"/>
      <url>/chunyujin/6e2ea259.html</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS-amp-macOS终端配置"><a href="#CentOS-amp-macOS终端配置" class="headerlink" title="CentOS &amp; macOS终端配置"></a>CentOS &amp; macOS终端配置</h1><h2 id="终端美化（两系统通用）"><a href="#终端美化（两系统通用）" class="headerlink" title="终端美化（两系统通用）"></a>终端美化（两系统通用）</h2><h3 id="1-设置默认-shell-为-zsh"><a href="#1-设置默认-shell-为-zsh" class="headerlink" title="1.设置默认 shell 为 zsh"></a>1.设置默认 shell 为 zsh</h3><p>查看系统所有的 shell 列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure><p>设置默认 shell 为 zsh，它功能比较多，会好使一些。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><h3 id="2-安装-oh-my-zsh"><a href="#2-安装-oh-my-zsh" class="headerlink" title="2.安装 oh-my-zsh"></a>2.安装 oh-my-zsh</h3><p>oh-my-zsh 是一款社区驱动的命令行工具，它基于 zsh 命令行，提供了主题配置，插件机制，大大提高了可玩（用）性。它的 Github 地址为：<a href="https://github.com/robbyrussell/oh-my-zsh">https://github.com/robbyrussell/oh-my-zsh</a></p><p>我们可以使用 curl 安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure><p>上面地址不行的话，可以尝试下面这个：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure><h3 id="3-配置命令自动提示、语法高亮"><a href="#3-配置命令自动提示、语法高亮" class="headerlink" title="3.配置命令自动提示、语法高亮"></a>3.配置命令自动提示、语法高亮</h3><h4 id="1⃣️命令自动提示："><a href="#1⃣️命令自动提示：" class="headerlink" title="1⃣️命令自动提示："></a>1⃣️命令自动提示：</h4><p>这里我们用到 zsh-autosuggestions 插件，它可以让终端提示我们接下来可能要输入的命令，按右键即可补齐，提高我们工作的效率。</p><p>首先，我们先将仓库克隆到 ～&#x2F;.oh-my-zsh&#x2F;custom&#x2F;plugins 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions.git $ZSH/custom/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure><h4 id="2⃣️语法高亮："><a href="#2⃣️语法高亮：" class="headerlink" title="2⃣️语法高亮："></a>2⃣️语法高亮：</h4><p>zsh-syntax-highlighting 语法高亮插件，作用：命令错误显示红色，直到你输入正确才会变绿色</p><p>安装如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH/custom/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><h4 id="3⃣️配置文件内容，使上面功能被添加："><a href="#3⃣️配置文件内容，使上面功能被添加：" class="headerlink" title="3⃣️配置文件内容，使上面功能被添加："></a>3⃣️配置文件内容，使上面功能被添加：</h4><p>使用<code>vim ~/.zshrc</code>打开文件，找到其中的插件设置，默认是<code>plugins=(git)</code>，我们将其修改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Add wisely, as too many plugins slow down shell startup.</span></span><br><span class="line">plugins=(</span><br><span class="line">  git</span><br><span class="line">  zsh-autosuggestions</span><br><span class="line">  zsh-syntax-highlighting</span><br><span class="line">)</span><br><span class="line">[ -f /usr/local/etc/profile.d/autojump.sh ] &amp;&amp; . /usr/local/etc/profile.d/autojump.sh</span><br><span class="line">source $ZSH/oh-my-zsh.sh</span><br></pre></td></tr></table></figure><p>退出文件后，输入<code>source ~/.zshrc</code>，或者重启中断，应用设置</p><blockquote><p>如果未安装vim，见下方vim安装教程</p></blockquote><h3 id="4-设置-zsh-主题"><a href="#4-设置-zsh-主题" class="headerlink" title="4.设置 zsh 主题"></a>4.设置 zsh 主题</h3><p>我们可以通过<code> vim ~/.zshrc</code> 命令打开 zsh 的配置文件，修改其中的<code> ZSH_THEME</code> 字段的值，进行主题的修改。</p><p>大家可以在 <a href="https://github.com/ohmyzsh/ohmyzsh/wiki/themes">https://github.com/ohmyzsh/ohmyzsh/wiki/themes</a> 链接中，选择自己喜欢的主题。</p><p>我选择的主题的是 crcandy，因为它选择的信息比较全，而且它不依赖其他的特殊字体，可以在不同的终端下正常显示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=&quot;crcandy&quot;</span><br></pre></td></tr></table></figure><p>退出文件后，输入<code>source ~/.zshrc</code>，或者重启中断，应用设置</p><h2 id="CentOS配置"><a href="#CentOS配置" class="headerlink" title="CentOS配置"></a>CentOS配置</h2><h3 id="1-vim安装"><a href="#1-vim安装" class="headerlink" title="1.vim安装"></a>1.vim安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y vim</span><br></pre></td></tr></table></figure><h3 id="2-安装VimForCpp"><a href="#2-安装VimForCpp" class="headerlink" title="2.安装VimForCpp"></a>2.安装VimForCpp</h3><p>VimForCpp是由比特教育汤众老师开发的一款软件，帮助对vim配置方法不熟悉的新手封装的一键式vim环境安装包. 主要针对终端vim用户, 适合远程ssh连接Linux服务器进行开发的场景，将vim打造成一个cpp开发IDE</p><p>教程：<a href="https://gitee.com/c-yujin/vimforcpp">https://gitee.com/c-yujin/vimforcpp</a></p><h3 id="经常遇到的问题："><a href="#经常遇到的问题：" class="headerlink" title="经常遇到的问题："></a>经常遇到的问题：</h3><h4 id="1⃣️VimForCpp图标问题"><a href="#1⃣️VimForCpp图标问题" class="headerlink" title="1⃣️VimForCpp图标问题"></a>1⃣️VimForCpp图标问题</h4><p>有些shell下，VimForCpp可能会遇到图标无法正常显示的情况，可以按照原链接最下面的教程进行解决，如果无法解决，可以尝试以下方式，关闭图标显示：<br>使用<code>sudo vim ~./vimrc</code>进入配置文件，将<code>Plug &#39;ryanoasis/vim-devicons&#39;</code>注释掉即可</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202308311108325.png" alt="截屏2023-08-31 11.08.20" style="zoom:50%;" /><h4 id="2⃣️使用vim打开文件时，显示YouCompleteMe插件不支持此低版本vim"><a href="#2⃣️使用vim打开文件时，显示YouCompleteMe插件不支持此低版本vim" class="headerlink" title="2⃣️使用vim打开文件时，显示YouCompleteMe插件不支持此低版本vim"></a>2⃣️使用vim打开文件时，显示YouCompleteMe插件不支持此低版本vim</h4><p>由于VimForCpp使用了YouCompleteMe这款插件，若插件版本过高，vim版本低，就会出现此错误</p><p>解决方法：降级YouCompleteMe插件，或升级vim版本</p><h5 id="在服务器上升级vim到最新版本："><a href="#在服务器上升级vim到最新版本：" class="headerlink" title="在服务器上升级vim到最新版本："></a>在服务器上升级vim到最新版本：</h5><ol><li>通过yum安装Python3</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y git gcc-c++ ncurses-devel python-devel cmake wget make</span><br><span class="line">sudo yum install -y python36 python36-devel</span><br></pre></td></tr></table></figure><ol start="2"><li>克隆Github的vim项目</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 克隆项目到本地</span><br><span class="line">// 假定是在~目录下克隆，实际可变更位置。</span><br><span class="line">cd ~</span><br><span class="line">git clone https://github.com/vim/vim.git</span><br></pre></td></tr></table></figure><ol start="3"><li>配置并编译Vim</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 进入项目</span><br><span class="line"><span class="built_in">cd</span> vim</span><br><span class="line"></span><br><span class="line">// 配置参数</span><br><span class="line">./configure --prefix=/usr/local/vim  --enable-pythoninterp=<span class="built_in">yes</span> --enable-python3interp=<span class="built_in">yes</span> --with-python-command=python --with-python3-command=python36</span><br><span class="line"></span><br><span class="line">// 编译文件，可能需要使用sudo权限</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">// 编译成功后，vim/src/目录下，会有 vim 文件，后面会用到</span><br><span class="line"><span class="built_in">ls</span> ~/vim/src -al</span><br></pre></td></tr></table></figure><ol start="4"><li>复制Vim到系统配置，并修改Profile</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 复制前可以备份一下</span><br><span class="line">sudo <span class="built_in">cp</span> /usr/bin/vim /usr/bin/vim.backup</span><br><span class="line"></span><br><span class="line">// 复制前面编译的vim到系统配置</span><br><span class="line"><span class="built_in">cd</span> ~/vim/src</span><br><span class="line">sudo <span class="built_in">cp</span> vim /usr/bin</span><br><span class="line"></span><br><span class="line">// 修改系统的Profile, 如果sudo权限不够，则可以尝试使用root用户，我是用的root用户。</span><br><span class="line">su  // 输入root密码，如果还没有设置，则输入 `sudo passwd` 设置root密码。</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PATH=\$PATH:/usr/local/vim/bin&quot;</span> &gt;&gt; /etc/profile</span><br><span class="line"></span><br><span class="line">// 运行刚修改的配置。</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line">// 最后，check version</span><br><span class="line">vim --version</span><br><span class="line">// 同时，也能看到它支持Python3了。(7.4是不支持的。)</span><br></pre></td></tr></table></figure><blockquote><p>作者：神执念浅言多行<br>链接：<a href="https://www.jianshu.com/p/b44d568aef9f">https://www.jianshu.com/p/b44d568aef9f</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h4 id="3⃣️使用vim打开一些文件时，使用键盘上下左右键变成了在文件中输入内容"><a href="#3⃣️使用vim打开一些文件时，使用键盘上下左右键变成了在文件中输入内容" class="headerlink" title="3⃣️使用vim打开一些文件时，使用键盘上下左右键变成了在文件中输入内容"></a>3⃣️使用vim打开一些文件时，使用键盘上下左右键变成了在文件中输入内容</h4><p>此情况多见于普通用户打开一些root权限文件，也可能是由于YouCompleteMe插件产生的bug</p><p>如下图，在正常模式下，使用键盘上下左右键翻页，变成了进入到插入模式下的输入字母”B”</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202308311126771.gif" alt="Aug-31-2023 11-25-58"></p><p>解决方法1:</p><p>使用hjkl移动光标，不使用键盘上下左右键</p><p>解决方法2:</p><p>在root权限下打开，即<code>sudo vim 文件</code></p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【怪物猎人冰原】武器介绍_片手</title>
      <link href="/chunyujin/ed234e8a.html"/>
      <url>/chunyujin/ed234e8a.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本期文本攻略，可以搭配相关动作演示视频对比观看，视频已内嵌在文章最后，也可点击视频下方链接进入原地址观看，</p><h1 id="简介和定位"><a href="#简介和定位" class="headerlink" title="简介和定位"></a>简介和定位</h1><p>​在冰原片手剑的最后一次更新之后，片手剑的JR伤害提升了百分之四十，这让片手剑从一个伤害不错机动性强的武器一跃成为了高伤害高机动性的武器。凭借着JR“一刀一个飞圆斩“替代虫棍成为了新一代完美武器（雾。</p><p>​片手剑，又名单手剑，猎人在装备时，左手持剑，右手持盾，盾牌的防御性能为所有近战带盾武器的最低，防御性能：片手剑&lt;盾斧&lt;长枪&amp;铳枪。在实战中，片手剑的盾牌更像是一种输出手段，在很多招式中都使用了盾牌攻击，盾牌攻击带有一定的眩晕能力。防御只是在很少一部分时间下是用来抵挡怪物的攻击的（因为挡也挡不住），更多情况下是作为派生动作的前置动作。片手剑是一个很吃机动性的武器，实际上，轻武器都很吃机动性，片手剑的优势体现在机动性和攻击性的相互转化，比如后撤步回避时可派生攻击动作，防御派生攻击动作，翻滚派生后撤步派生攻击动作等。</p><p>​片手剑的一大痛点是，短。短到通过肉眼判断时，武器明明是可以打中怪物的，但是实际上竟然打不到。在使用片手剑的时候，可以将片手剑想想成拳击手套，避免过长判断攻击距离，因为，它就是很短！</p><p>​总的来说，片手剑是一个趣味性比较高的武器，并且，它伤害很不俗（家人们，进战三幻神谁懂啊，另外两位真神是大剑和双刀）。它的招式派生比较复杂，但是在理解派生关系后，其实就很简单了。</p><h1 id="招式触发"><a href="#招式触发" class="headerlink" title="招式触发"></a>招式触发</h1><p><mark>注意，招式名称会用<code>方框</code>框起来；【】内对应的是具体按键；在按键时，有”先后按“和”同时按“，两个按键之间是先后关系时，使用”-&gt;“表示，是同时关系时，使用”+“表示（此表示方法和怪猎游戏内部招式教学相同）</mark></p><h2 id="对空飞翔爪（片手剑用于软化的好技能）"><a href="#对空飞翔爪（片手剑用于软化的好技能）" class="headerlink" title="对空飞翔爪（片手剑用于软化的好技能）"></a>对空飞翔爪（片手剑用于软化的好技能）</h2><p>做出“升龙拳”的姿势，用钩爪勾到怪物身上。</p><p>此招上身过程本身就算是一次轻武器软化。</p><p>所以两次升龙，或一次升龙上身后接一次武器攻击或者三次钩爪攻击，即可实现一次软化。</p><p>方便高效，不怕怪物发怒时不让钩在身上。</p><h3 id="出招解释："><a href="#出招解释：" class="headerlink" title="出招解释："></a>出招解释：</h3><p><u>拔刀状态下</u>，<code>翻滚</code>后按【L2】</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>需要在拔刀状态下翻滚才能使用，如何拔刀：</p><ol><li>直接【三角】攻击，拔刀，然后翻滚</li><li><code>防御</code>也会拔刀，按下【R2】防御键之后直接翻滚即可。</li><li>相比于攻击拔刀，防御拔刀不需要等攻击结束后即可翻滚，更快速。且人物在移动中使用攻击拔刀，会使出<code>突进斩</code>，后摇较大，不好接翻滚，而防御拔刀十分迅速。</li><li>在从怪物身上下落时，可以在控制提前按出<code>防御</code>这样下落之后后拉左摇杆+【圆圈】直接可以使用<code>后撤步</code></li><li>从怪物身上下来之后，会<mark>自动收刀</mark></li></ol><h2 id="后撤步（后退步伐）"><a href="#后撤步（后退步伐）" class="headerlink" title="后撤步（后退步伐）"></a>后撤步（后退步伐）</h2><p><code>后撤步</code>是带有回避判定的动作。<code>后撤步</code>经常作为前置动作，派生其他招式使用</p><p><code>后撤步</code>为片手中一个极容易派生的招式，几乎可以在所有的招式之后派生出来</p><p><code>后撤步</code>的前置条件：</p><ol><li>拔刀</li><li>触发于招式之后</li></ol><blockquote><p><code>后撤步</code>以及<code>后撤步</code>派生出的招式的第一击无法派生<code>后撤步</code>，完整<code>JR</code>中无法派生<code>后撤步</code></p><p>但是上面的情况中，可以通过“打断”的方式来强制派生<code>后撤步</code>，比如</p><ol><li><code>后撤步</code>派生出<code>飞身跃入斩</code>之后可以按【圆圈】使用<code>水平斩</code>打断，随后便可跟<code>后撤步</code></li><li><code>JR</code>中，可以按【圆圈】使用<code>水平斩</code>打断，随后便可跟<code>后撤步</code></li><li>注意，<code>后撤步</code>派生出<code>蓄力斩</code>之击中目标后，会自动打出<code>上冲斩</code>（小登龙），直到落下之前，都无法打断</li></ol></blockquote><p><code>后撤步</code>主要是为了派生<code>飞身跃入斩（然后接JR）</code>、<code>蓄力斩（击中目标后自动接上冲斩）</code>和<code>上捞斩</code></p><p><code>上捞斩</code>是在后撤后再次后拉左摇杆，即可派生</p><p><code>飞身跃入斩</code>和<code>蓄力斩</code>分别会在[JR（Just Rush 致命连击）](#JR（Just Rush 致命连击）（江湖人称农夫三拳、民工三连）)和<a href="#%E8%93%84%E5%8A%9B%E6%96%A9">蓄力斩</a>中介绍</p><h3 id="出招解释：-1"><a href="#出招解释：-1" class="headerlink" title="出招解释："></a>出招解释：</h3><p>基本出招方式为：在招式之后派生：左摇杆后拉 + 【圆圈】 <mark>注意是同时按</mark></p><blockquote><p>还有一种情况的衍生不需要后拉左摇杆，在连续使用三次【圆圈】攻击后，再按一次【圆圈】即可派生<code>后撤步</code></p><ol><li>【圆圈】水平斩-&gt;【圆圈】反击斩-&gt;【圆圈】回转斩击-&gt;【圆圈】后撤步</li><li>推左摇杆+【圆圈】盾攻击-&gt;【圆圈】里拳攻击-&gt;【圆圈】奋力强锤-&gt;【圆圈】后撤步</li></ol></blockquote><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h3><p><code>后撤步</code>是在招式之后派生的，而<code>防御</code>也是一个招式，由此，在收刀或者拔刀状态下，<u>原地<code>防御</code>派生<code>后撤步</code>是一种经常被使用的、速度快效率高的起手式或者连击时穿插动作</u></p><p>【R2】防御-&gt;后拉左摇杆+【圆圈】  ：防御派生后撤步</p><p>但是<code>防御后撤步</code>在实际按键的时候，容易失败：</p><blockquote><p><code>防御</code>和<code>后撤步</code>是先后关系，也就是先按【R2】，然后再同时 左摇杆后拉 + 【圆圈】，注意 ”左摇杆后拉 + 圆圈“是同时按的，不要先后按，否则使出的是<code>防御斩</code>，随后人物会一直举盾，无法执行其他动作，后摇极大</p><p>如果发现，人物是先向左或者右转头，再使用出的<code>防御斩</code>，说明按键时 左摇杆后拉 比 【圆圈】快了</p><p>而如果发现，人物直接使出了<code>防御斩</code>，然后不动，说明按键时【圆圈】比 左摇杆后拉 快了</p></blockquote><p>不过失败了也没关系，使出了<code>防御斩</code>，也可以继续，派生后撤步</p><p>小tips：点按R2之后，再拉左摇杆、按圆圈，如果速度过快，很容易造成顺序出错，且按键有种割裂感。&#x3D;&#x3D;不妨试试按下R2之后不立即松开，然后顺势再后拉左摇杆、按圆圈&#x3D;&#x3D;，这样玩家能明显感觉到按键流程的先后顺序，十分有助于提升手感，且这样的防御后撤步和点按的速度基本无差，主要是成功率很高。</p><blockquote><p>其实很多情况下按键，并不一定按完之后就要立刻抬起来，要松开是因为有些需要按多次，所以要松开，如果一个按键在按之后，并不需要立即再按，其实可以不立刻松开，这样玩家会感到比较明显的顺序感，有利于提升手感。</p></blockquote><p>在拔刀状态下，<code>翻滚</code>后也可派生<code>后撤步</code>。</p><p>在实战中，经常要用到翻滚，翻滚结束后直接就可以接后撤步进行一波输出。这个招式充分体现了片手剑的灵活性和机动性，在这里并不是指它的走位灵活，而是在很多情况、很多动作后都可以衔接攻击，甚至在翻滚后也可以来个农夫三拳，真正的见缝插针，无缝化流畅衔接。</p><h2 id="后撤步派生-JR（Just-Rush-致命连击）"><a href="#后撤步派生-JR（Just-Rush-致命连击）" class="headerlink" title="后撤步派生_JR（Just Rush 致命连击）"></a>后撤步派生_JR（Just Rush 致命连击）</h2><p>JR是一套动作值极高的片手剑招式，属于片手剑最强力的输出手段。</p><p>很猛，共有3阶段，7刀，一共370动作值（大剑真蓄200动作值）</p><h3 id="出招解释：-2"><a href="#出招解释：-2" class="headerlink" title="出招解释："></a>出招解释：</h3><p>JR的触发前置是：<code>飞身跃入斩</code></p><blockquote><p><code>飞身跃入斩</code>的两种派生方式：</p><ol><li><p><code>后撤步</code> -&gt; 【三角】 派生  （ 有时候会判定不到按住三角，所以建议多按几次）</p></li><li><p><u>拔刀时</u>，【L2】-&gt; 【R3】，先将射击模式切换为“瞄准强化射击”（随后一直会保持这个模式，再次重复则是切换回“拔刀投射器瞄准）</p><p>然后【L2】-&gt; 【R2】派生</p></li></ol></blockquote><p>随后人物在每间隔一小段时间会冒出红光并手柄震动，提示出招最佳时机，此时按 【三角】，使出<code>致命连击JR</code>的第一击，按照同样的方式，共触发出三段<code>JR</code>，完成后，人物会抱脸到怪物身上，给予最后一集并在空中后翻滚跳（类似于斩斧下脸）</p><blockquote><p><code>飞身跃入斩</code>和<code>JR</code>的每一击都可以使用左摇杆来轻微调整方向</p></blockquote><h3 id="用法建议："><a href="#用法建议：" class="headerlink" title="用法建议："></a>用法建议：</h3><p>但是一整套JR打下来需要一定的时间，属于站桩输出，且最后一击后会造成人物失位。因此建议在适当的时机使用，或者可以考虑只打出JR前几段攻击，不打最后一击，是用回避来终止。</p><p><mark>JR的每一段攻击都可以用回避打断，在实战中经常用。</mark></p><p>再怪物倒地的时候，如果怪物的倒地时间较长，可以采取先打半套JR，回避终止，接后撤步，再打一整套JR的方式来压起身。或者先来一套<code>蓄力斩</code>加<code>向下强锤</code>，回避，再打一整套JR，总是建议JR最后一击在动作终结的时候使用。</p><p>在实战中，JR往往是在具有输出时机的时候使用，比如怪物硬直，在此之前，通常使用小连招进行蹭刀，直到怪物倒地硬直。</p><blockquote><p>ps：竞速玩家则是采取一直JR的策略，主打高输出</p></blockquote><h2 id="后撤步派生-蓄力斩"><a href="#后撤步派生-蓄力斩" class="headerlink" title="后撤步派生_蓄力斩"></a>后撤步派生_蓄力斩</h2><h3 id="出招解释：-3"><a href="#出招解释：-3" class="headerlink" title="出招解释："></a>出招解释：</h3><p><code>后撤步</code>时按住【圆圈】不放，或者<code>后撤步</code>后再次长按【圆圈】，直到人物发红提示可以松开，释放<code>蓄力斩</code></p><blockquote><p>若一直不松开，则会自动释放<code>蓄力斩</code></p></blockquote><p><code>蓄力斩</code>在<u>命中目标后</u>会自动接<code>上冲斩</code>，在升空时，可派生两个动作</p><ol><li>空中按【三角】，使出<code>跳跃斩</code>，此招后摇小，灵活，适合高出打点，且有55点骑乘值</li><li>空中按【圆圈】，使出<code>向下强锤</code>，是盾击，两段伤害，在空中一段，落地后砸击地面一段（只是命中率比较低，主要是空中伤害），此招能累计眩晕值，且伤害较高,，在实战中常用。骑乘值为0</li></ol><p>在空中时，均可以推动左摇杆来更改方向</p><blockquote><p><code>蓄力斩</code>在未命中目标时，不会自动接<code>上冲斩</code>，此时按【三角】派生上捞斩，【圆圈】派生水平斩</p></blockquote><h3 id="用法建议：-1"><a href="#用法建议：-1" class="headerlink" title="用法建议："></a>用法建议：</h3><p>此招同为<code>后撤步</code>派生技，相较于<code>JR</code>，它虽然伤害略低，但是时间更短，后摇更小，更加灵活。实战中可根据情况来使用。</p><h2 id="上捞斩"><a href="#上捞斩" class="headerlink" title="上捞斩"></a>上捞斩</h2><p>常用作蹭刀的起手式。</p><ol><li><p><code>防御</code>-&gt;【三角】攻击</p></li><li><p>也可在后撤步之后，后拉左摇杆。一般是在后撤步使出后，某种情况下不需要向前攻击而是原地攻击。</p></li><li><p><code>蓄力斩</code>在未命中目标时，不会自动接<code>上冲斩</code>，此时按【三角】派生<code>上捞斩</code>，按【圆圈】派生<code>水平斩</code></p></li></ol><blockquote><p>上捞斩之后是可以跟后撤步的</p></blockquote><h2 id="下坠突刺"><a href="#下坠突刺" class="headerlink" title="下坠突刺"></a>下坠突刺</h2><p>在登墙时使用【三角】</p><p><code>下坠突刺</code>的动作值非常高，给予怪物多段伤害。</p><blockquote><p>值得注意的是，是“登墙”而非“爬墙后下落”</p><p>在高出下落、下滑过程中，使用出的招式是<code>跳跃斩</code>，也就是跟在<code>蓄力斩</code>时按【圆圈】使出的相同的招式</p><p>人物收刀时，面向墙面移动</p><p>如果按【R1】，则会爬墙，然后从墙上下落，爬墙到下落中，按【三角】，使出<code>跳跃斩</code></p><p>如果不按【R1】，直接按【三角】，则会登墙，并使用<code>下坠突刺</code></p></blockquote><h2 id="常用蹭刀连段"><a href="#常用蹭刀连段" class="headerlink" title="常用蹭刀连段"></a>常用蹭刀连段</h2><p>为什么要使用蹭刀连段？</p><p>在大多数时间里，怪物都是处于运动和攻击的自由态，猎人需要与其周旋，然后看准时机使用高伤害招式。在周旋过程中，就是要靠蹭刀连段来不断蹭刀，持续输出，寻找机会，创造机会。</p><p>片手剑的普通招式虽然伤害不及JR和蓄力斩，但是胜在攻击频率很高，一套下来也有不俗的输出。</p><h3 id="民工五连（已拔刀则是四连）"><a href="#民工五连（已拔刀则是四连）" class="headerlink" title="民工五连（已拔刀则是四连）"></a>民工五连（已拔刀则是四连）</h3><p>收刀状态下，<code>防御</code>-&gt;【三角】上捞斩，作为起手式</p><p>然后，【三角】斩下-&gt;【三角】横斩-&gt;【圆圈】水平斩-&gt;【圆圈】反击斩</p><blockquote><p>此招式原地打桩，且要注意，【圆圈】时不要推动左摇杆，否则使出的是盾击</p></blockquote><h3 id="老板六连（已拔刀则是五连）"><a href="#老板六连（已拔刀则是五连）" class="headerlink" title="老板六连（已拔刀则是五连）"></a>老板六连（已拔刀则是五连）</h3><p>收刀状态下，<code>防御</code>-&gt;【三角】上捞斩，作为起手式</p><p>然后，【三角】斩下-&gt;【三角】横斩-&gt;【圆圈】水平斩-&gt;左摇杆推向正前方以外任意方向(建议正前方45°左右)+【三角】旋回斩-&gt;【三角】突刺，之后是<code>旋回斩</code>和<code>突刺</code>复读。</p><blockquote><p>这个招式相较于民工五连，伤害更高，且<code>旋回斩</code>会更改攻击方向，在实战中怪物移动时更灵活，可绕圈打桩</p><p><code>旋回斩</code>和<code>突刺</code>的复读，只要是移动左摇杆+【三角】就可以，并不需要接在特定招式之后，但是它无法作为起手式。</p></blockquote><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>防御不只是用来防住怪物的攻击，还经常用来作为补正动作。</p><ol><li><p><u>收刀状态下</u>，在移动过程中按下【三角】攻击拔刀，人物会向前位移使出<code>突进斩</code>，距离长但是时间也长，若怪物很近，但是需要蹭刀，这招起手式就很不方便。</p><p>在拔刀前先按下<code>防御</code>，再按下【三角】攻击拔刀，此时人物就会使出<code>上捞斩</code>，不会向前突刺了，之后再进行蹭刀即可。</p><p>在实战中根据怪物与人物的距离判断蹭刀起手式使用<code>突进斩</code>还是<code>上捞斩</code>。</p></li><li><p>收刀状态下按<code>防御</code>拔刀，随后翻滚使用<code>对空飞翔爪</code>。</p></li><li><p><code>防御</code>派生<code>后撤步</code></p></li><li><p>在按下一次【R2】后<code>防御</code>会持续一定时间，表现就是人物一直举盾，在此期间都是可以派生<code>后撤步</code>的</p></li></ol><h2 id="基本小招式"><a href="#基本小招式" class="headerlink" title="基本小招式"></a>基本小招式</h2><h3 id="突进斩"><a href="#突进斩" class="headerlink" title="突进斩"></a>突进斩</h3><ol><li>收刀时，移动中按下【三角】</li><li>拔刀时，在没有前置招式时，【三角】+【圆圈】</li></ol><p>有一段向前的位移</p><h3 id="【三角】的招式"><a href="#【三角】的招式" class="headerlink" title="【三角】的招式"></a>【三角】的招式</h3><p>连续按【三角】，使出<code>斩下</code>、<code>横斩</code>、<code>剑盾连击</code>，动作值依次下降，且剑盾连击时间较长，因此在横斩之后考虑接其他招式</p><h3 id="【圆圈】的招式"><a href="#【圆圈】的招式" class="headerlink" title="【圆圈】的招式"></a>【圆圈】的招式</h3><p>第一击不推动左摇杆时，连续按【圆圈】，使出<code>水平斩</code>、<code>反击斩</code>、<code>回旋斩击</code>。回旋斩击后按【圆圈】会自动<code>后撤步</code></p><p>在第一击推动左摇杆时，连续按【圆圈】，使出<code>盾攻击</code>、<code>里拳攻击</code>、<code>奋力强锤</code>，每一击都会累积眩晕值。奋力强锤后按【圆圈】会自动<code>后撤步</code>。</p><h3 id="回旋斩击"><a href="#回旋斩击" class="headerlink" title="回旋斩击"></a>回旋斩击</h3><ol><li>如上，不推动左摇杆，连续按三次【圆圈】，最后一击为<code>回旋斩击</code></li><li>在<code>JR</code>、<code>蓄力斩</code>之外的攻击招式后，按【三角】+【圆圈】派生<code>回旋斩击</code></li></ol><p><code>回旋斩击</code>之后按【圆圈】，派生<code>后撤步</code></p><blockquote><p>因此可以蹭刀后跟<code>回旋斩击</code>，再跟<code>后撤步</code></p></blockquote><h1 id="演示视频"><a href="#演示视频" class="headerlink" title="演示视频"></a>演示视频</h1><iframe src="//player.bilibili.com/player.html?aid=231520910&bvid=BV1N841127vH&cid=1214544876&page=1&high_quality=1&danmaku=0&autoplay=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe><p><a href="https://www.bilibili.com/video/BV1N841127vH/?vd_source=727b430d8f6893d33c7696f5b7921dcd">【MHWI】片手剑-招式演示(搭配简介文字教学食用更佳)</a></p><p>专栏地址：</p><p><a href="https://www.bilibili.com/read/cv25373893">https://www.bilibili.com/read/cv25373893</a></p>]]></content>
      
      
      <categories>
          
          <category> MH </category>
          
          <category> MHWI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 怪物猎人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入b站视频</title>
      <link href="/chunyujin/44d47125.html"/>
      <url>/chunyujin/44d47125.html</url>
      
        <content type="html"><![CDATA[<p>在b站视频点击分享，获取“嵌入代码”</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202307291412908.png" alt="截屏2023-07-29 14.12.17" style="zoom:50%;" /><p>如上图，获取的嵌入代码为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=247120140&amp;bvid=BV1Av411a7bt&amp;cid=307398204&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置一下视频的长度、宽度、画质、弹幕开关、填充情况，并且关闭自动播放，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=247120140&amp;bvid=BV1Av411a7bt&amp;cid=307398204&amp;page=1&amp;high_quality=1&amp;danmaku=0&amp;autoplay=0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;allowfullscreen&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">sandbox</span>=<span class="string">&quot;allow-top-navigation allow-same-origin allow-forms allow-scripts&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">BILIBILI</span> 地址<span class="variable constant_">PC</span>端参数</span><br><span class="line">    &amp;high_quality=<span class="number">1</span>   (<span class="number">1</span>=最高画质 <span class="number">0</span>=最低画质)</span><br><span class="line">    &amp;danmaku=<span class="number">0</span>   (<span class="number">1</span>=打开弹幕 <span class="number">0</span>=关闭弹幕)</span><br><span class="line">iframe 参数</span><br><span class="line">    allowfullscreen=<span class="string">&quot;allowfullscreen&quot;</span> #移动端全屏</span><br><span class="line">    sandbox=<span class="string">&quot;allow-top-navigation allow-same-origin allow-forms allow-scripts&quot;</span> #禁止弹出网页</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">属性</th><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">align</td><td align="left">left right top middle bottom</td><td align="left">不赞成使用。请使用样式代替。规定如何根据周围的元素来对齐此框架。</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">frameborder</td><td align="left">10</td><td align="left">规定是否显示框架周围的边框。</td></tr><tr><td align="left">height</td><td align="left">pixels%</td><td align="left">规定 iframe 的高度。</td></tr><tr><td align="left">longdesc</td><td align="left">URL</td><td align="left">规定一个页面，该页面包含了有关iframe 的较长描述。</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">marginheight</td><td align="left">pixels</td><td align="left">定义 iframe的顶部和底部的边距。</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">marginwidth</td><td align="left">pixels</td><td align="left">定义 iframe的左侧和右侧的边距。</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">name</td><td align="left">frame_name</td><td align="left">规定 iframe 的名称。</td></tr><tr><td align="left">sandbox</td><td align="left">“”allow-formsallow-same-originallow-scriptsallow-top-navigation</td><td align="left">启用一系列对 &lt;_iframe&gt; 中内容的额外限制。</td></tr><tr><td align="left">scrolling</td><td align="left">yesnoauto</td><td align="left">规定是否在 iframe中显示滚动条。</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">seamless</td><td align="left">seamless</td><td align="left">规定 &lt;_iframe&gt; 看上去像是包含文档的一部分。</td></tr><tr><td align="left">src</td><td align="left">URL</td><td align="left">规定在 iframe中显示的文档的 URL。</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">srcdoc</td><td align="left">HTML_code</td><td align="left">规定在 &lt;_iframe&gt; 中显示的页面的 HTML 内容。</td></tr><tr><td align="left">width</td><td align="left">pixels%</td><td align="left">定义 iframe 的宽度。</td></tr></tbody></table><p>效果展示：</p><iframe src="//player.bilibili.com/player.html?aid=247120140&bvid=BV1Av411a7bt&cid=307398204&page=1&high_quality=1&danmaku=0&autoplay=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Typora </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主题设置</title>
      <link href="/chunyujin/5c7e764.html"/>
      <url>/chunyujin/5c7e764.html</url>
      
        <content type="html"><![CDATA[<p>在晚上码字的时候如果使用白色的主题背景会感觉对眼睛不是很友好，因此可以选择一些暗黑风格的主题来达到更舒适的效果</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230402225506602.png" alt="image-20230402225506602"></p><p>打开typora的设置，转到外观，如果对于初始的几种主题不满意可以选择获取主题，不过在此之前先点击”打开主题文件夹“，进入到主题文件夹中</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230402225649847.png" alt="image-20230402225649847" style="zoom:67%;" /><p>这几个后缀为.css的文件即是主题文件</p><blockquote><p>windows中会自动匹配类型，我的电脑上给.css文件匹配的类型是typora类型，但是本质上是.css</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230402231520351.png" alt="image-20230402231520351" style="zoom:67%;" /></blockquote><p>回到设置中来，打开”获取主题“，进入到官方主题网站（可能需要科学上网）</p><p>选择喜欢的主题进行下载</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230402225830308.png" alt="image-20230402225830308" style="zoom:67%;" /><p>此处以第一个”GitHub Dark Themes“为例，进入之后点击下载</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230402225952296.png" alt="image-20230402225952296" style="zoom:67%;" /><p>之后将下载好的压缩文件进行解压，将文件夹复制到之前打开的本地主题文件夹里theme里</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230402230219321.png" alt="image-20230402230219321" style="zoom:67%;" /><p>然后将这个主题文件夹Typora-GitHub-Themes-main里面后缀为.css的文件(或者显示为typora类型的文件)复制或者拖拽到theme文件夹中，这个文件即是主题文件，并且已经可以在Typora中应用了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230402230555379.png" alt="image-20230402230555379" style="zoom:67%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230402230625707.png" alt="image-20230402230625707" style="zoom:67%;" /><blockquote><p>有时候一个主题也有不同的风格，比如这个主题就有三种风格</p><p>可以选择自己喜欢的放入theme文件夹，也可以全部放入</p></blockquote><p>重启typora，在设置-外观中即可选用，或者直接点击页面上方的“主题”，即可应用新增的主题</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230402230802457.png" alt="image-20230402230802457" style="zoom:67%;" /><blockquote><p>个人推荐：</p><p>浅色模式的主题使用Typora自带的Github主题，简约，字体舒适，并且对于文档和代码段的处理、表示都很明显舒适</p><p>深色模式使用”<a href="https://theme.typora.io/theme/Aspartate/">Aspartate</a>“，颜色不是纯黑，有一点点发灰，接近windows系统的主题黑，颜色比较柔和(纯黑比较费眼睛)，并且格式布局、字体等与Typora自己的Github比较接近，对于代码段的处理也比较好</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Typora </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入图片</title>
      <link href="/chunyujin/ab111c04.html"/>
      <url>/chunyujin/ab111c04.html</url>
      
        <content type="html"><![CDATA[<p>插入图像与插入链接的语法基本一样，就是在最前面加了一个!字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![连接文本](图片路径)</span><br></pre></td></tr></table></figure><p>比如:</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-12-15%20220238.png" alt="这是一个参考文本和一个示例图片"></p><p>也可以直接将图片复制或者拖拽进来，配合上传到图床的功能，直接在图床中生成链接</p><p>比如:</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215214853021.png" alt="image-20221215214853021"  />]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Typora </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文字颜色</title>
      <link href="/chunyujin/26659f59.html"/>
      <url>/chunyujin/26659f59.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230306150531038.png" alt="image-20230306150531038"></p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Typora </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文字高亮</title>
      <link href="/chunyujin/4d67aa64.html"/>
      <url>/chunyujin/4d67aa64.html</url>
      
        <content type="html"><![CDATA[<h1 id="文字高亮"><a href="#文字高亮" class="headerlink" title="文字高亮"></a>文字高亮</h1><p>Typora设置中打开文字高亮</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301072259003.png" alt="截屏2023-01-07 22.58.58"></p><p>有两种高亮方式，一是按照markdown语法</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301072300282.png" alt="截屏2023-01-07 22.58.36"></p><p>二是按照html语法，在需要高亮的部分加上</p><p> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301072301879.png" alt="截屏2023-01-07 22.58.50"></p><p>第一种方式在有些网站比如个人博客上无法识别</p><h1 id="自定义文字高亮颜色"><a href="#自定义文字高亮颜色" class="headerlink" title="自定义文字高亮颜色"></a>自定义文字高亮颜色</h1><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230306145123272.png" alt="image-20230306145123272"></p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Typora </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用磁力链接</title>
      <link href="/chunyujin/ac21c363.html"/>
      <url>/chunyujin/ac21c363.html</url>
      
        <content type="html"><![CDATA[<p>等待更新中….</p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> 磁力链接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 磁力链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建立字符表_有效的字母异位词</title>
      <link href="/chunyujin/a309d3c0.html"/>
      <url>/chunyujin/a309d3c0.html</url>
      
        <content type="html"><![CDATA[<p>[题目来源](<a href="https://leetcode.cn/problems/valid-anagram/comments/">242. 有效的字母异位词 - 力扣（LeetCode）</a>)</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230405230509034.png" alt="image-20230405230509034"></p><p>常规的方法：对于两个字符串进行排序，然后判断两个字符串是否相等(可以直接判断字符串是否相等，if s&#x3D;&#x3D;t return true)</p><p>一种奇妙的思路：建立字符表</p><blockquote><p>两个字符串中的字符无非就是26个字母。建立一个容量为26的数组，内容全部初始化为0.如果s中存在某一字母，就在相应的位置上+1，如果t中存在某一字母，就在相应的位置上-1，最后如果数组中还是全为0，说明s和t中的内容正好相互抵消，否则说明s和t不是有效的字母异位词。（感觉有点像摩尔投票法中的支持者打架）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;; </span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">length</span>()!=t.<span class="built_in">length</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)&#123;</span><br><span class="line">            num[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            num[t[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(num[i]!=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>弊端：必须面对已知的字符，建立完整的字符表，比如已知含有的字符无非是26个字母。如果按照题目的进阶，unicode字符量很大，且不知道所有的字符是什么，无法建立字符表。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 刷题日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摩尔投票法_多数元素(绝对众数)</title>
      <link href="/chunyujin/4eceace9.html"/>
      <url>/chunyujin/4eceace9.html</url>
      
        <content type="html"><![CDATA[<p>[题目来源](<a href="https://leetcode.cn/problems/majority-element/solution/408-shi-jian-fu-za-du-wei-on-kong-jian-f-xyf1/">408 时间复杂度为 O(n)、空间复杂度为 O(1) - 多数元素 - 力扣（LeetCode）</a>)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230404232915115.png" alt="image-20230404232915115" style="zoom: 80%;" /><p>一般有以下三种思路：</p><ol><li><p>暴力求解，从第一个元素开始记录，遇到与第一个元素值相同的元素就计数+1，当某个元素的个数大于等于n&#x2F;2的时候，说明就是这个元素最多</p></li><li><p>先排序，后返回容器中第n&#x2F;2个元素</p></li><li><p>摩尔投票法：</p><blockquote><p>解决的问题是如何在任意多的候选人（选票无序），选出获得票数最多的那个。</p><p>（解决绝对众数的问题：如果一个元素出现的次数大于等于其他所有数出现的次数之和，那么这个数就是绝对众数，也就是说如n个数里如果有一个数的数量大于等于n&#x2F;2，这个数就是绝对众数）</p><p>形象化描述：</p><blockquote><p>想象着这样一个画面：</p><p>会议大厅站满了投票代表，每个都有一个牌子上面写着自己所选的候选人的名字。然后选举意见不合的（所选的候选人不同）两个人，会打一架，并且会同时击倒对方。显而易见，如果一个人拥有的选票比其它所有人加起来的选票还要多的话，这个候选人将会赢得这场“战争”，当混乱结束，最后剩下的那个代表（可能会有多个）将会来自多数人所站的阵营。</p><p>但是如果所有参加候选人的选票都不是大多数（选票都未超过一半），那么最后站在那的代表（一个人）并不能代表所有的选票的大多数。因此，当某人站到最后时，需要统计他所选的候选人的选票是否超过一半（包括倒下的），来判断选票结果是否有效。</p></blockquote><p>在本题中，显然是一定有一个候选人的选票达到大半的</p><p>算法的描述：</p><blockquote><p>我们维护一个 x ，表示当前的候选人，然后维护一个 num，用来表示当前候选人的选票数 。对于每一张新的选票，如果它投给了当前的候选人，就把 num 加1，否则就把 num 减1（也许你可以想象成，B的一个狂热支持者去把A的一个支持者揍了一顿，然后两个人都没法投票）。特别地，计票过程中如果 num&#x3D;0 ，我们可以认为目前谁都没有优势，所以新的选票投给谁，谁就成为新的候选人。</p><blockquote><p>如果我们要求的是众数，这样的做法并不能给出正确答案，但如果要求的是绝对众数（<strong>且绝对众数确实存在</strong>），那么 n 一定是正确的。</p><p>这是因为，在最后计票时，我们知道有 num 张票投给了 x ，假如绝对众数另有其人，那么一定是剩下的票投出来的。但剩下的 x− num 张票都是在“捉对厮杀”的过程中被抵消掉的，每一对被抵消的票都来自不同的候选人，所以一个候选人最多在这里拿到 n−num&#x2F;2 票，这不可能大于 n&#x2F;2 。但绝对众数确实存在，所以这个绝对众数就一定是 m 。</p><p>如果绝对众数不存在，摩尔投票会给出一个错误的解，所以一定要记得验证答案。</p></blockquote></blockquote><p>算法的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(num = <span class="number">0</span>)</span><br><span class="line">        x = A[i];</span><br><span class="line">    <span class="keyword">if</span>(A[i] == x)</span><br><span class="line">        num++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        num--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果实际情况下绝对众数本身就是不存在的，那么会得到一个错误的解，此时需要进行一下验证</span></span><br></pre></td></tr></table></figure></blockquote><p>摩尔投票法的进阶：</p><p>简单的摩尔投票法只是能找到一个选票最多的。但是如果要求选出N个人，这个N个人只要满足票数大于1&#x2F;(N+1)就可以，也是可以摩尔投票法的思想，只是需要进行一下修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x[N], num[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : nums) &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">find</span>(x, x + N, e) - x;</span><br><span class="line">    <span class="keyword">if</span> (i != N) &#123; <span class="comment">// 如果当前票投给了候选人之一</span></span><br><span class="line">        num[i]++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j = <span class="built_in">find</span>(num, num + N, <span class="number">0</span>) - num;</span><br><span class="line">    <span class="keyword">if</span> (j != N) &#123; <span class="comment">// 如果当前存在一个位置&quot;虚位以待&quot;</span></span><br><span class="line">        x[j] = e;</span><br><span class="line">        num[j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : num)</span><br><span class="line">        c--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后需要验证答案是否符合要求</span></span><br></pre></td></tr></table></figure><blockquote><p>原理是一样的。最后我们可以把票分为2个部分：投给了最多 N 个候选人的一部分，和被抵消的一部分。后者可以划分为若干个 N+1 元组，每个元组内的票都来自不同的候选人。因此，只有那些属于第一部分的人的票数可能超过总数的 1&#x2F;(N+1) 。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 刷题日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EVA资源获取及使用</title>
      <link href="/chunyujin/96ce1217.html"/>
      <url>/chunyujin/96ce1217.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://dc.btfan.cc/hash/bd798afb2ef464d2f527f01d8e814368e73be6b0">搜番 (btfan.cc)：eva全部资源磁力链接</a></p><p><a href="https://dc.btfan.cc/">搜番 (btfan.cc)</a></p><p><a href="https://cilitiantang.one/sites/39.html">磁力天堂 (cilitiantang.one)</a></p><p><a href="https://www.bilibili.com/read/cv9456438/">分享【全套】新世纪福音战士TV 26话+新老剧场版字幕包 EVA-FANS&amp; 白月字幕组 - 哔哩哔哩 (bilibili.com)</a></p><blockquote><p>字幕推荐这一版，很细节</p></blockquote><p>持续更新中……</p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> 磁力链接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 磁力链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是解空间树</title>
      <link href="/chunyujin/87a30441.html"/>
      <url>/chunyujin/87a30441.html</url>
      
        <content type="html"><![CDATA[<p>什么是解空间树</p><p>比较权威全面的方法可以参考百度</p><p>形象化描述：</p><p>递归的所有过程都可以通过树形结构来表述，回溯是递归的副产品，所以回溯也可以通过属性结构来表示，而且回溯的结果是树形结构的叶子节点，所以这个这个树形结构就是解空间树</p>]]></content>
      
      
      <categories>
          
          <category> 算法分析与设计 </category>
          
          <category> 回溯法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯法_资源</title>
      <link href="/chunyujin/19c828d.html"/>
      <url>/chunyujin/19c828d.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNjY5NTYxNA==&action=getalbum&album_id=1607983171550167042&scene=173&from_msgid=2247485237&from_itemidx=1&count=3&nolastread=1#wechat_redirect">#回溯算法 (qq.com)</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247485237&idx=1&sn=1bae4c3d0d3965af44878093a5a49f58&chksm=f9a23464ced5bd72ff9ddcc9c70f69131a9e57e5c1aa674cc62551cd434c64f10a88395dce60&scene=21#wechat_redirect">关于回溯算法，你该了解这些！ (qq.com)</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247485253&idx=1&sn=8332edaabc9bf43e45835bce7964ce88&chksm=f9a23414ced5bd02a80be49c91bb42f286ce1e15bbea77e6570470a4491c9da0f29160eba838&cur_album_id=1485825793120387074&scene=189#wechat_redirect">回溯算法：求组合问题！ (qq.com)</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247485264&idx=1&sn=860006efeb344db329b555a8b2711769&chksm=f9a23401ced5bd17aa2d374c12c558fd2dcbb57d2aba799dd62e64a27e88027dbfa8677989ae&cur_album_id=1485825793120387074&scene=189#wechat_redirect">回溯算法：组合问题再剪剪枝 (qq.com)</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247485277&idx=1&sn=0553db6b5c5952094d536ae2b8c18124&chksm=f9a2340cced5bd1ab3ec69fb1209242081185eb90b1144aa29b5959d31e946237b67a011e3a8&cur_album_id=1485825793120387074&scene=189#wechat_redirect">回溯算法：求组合总和！ (qq.com)</a></p><p><a href="https://mp.weixin.qq.com/s/FLg8G6EjVcxBjwCbzpACPw">回溯算法：求组合总和（二） (qq.com)</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247485360&idx=1&sn=2256a0f01a304d82a2b59252327f3edb&chksm=f9a234e1ced5bdf72f4f27d55618fdb185f324260a2776a266b497956b28c9f317a83b1bf36a&scene=178&cur_album_id=1607983171550167042#rd">回溯算法：求组合总和（三）</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247485295&idx=1&sn=35bd6c240a5a59d7ea6d9f98c09e7dbd&scene=21#wechat_redirect">回溯算法：电话号码的字母组合 (qq.com)</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247485372&idx=1&sn=29cc3421fb742faa57824b9a626342ad&scene=21#wechat_redirect">回溯算法：分割回文串</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247485402&idx=1&sn=6963af3e2aa8d58e41b71d73d53ea8f6&chksm=f9a2348bced5bd9d50f845b9f2d671f3c1d6d5376e6c7d15f86b0c5a0320f2ae905dea11d082&scene=178&cur_album_id=1607983171550167042#rd">回溯算法：求子集问题！</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247485466&idx=1&sn=2b5420bca9b66356d777bc4530a224c5&chksm=f9a23b4bced5b25d254e721f131655fe5889137bf63c182ea0ed4dd6b62515a7798a6a566d8c&scene=178&cur_album_id=1607983171550167042#rd">回溯算法：递增子序列</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247485390&idx=1&sn=e95ad5b1c40f06fc18cd3fec54fd1cbc&chksm=f9a2349fced5bd89092073366fa77e0f3949dd75e5a7e3017e3d289551be10bdc6aa745b5f11&scene=178&cur_album_id=1607983171550167042#rd">回溯算法：复原IP地址</a></p><p>还有更多内容</p><blockquote><p><a href="https://mp.weixin.qq.com/s/FLg8G6EjVcxBjwCbzpACPw">回溯算法：求组合总和（二） (qq.com)</a></p><p>这里面的图是有错误的？</p><p>在startIndex访问到后期的时候，数组中startIndex前面的数不会、也不需要被访问到，因为startIndex之前的数一定可以访问后面的，但是之后的数不需要也不能访问之前的，因为会造成结果的重复，只能访问startIndex位置以及之后位置的。并且按照代码流程走下来也确实如此。</p><p>原来的：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202304062119069.png" alt="640" style="zoom:80%;" /><p>实际上应该是的：</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202304062120352.PNG" alt="IMG_1352"></p></blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247485372&idx=1&sn=29cc3421fb742faa57824b9a626342ad&scene=21#wechat_redirect">回溯算法：分割回文串</a></p><p>不需要剪枝，或者说判断回文字符串本身就属于剪枝</p><blockquote><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202304071014373.jpeg" alt="IMG_1354"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法分析与设计 </category>
          
          <category> 回溯法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态库和静态库的感性认识</title>
      <link href="/chunyujin/b67d47f3.html"/>
      <url>/chunyujin/b67d47f3.html</url>
      
        <content type="html"><![CDATA[<p>动态库和静态库的感性认识：</p><h3 id="动态链接："><a href="#动态链接：" class="headerlink" title="动态链接："></a>动态链接：</h3><blockquote><p>学校里不让带电脑，要打游戏，无法自己实现，只能跑到网吧里打</p></blockquote><p>程序执行之前：</p><p>获取动态库的位置，将程序与动态库进行链接</p><blockquote><p>到了学校里，向学长打听好网吧的位置，牢记于心</p></blockquote><p>程序执行时：</p><p>程序运行到某一行，到之前链接的动态库中寻找相应的函数的实现方法</p><blockquote><p>想打游戏的时候，就按照学长给的地址去到网吧，并在里面开一个机子，网管给出机子的号码，在网吧里根据号码找到自己的机子</p></blockquote><blockquote><p>优点：各个程序共享同一个库，可以节省资源，程序的体积相对小</p><p>缺点：必须依赖外部库，如果库缺失，会导致几乎所有的程序失效</p></blockquote><h3 id="静态链接："><a href="#静态链接：" class="headerlink" title="静态链接："></a>静态链接：</h3><blockquote><p>学校里让带电脑，要打游戏的时候，只要自己有电脑，就能打，但是前提是自己把电脑带到了学校里</p></blockquote><p>程序执行之前：</p><p>将库(静态库)中的对应的代码提前拷贝到自己的程序里</p><p>在程序执行时：</p><p>遇到需要的函数的实现时，直接在拷贝好的代码里找就可以了，不依赖库</p><blockquote><p>优点：不依赖外部库，程序可以独立执行</p><p>缺点：浪费资源，程序的体积相对大</p></blockquote><p>Linux默认进行动态链接</p><p>如果要进行静态链接，要在指令后加<code>-static</code></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202304112158098.png" alt="CT-20230411135740 Redacted"></p><blockquote><p><code>mytest</code>可执行程序是通过动态链接生成的，<code>mytest2</code>是通过静态链接生成的，可见二者相差100倍的大小，而且两者的功能还只是输出一句”hello world”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>父类是非抽象类子类能是抽象类</title>
      <link href="/chunyujin/9107dc23.html"/>
      <url>/chunyujin/9107dc23.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230331174324280.png" alt="image-20230331174324280"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日记 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java_输入</title>
      <link href="/chunyujin/9e54541f.html"/>
      <url>/chunyujin/9e54541f.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的输入"><a href="#Java中的输入" class="headerlink" title="Java中的输入"></a>Java中的输入</h1><ul><li>Java使用的是<code>Scanner</code>类的对象来获取用户的输入</li></ul><p>首先定义一个<code>Scanner</code>类的对象，名称任意，此处以<code>sca</code>为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sca</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure><p><code>sca</code>的输入流缓冲区里就用来保存用户在控制台输入的数据</p><blockquote><p><code>sca</code>不同于C++中的<code>cin</code>，它不是一个全局变量，有作用域，不过一个作用域里有一个Scanner类的对象就够用了，因为只需要一个缓冲区就可以获得输入流的所有数据</p></blockquote><p>用户再控制台输入数据之后，按下回车，将数据送入<code>sca</code>的输入流缓冲区</p><blockquote><p>跟C++的<code>cin</code>一样</p></blockquote><blockquote><p><font color = red>Java的<code>src</code>输入流缓冲区保存数据是按照字符串进行保存的</font></p></blockquote><p>通过<code>Scanner</code>的成员方法将<code>Scanner</code>对象输入流缓冲区的数据赋值给变量</p><p>有几种常用的成员方法</p><p>以<code>Scanner</code>的对象<code>sca</code>为例:</p><ol><li><p><code>sca.next()</code></p><p>这个成员方法是 返回<code>sca</code>的输入流缓冲区的分隔符之前的数据，返回值类型是字符串。数据被返回后，流出缓冲区</p><p><mark style="background-color">此时，分隔符是空格<code>&#39; &#39;</code>、tab<code>&#39;\t&#39;</code>、换行符<code>&#39;\n&#39;</code></mark></p><blockquote><p><mark style="background-color">并且此时如果分隔符在有效数据之前，会自动将分隔符忽略掉，直到获取的数据是有效数据而不是分隔符</mark></p><p>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> sca.next();</span><br></pre></td></tr></table></figure><p>如果输入<code>&quot;               A&quot;</code>(A之前很多空格)，<code>A</code>是才有效数据，<code>A</code>之前的空格是分隔符，在从<code>cin</code>的输入流缓冲区获取数据的时候，会自动忽略<code>A</code>之前的分隔符空格，只获取有效数据<code>A</code></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303151642907.png" alt="截屏2023-03-15 16.41.29" style="zoom:50%;" /></blockquote><p>比如：</p><p>在控制台输入<code>&quot;1 2 3 4 5 6 7&quot;</code>（数字之间有空格），按下回车，添加回车符到数据中，<code>&quot;1 2 3 4 5 6 7&#39;\r&#39;&quot;</code>，数据被送入<code>sca</code>的输入流缓冲区，回车符<code>&#39;\r&#39;</code>在缓冲区变成了换行符<code>&#39;\n&#39;</code>，此时缓冲区里的数据为<code>&quot;1 2 3 4 5 6 7&#39;\n&#39;&quot;</code></p><p>执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">i</span> <span class="operator">=</span> sca.next();</span><br></pre></td></tr></table></figure><p>将<code>sca</code>的输入流缓冲区换行符，空格<code>&#39; &#39;</code>，之前的数据<code>1</code>作为返回值赋值给<code>i</code>，并流出缓冲区，缓冲区剩余数据为<code>&quot;2 3 4 5 6 7&#39;\n&#39;&quot;</code></p></li><li><p><code>sca.nextLine()</code></p><p>获取<code>src</code>输入流缓冲区中的一行数据，也就是’<code>\n&#39;</code>之前的所有数据，包括空格。返回值类型是字符串，字符串中包括空格。<mark style="background-color">此时空格<code>&#39; &#39;</code>就不是分隔符了，分隔符是<code>&#39;\n&#39;</code></mark></p><p>比如：</p><p>如果接着上面的代码，先在控制台输入<code>&quot;hello world&quot;</code>并按下回车送入缓冲区，此时<code>sca</code>输入流缓冲区中的数据是<code>&quot;2 3 4 5 6 7&#39;\n&#39;hello world&#39;\n&#39;&quot;</code></p><p>执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> sca.nextLine();</span><br><span class="line"><span class="type">String</span> <span class="variable">y</span> <span class="operator">=</span> sca.nextLine();</span><br></pre></td></tr></table></figure><p>先是<code>x</code>获取到缓冲区换行符之前的所有数据，也就是<code>&quot;2 3 4 5 6 7&quot;</code>，<code>sca</code>输入流缓冲区剩余的数据是””<code>hello world&#39;\n&#39;&quot;</code></p><p>之后<code>y</code>获取缓冲区换行符之前的所有数据，即<code>&quot;hello world&quot;</code>，<code>sca</code>缓冲区没有剩余数据了，为空</p></li><li><p><code>sca</code>缓冲区中的数据是按照字符串存储的，如果想要按照指定的类型从缓冲区中获取数据，使用以下函数</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>nextBoolean()</code></td><td align="left">从缓冲区获取数据，并转化为<code>boolean</code>布尔值返回</td></tr><tr><td align="left"><code>nextByte()</code></td><td align="left">从缓冲区获取数据，并转化为<code>byte</code>字节值返回</td></tr><tr><td align="left"><code>nextDouble()</code></td><td align="left">从缓冲区获取数据，并转化为<code>double</code>双精度值返回</td></tr><tr><td align="left"><code>nextFloat()</code></td><td align="left">从缓冲区获取数据，并转化为<code>float</code>浮点值返回</td></tr><tr><td align="left"><code>nextInt()</code></td><td align="left">从缓冲区获取数据，并转化为<code>int</code>值返回</td></tr><tr><td align="left"><code>nextLine()</code></td><td align="left">从缓冲区读取<code>String</code>字符串值</td></tr><tr><td align="left"><code>nextLong()</code></td><td align="left">从缓冲区读取<code>long</code>值</td></tr><tr><td align="left"><code>nextShort()</code></td><td align="left">从缓冲区读取<code>short</code>值</td></tr></tbody></table><p>使用这类函数的前提是输入流缓冲区里的数据是能转化成相应的类型</p><p>比如缓冲区里的<code>&quot;123&quot;</code>可以转化为<code>int</code>类型的<code>123</code>，但是<code>&quot;A&quot;</code>并不能转化为<code>int</code>类型，如果要转化成<code>int</code>类型，只有数字字符串才可以</p><blockquote><p>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sca</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sca.nextInt();</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303151701983.png" alt="截屏2023-03-15 16.59.14" style="zoom: 50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303151702764.png" alt="截屏2023-03-15 16.59.23" style="zoom:50%;" /></blockquote><p>所以某种程度上，使用此类成员函数可以提升数据安全性</p><p>防止用户输入数据类型不匹配而出错</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程日记 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_输入</title>
      <link href="/chunyujin/52566707.html"/>
      <url>/chunyujin/52566707.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-中的输入"><a href="#C-中的输入" class="headerlink" title="C++中的输入"></a>C++中的输入</h1><ul><li>C++中使用<code>cin</code>对象来获取用户的输入</li></ul><p><code>cin</code>是一个标准输入流对象，即是<code>istream</code>类的对象</p><p><code>cin</code>是全局变量</p><p><code>cin</code>对象”连接”到标准输入设备(一般是用户的键盘)，用来存储IO流中的输入的数据(保存在<code>cin</code>的输入流缓冲区中)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line">cin &gt;&gt; i;</span><br></pre></td></tr></table></figure><p><code>cin &gt;&gt; i</code>在执行时</p><ul><li><p>系统从cin的输入流缓冲区中获取数据</p><ul><li><p>如果cin的输入流缓冲区中没有数据，则等待用户在控制台输入数据，然后<mark style="background-color:pink">按下回车，将数据送入<code>cin</code>的输入流缓冲区</mark></p><blockquote><p>输入的数据只有在缓冲区才能被读取</p><p>空格、tab、换行符，也都是数据，分别是<code>&#39; &#39;</code>  <code>&#39;\t&#39;</code> <code>&#39;\n&#39;</code>  </p><p>键盘上的回车键对应的是输入<code>&#39;\r&#39;</code>，输入后，会将数据送入缓冲区，并且<code>&#39;\r&#39;</code>变成<code>&#39;\n&#39;</code>保存在缓冲区数据的最后面，作为分隔符</p></blockquote></li></ul></li><li><p>然后将<code>cin</code>输入流缓冲区的数据赋值给<code>i</code></p></li></ul><p><font color = red><code>cin</code>输入流缓冲区保存数据的形式本质上是二进制，根据上下文(被赋值对象的类型)，将数据以被赋值对象的类型赋值给被赋值对象</font></p><p>比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a;</span><br><span class="line">cin &gt;&gt; a;</span><br></pre></td></tr></table></figure><p>如果在控制台中输入<code>65</code>，<code>cin</code>输入流缓冲区的数据赋值给<code>a</code>的时候，按照<code>a</code>的类型<code>char</code>，赋值给<code>a</code>的数据是<code>&#39;A&#39;</code></p><p>这跟从控制台中输入<code>A</code>的作用是一样的，因为它们的数据一样，只是上下文不同，含义不同</p><blockquote><p>”流“</p><p>像是一个管道，或者说队列</p><p>先流入的先流出，后流入的后流出</p><p>在向输入流输入数据的时候，数据流入到输入流，先输入的在前面，后输入的在后面</p><p>在向输入流获取数据的时候，数据流出输入流，先获取前面的数据，再获取后面的数据</p></blockquote><blockquote><p>cin的输入流缓冲区中保存用户输入的所有数据，根据指令将数据从前向后依次赋值给对象，若缓冲区为空，则从控制台中获取新输入的数据到输入流缓冲区</p><blockquote><p>所以并不是需要输入一个数据的时候输入一个数据，而是可以一次性将多个数据输入，在需要的时候从缓冲区取</p></blockquote></blockquote><blockquote><p>根据被赋值对象类型的不同、操作方式不同，cin从缓冲区读取数据的方式也不同</p><p>比如：</p><p>在控制台输入<code>1 2 3 4 5 6 7 </code>，每个数字之间有空格</p><p>输入之后要按下回车，将数据送入到标准输入缓冲区，cin的输入缓冲区变成了<code>1 2 3 4 5 6 7&#39;\n&#39;</code></p><p>如果执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line">cin &gt;&gt; i；</span><br></pre></td></tr></table></figure><p>因为<code>i</code>是一个整形，则系统会将<code>cin</code>输入流<code>1 2 3 4 5 6 7&#39;\n&#39;</code>中分隔符之前的数据作为整形赋值给<code>i</code></p><blockquote><p><font color=blue>正如上面所说，数据并不是按照整形或者字符存储在缓冲区的，而是二进制，这里这样表示是为了直观</font></p></blockquote><p>此时以空格<code>&#39; &#39;</code>、tab<code>&#39;\t&#39;</code>和换行符<code>&#39;\n&#39;</code>作为分隔符，遇到分隔符就停止获取，此时是将<code>1</code>赋值给<code>i</code>，<code>cin</code>输入流缓冲区中剩下的数据是<code>2 3 4 5 6 7\n</code></p><blockquote><p><mark style="background-color">此时<code>cin</code>的输入流缓冲区在获取数据的时候，空格<code>&#39; &#39;</code>、tab<code>&#39;\t&#39;</code>、换行符<code>&#39;\n&#39;</code>等是作为分隔符的。</mark></p><blockquote><p><mark style="background-color">并且此时如果分隔符在有效数据之前，会自动将分隔符忽略掉，直到获取的数据是有效数据而不是分隔符</mark></p><p>比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a;</span><br><span class="line">cin &gt;&gt; a;</span><br></pre></td></tr></table></figure><p>如果输入<code>&quot;               A&quot;</code>(A之前很多空格)，<code>A</code>是才有效数据，<code>A</code>之前的空格是分隔符，在从<code>cin</code>的输入流缓冲区获取数据的时候，会自动忽略<code>A</code>之前的分隔符空格，只获取有效数据<code>A</code></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303151642907.png" alt="截屏2023-03-15 16.41.29" style="zoom:50%;" /></blockquote><p>书接上回，如果再执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string a;</span><br><span class="line">cin &gt;&gt; a;</span><br></pre></td></tr></table></figure><p><code>a</code>中只会获取<code>&quot;2&quot;</code>，因为2后面的空格是分隔符</p><p>我们下面不用这个方式进行演示，假设上面这行代码没有写入</p></blockquote><p>如果此时再向控制台输入<code>hello world</code>并按下回车，输入的数据会送入到cin的输入流缓冲区，现在cin的输入流缓冲区的数据是<code>2 3 4 5 6 7&#39;\n&#39;hello world\n&#39;</code></p><p>如果再执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string x;</span><br><span class="line"><span class="built_in">getline</span>(cin,x);</span><br><span class="line"><span class="comment">//getline是C++标准库函数，分为两种形式(重载)，只知道此处的作用是可以获取cin缓冲区中一行数据(字符串)赋值给字符串x，也就是可以获取换行符之前的所以数据，包括空格</span></span><br><span class="line"><span class="comment">//getline是从cin缓冲区中获取制定类型的数据，类似的还有getchar,getchar等，这样就好理解了</span></span><br></pre></td></tr></table></figure><p><mark style="background-color">此时空格<code>&#39; &#39;</code>就不作为分隔符了，因为空格在这里作为一个字符<code>&#39; &#39;</code>，分隔符是换行符<code>&#39;\n&#39;</code></mark>，指令<code>getline(cin,x)</code>会将cin输入流缓冲区中分隔符之前的所有数据赋值给x，x中的数据是<code>&quot;2 3 4 5 6 7&quot;</code></p><p><code>cin</code>输入流缓冲区剩下的是<code>hello world\n&#39;</code></p><p>如果再执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string y;</span><br><span class="line"><span class="built_in">getline</span>(cin,y);</span><br></pre></td></tr></table></figure><p>则<code>y</code>中的数据是<code>hello world</code>，<code>cin</code>输入数据流中没有数据了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinGW配置</title>
      <link href="/chunyujin/91f40f34.html"/>
      <url>/chunyujin/91f40f34.html</url>
      
        <content type="html"><![CDATA[<h4 id="安装MinGW"><a href="#安装MinGW" class="headerlink" title="安装MinGW"></a>安装MinGW</h4><p>相比在 Linux 平台上安装 GCC 编译环境，在 Windows 平台上安装 MinGW 是比较简单的，只需经历以下几个过程。</p><ol><li><p>打开 <a href="https://osdn.net/projects/mingw/">MinGW 官网</a>（点击即可进入官网），下载 MinGW 安装包。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215731250.png" alt="image-20221215215731250" style="zoom:67%;" /></li><li><p>下载完成后，会得到一个名为 mingw-get-setup.exe 的安装包，双击打开它，可以看到如下的对话框：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215752602.png" alt="image-20221215215752602" style="zoom:67%;" /></li><li><p>直接点击“Install”，进入下面的对话框，自定义安装位置，然后选择continue</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215808186.png" alt="image-20221215215808186" style="zoom:67%;" /></li><li><p>进入安装 MinGW 配置器的界面。安装完成之后，得到一个名为 “MinGW Installer Manager” 的软件，借助它，可以随时根据需要修改 GCC 编译器的配置。点击“continue”,会自动弹出配置界面，如下所示：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215823311.png" alt="image-20221215215823311" style="zoom:67%;" /></li><li><p>为使 GCC 同时支持编译 C 语言和 C++，需勾选图中标注的 2 项。我们知道，GCC 还支持其它编程语言，读者可借助此配置器，随时实际需要安装自己需要的编译环境。勾选完成后，在菜单栏中选择<code>Installation -&gt; Apply Changes</code>，弹出如下对话框：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215851706.png" alt="image-20221215215851706" style="zoom:67%;" /></li></ol><p>选择“Apply”。然后耐心等待，直至安装成功，即可关闭此界面。注意，整个安装过程中可能会提示某些组件下载失败，但没关系，后续需要时，可以通过 MinGw Installer（图 4 所示）安装界面中的 “All Packages”选项中，手动选择指定的安装包进行安装。</p><h4 id="添加到环境变量"><a href="#添加到环境变量" class="headerlink" title="添加到环境变量"></a>添加到环境变量</h4><p>打开<code>我的电脑</code>-&gt;<code>属性</code>-&gt;<code>高级系统设置</code>-&gt;<code>“高级”中的环境变量</code></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213001922.png" alt="image-20221215213001922" style="zoom:67%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213141396.png" alt="image-20221215213141396" style="zoom: 67%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213248912.png" alt="image-20221215213248912" style="zoom:67%;" /><p>在上方的“用户变量”的Path变量中添加MinGW的bin的位置</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213407962.png" alt="image-20221215213407962" style="zoom:67%;" /><blockquote><p>也可以在下方的“系统变量”的Path中添加MinGW的bin的位置</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213829809.png" alt="image-20221215213829809" style="zoom:67%;" /><p>环境变量、系统变量、用户变量的关系：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215214853021.png" alt="image-20221215214853021" style="zoom: 50%;" /><p>环境变量只是一个总称，代表了系统变量和用户变量，因此我们说环境变量都是指的系统变量和用户变量。系统变量就是系统级别的变量，用户需要使用系统变量。如果系统变量被修改了，而任何系统用户都在用系统变量，因此每个系统用户都将受到影响。用户变量运行在系统变量之上的，每个用户拥有不同的用户变量，不同用户的用户变量之间是并列的，也是互不干扰的。</p></blockquote><h4 id="检验配置完成"><a href="#检验配置完成" class="headerlink" title="检验配置完成"></a>检验配置完成</h4><p>打开命令行提示符，输入<code>gcc -v</code>或者<code>g++ -v</code></p><p>出现下面则说明成功</p><img src = "https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-12-15%20220238.png" style="zoom: 67%;" >]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MinGW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_前言</title>
      <link href="/chunyujin/2ef92d18.html"/>
      <url>/chunyujin/2ef92d18.html</url>
      
        <content type="html"><![CDATA[<p>此部分笔记只是对于课件的补充，具体应结合课件和板书来看</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_内联函数</title>
      <link href="/chunyujin/9b439c80.html"/>
      <url>/chunyujin/9b439c80.html</url>
      
        <content type="html"><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote><p>inline修饰的函数叫做<strong>内联函数</strong>，编译时C++编译器会在调用内联函数的地方展开，没有函数调用建立栈帧 的开销，内联函数提升程序运行的效率。</p></blockquote><p>适用于定义频繁使用的短小函数</p><blockquote><p>C++中如何实现处理的：</p><blockquote><p>用宏定义函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">returen x+y</span>;</span><br></pre></td></tr></table></figure><p>宏定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(x,b) ((x) + (y))</span></span><br></pre></td></tr></table></figure><p>宏定义的本质就是替换</p></blockquote><p>宏的语法机制不好，容易出错，不支持调试，没有类型安全检查</p><p>于是C++有了内联函数</p><p><strong>内联函数的本质也是替换</strong></p><ol><li><p>debug可以打断点调试 (因为内联函数在debug时不会进行替换，所以可以进行调试)</p></li><li><p>不容易出错，写法和普通函数一样</p></li></ol><h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><ol><li>inline是一种以空间换时间的做法，如果编译器将函数当成内联函数处理，在编译阶段，会用函数体替 换函数调用，缺陷：可能会使目标文件变大，优势：少了调用开销，提高程序运行效率。</li><li>inline对于编译器而言只是一个建议，不同编译器关于inline实现机制可能不同，一般建议：将函数规 模较小(即函数不是很长，具体没有准确的说法，取决于编译器内部实现)、不是递归、频繁调用的函数 采用inline修饰，否则编译器会忽略inline特性。</li><li>inline不建议声明和定义分离，分离会导致链接错误。因为inline被展开，就没有函数地址了，链接就会在符号表里找不到函数。</li></ol><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>内联函数的关键子inline、缺省函数的缺省参数等，在函数声明或实现中只能出现一次，一般建议出现在声明中，实现中只是对于函数进行实现，声明是对外的接口，更能体现封装性</p><h4 id="【面试题】宏的优缺点"><a href="#【面试题】宏的优缺点" class="headerlink" title="【面试题】宏的优缺点"></a>【面试题】宏的优缺点</h4><p>宏的优点：</p><ol><li>增强代码的复用性</li><li>提高性能</li></ol><p>宏的缺点：</p><ol><li>不方便调试宏。（因为预编译阶段进行了替换）</li><li>导致代码可读性差，可维护性差，容易误用。</li><li>没有类型安全的检查</li></ol><p>C++中用什么方法代替宏？</p><ol><li>常量定义 换用const enum</li><li>短小函数定义 换用内联函数</li></ol>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_引用</title>
      <link href="/chunyujin/9f8ff3a6.html"/>
      <url>/chunyujin/9f8ff3a6.html</url>
      
        <content type="html"><![CDATA[<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h4 id="引用的特性："><a href="#引用的特性：" class="headerlink" title="引用的特性："></a>引用的特性：</h4><ol><li><p>引用在定义时就要初始化</p></li><li><p>一个变量可以被多个引用</p></li><li><p>一个引用只能由一个实体变量，不能引用多个</p></li><li><p>引用不能降低实体的可执行权限，只能提升或者不变</p><blockquote><p>比如在引用常量的时候，常量只有可读权限，没有写权限，因此在定义引用的时候必须要用const来定义出常量引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;<span class="comment">//错误</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c = a;<span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d;</span><br><span class="line"><span class="type">int</span> &amp;e = d;<span class="comment">//正确</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;f = d;<span class="comment">//正确，不能通过引用f来修改d的值</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> g;</span><br><span class="line"><span class="type">int</span> &amp;h = g;<span class="comment">//错误，类型不同</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> &amp;i = g;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure></blockquote></li></ol><h4 id="引用的两种常用方法："><a href="#引用的两种常用方法：" class="headerlink" title="引用的两种常用方法："></a>引用的两种常用方法：</h4><ul><li>作为参数</li><li>作为函数返回值</li></ul><h5 id="引用作为参数时属于输出型参数"><a href="#引用作为参数时属于输出型参数" class="headerlink" title="引用作为参数时属于输出型参数"></a>引用作为参数时属于<mark style="background-color: pink">输出型参数</mark></h5><blockquote><p>现实编程中有一个函数要返回多个值很普遍</p><p>但是一个函数只有一个返回值(return)，<font color = red>返回值其实只是用来表示函数的执行结果</font></p><p>通常，将引用作为参数时，在函数内的更改直接就影响到了引用的实体，实现了函数向外的输出，实现了”多返回值”</p><p>如果一个参数只是输入到函数，在内部的改变不会影响外部变量的改变的就是输入型参数；一个参数在函数内发生的改变影响函数外变量的改变的就是输出型参数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a += a;</span><br><span class="line">    b += b;</span><br><span class="line">c = a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Add</span>(x);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果是 1 2 6</span></span><br></pre></td></tr></table></figure><h5 id="引用作为函数返回值"><a href="#引用作为函数返回值" class="headerlink" title="引用作为函数返回值"></a>引用作为函数返回值</h5><blockquote><p>此处应复习一下鹏哥讲的栈帧</p></blockquote><p><strong><mark style="background-color:lime">传值返回</mark></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">A</span> <span class="params">( <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//A的返回值tem是n的拷贝，是一个临时变量</span></span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/721EF9BBF65C834644F19D25C7DAE74F.png" alt="img" style="zoom: 33%;" /><blockquote><ol><li><p>main函数里调用A函数，将实参x拷贝给b，传入到A中</p></li><li><p>n时局部变量，在A中，且n是返回值return。return作为函数结束标志，此时会产生一个临时变量tem作为n的拷贝，然后将tem传向main</p><p>为何要产生一个临时变量，因为在离开函数A作用域之后n的内存会被释放，无法被访问，因此在此之前要生成临时变量。临时变量存放在在调用函数A之前就开辟好的一块空间里。</p><p>如何证明确实<mark style="background-color:pink">返回值是一个临时变量</mark>？</p><blockquote><p><font color = red>临时变量具有常性</font></p><p>所以如果main中使用一个引用来接收A的返回值，则会报错，如果用const 引用来接收，不会报错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> &amp;a = <span class="built_in">A</span>(x); <span class="comment">//报错</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;a = <span class="built_in">A</span>(x); <span class="comment">//不报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明A的返回值是一个具有常性</p><blockquote><p> 在引用的时候权限不能放大，只能缩小或者不变，所以必须声明被a引用时的对象是个常量才可以</p></blockquote><p>为什么使用引用来接收</p><blockquote><p>引用只是取别名，a就是A的返回值n本身</p><p>如果使用值来接收，<code>int a = A(b)</code>，是将A的返回值拷贝赋值给a，不是同一个变量了</p></blockquote></blockquote></li></ol></blockquote><p><strong><mark style="background-color:lime">传引用返回</mark></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">A</span> <span class="params">(<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//A的返回值是tem，是n的引用</span></span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/90228CD120AD756DDC37EB40BF06550F.png" alt="img" style="zoom: 33%;" /><p>返回值类型为引用的时候则不是拷贝一个临时变量，返回的是A中局部变量n的引用tem，引用只是别名，不会占空间</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> &amp;a = <span class="built_in">A</span>(x); <span class="comment">//不会报错，因为A的返回值不是临时变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回值tem是n的引用，a就也是n的引用</span></span><br></pre></td></tr></table></figure></blockquote><p>由于离开函数作用域之后局部变量内存会被释放，所以如果变量n是A内部一个局部变量，A的返回值tem是n的引用，则通过返回值访问n的时候就是非法访问</p><blockquote><p> 所以C++的规定是：</p><p><font color = blue>离开函数作用域之后，如果返回值的内存还没有被释放(比如返回值类型是静态变量全局变量之类)，则可以使用引用返回，否则必须使用传值返回。否则会造成非法访问</font></p></blockquote><p>总结：</p><p>传值返回：会有一个拷贝</p><p>传引用返回：没有拷贝，只是返回别名</p><blockquote><p>因此传引用返回的效率要比传值返回高，因为不用拷贝返回值</p></blockquote><h4 id="引用和指针的区别："><a href="#引用和指针的区别：" class="headerlink" title="引用和指针的区别："></a>引用和指针的区别：</h4><ol><li><p>在<strong>语法概念</strong>上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间。</p><p>在<strong>底层实现</strong>上实际是有空间的，因为引用是按照指针方式来实现的。</p></li><li><p><strong>引用</strong>在定义时<strong>必须初始化</strong>，指针没有要求</p></li><li><p><strong>引用</strong>在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型 实体</p></li><li><p><strong>没有NULL引用</strong>，但有NULL指针</p></li><li><p><strong>在sizeof中含义不同</strong>：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占 4个字节) </p></li><li><p>引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小</p></li><li><p><strong>有多级指针，但是没有多级引用</strong></p></li><li><p>访问实体方式不同，<strong>指针需要显式解引用，引用编译器自己处理</strong></p></li><li><p><strong>引用比指针使用起来相对更安全</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态开辟二维数组</title>
      <link href="/chunyujin/bd13564e.html"/>
      <url>/chunyujin/bd13564e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>int a</p><blockquote><p>a是int类型的变量，内存中被命名为a的空间内保存的是一个整形数据</p></blockquote><p>int* b</p><blockquote><p>b是int类指针类型的变量，内存中被命名为b的空间内保存的是一个整形指针(整形的地址)的数据</p></blockquote><p>int** c</p><blockquote><p>c是int类型的指针的指针类型的变量，内存中被命名为c的空间内保存的是一个整形指针的指针(整形指针的地址)的数据</p></blockquote></blockquote><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">4</span>];</span><br><span class="line"><span class="comment">//int是数组中元素的类型，a是数组的名称，也是数组的首元素的地址的引用，数组的元素在内存中是连续开辟的</span></span><br><span class="line"><span class="type">int</span>* b[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//数组b中的元素数据类型是int*，即整形指针</span></span><br></pre></td></tr></table></figure><h5 id="一维数组的动态开辟："><a href="#一维数组的动态开辟：" class="headerlink" title="一维数组的动态开辟："></a>一维数组的动态开辟：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//new了一个长度为10的int类型动态数组，并将数组的地址返回给a</span></span><br></pre></td></tr></table></figure><blockquote><p>别忘什么是动态内存：</p><p>栈中的内存开辟需要在编译前就要确定具体大小，比如在定义一个普通数组的时候，这个数组的大小一定是已知的，是一个常量，就算是用一个整形变量a用来在定义数组的时候表示数组的大小，在编译之前a的值也是一定要确定下来的</p><p>动态内存是在堆中开辟的，动态开辟内存就是在编译之前<u>可以不指定</u>需要开辟的空间的大小，在编译之后再根据程序猿的指定开辟相应的大小。</p></blockquote><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>如果在栈中定义二维数组(比如局部变量)，二维数组本质上就是一个一维数组，然后将一维数组按照指定的大小分成等分，比如一个m*n的二维数组，意思是m行n列，其实是将一个长度为m *n的等分为m份，每一份中有n个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">//这是一个3行四列的二维数组，本质上是由一个含有12个元素的一维数组，平均分成了三份，每份中四个元素</span></span><br></pre></td></tr></table></figure><p>栈中的二维数组每行必须等长</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303091521445.JPG" alt="IMG_4084" style="zoom: 15%;" /><h5 id="二维数组的动态开辟："><a href="#二维数组的动态开辟：" class="headerlink" title="二维数组的动态开辟："></a>二维数组的动态开辟：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>** a = <span class="keyword">new</span> <span class="type">int</span>* [m];</span><br><span class="line"><span class="comment">//先new一个元素类型为int* 的m个元素大小的一维数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)</span><br><span class="line">&#123;</span><br><span class="line"> a[i] = <span class="keyword">new</span> <span class="type">int</span> [n]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个一位数组中的每个元素都是新开辟的一维数组的地址的指针</span></span><br></pre></td></tr></table></figure><p>动态开辟二维数组，实际上是先new一个数组元素为指针的一维数组，这个一维数组中的每个元素都是指向一个新开辟的一维数组地址的指针</p><p>所以在堆中开辟的二维数组并不要求每行都是等长的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303091522838.JPG" alt="IMG_4085" style="zoom:15%;" />]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java_内存分配</title>
      <link href="/chunyujin/844172b9.html"/>
      <url>/chunyujin/844172b9.html</url>
      
        <content type="html"><![CDATA[<h3 id="Java内存分配"><a href="#Java内存分配" class="headerlink" title="Java内存分配"></a>Java内存分配</h3><p>主要包括以下几个区域:</p><ol><li>寄存器：我们在程序中无法控制</li><li>栈：存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中</li><li>堆：存放用new产生的数据</li><li>静态域：存放在对象中用static定义的静态成员</li><li>常量池：存放常量</li><li>非RAM(随机存取存储器)存储：硬盘等永久存储空间</li></ol><hr><p>前瞻：</p><p>new出的空间都是作为动态内存在<strong>堆</strong>中分配的，比如new出的对象的成员属性、使用new开辟的数组中的各个元素、使用new创建的基本数据类型等</p><p>局部变量在<strong>栈</strong>中分配，通常情况下，基本数据类型、对象名（对象的引用）存储在栈中</p><blockquote><p>注意是通常情况下。</p><p>比如对象类型的数组，对象(的引用)是作为数组元素存储在堆中的，而不是栈:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>()&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    Point(<span class="type">int</span> a ,<span class="type">int</span> b)&#123;</span><br><span class="line">    <span class="built_in">this</span>.x = a;</span><br><span class="line">        <span class="built_in">this</span>.y = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span>&#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">hh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">55</span>,<span class="number">66</span>);</span><br><span class="line">        <span class="type">int</span>[] num = &#123;<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>,<span class="number">4</span>),<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">10</span>,<span class="number">20</span>),<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">33</span>,<span class="number">44</span>)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hh是new出来的一个Point类的对象，它的对象实体(成员属性)存储在堆区，而对象(名)保存在栈区，是对堆区的成员属性的引用</p><p>num是new出来的一个数组，它的数据元素存储在堆区，而数组(名)保存在栈区，是对堆区的数据元素的引用，数据元素又是Point的对象，是堆区的成员属性的引用</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/2C3EC5646817F65A5A5A21CC14DA01E0.png" alt="2C3EC5646817F65A5A5A21CC14DA01E0" style="zoom: 25%;" /></blockquote><p>常量存储在<strong>常量池</strong></p><hr><h5 id="Java内存分配中的栈"><a href="#Java内存分配中的栈" class="headerlink" title="Java内存分配中的栈"></a><font color=red>Java内存分配中的栈</font></h5><p>　　在函数中定义的一些<mark>基本类型的变量数据</mark>和<mark>对象的引用变量</mark>都在函数的栈内存中分配。当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当该变量退出该作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。 </p><h5 id="Java内存分配中的堆"><a href="#Java内存分配中的堆" class="headerlink" title="Java内存分配中的堆"></a><font color=red>Java内存分配中的堆</font></h5><p>　　堆内存用来存放由<mark>new创建的对象和数组</mark>。 在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。</p><p> 　在堆中产生了一个数组或对象后，还可以 在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。引用变量就相当于是为数组或者对象起的一个名称。</p><p>　　引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，但仍 然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。这也是 Java 比较占内存的原因。 </p><p>　　<mark style="background-color: pink">实际上，栈中的变量指向堆内存中的变量，这就是Java中的指针！ </mark></p><h5 id="常量池-constant-pool"><a href="#常量池-constant-pool" class="headerlink" title="常量池 (constant pool)"></a><font color=red>常量池 (constant pool)</font></h5><p>　　常量池指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。除了包含代码中所定义的各种基本类型（如int、long等等）和对象型（如String及数组）的常量值(final)还包含一些以文本形式出现的符号引用，比如： </p><ol><li>类和接口的全限定名；</li><li>字段的名称和描述符； </li><li>方法和名称和描述符。</li></ol><p>　　虚拟机必须为每个被装载的类型维护一个常量池。常量池就是该类型所用到常量的一个有序集和，包括直接常量（string,integer和 floating point常量）和对其他类型，字段和方法的符号引用。</p><p>　　对于String常量，它的值是在常量池中的。而JVM中的常量池在内存当中是以表的形式存在的， 对于String类型，有一张固定长度的CONSTANT_String_info表用来存储文字字符串值，注意：该表只存储文字字符串值，不存储符号引 用。说到这里，对常量池中的字符串值的存储位置应该有一个比较明了的理解了。</p><p>　　在程序执行的时候,常量池会储存在Method Area,而不是堆中。</p><h5 id="堆与栈"><a href="#堆与栈" class="headerlink" title="堆与栈"></a><font color=red>堆与栈</font></h5><p>　　Java的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new、newarray、 anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态 分配内存，存取速度较慢。 </p><p>　　栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量数据（int, short, long, byte, float, double, boolean, char）和对象句柄(引用)。</p><p>　　这里我们主要关心栈，堆和常量池，对于栈和常量池中的对象可以共享，对于堆中的对象不可以共享。栈中的数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会消失。堆中的对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定，具有很大的灵活性。</p><h5 id="字符串内存分配-gt"><a href="#字符串内存分配-gt" class="headerlink" title="字符串内存分配&gt;"></a><font color = red>字符串内存分配</font>&gt;</h5><p>　　对于字符串，其对象的引用都是存储在栈中的，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，如果是运行期（new出来的）才能确定的就存储在堆中。对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份。 </p><p>如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;china&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;china&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;china&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">ss1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;china&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">ss2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;china&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">ss3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;china&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://images2015.cnblogs.com/blog/908514/201607/908514-20160720101024841-238269977.jpg" alt=""></p><p>　　这里解释一下黄色这3个箭头，对于通过new产生一个字符串（假设为“china”）时，会先去常量池中查找是否已经有了“china”对象，如果没有则在常量池中创建一个此字符串对象，然后堆中再创建一个常量池中此”china”对象的拷贝对象。</p><p>　　这也就是有道面试题：Strings&#x3D;newString(“xyz”);产生几个对象？一个或两个，如果常量池中原来没有”xyz”,就是两个。</p><p>　　存在于.class文件中的常量池，在运行期被JVM装载，并且可以扩充。String的 intern()方法就是扩充常量池的 一个方法；当一个String实例str调用intern()方法时，Java 查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用</p><p>如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s0= <span class="string">&quot;kvill&quot;</span>;   </span><br><span class="line">String s1=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;kvill&quot;</span>);   </span><br><span class="line">String s2=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;kvill&quot;</span>);   </span><br><span class="line">System.out.println( s0==s1 );     </span><br><span class="line">s1.intern();   </span><br><span class="line">s2=s2.intern(); <span class="comment">//把常量池中&quot;kvill&quot;的引用赋给s2   </span></span><br><span class="line">System.out.println( s0==s1);   </span><br><span class="line">System.out.println( s0==s1.intern() );   </span><br><span class="line">System.out.println( s0==s2 ); </span><br></pre></td></tr></table></figure><p>输出结果：</p><p>false<br>false<br>true<br>true</p><p>String常量池问题的几个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">【<span class="number">1</span>】</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;   </span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;   </span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + bb;   </span><br><span class="line">System.out.println((a == b)); <span class="comment">//result = false </span></span><br><span class="line"></span><br><span class="line">【<span class="number">2</span>】</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;   </span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;   </span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + bb;   </span><br><span class="line">System.out.println((a == b)); <span class="comment">//result = true </span></span><br><span class="line"></span><br><span class="line">【<span class="number">3</span>】</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;   </span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> getBB();   </span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + bb;   </span><br><span class="line">System.out.println((a == b)); <span class="comment">//result = false   </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getBB</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;b&quot;</span>;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>分析：</p><p>　　【1】中，JVM对于字符串引用，由于在字符串的”+”连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的，即”a” + bb无法被编译器优化，只有在程序运行期来动态分配并将连接后的新地址赋给b。所以上面程序的结果也就为false。</p><p>　　【2】和【1】中唯一不同的是bb字符串加了final修饰，对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中。所以此时的”a” + bb和”a” + “b”效果是一样的。故上面程序的结果为true。</p><p>　　【3】JVM对于字符串引用bb，它的值在编译期无法确定，只有在程序运行期调用方法后，将方法的返回值和”a”来动态连接并分配地址为b，故上面程序的结果为false。</p><p>结论：</p><p>　　字符串是一个特殊包装类,其引用是存放在栈里的,而对象内容必须根据创建方式不同定(常量池和堆).有的是编译期就已经创建好，存放在字符串常 量池中，而有的是运行时才被创建.使用new关键字，存放在堆中。</p><h5 id="基础类型的变量和常量在内存中的分配"><a href="#基础类型的变量和常量在内存中的分配" class="headerlink" title="基础类型的变量和常量在内存中的分配"></a>基础类型的变量和常量在内存中的分配</h5><p>　　对于基础类型的变量和常量，变量和引用存储在栈中，常量存储在常量池中。</p><p>如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">INT1</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">INT2</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">INT3</span> <span class="operator">=</span> <span class="number">9</span>;</span><br></pre></td></tr></table></figure><p><img src="https://images2015.cnblogs.com/blog/908514/201607/908514-20160720152401622-482243128.jpg" alt="img"></p><p>　　编译器先处理int i1 &#x3D; 9；首先它会在栈中创建一个变量为i1的引用，然后查找栈中是否有9这个值，如果没找到，就将9存放进来，然后将i1指向9。接着处理int i2 &#x3D; 9；在创建完i2的引用变量后，因为在栈中已经有9这个值，便将i2直接指向9。这样，就出现了i1与i2同时均指向9的情况。最后i3也指向这个9。</p><h5 id="成员变量和局部变量在内存中的分配"><a href="#成员变量和局部变量在内存中的分配" class="headerlink" title="成员变量和局部变量在内存中的分配"></a>成员变量和局部变量在内存中的分配</h5><p>　　对于成员变量和局部变量：成员变量就是方法外部，类的内部定义的变量；局部变量就是方法或语句块内部定义的变量。局部变量必须初始化。 形式参数是局部变量，局部变量的数据存在于栈内存中。栈内存中的局部变量随着方法的消失而消失。 成员变量存储在堆中的对象里面，由垃圾回收器负责回收。  如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BirthDate</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> day;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> month;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> year;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BirthDate</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> m, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        day = d;</span><br><span class="line">        month = m;</span><br><span class="line">        year = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略get,set方法………</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">date</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test.change(date);</span><br><span class="line">        <span class="type">BirthDate</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BirthDate</span>(<span class="number">7</span>, <span class="number">7</span>, <span class="number">1970</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        i = <span class="number">1234</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images2015.cnblogs.com/blog/908514/201607/908514-20160720153756247-1230687149.jpg" alt="img"></p><p>　　对于以上这段代码，date为局部变量，i,d,m,y都是形参为局部变量，day，month，year为成员变量。下面分析一下代码执行时候的变化：   </p><ol><li>main方法开始执行：int date &#x3D; 9; date局部变量，基础类型，引用和值都存在栈中。</li><li>Test test &#x3D; new Test();test为对象引用，存在栈中，对象(new Test())存在堆中。 </li><li>test.change(date); i为局部变量，引用和值存在栈中。当方法change执行完成后，i就会从栈中消失。</li><li>BirthDate d1&#x3D; new BirthDate(7,7,1970); d1为对象引用，存在栈中，对象(new BirthDate())存在堆中，其中d，m，y为局部变量存储在栈中，且它们的类型为基础类型，因此它们的数据也存储在栈中。day,month,year为成员变量，它们存储在堆中(new BirthDate()里面)。当BirthDate构造方法执行完之后，d,m,y将从栈中消失。 </li><li>main方法执行完之后，date变量，test，d1引用将从栈中消失，new Test(), new BirthDate()将等待垃圾回收。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java_抽象类_接口</title>
      <link href="/chunyujin/c8c5b94d.html"/>
      <url>/chunyujin/c8c5b94d.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-抽象类"><a href="#Java-抽象类" class="headerlink" title="Java 抽象类"></a>Java 抽象类</h1><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><hr><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p><blockquote><p>抽象类就是用来继承的，比如犬科，犬科里面含有很多种类的犬，但是各种犬之间的特征是不同的，因此先设计犬科这个抽象类，包含犬科的基本属性，再由具体的犬种比如哈士奇犬类继承犬科这个抽象类，构建了犬科属性下的一个具体的哈士奇犬类</p></blockquote><p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p><p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p><p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p><p>在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><blockquote><p>抽象类使用关键字<code>abstract</code>定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> class 抽象类名称&#123;</span><br><span class="line">    <span class="comment">/*成员属性、成员方法*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 子类名称 extends 父类名称&#123;    <span class="comment">//继承抽象类</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> class 子类 extends 抽象类&#123;  <span class="comment">//抽象类继承抽象类</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>如果一个方法只给出了定义，但是没有给出实现，这个方法就是抽象方法。</p><blockquote><p>还是拿犬科举例子，犬具有跑步姿势，跑步姿势属于犬的行为，我们可以用一个方法来描述犬的跑步姿势。但是不同犬类的跑步姿势不同，可以先在犬科这个抽象类中定义上跑步姿势这一方法，但是并不实现，在继承了犬科的具体的犬种中对于该犬种的跑步姿势进行具体的描述</p></blockquote><p>含有抽象方法的类必须是抽象类；抽象类不一定含有抽象方法</p><blockquote><p>具有抽象特征的类就是抽象类，很明显，抽象方法是一种抽象，故含有抽象方法的类必须定义为抽象类</p></blockquote><p>抽象类的子类中必须实现抽象类中的方法，除非本身也是抽象类</p><p>抽象方法的权限不能是private，否则无法被子类访问，子类无法实现抽象类中的方法</p><blockquote><p>抽象方法也是用关键字<code>abstract</code>定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> 方法返回值类型 抽象方法名(参数列表); <span class="comment">//注意，只声明，不能实现</span></span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="抽象类总结规定"><a href="#抽象类总结规定" class="headerlink" title="抽象类总结规定"></a>抽象类总结规定</h3><ul><li><ol><li>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li></ol></li><li><ol start="2"><li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li></ol></li><li><ol start="3"><li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li></ol></li><li><ol start="4"><li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li></ol></li><li><ol start="5"><li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li></ol></li></ul><h1 id="Java-接口"><a href="#Java-接口" class="headerlink" title="Java 接口"></a>Java 接口</h1><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是<strong>抽象方法的集合</strong>，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><blockquote><p>如果抽象类中的所有方法都是抽象方法，这个抽象类就是接口</p></blockquote><p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p><p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p><p>接口无法被实例化，但是可以被实现(类似于子类通过继承来实现抽象类的抽象方法，接口的实现不是接口的继承，接口只能继承给接口，类只能实现接口，不能继承接口)。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。</p><p>另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><h3 id="接口与类相似点："><a href="#接口与类相似点：" class="headerlink" title="接口与类相似点："></a>接口与类相似点：</h3><ul><li>一个接口可以有多个方法。</li><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 .class 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul><h3 id="接口与类的区别："><a href="#接口与类的区别：" class="headerlink" title="接口与类的区别："></a>接口与类的区别：</h3><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的默认方法和用static修饰的静态方法，两者都是非抽象方法。</li><li>接口不能包含成员变量，除了 static 和 final 变量。</li><li><strong>接口不是被类继承了，而是要被类实现。</strong><ul><li>接口只能被接口继承，类只能实现接口，不是继承接口</li></ul></li><li>接口支持多继承。</li></ul><h3 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h3><ul><li>接口是隐式抽象的（即默认），故在定义接口时可以省略接口的修饰符关键字<code>abstract</code></li><li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式（即默认）的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li></ul><h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><ul><li><ol><li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li></ol></li><li><ol start="2"><li>抽象类中的成员变量可以是各种类型的，而<u>接口中的成员变量只能是 <strong>public static final</strong> 类型的</u>。</li></ol></li><li><ol start="3"><li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li></ol></li><li><ol start="4"><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ol></li></ul><blockquote><p><strong>注</strong>：JDK 1.8 以后，接口里可以有静态方法和方法体了。</p><p><strong>注</strong>：JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为”默认方法”，默认方法使用 default 关键字修饰。更多内容可参考 <a href="https://www.runoob.com/java/java8-default-methods.html">Java 8 默认方法</a>。</p><p><strong>注</strong>：JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。更多内容可参考 <a href="https://www.runoob.com/java/java9-private-interface-methods.html">Java 9 私有接口方法</a>。</p></blockquote><h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><blockquote><p>接口使用关键字<code>interface</code>声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名 extends 接口<span class="number">1</span>,接口<span class="number">2.</span>...&#123;</span><br><span class="line">    <span class="keyword">public</span> status <span class="keyword">final</span> 数据类型 常量名 = 常量值;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 抽象方法(参数列表);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>接口是可以继承多个父接口的，类来实现接口</p></li><li><p>接口中，成员属性默认(且只能)是<code>public static final</code>（公共全局常量)，故此修饰符可以省略</p><p>public：公有成员，在类外可以访问，确保接口的子类可以访问该成员</p><p>static：静态成员，全局变量，在类(接口)加载时就会在堆内存上分配，本类对象及子类各对象中该变量共同访问此空间</p><p>final：不可被修改，即为常量</p></li><li><p>接口中，抽象方法默认是<code>public abstract</code>，故此修饰符可以省略</p><p>必须是public，否则不可被继承，更不可能被实现</p><p>抽象方法自然是abstract</p></li><li><p>接口是隐式抽象的（即默认），所以在定义接口的时候可以省略接口的修饰符关键字<code>abstract</code></p></li></ul></blockquote></blockquote><h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><blockquote><p>在定义的类名后面加上<code>interface </code>和接口名即可&lt;这也说明了类不是继承接口(extends)，而是实现接口，只有接口能继承接口&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类名 interface 接口<span class="number">1</span>,接口<span class="number">2.</span>...&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类可以在继承父类的同时实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 子类名 extends 父类名 interface 接口<span class="number">1</span>,接口<span class="number">2.</span>...&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h3><p>最常用的继承接口是没有包含任何方法的接口。</p><p>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。</p><p>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p><blockquote><p>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util; <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EventListener</span> &#123;&#125;</span><br></pre></td></tr></table></figure></blockquote><p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p><ul><li><p>建立一个公共的父接口：</p><p>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p></li><li><p>向一个类添加数据类型：</p><p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java_基本概念</title>
      <link href="/chunyujin/9772543a.html"/>
      <url>/chunyujin/9772543a.html</url>
      
        <content type="html"><![CDATA[<h1 id="源文件–编译单元"><a href="#源文件–编译单元" class="headerlink" title="源文件–编译单元"></a>源文件–编译单元</h1><p>Java项目中的编译单元是后缀为<code>.java</code>的源文件</p><h1 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h1><p><mark>main方法是Java程序</mark>(就是项目)<mark>的入口</mark>，在Java项目(程序)执行的时候，从main方法开始执行。</p><p>一个源文件中最多有一个main方法；跟C++不同，<mark style= "background-color: pink">一个Java程序允许多个main函数</mark>，每个源文件中都可以有一个main方法，但是在程序执行的时候，<mark style = "background-color: pink">只能选择项目中的一个main方法作为项目的入口</mark>。</p><h1 id="public类-公共类"><a href="#public类-公共类" class="headerlink" title="public类(公共类)"></a>public类(公共类)</h1><blockquote><p>在此之前，先说一下访问权限</p><p>针对类、成员方法、成员属性，Java提供了四种访问控制权限修饰符关键字，在定义的时候加在最前面，附加上访问权限</p><p>分别是<code>private</code><code>defalut</code><code>protected</code><code>public</code></p><p><code>private</code>用于修饰<font color = red>成员对象</font>和<font color = red>成员方法</font></p><p>当<font color=blue>类</font>、<font color=red>成员方法</font>、<font color = red>成员属性</font>没有权限修饰符的时候，默认是<code>default</code>，最多可以在<u>本包下的其他源文件中被访问</u></p><p><code>protected</code>用于修饰<font color = red>成员对象</font>和<font color = red>成员方法</font></p><p><code>public</code>修饰<font color = blue>类</font>、<font color = red>成员属性</font>和<font color = red>成员方法</font>的时候，允许在本项目中任何地方被访问(全局访问)</p><blockquote><p> 以下为当<font color = black>成员属性</font>被不同的权限修饰符修饰时的可被访问的范围：</p><table><thead><tr><th>可被访问的范围</th><th>private</th><th>default</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>同一类中</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>同一包中的类</td><td></td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>同一项目下不同包中的子类</td><td></td><td></td><td>yes</td><td>yes</td></tr><tr><td>同一项目下全局范围</td><td></td><td></td><td></td><td>yes</td></tr></tbody></table><blockquote><p>不同包中的子类：本类作为父类时，在其他包中被继承</p></blockquote></blockquote></blockquote><p><mark style = "background-color: pink">源文件中只有public类是允许完全对外访问的</mark>(对项目内全局可访问，不只同包中)</p><p>不包中的类只有通过调用某类的public类才能间接调用该public类(所在源文件的)所在包下的其他非public类(如果这个public类中调用了其包中的非公共类的话，否则还是无法调用)</p><p>在程序编译的时候，只有通过源文件的public类才能访问到该源文件的内部，进而间接调用该源文件所在包中的非public类，所以<mark>public类是源文件的公共接口</mark>(只对外开放的口，不是Java的术语”接口”)</p><p>所以项目的<mark>main方法只能存在于public类中</mark>，否则无法被访问到</p><blockquote><p>例如源文件test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main方法必须用public修饰：因为要允许被全局访问，否则就算在public类中，main函数本身也不允许被访问</p><p>main方法必须用static修饰：main方法是public类的成员方法。普通的成员方法只能在类被实例化成对象，由对象用对象名调用，是对象方法；static修饰的成员方法是静态方法，在加载类的时候就被存储在静态域空间内了，通过类名就可以直接调用，不需要类实例化成对象。很显然，main函数作为项目的入口，一定是不需要实例化的</p></blockquote><p><mark style="background-color:pink">源文件的名称必须和文件内的public同名</mark></p><blockquote><p>这是好理解的，因为只有通过public类才能访问源文件</p></blockquote><p>由于源文件对外的接口是其中的公共类，所以在称呼源文件的时候可以称其为类，这里特指的是公共类</p><p><strong>源文件中并不一定要包含public类</strong>，当源文件的类需要直接被包外访问时，才需要被加上public权限，否则可以不加public，只被本包中的类访问</p><h1 id="包-package-软件包"><a href="#包-package-软件包" class="headerlink" title="包(package) (软件包)"></a>包(package) (软件包)</h1><blockquote><p>在使用C++编程的时候，一个项目里有若干个.c和.h源文件，它们是并行的，也就是说都存在于项目文件夹，且属于同一级。在C++中有使用<code>using namespace </code>命名空间这个机制来防止同名冲突，允许不同命名空间里的变量重名，只要在使用的时候指明变量的命名空间就行。</p></blockquote><p>在Java中，也给出了相似的机制，是通过包来实现的。</p><p>平时我们在使用电脑的操作系统的时候，通常将同一类的文件放到一个文件夹里，这样在进行查找的时候就能根据文件夹找到具体的文件。同时，同一个文件夹里不允许有同名的文件(文件拓展名也属于文件名)，但是不同的文件夹中可以存放不同的文件。</p><p>Java中的包就是这样。<mark style="background-color:pink">在项目中，可以将源文件按照某种方式进行分类，将同一类的文件放到一个包中，同一个包中的类名不允许重名，不同包中的类可以重名</mark>。</p><blockquote><p>类有两种权限，public和default，两种权限都是允许同包里的类访问，所以同包里的任何类都不允许重名</p></blockquote><p>这就跟操作系统的文件管理一样，文件夹里可以包含多个子文件夹，包里也可以存在多个子包，并且<mark style="background-color:pink">每个包属于一个命名空间，同一个命名空间里的变量不允许重名，不同命名空间里允许</mark>。</p><p>如同操作系统文件管理一样，应该先创建文件夹，再将文件添加到文件夹里(指定文件存在于哪个文件夹里)；不能先创建文件，然后指定其存在于哪个文件夹，因为有可能文件夹不存在</p><p>应该<mark style="background-color:pink">先创建包，再往包里添加文件</mark></p><ul><li>源文件的第一行用<code>package</code>关键字声明本源文件属于的包：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 文件所属的一级包.文件所属的二级包.文件所属的三级包;<span class="comment">//如果文件直接在项目底下，不属于任何包，不需要使用package声明；声明时路径要详细，并用.进行路径分隔</span></span><br><span class="line"><span class="keyword">public</span> class 类名&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后将文件移动到相应到包中</li></ul><blockquote><p>一定要确保<font color=red>文件中<code>package</code>声明的包路径</font>与<font color= red>文件实际存在于的包路径</font><font color=blue>一致</font>，否则会报错</p><blockquote><ul><li><p>比如在项目中有一个test.java，声明所属的包在test，但是test.java实际直接存在于项目底下，不在任何包中，此时会报错</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303082230342.png" alt="截屏2023-03-08 20.37.58" style="zoom: 50%;" /></li><li><p>包括当文件所属的包实际不存在时，也是属于声明的包路径与实际存在的包路径不一致</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303082230795.png" alt="截屏2023-03-08 22.25.01" style="zoom: 50%;" /></li></ul></blockquote></blockquote><ul><li>也可以在<font color = blue>包中直接创建源文件，源文件自带package声明</font> (更方便一些)</li></ul><h1 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h1><p>用于引入其他包内的类，包括类库中的类以及自定义的类</p><ol><li><p>类库中的类</p></li><li><p>引入包中的某个类</p><p><code>import java.util.Scanner;</code></p></li><li><p>引入包中的全部类</p><p><code>import jaca.util.*</code>（通配符的使用）</p></li><li><p>java.lang包提供了java语言的核心类库，包中的全部类，由系统自动引入(隐式引入)，不需要显示引入</p><p>比如包含了<code>system</code>类</p></li><li><p>如果使用<code>import</code>语句引入了整个包中的类，可能会增加编译时间但是不会影响运行性能</p></li><li><p>当程序中没有使用import语句声明类所在的包时，会默认使用当前路径下的类</p></li></ol><ul><li><font color = red><code>improt</code>语句必须位于包声明之后，类声明之前</font></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程日记 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深色模式下文章图片过暗</title>
      <link href="/chunyujin/ec9b450a.html"/>
      <url>/chunyujin/ec9b450a.html</url>
      
        <content type="html"><![CDATA[<p>在<code>/themes/butterfly/source/css/_mode/darkmode.styl </code></p><p>大约104行左右</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303071221998.png" alt="截屏2023-03-07 12.18.35"></p><p>修改关于第106行brightness的值</p><p>修改前值为0.5，效果：</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303071222747.png" alt="202301061858195"></p><p>修改之后值为1，效果：</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303071223543.png" alt="202301061858832"></p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片资源压缩指南</title>
      <link href="/chunyujin/7001a035.html"/>
      <url>/chunyujin/7001a035.html</url>
      
        <content type="html"><![CDATA[<h2 id="图片资源压缩指南"><a href="#图片资源压缩指南" class="headerlink" title="图片资源压缩指南"></a>图片资源压缩指南</h2><p>在p站等图片网站下载的原图作为网站背景文件太大，动辄十几mb，加载很慢</p><ul><li><p>先本地图片编辑，将图片尺寸缩小(一般1080p～2k大小作为背景就很够用了)，实现第一步减小体积</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303071025058.png" alt="截屏2023-03-07 10.24.38" style="zoom: 33%;" /></li><li><p>使用图片压缩网站或者软件进行进一步压缩，这里有两个网站</p><p>压缩图片分为有损压缩和无损压缩。无损压缩推荐<a href="https://tinypng.com/">Tinypng</a>，有损压缩推荐<a href="https://github.com/meowtec/Imagine/releases">imagine</a>。</p><table><thead><tr><th align="left"></th><th align="left">TinyPNG</th><th align="left">Imagine</th></tr></thead><tbody><tr><td align="left">特点</td><td align="left">无损压缩</td><td align="left">有损压缩，以牺牲图像质量， 降低图像色彩来达到缩减图像大小的目的。</td></tr><tr><td align="left">优点</td><td align="left">能够完全保留图像色彩，不损伤图像质量</td><td align="left">1. 压缩程度高，支持转<code>png</code>为<code>jpg</code>或<code>webp</code>，进一步减少图片大小 2. 软件支持一次处理多张图片，无上限，处理完成支持直接批量覆盖原文件或重命名</td></tr><tr><td align="left">缺点</td><td align="left">单次仅能上传20张图片，每张限制大小为5MB，无法处理更大图片。</td><td align="left">PNG转其他格式为不可逆操作（指覆盖保存后），且可能反而会增加图片大小。</td></tr></tbody></table><p>个人比较推荐无损压缩的网站</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网址不支持某些字符</title>
      <link href="/chunyujin/8e17ffd9.html"/>
      <url>/chunyujin/8e17ffd9.html</url>
      
        <content type="html"><![CDATA[<p>网址不支持一些特殊字符，比如+ &amp;等</p><p>如果在分类或者标签中添加了这类字符，在网址中是无法显示字符的，只会显示可以显示的字符</p><p>比如有一个标签是C，一个标签是C++，网址无法识别++，会把++略去，点击C++的时候打开的路径就变成了C的<img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202302210924416.gif" alt="Feb-21-2023 09-22-50"></p><p>但只是网址不支持，不涉及网址的地方是没问题的</p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_二叉树（C++</title>
      <link href="/chunyujin/147dc864.html"/>
      <url>/chunyujin/147dc864.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构-二叉树（C-实现"><a href="#数据结构-二叉树（C-实现" class="headerlink" title="数据结构_二叉树（C++实现"></a>数据结构_二叉树（C++实现</h1><blockquote><p>1前言：此类笔记仅用于个人复习，内容主要在于记录和体现个人理解，详细还请结合bite课件、录播、板书和代码。</p></blockquote><p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><ol><li><strong>本篇中的是一般二叉树(包括线索树、表达式树)是通过<u>链式结构</u>实现的</strong>，关于顺序结构的实现请见C语言版(顺便有堆的相关内容)</li><li><strong>本篇中哈夫曼树的结点存储是用的是<u>顺序结构</u></strong></li><li>模版不支持分离编译，因此跟以往自定义变量和函数时，声明在头文件、实现在源文件不同，定义(声明+实现)都是在头文件中【详见code日记】</li></ol></blockquote><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>采用<strong>链式存储</strong></p><h3 id="二叉树类的声明："><a href="#二叉树类的声明：" class="headerlink" title="二叉树类的声明："></a>二叉树类的声明：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模版不支持分离编译！！！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的链式存储</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span><span class="comment">//在buildExpressionTree中用到，用来进行string转等价int</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">nullPoint</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//binaryTree类的向前说明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binaryTree</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span><span class="comment">//二叉树结点类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">binaryTree</span>&lt;elemType&gt;;<span class="comment">//结点类将二叉树类视为友元函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">elemType data;</span><br><span class="line">Node&lt;elemType&gt; *left;<span class="comment">//指针域</span></span><br><span class="line">Node&lt;elemType&gt; *right;</span><br><span class="line"><span class="type">int</span> leftFlag; <span class="comment">//用于标识孩子指针是否为线索，0则说明left指向该结点的左孩子，1则说明left指向该结点的直接前驱</span></span><br><span class="line"><span class="type">int</span> rightFlag; <span class="comment">//用于标识孩子指针是否为线索，0则说明right指向该结点的右孩子，1则说明right指向该结点的直接后继</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Node</span>()</span><br><span class="line">&#123;</span><br><span class="line">left = <span class="literal">NULL</span>;</span><br><span class="line">right = <span class="literal">NULL</span>;</span><br><span class="line">leftFlag = <span class="number">0</span>;</span><br><span class="line">rightFlag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Node</span>(<span class="type">const</span> elemType&amp; data, Node&lt;elemType&gt; *left = <span class="literal">NULL</span>, Node&lt;elemType&gt; *right = <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;data = data;</span><br><span class="line"><span class="keyword">this</span>-&gt;left = left;</span><br><span class="line"><span class="keyword">this</span>-&gt;right = right;</span><br><span class="line">leftFlag = <span class="number">0</span>;</span><br><span class="line">rightFlag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binaryTree</span><span class="comment">//二叉树类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node&lt;elemType&gt; *root;<span class="comment">//链式二叉树的根结点指针</span></span><br><span class="line">elemType stopFlag;<span class="comment">//结束标志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">binaryTree</span>()</span><br><span class="line">&#123;</span><br><span class="line">root = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">creatTree</span><span class="params">(<span class="type">const</span> elemType&amp; flag)</span></span>;<span class="comment">//创建一棵二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> root == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;elemType&gt; *<span class="title">getRoot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Size</span><span class="params">(Node&lt;elemType&gt; *t)</span></span>;<span class="comment">//递归求二叉树的结点的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Size</span><span class="params">()</span></span>;<span class="comment">//求二叉树的结点个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Height</span><span class="params">(Node&lt;elemType&gt; *t)</span></span>;<span class="comment">//递归求二叉树的高度/深度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Height</span><span class="params">()</span></span>;<span class="comment">//求二叉树的高度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delTree</span><span class="params">(Node&lt;elemType&gt; *t)</span></span>;<span class="comment">//递归删除二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delTree</span><span class="params">()</span></span>;<span class="comment">//删除二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(Node&lt;elemType&gt; *t)</span></span>;<span class="comment">//按前序遍历输出以t为根的二叉树的结点的数据值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;<span class="comment">//前序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(Node&lt;elemType&gt; *t)</span></span>;<span class="comment">//按中序遍历输出以t为根的二叉树的结点的数据值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;<span class="comment">//中序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(Node&lt;elemType&gt; *t)</span></span>;<span class="comment">//按后序遍历输出以t为根的二叉树的结点的数据值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">()</span></span>;<span class="comment">//后序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>;<span class="comment">//层序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;elemType&gt; *<span class="title">threadMin</span><span class="params">()</span></span>;<span class="comment">//建立中序遍历线索树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadMidInOrder</span><span class="params">(Node&lt;elemType&gt; *first)</span></span>;<span class="comment">//借助 在原二叉树基础上 建立的中序遍历线索树，对于原二叉树实现非递归的中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadMidPreOrder</span><span class="params">()</span></span>;<span class="comment">//借助 在原二叉树基础上 建立的中序遍历线索树，对于原二叉树实现非递归的前序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;elemType&gt; *<span class="title">buildTree</span><span class="params">(elemType pre[], <span class="type">int</span> pl, <span class="type">int</span> pr,</span></span></span><br><span class="line"><span class="params"><span class="function">elemType mid[], <span class="type">int</span> ml, <span class="type">int</span> mr)</span></span>;<span class="comment">//已知一颗二叉树的前序遍历和中序遍历结果 建立这颗二叉树</span></span><br><span class="line"><span class="comment">//数组pre、mid分别是前序遍历、中序遍历的结果;pl、pr、ml、mr分别是前序、中序遍历结果数组的边界</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">init</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>;<span class="comment">//先将string类型的表达式，将元素由char变成string并存在vector中</span></span><br><span class="line"><span class="comment">// 这样才可以计算多位数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">judge</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>;<span class="comment">//判断操作符优先度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">stringToInt</span><span class="params">(string s)</span></span>;<span class="comment">//;string转成等价的int</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildExpressionTree</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>;<span class="comment">//将当前树建立为表达式树</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculateExpressionTree</span><span class="params">()</span></span>;<span class="comment">//计算当前这颗表达式树</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="二叉树类的成员变量介绍"><a href="#二叉树类的成员变量介绍" class="headerlink" title="二叉树类的成员变量介绍"></a>二叉树类的成员变量介绍</h4><p>二叉树结点类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//binaryTree类的向前说明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binaryTree</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span><span class="comment">//二叉树结点类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">binaryTree</span>&lt;elemType&gt;;<span class="comment">//结点类将二叉树类视为友元函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">elemType data;</span><br><span class="line">Node&lt;elemType&gt; *left;<span class="comment">//指针域</span></span><br><span class="line">Node&lt;elemType&gt; *right;</span><br><span class="line"><span class="type">int</span> leftFlag; <span class="comment">//用于标识孩子指针是否为线索，0则说明left指向该结点的左孩子，1则说明left指向该结点的直接前驱</span></span><br><span class="line"><span class="type">int</span> rightFlag; <span class="comment">//用于标识孩子指针是否为线索，0则说明right指向该结点的右孩子，1则说明right指向该结点的直接后继</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Node</span>()</span><br><span class="line">&#123;</span><br><span class="line">left = <span class="literal">NULL</span>;</span><br><span class="line">right = <span class="literal">NULL</span>;</span><br><span class="line">leftFlag = <span class="number">0</span>;</span><br><span class="line">rightFlag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Node</span>(<span class="type">const</span> elemType&amp; data, Node&lt;elemType&gt; *left = <span class="literal">NULL</span>, Node&lt;elemType&gt; *right = <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;data = data;</span><br><span class="line"><span class="keyword">this</span>-&gt;left = left;</span><br><span class="line"><span class="keyword">this</span>-&gt;right = right;</span><br><span class="line">leftFlag = <span class="number">0</span>;</span><br><span class="line">rightFlag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>data为结点的数据域</p><p>left和right是指针域</p><p>leftFlag&#x2F;rightFlag用于标识 孩子指针是否为线索，0则说明孩子指针保存的是指向该结点的孩子的地址，1则说明孩子指针保存的是该结点的直接前驱&#x2F;后继的地址</p><blockquote><p>详见<a href="#%E4%BA%8C%E5%8F%89%E7%BA%BF%E7%B4%A2%E6%A0%91">二叉线索树</a></p></blockquote></blockquote><p>二叉树类的成员变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binaryTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node&lt;elemType&gt; *root;<span class="comment">//链式二叉树的根结点指针</span></span><br><span class="line">elemType stopFlag;<span class="comment">//结束标志</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>stopFlag：在创建二叉树的时候，需要不断获取二叉树的结点，这个变量是用来 终止获取结点 的结束标志</p></blockquote><h3 id="二叉树类的实现："><a href="#二叉树类的实现：" class="headerlink" title="二叉树类的实现："></a>二叉树类的实现：</h3><h4 id="二叉树的构建"><a href="#二叉树的构建" class="headerlink" title="二叉树的构建"></a>二叉树的构建</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模版不支持分离编译！！！</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">creatTree</span>(<span class="type">const</span> elemType&amp; flag)<span class="comment">//创建一棵二叉树</span></span><br><span class="line"><span class="comment">//借助队列来创建一颗二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">queue&lt;Node&lt;elemType&gt; *&gt; que;</span><br><span class="line">elemType e, el, er;<span class="comment">//根结点、左孩子、右孩子的data</span></span><br><span class="line">Node&lt;elemType&gt; *p, *pl, *pr;<span class="comment">//根结点、左孩子、后孩子的地址</span></span><br><span class="line"></span><br><span class="line">stopFlag = flag;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Please input the root:&quot;</span>;<span class="comment">//输入根结点的值</span></span><br><span class="line">cin &gt;&gt; e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (e == flag)<span class="comment">//判断是否为结束标志</span></span><br><span class="line">&#123;</span><br><span class="line">root = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;elemType&gt;(e);<span class="comment">//new一个Node结点，作为根结点</span></span><br><span class="line">root = p;</span><br><span class="line"></span><br><span class="line">que.<span class="built_in">push</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">p = que.<span class="built_in">front</span>();</span><br><span class="line">que.<span class="built_in">pop</span>();<span class="comment">//获得队首元素并出队</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Please input the left_child and the right_child of &quot;</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; using &quot;</span> &lt;&lt; stopFlag</span><br><span class="line"> &lt;&lt; <span class="string">&quot; as no child&quot;</span>;</span><br><span class="line">cin &gt;&gt; el &gt;&gt; er;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (el != stopFlag)<span class="comment">//如果根结点有左孩子</span></span><br><span class="line">&#123;</span><br><span class="line">pl = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;elemType&gt;(el);</span><br><span class="line">p-&gt;left = pl;</span><br><span class="line">que.<span class="built_in">push</span>(pl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (er != stopFlag)<span class="comment">//如果根结点有右孩子</span></span><br><span class="line">&#123;</span><br><span class="line">pr = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;elemType&gt;(er);</span><br><span class="line">p-&gt;right = pr;</span><br><span class="line">que.<span class="built_in">push</span>(pr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>借助队列构建二叉树</p><p>首先创建树的根结点入队列</p><p>只要队列不为空，循环</p><p>每次获取队首元素p并出队</p><p>若p有孩子，则创建p的左&#x2F;右孩子结点，让p的指针域指向它们，并将左右孩子入队列。</p><p>否则不执行操作，进入下一次循环</p><p>队空，结束 <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211171311731.png" alt="截屏2022-11-17 13.11.05" style="zoom:50%;" /></p></blockquote><h4 id="递归求以二叉树的结点的个数"><a href="#递归求以二叉树的结点的个数" class="headerlink" title="递归求以二叉树的结点的个数"></a>递归求以二叉树的结点的个数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> binaryTree&lt;elemType&gt;::<span class="built_in">Size</span>(Node&lt;elemType&gt; *t)<span class="comment">//递归求二叉树的结点的个数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> t == <span class="literal">NULL</span> ? <span class="number">0</span> : <span class="number">1</span> + <span class="built_in">Size</span>(t-&gt;left) + <span class="built_in">Size</span>(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> binaryTree&lt;elemType&gt;::<span class="built_in">Size</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Size</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以结合图思考</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221014105348435.png" alt="image-20221014105348435" style="zoom: 80%;" /></blockquote><h4 id="递归求二叉树的高度-x2F-深度"><a href="#递归求二叉树的高度-x2F-深度" class="headerlink" title="递归求二叉树的高度&#x2F;深度"></a>递归求二叉树的高度&#x2F;深度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> binaryTree&lt;elemType&gt;::<span class="built_in">Height</span>(Node&lt;elemType&gt; *t)<span class="comment">//递归求二叉树的高度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Height</span>(t-&gt;left) &gt; <span class="built_in">Height</span>(t-&gt;right) ? <span class="built_in">Height</span>(t-&gt;left) + <span class="number">1</span> : <span class="built_in">Height</span>(t-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> binaryTree&lt;elemType&gt;::<span class="built_in">Height</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Height</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>节点的层次：从根开始定义，根为第一层，根的子结点所在的为第二层，以此类推</p><blockquote><p>如下图，A的层次是1，C的是2，H的是4</p></blockquote><p>树的高度&#x2F;深度：根中结点的最大层次，下图中树的高度就是4</p><p>思路：递归</p><p>结点为空则返回高度为0，否则返回当前结点为根结点的树的高度：</p><p>左右子树比较高度，更高的高度+1，就是当前结点为根结点的树的高度</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E5%9B%BE%E7%89%8720221117235938.jpg" alt="QQ图片20221117235938" style="zoom: 23%;" /></blockquote><h4 id="递归删除二叉树"><a href="#递归删除二叉树" class="headerlink" title="递归删除二叉树"></a>递归删除二叉树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">delTree</span>(Node&lt;elemType&gt; *t)<span class="comment">//递归删除二叉树</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">delTree</span>(t-&gt;left);</span><br><span class="line"><span class="built_in">delTree</span>(t-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> t;</span><br><span class="line"><span class="comment">/*这里t不用指向NULL，1是因为它是形参，指向也没用，2是下面的root需要指向形参是因为root是类的成员函数，后续还会调用它</span></span><br><span class="line"><span class="comment">避免root指向被释放的空间，造成非法访问，成为野指针*/</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">delTree</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">delTree</span>(root);</span><br><span class="line">root = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的遍历："><a href="#二叉树的遍历：" class="headerlink" title="二叉树的遍历："></a>二叉树的遍历：</h4><h5 id="二叉树的递归遍历："><a href="#二叉树的递归遍历：" class="headerlink" title="二叉树的递归遍历："></a>二叉树的递归遍历：</h5><h6 id="前序遍历-递归"><a href="#前序遍历-递归" class="headerlink" title="前序遍历(递归)"></a>前序遍历(递归)</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">preOrder</span>(Node&lt;elemType&gt; *t)<span class="comment">//递归，按前序遍历输出以t为根的二叉树的结点的数据值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;NUll &quot;;//如果想要更清楚观察前序遍历的原理，可以在空结点时输出&quot;NULL &quot;</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; t-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//根，左，右</span></span><br><span class="line"><span class="built_in">preOrder</span>(t-&gt;left);</span><br><span class="line"><span class="built_in">preOrder</span>(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//template&lt;class elemType&gt;</span></span><br><span class="line"><span class="comment">//void binaryTree&lt;elemType&gt;::preOrder()//递归，前序遍历整棵树</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//preOrder(root);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h6 id="中序遍历-递归"><a href="#中序遍历-递归" class="headerlink" title="中序遍历(递归)"></a>中序遍历(递归)</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">inOrder</span>(Node&lt;elemType&gt; *t)<span class="comment">//递归，按中序遍历输出以t为根的二叉树的结点的数据值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;NUll &quot;;//如果想要更清楚观察前序遍历的原理，可以在空结点时输出&quot;NULL &quot;</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">inOrder</span>(t-&gt;left);<span class="comment">//左，根，右</span></span><br><span class="line">cout &lt;&lt; t-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">inOrder</span>(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//template&lt;class elemType&gt;</span></span><br><span class="line"><span class="comment">//void binaryTree&lt;elemType&gt;::inOrder()//递归，中序遍历整棵树</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//inOrder(root);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h6 id="后序遍历-递归"><a href="#后序遍历-递归" class="headerlink" title="后序遍历(递归)"></a>后序遍历(递归)</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">postOrder</span>(Node&lt;elemType&gt; *t)<span class="comment">//递归，按后序遍历输出以t为根的二叉树的结点的数据值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;NUll &quot;;//如果想要更清楚观察前序遍历的原理，可以在空结点时输出&quot;NULL &quot;</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">postOrder</span>(t-&gt;left);</span><br><span class="line"><span class="built_in">postOrder</span>(t-&gt;right);</span><br><span class="line">cout &lt;&lt; t-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//template&lt;class elemType&gt;</span></span><br><span class="line"><span class="comment">//void binaryTree&lt;elemType&gt;::postOrder()//递归，后序遍历整棵树</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//postOrder(root);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h5 id="二叉树的非递归遍历："><a href="#二叉树的非递归遍历：" class="headerlink" title="二叉树的非递归遍历："></a>二叉树的非递归遍历：</h5><blockquote><p>二叉树的非递归遍历，需要用 栈 来进行辅助</p></blockquote><h6 id="前序遍历-非递归"><a href="#前序遍历-非递归" class="headerlink" title="前序遍历(非递归)"></a>前序遍历(非递归)</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">preOrder</span>()<span class="comment">//非递归，前序遍历整棵树</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">Node&lt;elemType&gt; *p;<span class="comment">//当前访问的结点</span></span><br><span class="line">stack&lt;Node&lt;elemType&gt; *&gt; s;<span class="comment">//辅助栈，存放即将访问的结点</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">push</span>(root);</span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">p = s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;right)</span><br><span class="line">s.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;left)</span><br><span class="line">s.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>前序遍历的访问是“根、左、右”</p><p>用一个栈s存储 需要遍历的结点 ，先将root入栈</p><p>只要栈不为空，就循环</p><p>获取栈顶元素p并出栈</p><p>访问p结点，输出p的data</p><p>看p有无左&#x2F;右孩子，有则入栈</p><p>注意应让右孩子先入栈，再让左孩子入栈</p><blockquote><p>因为栈的特性，后进先出，前序遍历要求访问完根结点之后先访问它的左孩子</p><p>所以应先让右孩子入栈，再让左孩子入栈，这样才能保证栈顶元素是左孩子</p></blockquote><blockquote><p> 还是因为栈的特性，访问结点的时候让它的孩子入栈，这样就保证了访问完结点之后访问的就是它的孩子</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20221118113318.png" alt="QQ截图20221118113318" style="zoom:40%;" /></blockquote><h6 id="中序遍历-非递归"><a href="#中序遍历-非递归" class="headerlink" title="中序遍历(非递归)"></a>中序遍历(非递归)</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">inOrder</span>()<span class="comment">//非递归，中序遍历整棵树</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">Node&lt;elemType&gt; *p;<span class="comment">//当前结点</span></span><br><span class="line">stack&lt;Node&lt;elemType&gt; *&gt; s1;<span class="comment">//辅助栈，保存即将访问的结点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag;<span class="comment">//用来记录结点的访问情况：是否访问过左孩子。没访问过则左孩子入栈；访问过左孩子才能访问当前结点的data，然后将右孩子入栈</span></span><br><span class="line"><span class="comment">//未访问过左孩子，值为0，访问过左孩子，值为1</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s2;<span class="comment">//保存s1中每个结点的访问情况</span></span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">push</span>(root);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//root的初始访问情况是0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">p = s1.<span class="built_in">top</span>();<span class="comment">//获取栈顶元素，为当前结点</span></span><br><span class="line">flag = s2.<span class="built_in">top</span>();<span class="comment">//获取栈顶元素，为当前结点的访问情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span>)<span class="comment">//如果访问过当前结点的左孩子，则访问当前结点的data，输出data、右孩子入栈</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//访问输出当前结点的data</span></span><br><span class="line">  <span class="comment">//访问完了当前结点的data，当前结点应当出栈</span></span><br><span class="line">      s1.<span class="built_in">pop</span>();</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;right)<span class="comment">//有右孩子则压栈</span></span><br><span class="line">&#123;</span><br><span class="line">s1.<span class="built_in">push</span>(p-&gt;right);<span class="comment">//右孩子压栈</span></span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//右孩子的初始访问情况是0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//没访问过左孩子</span></span><br><span class="line">&#123;</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">1</span>);<span class="comment">//更新当前结点的访问情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;left)<span class="comment">//左孩子入栈</span></span><br><span class="line">&#123;</span><br><span class="line">s1.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//左孩子初始访问情况是0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>中序遍历的访问顺序是“左、根、右”</p><p>在访问结点的时候，需要考虑该结点是否访问过左孩子，若没有访问左孩子，则应先访问左孩子，之后再访问当前结点data，然后再访问右孩子</p><p>用flag记录结点的访问情况，未访问过左孩子则值为0，访问过则值为1，根据flag来判断对当前结点如何操作</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20221118113318.png" alt="QQ截图20221118113318" style="zoom: 33%;" /></blockquote><h6 id="后序遍历-非递归"><a href="#后序遍历-非递归" class="headerlink" title="后序遍历(非递归)"></a>后序遍历(非递归)</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">postOrder</span>()<span class="comment">//非递归，后序遍历整棵树</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">Node&lt;elemType&gt; *p;<span class="comment">//当前结点</span></span><br><span class="line">stack&lt;Node&lt;elemType&gt; *&gt; s1;<span class="comment">//辅助栈，保存即将访问的结点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag;<span class="comment">//用来记录当前结点的访问情况。没访问过左孩子则左孩子入栈；访问过左孩子但没有访问过右孩子则右孩子入栈；访问过右孩子才能访问当前结点的data</span></span><br><span class="line"><span class="comment">//未访问过左孩子，值为0；访问过左孩子未访问过右孩子，值为1；访问过右孩子，值为2</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s2;<span class="comment">//保存s1中每个结点的访问情况</span></span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">push</span>(root);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//root的初始访问情况是0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">p = s1.<span class="built_in">top</span>();<span class="comment">//获取栈顶元素，为当前结点</span></span><br><span class="line">flag = s2.<span class="built_in">top</span>();<span class="comment">//获取栈顶元素，为当前结点的访问情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">2</span>)<span class="comment">//访问过当前结点的右孩子，则访问当前结点的data</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//访问输出当前结点的data</span></span><br><span class="line">  <span class="comment">//访问完了当前结点的data，当前结点应当出栈</span></span><br><span class="line">      s1.<span class="built_in">pop</span>();</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">1</span>)<span class="comment">//访问过当前结点的左孩子但未访问右孩子</span></span><br><span class="line">&#123;</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">2</span>);<span class="comment">//更新当前结点的访问情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;right)<span class="comment">//有右孩子则压栈</span></span><br><span class="line">&#123;</span><br><span class="line">s1.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//右孩子的初始访问情况是0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">0</span>)<span class="comment">//未访问过当前结点的左孩子</span></span><br><span class="line">&#123;</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">1</span>);<span class="comment">//更新当前结点的访问情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;left)<span class="comment">//左孩子入栈</span></span><br><span class="line">&#123;</span><br><span class="line">s1.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//左孩子初始访问情况是0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>思路跟中序遍历类似，访问结点的时候按照“左、右、根”的顺序</p><p>访问结点的时候要判断是否访问过左孩子，没有访问过左孩子要先访问左孩子，如果访问过左孩子要判断是否访问过右孩子，访问过右孩子才能访问当前结点，输出当前结点的值</p><p>flag为 0 说明 未访问过当前结点的左孩子；1则说明访问过左孩子但是没访问右孩子；2则说明访问过右孩子，可以输出当前结点的data</p></blockquote><h6 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">levelOrder</span>()<span class="comment">//层序遍历</span></span><br><span class="line">&#123;</span><br><span class="line">queue&lt;Node&lt;elemType&gt; *&gt; que;<span class="comment">//辅助队列保存即将访问的结点</span></span><br><span class="line">Node&lt;elemType&gt; *p;<span class="comment">//当前访问的结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">que.<span class="built_in">push</span>(root);</span><br><span class="line"><span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">p = que.<span class="built_in">front</span>();</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;left)</span><br><span class="line">que.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;right)</span><br><span class="line">que.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉线索树："><a href="#二叉线索树：" class="headerlink" title="二叉线索树："></a>二叉线索树：</h4><blockquote><p>对于n个结点的二叉树，在二叉链存储结构总中有n+1个空链域</p><blockquote><p>有些结点没有左&#x2F;右孩子，指针域保存的地址是空的，这个指针域是空链域</p></blockquote><p>利用这些空链域存放在 某种遍历次序下的结果中 该结点的 直接前驱结点 和 直接后继结点 的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树。</p><blockquote><p>直接前驱、直接后继：通过某种遍历方式，获得二叉树的遍历结果，在遍历结果中，某个结点的前一个结点就是 在当前遍历方式下 自己的直接前驱，后一个结点就是 在当前遍历方式下 自己的直接后继</p><p>如果指针域的指针存的是直接前驱&#x2F;后继的地址，则就能找到当前结点的直接前驱或者直接后继，这就为遍历提供了线索，故称这种指针为线索</p></blockquote><p>根据线索性质的不同，二叉树可分为前序遍历线索二叉树、中序遍历线索二叉树和后序遍历线索二叉树三种。</p></blockquote><h5 id="中序遍历线索二叉树的构建"><a href="#中序遍历线索二叉树的构建" class="headerlink" title="中序遍历线索二叉树的构建"></a>中序遍历线索二叉树的构建</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">Node&lt;elemType&gt; *binaryTree&lt;elemType&gt;::<span class="built_in">threadMin</span>()<span class="comment">//建立中序遍历线索树</span></span><br><span class="line"><span class="comment">//实质就是在中序遍历的时候将结点的空链域存上线索</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">Node&lt;elemType&gt; *first = <span class="literal">NULL</span>;<span class="comment">//记录中序遍历结果中的第一个结点</span></span><br><span class="line">Node&lt;elemType&gt; *pre = <span class="literal">NULL</span>;<span class="comment">//在中序遍历中当前结点的直接前驱</span></span><br><span class="line"></span><br><span class="line">Node&lt;elemType&gt; *p;<span class="comment">//当前结点</span></span><br><span class="line">stack&lt;Node&lt;elemType&gt; *&gt; s1;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag;</span><br><span class="line">  stack&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">push</span>(root);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//实质就是在中序遍历的时候将结点的空链域存上线索</span></span><br><span class="line"><span class="keyword">while</span> (!s1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    p = s1.<span class="built_in">top</span>();</span><br><span class="line">flag = s2.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;-----&quot;</span> &lt;&lt; endl;</span><br><span class="line">      s1.<span class="built_in">pop</span>();</span><br><span class="line">      s2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!first)<span class="comment">//p结点data在此已经访问完了，如果first为空说明p就是中序遍历结果中的第一个结点</span></span><br><span class="line">first = p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;right &amp;&amp; p-&gt;rightFlag == <span class="number">0</span>)<span class="comment">//如果当前结点有右孩子，右孩子入栈</span></span><br><span class="line">        <span class="comment">//rightFlag == 0说明右指针存的是右孩子，== 1说明右指针存的是直接后继</span></span><br><span class="line">&#123;</span><br><span class="line">s1.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!p-&gt;left)<span class="comment">//如果左指针为空，用来存直接前驱</span></span><br><span class="line">&#123;</span><br><span class="line">p-&gt;leftFlag = <span class="number">1</span>;</span><br><span class="line">p-&gt;left = pre;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//////////////辅助调试，输出一下当前结点直接前驱的data///////////////////////</span></span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;&#x27;s pre: &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;left)</span><br><span class="line">cout &lt;&lt; p-&gt;left-&gt;data &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//中序遍历结果中的第一个结点没有直接前驱，是线索二叉树中唯一一个左指针为空的</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!p-&gt;right)<span class="comment">//如果右指针为空，用来存直接后继</span></span><br><span class="line">&#123;</span><br><span class="line">p-&gt;rightFlag = <span class="number">1</span>;</span><br><span class="line">p-&gt;right = !s1.<span class="built_in">empty</span>() ? s1.<span class="built_in">top</span>() : <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//s1栈顶就是当前结点的直接后继，如果栈为空，说明当前结点是中序遍历结果中的最后一个结点，是线索二叉树中唯一一个右指针为空的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////辅助调试，输出一下当前结点直接前驱的data///////////////////////</span></span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;&#x27;s next: &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;right)</span><br><span class="line">cout &lt;&lt; p-&gt;right-&gt;data &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//中序遍历结果中的最后一个结点没有直接后继，是线索二叉树中唯一一个右指针为空的</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pre = p;<span class="comment">//已访问完当前结点，当前结点成为了下一个要访问的结点的直接前驱</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span><span class="comment">//如果flag == 0</span></span><br><span class="line">&#123;</span><br><span class="line">      s2.<span class="built_in">pop</span>();</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;leftFlag == <span class="number">0</span> &amp;&amp; p-&gt;left)<span class="comment">//左结点为左孩子的话，将左孩子入结点栈</span></span><br><span class="line">&#123;</span><br><span class="line">s1.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在进行中序遍历的时候顺便对当前访问的结点添加上线索</p><p>访问的上一个结点是当前结点的直接前驱，即将访问的下一个结点(栈顶元素)是当前结点的直接后继</p></blockquote><h5 id="借助中序遍历线索树实现-中序非递归遍历"><a href="#借助中序遍历线索树实现-中序非递归遍历" class="headerlink" title="借助中序遍历线索树实现 中序非递归遍历"></a>借助中序遍历线索树实现 中序非递归遍历</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">threadMidInOrder</span>(Node&lt;elemType&gt; *first)<span class="comment">//借助中序线索树，非递归 中序遍历原来的二叉树</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!first || !root)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">Node&lt;elemType&gt; *p = first;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;rightFlag == <span class="number">0</span>)<span class="comment">//如果p有右孩子，访问p的右孩子</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p-&gt;leftFlag == <span class="number">0</span> &amp;&amp; p-&gt;left)<span class="comment">//当前结点有左子树，应访问左子树的最左结点</span></span><br><span class="line">p = p-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">else</span><span class="comment">//如果p无右孩子，则直接用线索找它的直接后继</span></span><br><span class="line">p = p-&gt;right;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从first开始遍历</p><p>遍历结点时</p><p>有右孩子去往右孩子，访问右孩子时，右孩子有左子树，则去往左子树的最左结点</p><p>无右孩子则去往直接后继</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211201041959.png" alt="iShot_2022-11-20_10.41.22" style="zoom: 20%;" /></blockquote><h5 id="借助中序遍历线索树实现-前序非递归遍历"><a href="#借助中序遍历线索树实现-前序非递归遍历" class="headerlink" title="借助中序遍历线索树实现 前序非递归遍历"></a>借助中序遍历线索树实现 前序非递归遍历</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">threadMidPreOrder</span>()<span class="comment">//借助中序线索树，非递归 前序遍历 原来的二叉树</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">Node&lt;elemType&gt; *p = root;<span class="comment">//从root开始访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;leftFlag == <span class="number">0</span>)<span class="comment">//如果有左孩子，则直接访问左孩子</span></span><br><span class="line">p = p-&gt;left;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span><span class="comment">//没有左孩子则访问右孩子</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;rightFlag == <span class="number">1</span> &amp;&amp; p-&gt;right)<span class="comment">//如果没有右孩子，则去往直接后继，直到有右孩子或者右结点为空(中序遍历结果中的最后一个结点</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p = p-&gt;right;<span class="comment">//去往右孩子</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从root开始遍历</p><p>有左孩子访问左孩子</p><p>没有左孩子访问右孩子，没有右孩子则去往直接后继，直到有右孩子，访问右孩子</p></blockquote><h4 id="已知前中序遍历结果，求二叉树"><a href="#已知前中序遍历结果，求二叉树" class="headerlink" title="已知前中序遍历结果，求二叉树"></a>已知前中序遍历结果，求二叉树</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">Node&lt;elemType&gt; *binaryTree&lt;elemType&gt;::<span class="built_in">buildTree</span>(elemType pre[], <span class="type">int</span> pl, <span class="type">int</span> pr,</span><br><span class="line">elemType mid[], <span class="type">int</span> ml, <span class="type">int</span> mr)<span class="comment">//已知一颗二叉树的前序遍历和中序遍历结果 建立这颗二叉树</span></span><br><span class="line"><span class="comment">//数组pre、mid分别是前序遍历、中序遍历的结果;pl、pr、ml、mr分别是前序、中序遍历结果数组的边界</span></span><br><span class="line">&#123;</span><br><span class="line">Node&lt;elemType&gt; *p;<span class="comment">//创建当前树的根结点</span></span><br><span class="line">Node&lt;elemType&gt; *leftRoot, *rightRoot;<span class="comment">//创建当前树的左子树、右子树的根结点</span></span><br><span class="line"><span class="type">int</span> i, pos, num;<span class="comment">//pos：当前树的根在中序遍历中的位置，num：记录左子树结点个数</span></span><br><span class="line"><span class="comment">//(根在前序遍历中的位置不用记录，前序遍历结果的第一个就是)</span></span><br><span class="line"><span class="type">int</span> lpl, lpr, lml, lmr;<span class="comment">//记录前序遍历、中序遍历中左子树的范围</span></span><br><span class="line"><span class="type">int</span> rpl, rpr, rml, rmr;<span class="comment">//记录前序遍历、中序遍历中右子树的范围</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pl &gt; pr)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">p = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;elemType&gt;(pre[pl]);<span class="comment">//创建当前树的根结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line">root = p;<span class="comment">//如果当前的二叉树是空树，那就直接让当前的树等于创建的二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = ml; i &lt;= mr; i++)<span class="comment">//开始寻找前序遍历中的根在中序遍历中的位置</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mid[i] == pre[pl])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pos = i;<span class="comment">//----找到了中序遍历结果中的根结点----</span></span><br><span class="line">num = pos - ml;<span class="comment">//记录左子树的结点个数</span></span><br><span class="line"></span><br><span class="line">lpl = pl + <span class="number">1</span>;<span class="comment">//前序遍历结果中 左子树的范围</span></span><br><span class="line">lpr = pl + num;</span><br><span class="line">lml = ml;<span class="comment">//中序遍历结果中 左子树的范围</span></span><br><span class="line">lmr = pos - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">leftRoot = <span class="built_in">buildTree</span>(pre, lpl, lpr, mid, lml, lmr);<span class="comment">//递归，找遍历结果中 左子树中 的根结点</span></span><br><span class="line"></span><br><span class="line">rpl = lpl + <span class="number">1</span>;<span class="comment">//前序遍历结果中 右子树的范围</span></span><br><span class="line">rpr = pr;</span><br><span class="line">rml = pos + <span class="number">1</span>;<span class="comment">//中序遍历结果中 右子树的范围</span></span><br><span class="line">rmr = mr;</span><br><span class="line"></span><br><span class="line">rightRoot = <span class="built_in">buildTree</span>(pre, rpl, rpr, mid, rml, rmr);<span class="comment">//递归，找遍历结果中 右子树中 的根结点</span></span><br><span class="line"></span><br><span class="line">p-&gt;left = leftRoot;</span><br><span class="line">p-&gt;right = rightRoot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>根据前序遍历“根、左、右”和中序遍历“左、根、右”</p><p>前序遍历结果中的第一个结点就是根，在中序遍历中找到这个根，中序遍历结果中这个根的左面的所有结点就是这个根的左子树的遍历结果，右面的所有结点就是右子树的遍历结果</p><p>这样可以用前序遍历结果找根，中序遍历结果找子树的遍历结果，构建完整二叉树</p><blockquote><p>树是递归的结构，树可以分为根和子树，子树又分为根和子树</p><p>所以要递归找根结点，直到不能再分</p></blockquote><blockquote><p>例如：已知一棵树的前序遍历和中序遍历结果</p><blockquote><p>前序序列：B、L、S、C、F、D、G、I、H</p><p>中序序列：L、S、B、F、C、I、G、H、D</p></blockquote><p>理论思路过程：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20221120152841.png" alt="image" style="zoom: 33%;" /><p>算法实现：</p><p>pre、mid：前序遍历、中序遍历的结果结果数组</p><p>pl、pr、ml、mr：前序、中序遍历结果数组的左右边界</p><p>p：创建当前树的根结点</p><p>leftRoot、rightRoot：创建当前树的左子树、右子树的根结点<br>pos：记录当前树的根在中序遍历中的位置</p><p>(根在前序遍历中的位置不用记录，前序遍历结果的第一个就是)</p><p>num：记录左子树结点的个数</p><p>lpl、 lpr、 lml、 lmr：记录前序遍历、中序遍历中左子树的范围</p><p>rpl,、rpr,、rml、rmr：记录前序遍历、中序遍历中右子树的范围</p><p>​<img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211201635521.png" alt="iShot_2022-11-20_16.33.37" style="zoom: 33%;" /></p></blockquote></blockquote><h4 id="表达式树的构建："><a href="#表达式树的构建：" class="headerlink" title="表达式树的构建："></a>表达式树的构建：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">vector&lt;string&gt; binaryTree&lt;elemType&gt;::<span class="built_in">init</span>(<span class="type">const</span> string&amp; s)<span class="comment">//表达式的初始化处理</span></span><br><span class="line"><span class="comment">//原始表达式是string类型的，元素为char类型，因此值大于9的整数(也就是两位以上的整数)会被分成两个元素，无法正常表示和计算</span></span><br><span class="line"><span class="comment">//应先将表达式进行初始化：用元素类型为string的vector保存表达式的操作数和操作字符</span></span><br><span class="line">&#123;</span><br><span class="line">vector&lt;string&gt; v;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; s.<span class="built_in">length</span>())</span><br><span class="line">&#123;</span><br><span class="line">j = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (j &lt; s.<span class="built_in">length</span>() &amp;&amp; s[j] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; s[j] &gt;= <span class="string">&#x27;0&#x27;</span>)<span class="comment">//如果遇到了数字，就往后看是否为多位数</span></span><br><span class="line">&#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == j)<span class="comment">//说明没有遇到数字</span></span><br><span class="line">v.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(i++, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(i, j - i));</span><br><span class="line">i = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> binaryTree&lt;elemType&gt;::<span class="built_in">judge</span>(<span class="type">const</span> string&amp; s)<span class="comment">//判断操作符优先度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="string">&quot;+&quot;</span> || s == <span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;*&quot;</span> || s == <span class="string">&quot;/&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;(&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;)&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> binaryTree&lt;elemType&gt;::<span class="built_in">stringToInt</span>(string s)<span class="comment">//表达式中的操作数string类转int</span></span><br><span class="line">&#123;</span><br><span class="line">stringstream ss;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">ss &lt;&lt; s;</span><br><span class="line">ss &gt;&gt; i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">buildExpressionTree</span>(<span class="type">const</span> string&amp; s)<span class="comment">//将当前树建立为表达式树</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root)<span class="comment">//表达式树应该用空树来建</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;This binaryTree is not a null tree , please define another binaryTree to make it as a ExpressionTree&quot;</span></span><br><span class="line"> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stack&lt;string&gt; s1;<span class="comment">//操作符栈</span></span><br><span class="line">stack&lt;Node&lt;string&gt; *&gt; s2;<span class="comment">//子树栈，用来存放根结点的地址</span></span><br><span class="line">Node&lt;string&gt; *p, *left, *right;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; v = <span class="built_in">init</span>(s);<span class="comment">//先将string类型的表达式初始化，将元素由char变成string并存在vector中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">judge</span>(v[i]) == <span class="number">0</span>)<span class="comment">//如果是操作数，直接创建作为根结点进子树栈</span></span><br><span class="line">&#123;</span><br><span class="line">p = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;string&gt;(v[i]);</span><br><span class="line">s2.<span class="built_in">push</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">judge</span>(v[i]) == <span class="number">3</span>)<span class="comment">//如果当前操作符是左括号，直接进栈</span></span><br><span class="line">s1.<span class="built_in">push</span>(v[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">judge</span>(v[i]) == <span class="number">1</span> || <span class="built_in">judge</span>(v[i]) == <span class="number">2</span>)<span class="comment">//如果是 加减乘除 操作符</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s1.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">s1.<span class="built_in">push</span>(v[i]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (!s1.<span class="built_in">empty</span>() &amp;&amp; s1.<span class="built_in">top</span>() != <span class="string">&quot;(&quot;</span> &amp;&amp; <span class="built_in">judge</span>(v[i]) &lt; <span class="built_in">judge</span>(s1.<span class="built_in">top</span>()))</span><br><span class="line"><span class="comment">//如果栈不为空且栈顶元素不是&quot;(&quot;，并且当前操作符优先度 小于栈顶，就让栈顶出栈</span></span><br><span class="line"><span class="comment">//每次出栈，出栈的栈顶元素要与子树栈的两个栈顶元素构建成子树，并压入子树栈</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">right = s2.<span class="built_in">top</span>();</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line">left = s2.<span class="built_in">top</span>();</span><br><span class="line">s2.<span class="built_in">pop</span>();<span class="comment">//子树栈两个栈顶元素出栈</span></span><br><span class="line"></span><br><span class="line">p = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;string&gt;(s1.<span class="built_in">top</span>());</span><br><span class="line">s1.<span class="built_in">pop</span>();<span class="comment">//操作符栈顶元素出栈，与刚出子树栈的两个栈顶元素构建成子树，压入子树栈</span></span><br><span class="line">p-&gt;left = left;</span><br><span class="line">p-&gt;right = right;</span><br><span class="line"><span class="comment">//在表达式树中，数字作为左结点是操作数，右结点是被操作数（表达式中左边的数是操作数，右边的数是被操作数</span></span><br><span class="line"><span class="comment">//而表达式中的数字从左到右正序入栈，因此栈顶是被操作数，作为树结点的时候要记得反过来</span></span><br><span class="line">s2.<span class="built_in">push</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前操作符优先度不低于栈顶 or 栈为空</span></span><br><span class="line">s1.<span class="built_in">push</span>(v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">judge</span>(v[i]) == <span class="number">-1</span>)<span class="comment">//当前操作符是右括号的话</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">judge</span>(s1.<span class="built_in">top</span>()) != <span class="number">3</span>)<span class="comment">//在遇到左括号之前，一直将操作符栈顶弹栈</span></span><br><span class="line"><span class="comment">//每次出栈，出栈的栈顶元素要与子树栈的两个栈顶元素构建成子树，并压入子树栈</span></span><br><span class="line">&#123;</span><br><span class="line">right = s2.<span class="built_in">top</span>();</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line">left = s2.<span class="built_in">top</span>();</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">p = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;string&gt;(s1.<span class="built_in">top</span>());</span><br><span class="line">s1.<span class="built_in">pop</span>();</span><br><span class="line">p-&gt;left = left;</span><br><span class="line">p-&gt;right = right;</span><br><span class="line"></span><br><span class="line">s2.<span class="built_in">push</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">pop</span>();<span class="comment">//遇到左括号，左括号出栈</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s1.<span class="built_in">empty</span>())<span class="comment">//处理操作符栈，将栈顶元素出栈直到栈空</span></span><br><span class="line"><span class="comment">//每次出栈，出栈的栈顶元素要与子树栈的两个栈顶元素构建成子树，并压入子树栈</span></span><br><span class="line">&#123;</span><br><span class="line">right = s2.<span class="built_in">top</span>();</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line">left = s2.<span class="built_in">top</span>();</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">p = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;string&gt;(s1.<span class="built_in">top</span>());</span><br><span class="line">s1.<span class="built_in">pop</span>();</span><br><span class="line">p-&gt;left = left;</span><br><span class="line">p-&gt;right = right;</span><br><span class="line"></span><br><span class="line">s2.<span class="built_in">push</span>(p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子树栈中只会剩下一个根结点，这个根结点就是表达式树的根结点</span></span><br><span class="line">root = s2.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总体思路：</p><ol><li><p>表达式其实是一种递归，表达式是由 左操作数 操作符 右操作数 组成</p><p>而 操作数 是 表达式的值</p><p>所以表达式 是由 左表达式的值 操作符 右表达式的值 组成</p></li><li><p>在计算表达式的时候，要先知道 左操作数 和 右操作数 才能进行计算，也就是要先计算左表达式和右表达式</p></li><li><p>在计算表达式的时候，优先度越高的表达式越先计算，其结果作为优先度低一级的部分的操作数</p><p>因此表达式，是由优先度比自己高的表达式(的结果)组成的</p></li><li><p>所以表达式本质就是二叉树，左子树是左表达式，根结点是操作符，右子树是右表达式</p><p>树的叶子结点是表达式里的操作数</p></li></ol><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211201957372.jpeg" alt="IMG_0788" style="zoom:50%;" /></blockquote><blockquote><p>构建表达式树，就是优先度越高的部分组成的子树层次越深，越靠近叶子</p><p>从左到右顺序读取表达式的元素，将表达式的操作数都建成结点，这个是表达式树的叶子结点</p><p>优先级最高的表达式最先构建成树，并且成为优先级低于自己的表达式的子树</p></blockquote><blockquote><p>s1为操作符栈，用来比较操作符的优先度和存储操作符</p><p>s2为子树栈，存放已经建成的表达式子树</p><p>遍历表达式vector</p><p>如果是操作数，直接进s2栈</p><p>如果是操作符</p><ol><li><p>如果s1栈为空，直接进s1</p></li><li><p>如果s1栈不为空</p><ol><li><p>如果当前操作符为 左括号，直接进栈</p></li><li><p>如果当前操作符是 加减乘除，就与栈顶比较，如果栈顶不为空且不为 左括号，比栈顶优先级低，就让栈顶出栈，</p><blockquote><p>每次出栈，出栈的栈顶元素要与子树栈的两个栈顶元素构建成子树，并压入子树栈</p></blockquote></li><li><p>如果当前操作符为 右括号，在遇到左括号之前，一直将操作符栈顶弹栈(操作符弹栈，按照👆的规矩)，直到遇到左括号，将左括号出栈</p><blockquote><p>每次出栈，出栈的栈顶元素要与子树栈的两个栈顶元素构建成子树，并压入子树栈</p></blockquote></li></ol></li></ol><p>遍历完表达式之后，处理子树栈，将各个子树组成一个表达式树</p><blockquote><p>将操作符栈栈顶出栈直到栈空，每次出栈，出栈的栈顶元素要与子树栈的两个栈顶元素构建成子树，并压入子树栈</p></blockquote><p>子树栈中只会剩下一个根结点，这个根结点就是表达式树的根结点</p></blockquote><h4 id="表达式树的计算："><a href="#表达式树的计算：" class="headerlink" title="表达式树的计算："></a>表达式树的计算：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> binaryTree&lt;elemType&gt;::<span class="built_in">calculateExpressionTree</span>()<span class="comment">//计算表达式树</span></span><br><span class="line"><span class="comment">//表达式数字都是叶子结点，操作符都是分支结点。用后序遍历访问整棵树，遇到数字就进操作数栈，遇到操作符就用操作数栈里的数字计算，结果入栈</span></span><br><span class="line"><span class="comment">//在后序非递归遍历的基础上进行修改即可</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">stack&lt;Node&lt;elemType&gt; *&gt; s1;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line">Node&lt;elemType&gt; *p;</span><br><span class="line"><span class="type">int</span> flag;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; num;<span class="comment">//操作数栈</span></span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">push</span>(root);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">flag = s2.<span class="built_in">top</span>();</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line">p = s1.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">s1.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;data == <span class="string">&quot;+&quot;</span> || p-&gt;data == <span class="string">&quot;-&quot;</span> || p-&gt;data == <span class="string">&quot;*&quot;</span> || p-&gt;data == <span class="string">&quot;/&quot;</span>)<span class="comment">//如果是操作符，执行计算</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n2 = num.<span class="built_in">top</span>();</span><br><span class="line">num.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> n1 = num.<span class="built_in">top</span>();</span><br><span class="line">num.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;data == <span class="string">&quot;+&quot;</span>)</span><br><span class="line">num.<span class="built_in">push</span>(n1 + n2);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;data == <span class="string">&quot;-&quot;</span>)</span><br><span class="line">num.<span class="built_in">push</span>(n1 - n2);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;data == <span class="string">&quot;/&quot;</span>)</span><br><span class="line">num.<span class="built_in">push</span>(n1 / n2);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;data == <span class="string">&quot;*&quot;</span>)</span><br><span class="line">num.<span class="built_in">push</span>(n1 * n2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">num.<span class="built_in">push</span>(<span class="built_in">stringToInt</span>(p-&gt;data));<span class="comment">//如果是操作数，转化为int之后存入操作数栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;right)</span><br><span class="line">&#123;</span><br><span class="line">s1.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;left)</span><br><span class="line">&#123;</span><br><span class="line">s1.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>计算的时候就采用后序遍历</p><blockquote><p> 访问当前结点之前先访问左右孩子，因此树中最先访问的是叶子结点也就是操作数，凡是操作数都入栈保存下来，在访问到操作符的时候就用栈中的操作数进行计算，计算结果作为操作数入栈</p></blockquote></blockquote><h2 id="哈夫曼树-x2F-最优二叉树"><a href="#哈夫曼树-x2F-最优二叉树" class="headerlink" title="哈夫曼树&#x2F;最优二叉树"></a>哈夫曼树&#x2F;最优二叉树</h2><p>路径：一个结点到另一个结点之间的通路就是路径。比如B到H就是一条路径，B到G也是一条路径</p><p>路径的长度：路径上经过的边(“树枝”)的数目。从根结点到第i层结点的路径的长度就是 i-1</p><p>结点的权：给一个结点赋予一个权值。比如给E一个权值20</p><p>结点的带权路径长度：根结点到一个带权结点的路径长度乘这个结点的权值。H的带权路径长度是2*19&#x3D;38</p><p>树的带权路径长度(WPL)：所有叶子结点的带权路径长度之和。这棵树的WPL是2 * 44 + 3 * 19 + 2 * 46 + 2 * 11 &#x3D;  259</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211211629914.png" alt="截屏2022-11-21 16.23.38" style="zoom:50%;" /><p>哈夫曼树&#x2F;最优二叉树：当有n的带权结点，都作为叶子结点构建成一棵二叉树时，如果构建成的二叉树的WPL最小，就称为“最优二叉树”，也称“哈夫曼树”</p><p>哈夫曼编码：在一棵哈夫曼树中，从根结点开始向下走，经过左孩子记为0，经过右孩子记为1，直到某个叶子结点，从根到这个叶子结点得到的0、1序列就是这个叶子结点的哈夫曼编码。比如，假设上面的树是哈夫曼树，H的哈夫曼编码求法：从A开始到H，A-&gt;B:0, B-&gt;E:1, E-&gt;H:1，叶子结点E的哈夫曼编码就是011. </p><h3 id="哈夫曼树类的声明："><a href="#哈夫曼树类的声明：" class="headerlink" title="哈夫曼树类的声明："></a>哈夫曼树类的声明：</h3><p>采用<strong>顺序存储</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模版不支持分离编译！！！</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HFNode</span><span class="comment">//构建哈夫曼树的结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">elemType data;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line"><span class="type">int</span> parents, left, right;<span class="comment">//保存当前结点的父亲和孩子的位置下标</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">HFNode</span>()</span><br><span class="line">&#123;</span><br><span class="line">weight = <span class="number">0</span>;</span><br><span class="line">parents = <span class="number">0</span>;</span><br><span class="line">left = <span class="number">0</span>;</span><br><span class="line">right = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">huffmanTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HFNode&lt;elemType&gt; *HFTree;<span class="comment">//哈夫曼树顺序表，其实这里用vector更方便一点</span></span><br><span class="line"><span class="type">int</span> leafSize;<span class="comment">//保存哈夫曼树叶子结点的个数</span></span><br><span class="line">vector&lt;string&gt; HFCode;<span class="comment">//哈夫曼树编码表，保存每个叶子结点的哈夫曼编码</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">huffmanTree</span>()</span><br><span class="line">&#123;</span><br><span class="line">HFTree = <span class="literal">NULL</span>;</span><br><span class="line">leafSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;HFNode&lt;elemType&gt;&gt; <span class="built_in">getNode</span>();<span class="comment">//获取叶子结点集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildBestBinaryTree</span><span class="params">(vector&lt;HFNode&lt;elemType&gt;&gt; allNode)</span></span>;<span class="comment">//创建最优二叉树/哈夫曼树</span></span><br><span class="line"></span><br><span class="line"><span class="function">HFNode&lt;elemType&gt; *<span class="title">getRoot</span><span class="params">()</span><span class="comment">//返回构建好的哈夫曼树表的地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> HFTree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeHuffmanCode</span><span class="params">()</span></span>;<span class="comment">//创建每个叶子结点的哈夫曼编码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="哈夫曼树类的成员变量介绍"><a href="#哈夫曼树类的成员变量介绍" class="headerlink" title="哈夫曼树类的成员变量介绍"></a>哈夫曼树类的成员变量介绍</h4><p>哈夫曼树结点类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HFNode</span><span class="comment">//构建哈夫曼树的结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">elemType data;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line"><span class="type">int</span> parents, left, right;<span class="comment">//保存当前结点的父亲和孩子的位置下标</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">HFNode</span>()</span><br><span class="line">&#123;</span><br><span class="line">weight = <span class="number">0</span>;</span><br><span class="line">parents = <span class="number">0</span>;</span><br><span class="line">left = <span class="number">0</span>;</span><br><span class="line">right = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>相比普通二叉树的结点，由于用顺序表存储，孩子结点指针域换成了位置下标，并加了父结点位置下标</p><p>增加了结点的权值weight</p></blockquote><p>哈夫曼树类的成员变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">huffmanTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HFNode&lt;elemType&gt; *HFTree;<span class="comment">//哈夫曼树顺序表，其实这里用vector更方便一点</span></span><br><span class="line"><span class="type">int</span> leafSize;<span class="comment">//保存哈夫曼树叶子结点的个数</span></span><br><span class="line">vector&lt;string&gt; HFCode;<span class="comment">//哈夫曼树编码表，保存每个叶子结点的哈夫曼编码</span></span><br></pre></td></tr></table></figure><h3 id="哈夫曼树类的实现："><a href="#哈夫曼树类的实现：" class="headerlink" title="哈夫曼树类的实现："></a>哈夫曼树类的实现：</h3><h4 id="哈夫曼树的构建"><a href="#哈夫曼树的构建" class="headerlink" title="哈夫曼树的构建"></a>哈夫曼树的构建</h4><p>要想构建二叉树首先得有叶子结点，要先获取叶子结点集合</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模版不支持分离编译！！！</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">vector&lt;HFNode&lt;elemType&gt;&gt; huffmanTree&lt;elemType&gt;::<span class="built_in">getNode</span>()<span class="comment">//获取叶子结点集合</span></span><br><span class="line">&#123;</span><br><span class="line">vector&lt;HFNode&lt;elemType&gt;&gt; allNode;<span class="comment">//创建一个容器，存储叶子结点</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Input the data and weight of the HFNode to add it &quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Before you input , input Y to continue ,or others to exit &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">char</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">while</span> (x == <span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">elemType data;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;input the data of the HFNode&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; data;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;input the weight of the HFNode&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; weight;</span><br><span class="line"></span><br><span class="line">HFNode&lt;elemType&gt; n;</span><br><span class="line">n.weight = weight;</span><br><span class="line">n.data = data;</span><br><span class="line"></span><br><span class="line">allNode.<span class="built_in">push_back</span>(n);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Input the data and weight of the HFNode to add it &quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Before you input , input Y to continue ,or others to exit &quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">&#125;</span><br><span class="line">leafSize = allNode.<span class="built_in">size</span>();<span class="comment">//当前存储的结点就是是之后建成的哈夫曼树的叶子结点</span></span><br><span class="line"><span class="keyword">return</span> allNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用叶子结点集合构建哈夫曼树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> huffmanTree&lt;elemType&gt;::<span class="built_in">buildBestBinaryTree</span>(vector&lt;HFNode&lt;elemType&gt;&gt; allNode)<span class="comment">//建立最优二叉树/哈夫曼树</span></span><br><span class="line">&#123;</span><br><span class="line">HFTree = <span class="keyword">new</span> HFNode&lt;elemType&gt;[<span class="number">2</span> * allNode.<span class="built_in">size</span>()];<span class="comment">//构建哈夫曼树顺序表</span></span><br><span class="line"><span class="comment">//按照最优二叉树的要求，初始带权值的结点都是叶子结点，也就是allNode里存储的都是叶子节点</span></span><br><span class="line"><span class="comment">//并且根据最优二叉树的特点，会发现分支结点全部都是度为2的结点</span></span><br><span class="line"><span class="comment">//根据二叉树的性质，叶子结点个数为n个，则度为2的结点个数为n-1</span></span><br><span class="line"><span class="comment">//根据最优二叉树的构造方法，分支结点都是度为2的，因此最优二叉树中结点个数总是为2*n-1</span></span><br><span class="line"><span class="comment">//我们开辟2*n个空间，空出第一个位置，如果表中的结点无父亲或孩子，那么就让对应的位置下标为0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; allNode.<span class="built_in">size</span>(); i++)<span class="comment">//叶子结点转移到哈夫曼树顺序表，并空出哈夫曼树表的第一个位置</span></span><br><span class="line">&#123;</span><br><span class="line">HFTree[i + <span class="number">1</span>] = allNode[i];</span><br><span class="line">HFTree[i + <span class="number">1</span>].parents = <span class="number">0</span>;</span><br><span class="line">HFTree[i + <span class="number">1</span>].left = <span class="number">0</span>;</span><br><span class="line">HFTree[i + <span class="number">1</span>].right = <span class="number">0</span>;<span class="comment">//一开始所有的结点都没有父亲和孩子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = allNode.<span class="built_in">size</span>();<span class="comment">//用i来表示当前没有父结点的结点的个数</span></span><br><span class="line"><span class="type">int</span> n = allNode.<span class="built_in">size</span>();<span class="comment">//用n来表示当前哈夫曼树表中结点的个数，同时也算是最后面的元素的权重</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i != <span class="number">1</span>)<span class="comment">//一开始所有结点都没有父结点，当哈夫曼树建立完成之后，只有根结点是没有父亲的，由此来判定哈夫曼树是否建成</span></span><br><span class="line"><span class="comment">//由于每次循环创建一个新结点，原来权重最小的两个结点有了父结点，i-2，但是新结点是没有父结点的，所以每次循环总体上为i-1</span></span><br><span class="line"><span class="comment">//(当然，也可以用n来判定循环，n&lt;2*allNode.size()，画图理解即可）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> first_min, second_min;<span class="comment">//定义没有父结点的结点中权重最小的两个结点的下标</span></span><br><span class="line"><span class="type">double</span> first_min_weight = <span class="number">9999</span>;<span class="comment">//将两个权重初始化为一个大到不可能的权重</span></span><br><span class="line"><span class="type">double</span> second_min_weight = <span class="number">9999</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++)<span class="comment">//寻找权重第一小的无父结点的结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (HFTree[x].parents == <span class="number">0</span> &amp;&amp; HFTree[x].weight &lt; first_min_weight)</span><br><span class="line">&#123;</span><br><span class="line">first_min = x;</span><br><span class="line">first_min_weight = HFTree[x].weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++)<span class="comment">//寻找权重第二小的无父结点的结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x != first_min &amp;&amp; HFTree[x].parents == <span class="number">0</span> &amp;&amp; HFTree[x].weight &lt; second_min_weight)</span><br><span class="line">&#123;</span><br><span class="line">second_min = x;</span><br><span class="line">second_min_weight = HFTree[x].weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> weight_added = first_min_weight + second_min_weight;</span><br><span class="line"></span><br><span class="line">n++;</span><br><span class="line"></span><br><span class="line">HFTree[first_min].parents = n;<span class="comment">//原来的权重最小结点变成了新结点的孩子</span></span><br><span class="line">HFTree[second_min].parents = n;</span><br><span class="line"></span><br><span class="line">HFTree[n].left = first_min;</span><br><span class="line">HFTree[n].right = second_min;</span><br><span class="line">HFTree[n].weight = weight_added;</span><br><span class="line">i--;<span class="comment">//由于创建了一个新结点，原来权重最小的两个结点有了父结点，i-2，但是新结点是没有父结点的，所以总体上为i-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下辅助调试代码，便于判断是否正确建立了一棵哈夫曼树</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;index: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;data: &quot;</span> &lt;&lt; HFTree[x].data &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;weight: &quot;</span> &lt;&lt; HFTree[x].weight &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;parents: &quot;</span> &lt;&lt; HFTree[x].parents &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;left: &quot;</span> &lt;&lt; HFTree[x].left &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;right: &quot;</span> &lt;&lt; HFTree[x].right &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---------&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>哈夫曼算法：</p><p>每次找哈夫曼顺序表里权重最小的两个结点，创建一个新结点，新结点是权重是两个最小结点的和，最小结点是新结点的左孩子，次小结点是新结点的右孩子，新结点存入哈夫曼顺序表。这样构建出来的树就是哈夫曼树。</p><blockquote><p>创建一个哈夫曼树顺序表用来存储哈夫曼树。</p><p>之前获得的叶子结点集合作为哈夫曼树的叶子结点。根据二叉树的性质，如果叶子结点的数目是n，则度为2的结点数目是n-1，而通过哈夫曼算法建立的哈夫曼树，所有的分支结点的度都是2，故哈夫曼树的结点总数是2n-1。</p><p>我们创建一个大小为2n的哈夫曼树顺序表，空出第一个位置，如果表中的结点无父亲或孩子，那么就让对应的下标为0</p><p>先将所有叶子结点添加到哈夫曼树表</p><blockquote><p>刚开始所有的叶子结点都没有父亲、孩子，故父亲、孩子下标都为0</p></blockquote><p>一开始所有结点都没有父结点，当哈夫曼树建立完成之后，只有根结点是没有父亲的，由此来判定哈夫曼树是否建成</p><blockquote><p>由于每次循环创建一个新结点，原来权重最小的两个结点有了父结点，没有父结点的结点总数-2，但是新结点是没有父结点的，所以每次循环总体上为无父结点的结点总数-1</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/B35974B77F32A658ED5B854157436CA7.png" alt="img" style="zoom: 25%;" /></blockquote></blockquote><h4 id="创建哈夫曼编码"><a href="#创建哈夫曼编码" class="headerlink" title="创建哈夫曼编码"></a>创建哈夫曼编码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> huffmanTree&lt;elemType&gt;::<span class="built_in">makeHuffmanCode</span>()<span class="comment">//创建每个叶子结点的哈夫曼编码</span></span><br><span class="line"><span class="comment">//因为哈夫曼树顺序表里面前面的都是叶子结点(前半部分结点都是叶子结点，即(哈夫曼树顺序表结点个数+1)/2个）</span></span><br><span class="line"><span class="comment">//但是并没有写求哈夫曼树顺序表结点个数的函数，不过有记录叶子结点个数的变量leafSize</span></span><br><span class="line">&#123;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; s;<span class="comment">//每次用来存储单个叶子结点的编码</span></span><br><span class="line"></span><br><span class="line">HFCode.<span class="built_in">push_back</span>(<span class="string">&quot; &quot;</span>);<span class="comment">//因为哈夫曼树表第一个元素没有存结点，这里保持和哈夫曼树表同步</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= leafSize; i++)<span class="comment">//因为一共leafSize个结点，且是从权重1开始遍历，所以要遍历到第leafSize个，应该取到leafSize</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (HFTree[j].parents != <span class="number">0</span>)<span class="comment">//不断向上寻找当前结点的父亲，并且判断当前结点是其父亲的左孩子还是右孩子，左为&#x27;0&#x27;，右为&#x27;1&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (HFTree[HFTree[j].parents].left == j)</span><br><span class="line">s.<span class="built_in">push</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">s.<span class="built_in">push</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">j = HFTree[j].parents;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">HFCode[i].<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行辅助调试</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= leafSize; i++)<span class="comment">////因为一共leafSize个结点，且是从权重1开始遍历，所以要遍历到第leafSize个，应该取到leafSize</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;data is: &quot;</span> &lt;&lt; HFTree[i].data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;code is: &quot;</span> &lt;&lt; HFCode[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于每一个叶子结点进行哈夫曼编码的时候，用字符栈保存自己的哈夫曼编码</p><p>不断向上寻找当前结点的父亲，并且判断当前结点是其父亲的左孩子还是右孩子，左为’0’，右为’1’</p><p>所有叶子结点的哈夫曼编码保存到HFCode中</p></blockquote><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>That’s all, thanks for reading!💐</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_KMP算法</title>
      <link href="/chunyujin/c4fcfcf8.html"/>
      <url>/chunyujin/c4fcfcf8.html</url>
      
        <content type="html"><![CDATA[<h3 id="数据结构-KMP算法"><a href="#数据结构-KMP算法" class="headerlink" title="数据结构_KMP算法"></a>数据结构_KMP算法</h3><blockquote><p>前言：此类笔记仅用于个人复习，内容主要在于记录和体现个人理解</p></blockquote><p>[toc]</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><blockquote><p>有两条字符串，一条长，一条短，现在要求检查长的字符串，看看里面是不是包含短的字符串，如果包含，就返回短串的首元素在长串中的位置。如果没有的话，就返回-1。长串称为“主串”，短串称为“模式串”，简称“模式”。（不知道为啥这么叫，感觉有点抽象</p></blockquote><blockquote><p><strong>为了解决这个问题，就诞生出了一种算法：BF算法（暴力算法）</strong></p><p>指针i指向主串，j指向模式串</p><p>从主串的第一个元素、模式的第一个元素开始遍历，比较，如果相等，i、j后移，看后面的元素是否也都一样。如果在一个地方遇到了i、j指向的元素不同的情况，就称为“失配”，说明从主串第一个元素、模式第一个元素开始的话两个字符串没办法匹配</p><p>那么就让i起始位置变成主串的第二个元素，j起始位置指回模式的第一个元素（称为“回溯”），进行第二次遍历，看能否匹配上模式串。</p><p>直到，找到能完全匹配的情况下i的起始位置，或者，i的起始位置的剩余长度小于模式的长度（此时肯定没法匹配了，因为长度都不够了）</p><blockquote><p>例如下面👇</p>   <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303090741370.jpeg" alt="IMG_0625" style="zoom: 50%;" /><p>在此处，失配了，所以要进行回溯，i的初始位置变成第二个元素位置，j的初始位置变成第一个元素位置，再进行匹配</p>   <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303090741949.jpeg" alt="IMG_0628" style="zoom:50%;" /><p>此处为了方便观看，将模式和主串的起始位置进行一下对齐👇</p>   <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303090741348.jpeg" alt="IMG_0629" style="zoom:50%;" /><p>很明显，不匹配，主串的起始位置后移，模式的起始位置回溯到首元素</p>   <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303090741699.jpeg" alt="IMG_0630" style="zoom:50%;" /><p>一直到匹配或者主串的剩余元素少于模式</p>   <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303090742930.jpeg" alt="IMG_0631" style="zoom: 36%;" /><p>匹配成功</p></blockquote><p>但是这算法，每次，都需要主串指针i回到起始位置的后一个位置作为新的起始位置，并且模式指针j回到首元素，效率很低</p><p>如果定主串长度为M，模式为N，则时间复杂度为O(M*N)</p><p><strong>为了优化这种算法，曾经就有三位大佬创造出了一种效率极高的，时间复杂度为O(M+N)的算法：KMP算法</strong></p></blockquote><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><blockquote><p>并不一定在一开始模式就和主串不匹配，可能直到出现失配之前，模式从开头到模式的失配点这一段跟主串起始位置到自己失配点是匹配的，并且在匹配的这一小段中模式中后半段可能会有一段跟模式自己开头的一段是相同的，比如模式abcabcd中的abcd中的abc跟模式开头的abc是一样的，而因为匹配的这一小段，主串跟模式是一样的，所以说匹配的这一段中的主串的后面的一段和模式开头的一段也是相同的。</p><blockquote><p>“后面的一段跟前面一段相同”有个专业的说法，先听下面的引入：</p><p>“前缀”就是从字符串的 开头 开始，从前往后构成的子串，比如abcabc中，a、ab、abc、abca、abcab、abcabc</p><p>“后缀”就是从字符串的 结尾 开始，从前往后构成的子串，比如abcabc中，c、bc、abc、cabc、bcabc、abcabc</p><p>我们会发现，<strong>除了当整个字符串作为自己的前缀或者后缀之外</strong>（当然，单个元素的字符串就是整个字符串是自己的前缀和后缀），会有前缀跟后缀相等的情况，比如前缀abc和后缀abc，其中这种情况下最长的前缀就叫“最长前缀”，后缀就叫”最长后缀“，（所以单个元素的字符串没有所谓“最长前&#x2F;后缀”）</p><p>”后面这一段跟前面这一段相等”的情况下，后面这一段就是“最长后缀”，前面这一段就是“最长前缀”</p></blockquote><p>这样的话，只需要找到模式的失配点之前这一段里，“最长前缀”的位置就可以</p><p>因为在匹配上的这一段中，模式中的“最长前缀”跟主串中的“最长后缀”是相等的，所以这里就不用再判断前面是不是相等了，一定是相等的</p><p>从模式中的”最长前缀“的下一个元素开始跟主串中的”最长后缀“的下一个元素（也就是主串的失配点）开始进行比较就行，而不用回溯（还是因为不用判断，前面一定是相等的）</p><blockquote><p>比如用上面的例子，在第一次检查的时候遇到了失配</p>   <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303090742005.jpeg" alt="IMG_0632" style="zoom:50%;" /><p>在失配之前都是匹配的，模式和主串在失配点之前的段其中有最长前缀和最长后缀是</p>   <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303090742980.jpeg" alt="IMG_0634" style="zoom:50%;" /><p>将模式的i的起始位置定为它的最长前缀的后一个元素，主串的起始位置就是失配点</p>   <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303090742957.jpeg" alt="IMG_0637" style="zoom:55%;" /><p>会发现模式中j起始位置之前的段就是之前的最长前缀，跟主串之前的最长后缀正好匹配，就不用从头开始检查了</p><p>所以模式的原最长前缀的后一个元素作为j的起始位置是合理且简单的</p></blockquote></blockquote><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><blockquote><p>面临一个问题</p><blockquote><p>一旦失配，模式的j的起始位置就要变成失配点之前的段的最长前缀的后一个元素，但是在检查之前，我们并不知道模式会在什么位置失配，所以应该找到每个元素作为失配点的时候，j的起始位置应该在哪儿</p></blockquote></blockquote><blockquote><p>所以要解决这个问题，就要先</p><p><strong>找到模式中每个元素作为失配点的时候j的起始位置</strong></p><p>如果失配点是模式的第一个元素，则没法回退（或者说不用回退），起始位置还是开头，但是主串的i需要向后后移</p><p>如果失配点是模式的第二个元素，它前面只有一个元素，没有“最长前缀”，只能向前回退，将第一个元素作为起始位置</p><p>剩下的第三到第N个元素的作为失配点的时候，起始位置就要找出来了</p><p>那就用指针x从第三个元素开始遍历模式</p><p>我们发现<strong>j的权重，正好等于j前面的字符串的长度</strong>，比如j&#x3D;5，j之前的字符是从0～4，一共5个</p><p>那么j之前的字符串的前缀的长度k最长只能是5-1&#x3D;4（因为最长前缀不能是字符串自己），也就是k&#x3D;j-1</p><p>所以<strong>最长前缀的长度k取值范围是1～j-1</strong>，<strong>k也是最长后缀的长度</strong></p><p>如果字符串长度j&#x3D;5，k&#x3D;4，那么<strong>j-k</strong>&#x3D;1，这是<strong>正好是最长后缀的开头的权重</strong>，而最长前缀的开头永远都是字符串首元素，也就是权重是0</p><p>这就好办了，我们只要从最长前&#x2F;后缀的长度开始下手就行，假设最长前缀长度k&#x3D;j-1，检验前缀和后缀是否匹配，也就是前缀指针p从0开始，后缀指针q从j-k开始，往后比较。而因为p、q同步移动，且p从0开始，所以q其实等于j-k+p，我们比较p和j-k+q就可以</p><p>如果不匹配，就说明假设的这个最长前缀长度k比实际的最长前缀长度大了，我们只需要减小k就可以了</p><p>最后得出的k就是实际的最长前缀长度，而，k正好是最长前缀的后一个元素（比如k&#x3D;3，则0～2是最长前缀，3上就是最长前缀的后一个元素）</p><blockquote><p>可以自己画图理解</p></blockquote><p>这样就找到了模式中每个元素作为失配点的时候j的起始位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">nextValue</span><span class="params">(<span class="type">const</span> string &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *next, q, j, k; <span class="comment">//定义了一个next数组用来存放每个元素作为失配点的时候j的起始位置权重</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t.<span class="built_in">length</span>() == <span class="number">0</span>) <span class="comment">//如果字符串是空的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    next = <span class="keyword">new</span> <span class="type">int</span>[t.<span class="built_in">length</span>()];</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">//当第一个元素作为失配点的时候，不用退回，返回-1来告知</span></span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">//当第二个元素为失配点的时候，j退回到首元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; t.<span class="built_in">length</span>(); j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (k = j - <span class="number">1</span>; k &gt; <span class="number">0</span>; k--) <span class="comment">//从假设最长后缀长度为j-1开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (q = <span class="number">0</span>; q &lt; k; q++) <span class="comment">//最长前缀q从开头开始，到假定的长度位置结束，与最长后缀进行匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.<span class="built_in">at</span>(q) != t.<span class="built_in">at</span>(j - k + q)) <span class="comment">//如果匹配失败，就结束匹配</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (q == k) <span class="comment">//说明此时最长前缀已经匹配完，q已经指向了最长前缀的下一给元素</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next[j] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMP</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">const</span> string &amp;t, <span class="type">int</span> start)</span> <span class="comment">//主串是s，模式是t，不一定从s的开头开始检查是否包含t，可能从s的start位置开始检查</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *next;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> curStart; <span class="comment">//模式的首元素在主串中的位置</span></span><br><span class="line">    <span class="type">int</span> i = start, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    next = <span class="built_in">nextValue</span>(t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= (s.<span class="built_in">length</span>() - t.<span class="built_in">length</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        curStart = i - j; <span class="comment">//因为i、j是起始位置，但不两个串首元素位置，而模式中j到首元素之间的这些元素与主串中是匹配的，所以主串中从i往前j个元素就是模式首元素在主串中的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt; t.<span class="built_in">length</span>() &amp;&amp; (s.<span class="built_in">at</span>(i) == t.<span class="built_in">at</span>(j))) <span class="comment">//先检查匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == t.<span class="built_in">length</span>()) <span class="comment">//模式遍历完了，说明完全匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            pos = curStart;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//出现失配</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (next[j] == <span class="number">-1</span>) <span class="comment">//如果首元素就失配，只能让i后移</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//说明失配点之前的段是匹配的，j去往相应初始位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303090742965.jpeg" alt="IMG_0638" style="zoom:50%;" /></blockquote><h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>That’s all, thanks for reading!💐</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_队列（C++</title>
      <link href="/chunyujin/9536edd6.html"/>
      <url>/chunyujin/9536edd6.html</url>
      
        <content type="html"><![CDATA[<h3 id="数据结构-队列（C-实现"><a href="#数据结构-队列（C-实现" class="headerlink" title="数据结构_队列（C++实现"></a>数据结构_队列（C++实现</h3><blockquote><p>前言：此类笔记仅用于个人复习，内容主要在于记录和体现个人理解，详细还请结合bite课件、录播、板书和代码。</p></blockquote><p>[toc]</p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>没什么好说的</p><p>也就是</p><ol><li><p>队列一般用链表实现比较常用,下面实现的也是链式栈</p></li><li><p>&#x3D;&#x3D;注意下面类的提前声明和友元类的作用&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;<strong>assert果然还是太暴力了</strong>，能不用就不用吧，但是一定要记住要判断 指针 为空的情况&#x3D;&#x3D;</p><ol><li>&#x3D;&#x3D;可以抛出异常信号  (建议用这个，因为运行错误的时候知道原因&#x3D;&#x3D;</li><li>&#x3D;&#x3D;可以直接返回&#x3D;&#x3D;</li><li>判断指针head为空的方式</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head) <span class="comment">// if(!head)等价于if(head==NULL),head==NULL是head为空时等式成立，值为真</span></span><br><span class="line">  <span class="comment">// head为空的话head就相当于0（假），非空就是真，所以当head为空的时候，!head就是真</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();<span class="comment">//这里使用了抛出异常信号的方式,而且抛出的是一个匿名对象(因为要的是它的类型，没必要给对象命名了)</span></span><br><span class="line">         </span><br><span class="line"><span class="comment">//如果采用直接返回的方式</span></span><br><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">    <span class="keyword">return</span>;<span class="comment">//直接返回的话，在有返回类型的函数里面可能会报错</span></span><br><span class="line">         </span><br><span class="line"><span class="comment">//以上两者都可以终止函数，不过直接return只能用在无返回值函数上，return本质是终止函数运行并返回NULL</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><blockquote><p><strong>queue.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">nullPointer</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;<span class="comment">//用作异常信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>;<span class="comment">//类的向前声明，因为下面的Node中要用到Queue类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Queue</span>&lt;elemType&gt;;<span class="comment">//将Queue看作Node的友元类，这样Queue中（Node类外)可以访问Node的私有成员，后面Queue的函数用到了Node的私有成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">elemType data;</span><br><span class="line">Node *next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Node</span>() &#123; next = <span class="literal">NULL</span>; &#125;;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">const</span> elemType &amp;x, Node *p = <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  data = x;</span><br><span class="line">  next = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;这里一定要注意为什么提前声明queue以及为什么Node类将queue类看作友元类&#x3D;&#x3D;</p><p>&#x3D;&#x3D;还要注意&#x3D;&#x3D;</p><p>&#x3D;&#x3D;类的向前声明的时候类后面不加模板参数，但是前面一定要有参数模板的声明；&#x3D;&#x3D;</p><p>&#x3D;&#x3D;友元类后面一定要有模板参数&#x3D;&#x3D;</p><p>&#x3D;&#x3D;就按上面的写法&#x3D;&#x3D;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node&lt;elemType&gt; *head, *tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Queue</span>() &#123; head = tail = <span class="literal">NULL</span>; &#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> !head; &#125;;<span class="comment">//队列为空（头结点为空）返回真</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;; <span class="comment">//这个函数没有意义，因为队列是单链表，没有满容可言</span></span><br><span class="line"><span class="function">elemType <span class="title">getHead</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushQueue</span><span class="params">(<span class="type">const</span> elemType &amp;x)</span></span>; <span class="comment">//入队，尾插</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">popQueue</span><span class="params">()</span></span>;                   <span class="comment">//出队，头删</span></span><br><span class="line">~<span class="built_in">Queue</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>queue.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">elemType Queue&lt;elemType&gt;::<span class="built_in">getHead</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="comment">// if(!head)等价于if(head==NULL),head==NULL是head为空时等式成立，值为真</span></span><br><span class="line">  <span class="comment">// head为空的话head就相当于0（假），非空就是真，所以当head为空的时候，!head就是真</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"><span class="keyword">return</span> head-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if(!head)等价于if(head&#x3D;&#x3D;NULL)</p><p>head&#x3D;&#x3D;NULL是head为空时等式成立，值为真</p><p>head为空的话head就相当于0（假），非空就是真，所以当head为空的时候，!head就是真</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> Queue&lt;elemType&gt;::<span class="built_in">pushQueue</span>(<span class="type">const</span> elemType &amp;x) <span class="comment">//入队，尾插</span></span><br><span class="line">&#123;</span><br><span class="line">Node&lt;elemType&gt; *New = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;elemType&gt;(x);</span><br><span class="line"><span class="keyword">if</span> (!head)</span><br><span class="line">&#123;</span><br><span class="line">  head = tail = New;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  tail-&gt;next = New;</span><br><span class="line">  tail = tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> Queue&lt;elemType&gt;::<span class="built_in">popQueue</span>() <span class="comment">//出队，头删</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//用return和throw queueIsNull()都可以终止函数，不过直接return只能用在无返回值函数上</span></span><br><span class="line"><span class="comment">//return本质是终止函数运行并返回NULL</span></span><br><span class="line">Node&lt;elemType&gt; *p = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">  tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用return和throw queueIsNull()都可以终止函数，不过直接return只能用在无返回值函数上</p><p>return本质是终止函数运行并返回NULL</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">Queue&lt;elemType&gt;::~<span class="built_in">Queue</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!head)</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line">Node&lt;elemType&gt; *p = head;</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">  head = head-&gt;next;</span><br><span class="line">  <span class="built_in">delete</span> (p);</span><br><span class="line">&#125;</span><br><span class="line">tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p><strong>有些函数直接作为了上面实现的队列的成员函数，用的时候别忘了在queue.h中声明</strong></p><ol><li></li></ol><p>用两个队列实现栈</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt; <span class="comment">//先写一个求队列元素个数的函数，后面会用</span></span><br><span class="line"><span class="type">int</span> Queue&lt;elemType&gt;::<span class="built_in">size</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;elemType&gt; *p = head;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        x++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Queue&lt;elemType&gt; a, b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> elemType &amp;x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!a.<span class="built_in">isEmpty</span>())</span><br><span class="line">            a.<span class="built_in">pushQueue</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.<span class="built_in">pushQueue</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// assert(!a.isEmpty() &amp;&amp; !b.isEmpty());</span></span><br><span class="line">        Queue&lt;elemType&gt; *qEmpty = a.<span class="built_in">isEmpty</span>() ? &amp;a : &amp;b;</span><br><span class="line">        Queue&lt;elemType&gt; *qUnEmpty = a.<span class="built_in">isEmpty</span>() ? &amp;b : &amp;a;</span><br><span class="line">        <span class="keyword">while</span> (qUnEmpty-&gt;<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qEmpty-&gt;<span class="built_in">pushQueue</span>(qUnEmpty-&gt;<span class="built_in">getHead</span>());</span><br><span class="line">            qUnEmpty-&gt;<span class="built_in">popQueue</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        qUnEmpty-&gt;<span class="built_in">popQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">elemType <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// assert(a.isEmpty() &amp;&amp; !b.isEmpty());</span></span><br><span class="line">        Queue&lt;elemType&gt; *qEmpty = a.<span class="built_in">isEmpty</span>() ? &amp;a : &amp;b;</span><br><span class="line">        Queue&lt;elemType&gt; *qUnEmpty = a.<span class="built_in">isEmpty</span>() ? &amp;b : &amp;a;</span><br><span class="line">        <span class="keyword">while</span> (qUnEmpty-&gt;<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qEmpty-&gt;<span class="built_in">pushQueue</span>(qUnEmpty-&gt;<span class="built_in">getHead</span>());</span><br><span class="line">            qUnEmpty-&gt;<span class="built_in">popQueue</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x = qUnEmpty-&gt;<span class="built_in">getHead</span>();</span><br><span class="line">        qEmpty-&gt;<span class="built_in">pushQueue</span>(qUnEmpty-&gt;<span class="built_in">getHead</span>());</span><br><span class="line">        qUnEmpty-&gt;<span class="built_in">popQueue</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两个队列，一个总是空的，一个总是不空的</p><p>入栈就进非空队列，出栈把非空队列的前n个出到空队列，pop非空队列最后一个元素</p><p>非空队列就变成了空队列，空队列就变成了非队列</p></blockquote><ol start="2"><li></li></ol><p>现有一个整数队列， 需要将其前 k 个元素进行逆置， 剩余的元素保持原来的顺序。<br>例如队列[1， 2， 3， 4， 5， 6， 7， 8， 9]， 若 k 为 4， 则需要将队列调整为[4， 3， 2， 1， 5，6， 7， 8， 9]  </p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;seqStack.cpp&quot;</span><span class="comment">//要用到seqStack</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> Queue&lt;elemType&gt;::<span class="built_in">Reverse_k</span>(<span class="type">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line"> Queue&lt;elemType&gt; q;</span><br><span class="line"> seqStack&lt;elemType&gt; s;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>(i&lt;k)<span class="comment">//前k个元素放到栈中</span></span><br><span class="line"> &#123;</span><br><span class="line">     s.<span class="built_in">push</span>(<span class="built_in">getHead</span>());</span><br><span class="line">     <span class="built_in">popQueue</span>();</span><br><span class="line">     i++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span>(head)<span class="comment">//后n-k个元素放到临时队列中</span></span><br><span class="line"> &#123;</span><br><span class="line">     q.<span class="built_in">pushQueue</span>(<span class="built_in">getHead</span>());</span><br><span class="line">     <span class="built_in">popQueue</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span>(!s.<span class="built_in">isEmpty</span>())<span class="comment">//栈中的元素放到主队列</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">pushQueue</span>(s.<span class="built_in">top</span>());</span><br><span class="line">     s.<span class="built_in">pop</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span>(q.head!=<span class="literal">NULL</span>)<span class="comment">//临时队列的元素放到主队列中</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">pushQueue</span>(q.<span class="built_in">getHead</span>());</span><br><span class="line">     q.<span class="built_in">popQueue</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：前k个元素放到临时栈，后n-k个元素放到临时队列，再从临时栈中入到主栈，临时队列入到主栈</p></blockquote><ol start="3"><li></li></ol><p>现在有一批同学需要接收面试， 参加面试的同学按照先到先面试的原则接受面试官的考查。 本次面试中面试官最看重的是同学的成绩， 现在面试官小明需要你设计程序实现以下功能：<br>（1） 某位同学加入面试队伍， 输入其名字和成绩；<br>（2） 队伍最前端的同学的面试结束， 离开场地；<br>（3） 小明想知道当前面试队伍里最好成绩是多少。</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">interview_team</span>; <span class="comment">//类的向前声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">interview_team</span>&lt;elemType&gt;; <span class="comment">//看作Node的友元类,友元类可以访问Node的私有成员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> point;</span><br><span class="line">    iNode&lt;elemType&gt; *next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">iNode</span>(string name = <span class="string">&quot;null&quot;</span>, <span class="type">int</span> point = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;point = point;</span><br><span class="line">        next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">interview_team</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    iNode&lt;elemType&gt; *head, *tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">interview_team</span>() &#123; head = tail = <span class="literal">NULL</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">i_push</span><span class="params">(string name, <span class="type">int</span> point)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head = tail = <span class="keyword">new</span> <span class="built_in">iNode</span>&lt;elemType&gt;(name, point);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next = <span class="keyword">new</span> <span class="built_in">iNode</span>&lt;elemType&gt;(name, point);</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">i_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        iNode&lt;elemType&gt; *p = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">delete</span> (p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">            tail == <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">i_best</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        iNode&lt;elemType&gt; *p = head;</span><br><span class="line">        <span class="type">int</span> best = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;point &gt; best)</span><br><span class="line">                best = p-&gt;point;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> best;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路：其实就是实现STL的队列中的部分功能</p></blockquote><h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>That’s all, thanks for reading!💐</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_单链表（C++</title>
      <link href="/chunyujin/4255e88b.html"/>
      <url>/chunyujin/4255e88b.html</url>
      
        <content type="html"><![CDATA[<h3 id="数据结构-SinglyLinkedList单链表（C-实现"><a href="#数据结构-SinglyLinkedList单链表（C-实现" class="headerlink" title="数据结构_SinglyLinkedList单链表（C++实现"></a>数据结构_SinglyLinkedList单链表（C++实现</h3><blockquote><p>前言：此类笔记仅用于个人复习，内容主要在于记录和体现个人理解，详细还请结合bite课件、录播、板书和代码。</p></blockquote><p>[toc]</p><h4 id="前言-amp-注意事项"><a href="#前言-amp-注意事项" class="headerlink" title="前言&amp;注意事项"></a>前言&amp;注意事项</h4><blockquote><ol><li><p>单链表C++的实现分为了结点类和链表类两个类，十分明了，可读性很高，也很容易写，节点类负责单个节点的操作，链表负责链表整体的操作</p></li><li><p>&#x3D;&#x3D;<strong>assert果然还是太暴力了</strong>，能不用就不用吧，但是一定要记住要判断 表指针 为空的情况&#x3D;&#x3D;</p><ol><li>&#x3D;&#x3D;可以抛出异常信号  (建议用这个，因为运行错误的时候知道原因&#x3D;&#x3D;</li><li>&#x3D;&#x3D;可以直接返回&#x3D;&#x3D;</li><li>判断指针head为空的方式</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head) <span class="comment">// if(!head)等价于if(head==NULL),head==NULL是head为空时等式成立，值为真</span></span><br><span class="line">  <span class="comment">// head为空的话head就相当于0（假），非空就是真，所以当head为空的时候，!head就是真</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();<span class="comment">//这里使用了抛出异常信号的方式,而且抛出的是一个匿名对象(因为要的是它的类型，没必要给对象命名了)</span></span><br><span class="line">               </span><br><span class="line"><span class="comment">//如果采用直接返回的方式</span></span><br><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">    <span class="keyword">return</span>;<span class="comment">//直接返回的话，在有返回类型的函数里面可能会报错</span></span><br><span class="line">               </span><br><span class="line"><span class="comment">//以上两者都可以终止函数，不过直接return只能用在无返回值函数上，return本质是终止函数运行并返回NULL</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><blockquote><p> <strong>SList.h</strong></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">nullPointer</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;<span class="comment">//用作异常信号的类，遇到空指针时抛出，用于判断是否成功扩容以及头指针是否为空</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">outofBound</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;; <span class="comment">//用作异常信号的类，用于判断是否越界</span></span><br></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sList</span>; <span class="comment">//类的向前说明，因为下面的node类将sList看作友元类，在此提前声明一下sList类的存在</span></span><br><span class="line"><span class="comment">//前面要声明参数模板，类后面不用跟参数模板</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">node</span> <span class="comment">//节点类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">sList</span>&lt;elemType&gt;;<span class="comment">//之后的sList中要用到node的私有成员data和next，只有将sList看作了友元类才行在sList中（属于node类外）访问node的私有成员</span></span><br><span class="line"><span class="comment">//友元类后面一定要跟参数模板</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">elemType data;</span><br><span class="line">node *next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">node</span>() : <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;<span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">node</span>(<span class="type">const</span> elemType &amp;e, node *N = <span class="literal">NULL</span>) <span class="comment">//含缺省参数的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">data = e;</span><br><span class="line">next = N;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> &#x3D;&#x3D;这里一定要注意为什么提前声明sList以及为什么node类将sList类看作友元类&#x3D;&#x3D;</p><p> &#x3D;&#x3D;还要注意&#x3D;&#x3D;</p><p> &#x3D;&#x3D;类的向前声明的时候类后面不加模板参数，但是前面一定要有参数模板的声明；&#x3D;&#x3D;</p><p> &#x3D;&#x3D;友元类后面一定要有模板参数&#x3D;&#x3D;</p><p> &#x3D;&#x3D;就按上面的写法&#x3D;&#x3D;</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sList</span> <span class="comment">//单链表类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">node&lt;elemType&gt; *head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">sList</span>(); <span class="comment">//构造函数，建立一个空链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sListempty</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//判空，空则返回真，否则返回假</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bool sListFull()const;//判满（额，我倒是想知道怎么判断是满的，没什么用这个</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sListLength</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//返回链表长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sListPushBack</span><span class="params">(elemType &amp;e)</span></span>; <span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sListPushHead</span><span class="params">(elemType &amp;e)</span></span>; <span class="comment">//头插</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sListPopBack</span><span class="params">()</span></span>; <span class="comment">//尾删</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sListPopHead</span><span class="params">()</span></span>; <span class="comment">//头删</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sListInsert</span><span class="params">(<span class="type">int</span> pos, elemType &amp;e)</span></span>; <span class="comment">//在pos位置插入e（在pos结点的前面插入e</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sListErase</span><span class="params">(<span class="type">int</span> pos)</span></span>; <span class="comment">//删除pos结点</span></span><br><span class="line"></span><br><span class="line"><span class="function">elemType <span class="title">sListGet</span><span class="params">(<span class="type">int</span> pos)</span></span>; <span class="comment">//返回pos处的节点的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sListFind</span><span class="params">(elemType &amp;e)</span></span>; <span class="comment">//返回值等于e的结点的序号，没有匹配的则返回0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sListRemove</span><span class="params">(<span class="type">int</span> pos, elemType &amp;e)</span></span>; <span class="comment">//移除pos处的数据并赋值给e</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sListReverse</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//单链表元素就地逆置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sListClear</span><span class="params">()</span></span>; <span class="comment">//清空单链表，保留head结点，释放其余空间</span></span><br><span class="line"></span><br><span class="line">~<span class="built_in">sList</span>(); <span class="comment">//析构函数,销毁单链表，释放所有空间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <strong>SList.cpp</strong></p><p> 包含头文件以及构造函数的定义</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sList.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">sList&lt;elemType&gt;::<span class="built_in">sList</span>() <span class="comment">//构造函数，建立一个空链表</span></span><br><span class="line">&#123;</span><br><span class="line">head = <span class="keyword">new</span> <span class="built_in">node</span>&lt;elemType&gt;(); <span class="comment">//开辟一个结点对象空间（这里new的对象最后面这里加了括号，加不加括号的区别请看code日记）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">bool</span> sList&lt;elemType&gt;::<span class="built_in">sListempty</span>() <span class="type">const</span> <span class="comment">//判空，空则返回真，否则返回假</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> sList&lt;elemType&gt;::<span class="built_in">sListLength</span>() <span class="type">const</span> <span class="comment">//返回链表长度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">node&lt;elemType&gt; *p = head-&gt;next; <span class="comment">//这里是让p=head-&gt;next这样可以统计有效节点的个数</span></span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">size++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sList&lt;elemType&gt;::<span class="built_in">sListPushBack</span>(elemType &amp;e) <span class="comment">//尾插</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line">node&lt;elemType&gt; *New, *p = head; <span class="comment">//这里让p=head，因为有链表为空的情况</span></span><br><span class="line"></span><br><span class="line">New = <span class="keyword">new</span> <span class="built_in">node</span>&lt;elemType&gt;(e); <span class="comment">//new了一个data初始化了的对象</span></span><br><span class="line"><span class="keyword">while</span> (p-&gt;next) <span class="comment">//找到最后一个节点</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = New;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sList&lt;elemType&gt;::<span class="built_in">sListPushHead</span>(elemType &amp;e) <span class="comment">//头插</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line">node&lt;elemType&gt; *New, *p = head-&gt;next;</span><br><span class="line"></span><br><span class="line">New = <span class="keyword">new</span> <span class="built_in">node</span>&lt;elemType&gt;(e);</span><br><span class="line">head-&gt;next = New;</span><br><span class="line">New-&gt;next = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sList&lt;elemType&gt;::<span class="built_in">sListPopBack</span>() <span class="comment">//尾删</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line">node&lt;elemType&gt; *p = head;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>)  <span class="comment">//如果链表是空的</span></span><br><span class="line"><span class="keyword">return</span>;  <span class="comment">//直接返回上一级函数</span></span><br><span class="line"><span class="keyword">if</span> (head-&gt;next-&gt;next == <span class="literal">NULL</span>) <span class="comment">//如果只有一个有效节点,不用找尾</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> head-&gt;next;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next-&gt;next) <span class="comment">//找尾</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> p-&gt;next;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sList&lt;elemType&gt;::<span class="built_in">sListPopHead</span>() <span class="comment">//头删</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line">node&lt;elemType&gt; *p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) <span class="comment">//如果链表是空的</span></span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//直接返回上一级函数</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">head-&gt;next = p-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sList&lt;elemType&gt;::<span class="built_in">sListInsert</span>(<span class="type">int</span> pos, elemType &amp;e) <span class="comment">//在pos位置插入e（在pos节点的前面插入e</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos &lt; <span class="number">1</span>) <span class="comment">//如果pos小于1则非法访问（越界</span></span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">outofBound</span>();</span><br><span class="line"></span><br><span class="line">node&lt;elemType&gt; *p = head, *New;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; j &lt; pos - <span class="number">1</span>) <span class="comment">// p为空说明走到了链表的最后面，也就是NULL</span></span><br><span class="line">&#123;</span><br><span class="line">j++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">outofBound</span>();</span><br><span class="line"><span class="comment">// return;</span></span><br><span class="line">New = <span class="keyword">new</span> <span class="built_in">node</span>&lt;elemType&gt;(e, p-&gt;next);</span><br><span class="line">p-&gt;next = New;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ​p的位置是在pos位的前一个，数据插在pos的位置就是插在p的后面，如果p在尾节点，插入在p的后面是没问题的，如果p走到了节点的尾部也就是尾结点的next也就是NULL，那说明pos肯定是超出了范围，否则在此之间p就能走到pos的前一个位置而终止循环</p><p> ​插入是可以尾插的，即pos的位置是在最后一个节点的后面，或者说NULL的前面,此时p在尾结点</p><p> ​while里面j的作用是判断有没有走到pos的位置之前，如果j&#x3D;pos-1，说明p走到了pos的前一个位置</p><p> ​如果数组长度为7，pos的位置是8，那么在p走到最后一个节点的时候，j&#x3D;7，p就停止移动，此时相当于尾插</p><p> ​如果数组的长度是7，pos的位置是9，那么在p走到最后一个节点的时候，j&#x3D;7，p不为空，j&lt;8，p继续后移到NULL，此时走了到链表的尽头，说明了链表长度不够，要插入的位置是在NULL还往后，这是非法访问</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sList&lt;elemType&gt;::<span class="built_in">sListErase</span>(<span class="type">int</span> pos) <span class="comment">//删除pos节点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">outofBound</span>();</span><br><span class="line"></span><br><span class="line">node&lt;elemType&gt; *p = head;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; pos - <span class="number">1</span>) <span class="comment">// p-&gt;next为空说明p走到了最后一个节点，如果走到了最后一个节点，说明pos的位置越界</span></span><br><span class="line">&#123;</span><br><span class="line">j++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!p-&gt;next)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">outofBound</span>();</span><br><span class="line">node&lt;elemType&gt; *tmp = p-&gt;next; <span class="comment">// p是pos的前一个节点</span></span><br><span class="line">p-&gt;next = tmp-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 删除只能删除存在的节点，如果删除超过长度的节点就是非法的，所以pos只能访问存在的节点的位置，即在NULL之前，head之后</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">elemType sList&lt;elemType&gt;::<span class="built_in">sListGet</span>(<span class="type">int</span> pos) <span class="comment">//返回pos处的节点的值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">outofBound</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">node&lt;elemType&gt; *p = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; pos - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">j++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!p-&gt;next)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">outofBound</span>();</span><br><span class="line"><span class="keyword">return</span> p-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 也是只能访问存在的节点的位置</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> sList&lt;elemType&gt;::<span class="built_in">sListFind</span>(elemType &amp;e) <span class="comment">//返回值等于e的结点的序号，没有匹配的则返回0</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">node&lt;elemType&gt; *p = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;data == e)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sList&lt;elemType&gt;::<span class="built_in">sListRemove</span>(<span class="type">int</span> pos, elemType &amp;e) <span class="comment">//移除pos处的数据并赋值给e</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">outofBound</span>();</span><br><span class="line"></span><br><span class="line">node&lt;elemType&gt; *p = head;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; pos - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">j++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!p-&gt;next)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">node&lt;elemType&gt; *tmp = p-&gt;next; <span class="comment">// p是pos的前一个节点</span></span><br><span class="line">p-&gt;next = tmp-&gt;next;</span><br><span class="line">e = tmp-&gt;data; <span class="comment">//将pos出的data赋值给引用e</span></span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sList&lt;elemType&gt;::<span class="built_in">sListReverse</span>() <span class="type">const</span> <span class="comment">//单链表元素就地逆置 (这个比较重点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line">node&lt;elemType&gt; *p, *q; <span class="comment">//兄弟协同</span></span><br><span class="line">p = head-&gt;next;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = p; <span class="comment">//首席插入</span></span><br><span class="line">p = q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/IMG_0576.PNG" alt="IMG_0576" style="zoom: 33%;" /> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/IMG_0577(20220913-081601).PNG" alt="IMG_0577(20220913-081601)" style="zoom:33%;" /> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/B25A0B6D7231FCFDAC865F593D313118.png" alt="img" style="zoom:33%;" /> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sList&lt;elemType&gt;::<span class="built_in">sListClear</span>() <span class="comment">//清空单链表，保留head结点，释放其余空间</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line">node&lt;elemType&gt; *p = head-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">head-&gt;next = p-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">sList&lt;elemType&gt;::~<span class="built_in">sList</span>() <span class="comment">//析构函数,销毁单链表，释放所有空间</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sListClear</span>();</span><br><span class="line"><span class="keyword">delete</span> head;</span><br><span class="line">head == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><ol><li>头部操作比尾部操作简单，因为尾部操作需要先找尾，找尾还要看有效节点是一个还是多个，一个的话就不用找，多个的话就要找</li><li>这里我犯了一个糊涂，混淆了一些东西，解释一下：</li></ol><blockquote><ol><li>new开辟动态内存之后返回的是地址</li><li>访问对象的成员的时候的格式是 对象.成员 ；使用指针来访问对象成员的时候是 对象指针-&gt;成员</li></ol><p>这一点是因为，类和对象是一种特殊的结构体（自定义类型），结构体访问成员就是 </p><p>结构体名.结构体成员</p><p>或者</p><p>结构体指针-&gt;结构体成员</p></blockquote><ol start="3"><li>匿名对象名后面无论加不加初始化参数都要有括号(C++异常处理有说明)</li><li>一定要写对单词！我写顺序表因为main写成mian找了很长时间的错误，写单链表因为friend写成了frind又找了很久错误</li></ol></blockquote><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><blockquote><p><strong>1.约瑟夫环</strong></p><p>n个人围成一个圈，从1、2、3开始报数。当报到m时，第m个人出列，并从原来的第m+1人重新开始1、2、3报数。如此循环，直到圈中只剩下一个人。这个圈称为约瑟夫环。试用单向循环链表实现该游戏，并输出最后剩下的那人的姓名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span><span class="comment">//单链表结点</span></span><br><span class="line">&#123;</span><br><span class="line">Node* next;</span><br><span class="line">string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ring</span><span class="comment">//约瑟夫环结构体（单向循环链表）</span></span><br><span class="line">&#123;</span><br><span class="line">Node* head;</span><br><span class="line">Node* tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThrowOut</span><span class="params">(Ring* ring, <span class="type">int</span> n, <span class="type">int</span> m)</span><span class="comment">//用于让第m个人出列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; m)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">Node* temp=ring-&gt;head;</span><br><span class="line">Node* x=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j; j &lt; m<span class="number">-1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; temp-&gt;next-&gt;name &lt;&lt; endl;//输出每次出列的人的名字</span></span><br><span class="line">x = temp-&gt;next;</span><br><span class="line">temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(x);</span><br><span class="line"></span><br><span class="line">ring-&gt;tail = temp;</span><br><span class="line">ring-&gt;head = temp-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ringGame</span><span class="params">(Ring* ring,<span class="type">int</span> n)</span><span class="comment">//约瑟夫环游戏实现函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (ring-&gt;head == ring-&gt;tail)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Please keynode the number you want to throw out&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line"><span class="built_in">ThrowOut</span>(ring, n, m);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;The last member&#x27;s name is:  &quot;</span>&lt;&lt; ring-&gt;head-&gt;name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.已知表头元素为c的单链表在内存中的存储状态如下表所示</strong></p><table><thead><tr><th align="center">地址</th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">1000H</td><td align="center">a</td><td align="center">1010H</td></tr><tr><td align="center">1004H</td><td align="center">b</td><td align="center">100CH</td></tr><tr><td align="center">1008H</td><td align="center">c</td><td align="center">1000H</td></tr><tr><td align="center">100CH</td><td align="center">d</td><td align="center">NULL</td></tr><tr><td align="center">1010H</td><td align="center">e</td><td align="center">1004H</td></tr><tr><td align="center">1014H</td><td align="center"></td><td align="center"></td></tr></tbody></table><p>现将f存放于1014H处并插入到单链表中，若f在逻辑上位于a和e之间，则a，e，f的“链接地址”依次是什么？</p><blockquote><p>原来逻辑上：c，a，e，b，d</p><p>现在逻辑上：c，a，f，e，b，d</p><p>则a的链接地址（后继指针）变成了f的地址，f的链接地址变成了e的，e的不变</p><p>即a-&gt;next&#x3D;1014H, f-&gt;next&#x3D;1010H, e-&gt;next&#x3D;1004H</p></blockquote><p><strong>3.集合的并、差</strong>（不一定是有序的集合</p><p>利用链式结构分别实现集合运算<br>$$<br>C&#x3D;A\cup B、C&#x3D;A-B&#x3D;A-A\cap B<br>$$<br>并分析其时间复杂度。要求运算结束后在内存中的A、B两个集合中的元素不变</p><blockquote><p>思路：</p><p>求并集的时候，可以先将A、B简单相加得C，然后删除C中数据重复的结点</p><p>求差时候，以A为基础，A中的每个结点和B比较，A、B中有相同的就不插入C，把A中具有且B中没有的插入到C</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span><span class="comment">//单链表结点</span></span><br><span class="line">&#123;</span><br><span class="line">Node* next;</span><br><span class="line"><span class="type">int</span> data;<span class="comment">//方便起见就假设集合是一个数集吧~~</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CT</span><span class="comment">//集合结构体,CT是collection的缩写</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CT</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">And</span><span class="params">(CT*, CT*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Difference</span><span class="params">(CT*, CT*)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CT::<span class="built_in">CT</span>()</span><br><span class="line">&#123;</span><br><span class="line">Node* C = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">head = C;</span><br><span class="line">C-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">C-&gt;data = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CT::And</span><span class="params">(CT* A, CT* B)</span><span class="comment">//求并集:A+B-AB</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A == <span class="literal">NULL</span> || B == <span class="literal">NULL</span> )</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">Node* a = A-&gt;head;</span><br><span class="line">Node* b = B-&gt;head;</span><br><span class="line">Node* c = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (a)</span><br><span class="line">&#123;</span><br><span class="line">c-&gt;data = a-&gt;data;</span><br><span class="line">c-&gt;next = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">c = c-&gt;next;</span><br><span class="line">c-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">a = a-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (b)</span><br><span class="line">&#123;</span><br><span class="line">c-&gt;data = b-&gt;data;</span><br><span class="line">c-&gt;next = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">c = c-&gt;next;</span><br><span class="line">c-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">b = b-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">c = head;</span><br><span class="line"><span class="keyword">while</span> (c)</span><br><span class="line">&#123;</span><br><span class="line">Node* x = c;</span><br><span class="line">Node* y = c-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (c-&gt;data != y-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">x = x-&gt;next;</span><br><span class="line">y = y-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">x-&gt;next = y-&gt;next;</span><br><span class="line"><span class="built_in">delete</span>(y);</span><br><span class="line">y = x-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c = c-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CT::Difference</span><span class="params">(CT* A, CT* B)</span><span class="comment">//求差集,遍历A中的每一个元素的时候遍历B中的每一个元素，有相同的就不加入到C，没有就加入到C</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* a = A-&gt;head;</span><br><span class="line">Node* c = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (A == <span class="literal">NULL</span> || B == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (a)</span><br><span class="line">&#123;</span><br><span class="line">Node* b = B-&gt;head;</span><br><span class="line"><span class="keyword">while</span> (b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a-&gt;data == b-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">b = b-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">c-&gt;data = a-&gt;data;</span><br><span class="line">c-&gt;next = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">c = c-&gt;next;</span><br><span class="line">c-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">a = a-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>&#x3D;&#x3D;下面这些函数都是直接在上面👆写好的单链表头文件（sList.h）中作为了成员函数声明的，并在另一个文件中定义的&#x3D;&#x3D;</p><blockquote><p>当然也可以不用作为成员函数，而是重新写一个头文件和源文件，并在头文件中包含单链表的源文件来使用写好的单链表</p><p>但是因为题目大都是在现有链表的基础上进行操作，也就是对链表进行操作，不如直接写成链表的成员函数，直接在链表中调用更方便</p></blockquote><p>1.求两个递增单链表的交、并、差集，并且要求结果也是递增的单链表</p><p>请用两种方案实现：一种是用原有空间，一种是用新的空间</p><blockquote><p>用原有空间的话，就是以A为主链，将A作为结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交集 就是在A中只保留下来AB都有的</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sList&lt;elemType&gt;::<span class="built_in">intersection</span>(sList&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">node&lt;elemType&gt; *i, *j;</span><br><span class="line">i = head;</span><br><span class="line">j = b.head-&gt;next;<span class="comment">//这里有个彩蛋，类内访问外部同类对象的私有成员，这是合理的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i-&gt;next &amp;&amp; j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;next-&gt;data == j-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">i = i-&gt;next;</span><br><span class="line">j = j-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;next-&gt;data &lt; j-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">node&lt;elemType&gt; *k = i-&gt;next;</span><br><span class="line">i-&gt;next = i-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">delete</span> (k);</span><br><span class="line">k = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">j = j-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i-&gt;next)<span class="comment">//如果主集合i指针之后不会空，应该清除多余的元素</span></span><br><span class="line">&#123;</span><br><span class="line">node&lt;elemType&gt; *k = i-&gt;next;</span><br><span class="line">i-&gt;next = i-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">delete</span> (k);</span><br><span class="line">k = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交集是&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= <span class="built_in">sListLength</span>(); x++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sListGet</span>(x) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sListLength</span>() == <span class="number">0</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;空集&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里要注意，因为涉及删除，所以a中要用两个指针，或者指针指向被判断的元素的前一个，指针的next指向被判断的元素，为删除做准备</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并集就是把 B中有且A中没有的 给A</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sList&lt;elemType&gt;::<span class="built_in">unionSet</span>(sList&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">node&lt;elemType&gt; *i, *j;</span><br><span class="line">i = head;</span><br><span class="line">j = b.head-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i-&gt;next &amp;&amp; j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;next-&gt;data == j-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">i = i-&gt;next;</span><br><span class="line">j = j-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;data &lt; j-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;next-&gt;data &gt; j-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">node&lt;elemType&gt; *k = <span class="keyword">new</span> node&lt;elemType&gt;;<span class="comment">//这里要注意，如果只是将j的结点给i的next，则结点之后所有都是j的结点了，因此只能新开一个结点并赋值</span></span><br><span class="line">k-&gt;next = i-&gt;next;</span><br><span class="line">k-&gt;data = j-&gt;data;</span><br><span class="line">i-&gt;next = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">i = i-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">j = j-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j)<span class="comment">//如果b没有走完，b中剩下的的元素一定都是比a中的大的，因此不用判断大小，全部给到a就可以，而且直接连接上结点就可以，不用新开结点再赋值</span></span><br><span class="line">&#123;</span><br><span class="line">i-&gt;next = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;并集是&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= <span class="built_in">sListLength</span>(); x++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sListGet</span>(x) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sListLength</span>() == <span class="number">0</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;空集&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//差集就是保留A中有且B中没有的</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sList&lt;elemType&gt;::<span class="built_in">complementarySet</span>(sList&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">node&lt;elemType&gt; *i, *j;</span><br><span class="line">i = head;</span><br><span class="line">j = b.head-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i-&gt;next &amp;&amp; j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;next-&gt;data == j-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">node&lt;elemType&gt; *k = i-&gt;next;</span><br><span class="line">i-&gt;next = i-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">delete</span> (k);</span><br><span class="line">k = <span class="literal">NULL</span>;</span><br><span class="line">j = j-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;next-&gt;data &lt; j-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">i = i-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">j = j-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;差集是&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= <span class="built_in">sListLength</span>(); x++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sListGet</span>(x) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sListLength</span>() == <span class="number">0</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;空集&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用申请新空间的方案：也就是用另外一个链表C作为结果链</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交集就是将A、B都有的才放入C</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sList&lt;elemType&gt;::<span class="built_in">intersection_new</span>(sList&amp; a, sList&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">node&lt;<span class="type">int</span>&gt; *i = a.head-&gt;next;</span><br><span class="line">node&lt;<span class="type">int</span>&gt; *j = b.head-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &amp;&amp; j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;data == j-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sListPushBack</span>(i-&gt;data);</span><br><span class="line">i = i-&gt;next;</span><br><span class="line">j = j-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;data &lt; j-&gt;data)</span><br><span class="line">i = i-&gt;next;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">j = j-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交集是&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= <span class="built_in">sListLength</span>(); x++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sListGet</span>(x) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sListLength</span>() == <span class="number">0</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;空集&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并集就是A有B没有，放入，B有A没有，放入，AB都有，放入</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sList&lt;elemType&gt;::<span class="built_in">unionSet_new</span>(sList&amp; a, sList&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">node&lt;<span class="type">int</span>&gt; *i = a.head-&gt;next;</span><br><span class="line">node&lt;<span class="type">int</span>&gt; *j = b.head-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &amp;&amp; j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;data == j-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sListPushBack</span>(i-&gt;data);</span><br><span class="line">i = i-&gt;next;</span><br><span class="line">j = j-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;data &lt; j-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sListPushBack</span>(i-&gt;data);</span><br><span class="line">i = i-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sListPushBack</span>(j-&gt;data);</span><br><span class="line">j = j-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sListPushBack</span>(i-&gt;data);</span><br><span class="line">i = i-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sListPushBack</span>(j-&gt;data);</span><br><span class="line">j = j-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;并集是&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= <span class="built_in">sListLength</span>(); x++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sListGet</span>(x) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sListLength</span>() == <span class="number">0</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;空集&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//差集 A中有B中没有的放入C &lt;或者简单一点，调用交集函数然后将A中的减去交集&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sList&lt;elemType&gt;::<span class="built_in">complementarySet_new</span>(sList&amp; a, sList&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">sList&lt;<span class="type">int</span>&gt; K;<span class="comment">//先求出ab的交集K</span></span><br><span class="line">node&lt;<span class="type">int</span>&gt; *m = a.head-&gt;next;</span><br><span class="line">node&lt;<span class="type">int</span>&gt; *n = b.head-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (m &amp;&amp; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m-&gt;data == n-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">K.<span class="built_in">sListPushBack</span>(m-&gt;data);</span><br><span class="line">m = m-&gt;next;</span><br><span class="line">n = n-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m-&gt;data &lt; n-&gt;data)</span><br><span class="line">m = m-&gt;next;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">n = n-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node&lt;<span class="type">int</span>&gt; *k = K.head-&gt;next;</span><br><span class="line">node&lt;<span class="type">int</span>&gt; *i = a.head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (i &amp;&amp; k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;data != k-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sListPushBack</span>(i-&gt;data);</span><br><span class="line">i = i-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">i = i-&gt;next;</span><br><span class="line">k = k-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sListPushBack</span>(i-&gt;data);</span><br><span class="line">i = i-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;差集是&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= <span class="built_in">sListLength</span>(); x++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sListGet</span>(x) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sListLength</span>() == <span class="number">0</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;空集&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>2.已知线性表中的元素以值递增有序排列，并以单链表做存书结构。请写一种高效的算法，删除表中所有值大于mink且小于maxk的元素（如果表中有这样的元素），同时释放被删除的结点空间，并分析一下算法的时间复杂度</p><blockquote><p>用双指针就可以解决，一个i在前，一个j在后</p><p>i先找到区间（大于mink小于maxk的区间）之前的第一个元素（也就是小于mink的元素里面的最后一个元素）（此时i-&gt;data&lt;&#x3D;mink , i-&gt;next-&gt;data&gt;&#x3D;mink)</p><p>然后j开始往后找到区间之后的第一个元素(也就是j一直往后，直到j-&gt;data&gt;&#x3D;mark)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sList&lt;elemType&gt;::<span class="built_in">interval</span>(<span class="type">int</span> mink, <span class="type">int</span> maxk)</span><br><span class="line">&#123;</span><br><span class="line">    node&lt;<span class="type">int</span>&gt; *i, *j;</span><br><span class="line">    j = i = head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i-&gt;data &lt;= mink &amp;&amp; i-&gt;next-&gt;data &lt;= mink)</span><br><span class="line">            i = i-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    j = i;</span><br><span class="line">    <span class="keyword">while</span> (j-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j-&gt;data &lt; maxk )</span><br><span class="line">            j = j-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i-&gt;next != j)</span><br><span class="line">    &#123;</span><br><span class="line">        node&lt;<span class="type">int</span>&gt; *k = i-&gt;next;</span><br><span class="line">        i-&gt;next = i-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> k;</span><br><span class="line">        k = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>That’s all, thanks for reading!💐</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_栈应用_中缀式转后缀式并计算</title>
      <link href="/chunyujin/db3b0256.html"/>
      <url>/chunyujin/db3b0256.html</url>
      
        <content type="html"><![CDATA[<h3 id="中缀式转后缀式并计算（图文解释"><a href="#中缀式转后缀式并计算（图文解释" class="headerlink" title="中缀式转后缀式并计算（图文解释"></a>中缀式转后缀式并计算（图文解释</h3><blockquote><p>前言：此类笔记仅用于个人复习，内容主要在于记录和体现个人理解，详细还请结合bite课件、录播、板书和代码。</p></blockquote><p>[toc]</p><hr><h4 id="前言：用到的头文件"><a href="#前言：用到的头文件" class="headerlink" title="前言：用到的头文件"></a>前言：用到的头文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span><span class="comment">//stringstream类需要包含的头文件，这个类的作用是将元素全是数字字符string类转换成字面上等价的int类</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><hr><h4 id="1-输入一个中缀式"><a href="#1-输入一个中缀式" class="headerlink" title="1.输入一个中缀式"></a>1.输入一个中缀式</h4><p>$$<br>5*3(12-1++)&#x2F;5<br>$$</p><p>计算结果就是17（一会儿可以用来验证程序结果是否正确</p><p>输入的这个中缀式的数据是由字符组成的，中缀式本身就是一个string类型</p><p>如果用字符的话，单个的数字或者符号，比如其中的 ‘5’、’*’、’3’、’(‘ 等轻易就会识别出来</p><p>但是“12”和“++”就会被识别成’1’、’2’、和’+’、’+’</p><p>所以需要将中缀式进行转化，变成能识别多个字符的格式</p><h4 id="2-将中缀式变成一个string类型数组，存储的数据由字符变成string类型"><a href="#2-将中缀式变成一个string类型数组，存储的数据由字符变成string类型" class="headerlink" title="2.将中缀式变成一个string类型数组，存储的数据由字符变成string类型"></a>2.将中缀式变成一个string类型数组，存储的数据由字符变成string类型</h4><p>建立一个string类型数组，命名为&#x3D;&#x3D;<strong>save</strong>&#x3D;&#x3D;</p><blockquote><p><strong>转化规则</strong>：</p><p>用一个指针遍历 原中缀式</p><p>如果遇到了数字字符，就向后检查，直到遇到非数字字符，将检查的这一段字符都作为一个string的成员保存，并存在&#x3D;&#x3D;save&#x3D;&#x3D;中</p><p><strong>否则</strong>如果遇到了 ‘+’ 或者 ‘-’ ，就向后检查，直到遇到非 ‘+’ 或者 ‘-’ ，将检查的这一段字符都作为一个string的成员保存，并存在&#x3D;&#x3D;save&#x3D;&#x3D;中</p><p>直到指针遍历完原中缀式为止</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">init</span><span class="params">(string s)</span> <span class="comment">//初始化给出的原始中缀式，处理多位数以及自增自减（原来的中缀式式一个字符串单个元素是一个字符，现在将它初始化为一个容器，容器元素就是字符串（string）</span></span></span><br><span class="line"><span class="function"><span class="comment">//无论字符有几个都当作一个string并存到vector容器中作为其一个元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;string&gt; v;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j;</span><br><span class="line"><span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">j = i;</span><br><span class="line"><span class="keyword">if</span> (j &lt; s.<span class="built_in">size</span>() &amp;&amp; s.<span class="built_in">at</span>(j) &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; s.<span class="built_in">at</span>(j) &gt;= <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j &lt; s.<span class="built_in">size</span>() &amp;&amp; s.<span class="built_in">at</span>(j) &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; s.<span class="built_in">at</span>(j) &gt;= <span class="string">&#x27;0&#x27;</span>) <span class="comment">//判断是否为数字以及是不是多位数</span></span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j &lt; s.<span class="built_in">size</span>() &amp;&amp; (s.<span class="built_in">at</span>(j) == <span class="string">&#x27;+&#x27;</span> || s.<span class="built_in">at</span>(j) == <span class="string">&#x27;-&#x27;</span>)) <span class="comment">//判断是不是自增自减运算符</span></span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == j) <span class="comment">//说明没有遇到数字或者自增自减运算符</span></span><br><span class="line">v.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(i++, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(i, j - i));</span><br><span class="line">i = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202209290035521.jpg" alt="Sketch-20" style="zoom: 15%;" /> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202209290035868.jpg" alt="Sketch-21" style="zoom:15%;" /> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202209290036576.jpg" alt="Sketch-22" style="zoom:15%;" /><p>save就是转化后的中缀式，返回它就可以</p><h4 id="3-中缀式转后缀式"><a href="#3-中缀式转后缀式" class="headerlink" title="3.中缀式转后缀式"></a>3.中缀式转后缀式</h4><p>用一个string指针遍历中缀式</p><p>建立一个字符串数组save，用来存储后缀式的元素</p><p>建立一个操作符栈result（string类），用来调整操作符的顺序</p><blockquote><p>规则：</p><p>如果元素是数字，就直接进入后缀式</p><p>如果元素是操作符，就要进行一下判断：</p><p>如果操作符栈result是空的，就直接让元素进栈</p><p>如果result栈不是空，就进行判断：</p><p>​如果栈顶优先度小于中缀式中的，中缀式中的操作符直接进栈</p><p>​如果栈顶优先度不小于中缀式，则栈顶先出栈到后缀式，中缀式的操作符再进栈</p><p>​如果中缀式元素是‘）’，则一直出栈，直到把括号内的元素全部出栈</p><p>​另外，如果‘（’不在栈内，则它的优先度被认为是最高的，栈内的‘（’是最低的</p><p>等中缀式遍历完之后，检查栈是否为空，不为空就出栈到后缀式，直到栈为空</p><p>操作符优先级：(从上到下递减)</p><p><strong>栈外的‘（’</strong>  </p><p>  <strong>‘++’、‘–‘</strong>   </p><p> <strong>’*‘、’&#x2F;‘</strong>  </p><p>  <strong>’+‘、’-‘</strong>  </p><p>  <strong>栈内的’（‘</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">judge</span><span class="params">(string s)</span> <span class="comment">//判断运算符优先度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="string">&quot;+&quot;</span> || s == <span class="string">&quot;-&quot;</span>) <span class="comment">//操作符也是string，妙</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;*&quot;</span> || s == <span class="string">&quot;/&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;++&quot;</span> || s == <span class="string">&quot;--&quot;</span>) <span class="comment">//自增自减优先级是仅次于左括号的</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;(&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;)&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">transform</span><span class="params">(vector&lt;string&gt; v)</span><span class="comment">//转后缀式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stack&lt;string&gt; result;</span><br><span class="line">vector&lt;string&gt; save;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">judge</span>(v[i]) == <span class="number">0</span>) <span class="comment">//遇到数字就直接输出</span></span><br><span class="line">save.<span class="built_in">push_back</span>(v[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">judge</span>(v[i]) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result.<span class="built_in">empty</span>()) <span class="comment">//栈为空则直接压栈</span></span><br><span class="line">result.<span class="built_in">push</span>(v[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">judge</span>(v[i]) &gt; <span class="built_in">judge</span>(result.<span class="built_in">top</span>())) <span class="comment">//操作符优先级比栈顶操作符优先级高</span></span><br><span class="line">&#123;</span><br><span class="line">result.<span class="built_in">push</span>(v[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> ((!result.<span class="built_in">empty</span>()) &amp;&amp; <span class="built_in">judge</span>(result.<span class="built_in">top</span>()) &gt;= <span class="built_in">judge</span>(v[i]) &amp;&amp;</span><br><span class="line">   result.<span class="built_in">top</span>() != <span class="string">&quot;(&quot;</span>) <span class="comment">//弹栈并输出直到栈为空或遇到优先级更低的操作符 (除了左括号)</span></span><br><span class="line">&#123;</span><br><span class="line">save.<span class="built_in">push_back</span>(result.<span class="built_in">top</span>());</span><br><span class="line">result.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">result.<span class="built_in">push</span>(v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">judge</span>(v[i]) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (result.<span class="built_in">top</span>() != <span class="string">&quot;(&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">save.<span class="built_in">push_back</span>(result.<span class="built_in">top</span>());</span><br><span class="line">result.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">result.<span class="built_in">pop</span>();<span class="comment">//抛弃‘（’</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!result.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">save.<span class="built_in">push_back</span>(result.<span class="built_in">top</span>());</span><br><span class="line">result.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> save;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/6E676ED2FAE6E90353E0FD482F2AC9FF.png" alt="img" style="zoom: 50%;" /> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/5FF6213D01810F9AB053885AE494B7F8.png" alt="img" style="zoom: 50%;" /> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/66B7012D51C8791CF07F4DE67E85E8AB.png" alt="img" style="zoom: 50%;" /> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/22005441D9A5F6CAE98D1589A833F308.png" alt="img" style="zoom: 50%;" /> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/630C6A3F431A97BC5D18FA26BA5D4147.png" alt="img" style="zoom: 50%;" /><h4 id="4-后缀式的计算"><a href="#4-后缀式的计算" class="headerlink" title="4.后缀式的计算"></a>4.后缀式的计算</h4><p>构建一个计算结果栈，result（int类）</p><blockquote><p>分为两个模块：</p><ol><li>如果元素是数字，就进行“string转int”操作，转换后的结果入result栈</li><li>如果是操作符，就从栈顶取数字进行计算，并将计算结果入result<ol><li>如果操作符是加减乘除，需要从栈中取两个数字，因为加减乘除是二元运算符，另外注意，由于从后缀式入栈到result，先进的数字a在栈底，后进的b在栈顶，而加减乘除是后缀式从前往后的顺序，比如后缀式ab-，ab进栈之后就变成了ba，应该用a-b，而不是b-a</li><li>如果操作符是一元运算符，就直接取栈顶元素，计算之后返回result</li></ol></li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">stringToInt</span><span class="params">(string s)</span> <span class="comment">//将操作数字符串转变成int</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stringstream ss;<span class="comment">//stringstream类的作用是将元素全是数字字符string类转换成字面上等价的int类</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">ss &lt;&lt; s;</span><br><span class="line">ss &gt;&gt; i;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(vector&lt;string&gt; v)</span> <span class="comment">//进行计算</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; result; <span class="comment">//结果栈</span></span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">judge</span>(v[i]) == <span class="number">0</span>) <span class="comment">//如果是操作数，则转换为int之后直接入到结果栈</span></span><br><span class="line">result.<span class="built_in">push</span>(<span class="built_in">stringToInt</span>(v[i]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">a = result.<span class="built_in">top</span>();</span><br><span class="line">result.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!result.<span class="built_in">empty</span>()) <span class="comment">//如果结果栈里面的元素够两个的话，才能进行加减乘除</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (v[i] == <span class="string">&quot;+&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">b = result.<span class="built_in">top</span>();</span><br><span class="line">result.<span class="built_in">pop</span>();</span><br><span class="line">result.<span class="built_in">push</span>(b + a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (v[i] == <span class="string">&quot;-&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">b = result.<span class="built_in">top</span>();</span><br><span class="line">result.<span class="built_in">pop</span>();</span><br><span class="line">result.<span class="built_in">push</span>(b - a); <span class="comment">//因为在后缀式中靠前的元素先入栈，后面的元素后入栈，后入栈的先出，所以在后缀式中的顺序是b在a之前，按照运算顺序就是b-a</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (v[i] == <span class="string">&quot;*&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">b = result.<span class="built_in">top</span>();</span><br><span class="line">result.<span class="built_in">pop</span>();</span><br><span class="line">result.<span class="built_in">push</span>(b * a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (v[i] == <span class="string">&quot;/&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">b = result.<span class="built_in">top</span>();</span><br><span class="line">result.<span class="built_in">pop</span>();</span><br><span class="line">result.<span class="built_in">push</span>(b / a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (v[i] == <span class="string">&quot;++&quot;</span>)</span><br><span class="line">result.<span class="built_in">push</span>(++a);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (v[i] == <span class="string">&quot;--&quot;</span>)</span><br><span class="line">result.<span class="built_in">push</span>(--a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/D83F5F0EBA30975779FA865B8A2AE43B.png" alt="img" style="zoom:50%;" /> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/B704F19B921D4032ADC66F790F47B708.png" alt="img" style="zoom:50%;" /> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/C067C83C14A1D479BEEBD4C52B408618.png" alt="img" style="zoom:50%;" /><h4 id="5-总的对外接口函数"><a href="#5-总的对外接口函数" class="headerlink" title="5.总的对外接口函数"></a>5.总的对外接口函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InfixToPostfixAndCalculate</span><span class="params">(string Infix)</span><span class="comment">//总的对外接口</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;您输入的中缀式是：&quot;</span> &lt;&lt; Infix &lt;&lt; endl;</span><br><span class="line">vector&lt;string&gt; v1 = <span class="built_in">init</span>(Infix);<span class="comment">//中缀式初始化：将中缀式的元素由字符变成string，将中缀式由string变成vector</span></span><br><span class="line">vector&lt;string&gt; v2 = <span class="built_in">transform</span>(v1);<span class="comment">//中缀式转后缀式</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;转化为后缀式并进行计算的计算结果是：&quot;</span> &lt;&lt; <span class="built_in">calculate</span>(v2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-思维导图"><a href="#6-思维导图" class="headerlink" title="6.思维导图"></a>6.思维导图</h4><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221109184625057.png" alt="image-20221109184625057"></p><p><a href="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E4%B8%AD%E7%BC%80%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E5%BC%8F%E5%B9%B6%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97.pdfhttps://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E4%B8%AD%E7%BC%80%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E5%BC%8F%E5%B9%B6%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97.pdf">中缀式转后缀式.pdf</a></p><h4 id="7-结束"><a href="#7-结束" class="headerlink" title="7.结束"></a>7.结束</h4><p>That’s all, thanks for reading!💐</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_线性表应用_多项式的计算</title>
      <link href="/chunyujin/4618b828.html"/>
      <url>/chunyujin/4618b828.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构-线性表的应用-多项式的计算"><a href="#数据结构-线性表的应用-多项式的计算" class="headerlink" title="数据结构_线性表的应用-多项式的计算"></a>数据结构_线性表的应用-多项式的计算</h2><blockquote><p>前言：此类笔记仅用于个人复习，内容主要在于记录和体现个人理解，详细还请结合bite课件、录播、板书和代码。</p></blockquote><hr><p>[toc]</p><hr><h3 id="一元多项式-polynomial-的加法"><a href="#一元多项式-polynomial-的加法" class="headerlink" title="一元多项式(polynomial)的加法"></a>一元多项式(polynomial)的加法</h3><h4 id="数学表示方法"><a href="#数学表示方法" class="headerlink" title="数学表示方法"></a>数学表示方法</h4><blockquote><p>一元多项式通常按幂升序排列，在数学上表示为：</p><p>p<del>n</del>(x) &#x3D;p<del>0</del> + p<del>1</del>x + p<del>2</del>x^2^ + p<del>3</del>x^3^ + p<del>4</del>x^4^ + p<del>5</del>x^5^ +…. + p<del>n</del>x^n^</p></blockquote><h4 id="计算机内实现"><a href="#计算机内实现" class="headerlink" title="计算机内实现"></a>计算机内实现</h4><blockquote><p>在计算机内实现的话，可以使用线性表来存储，每个结点内存储两个成员：data数据、next指针，data数据包括单项式的系数和次数</p><p>且是按照次数的升序来进行存储的</p><p>《《此处应有图片，参考课本图2-18</p></blockquote><h5 id="数据的存放方法"><a href="#数据的存放方法" class="headerlink" title="数据的存放方法"></a>数据的存放方法</h5><blockquote><p>如果不论次数是否为0都将数据存储进结点，那么有可能会造成空间的大量浪费,比如1 + x^100^</p><p>如果只存储次数不为0的单项式，不会造成空间的浪费，但是考虑到两个多项式相加，次数相同的多项式需要合并在一起，这种存储方式可能需要花费一些时间来寻找两个多项式里的相同次数的单项式</p></blockquote><h5 id="数据结构的选择"><a href="#数据结构的选择" class="headerlink" title="数据结构的选择"></a>数据结构的选择</h5><blockquote><ol><li>不用多说必须使用动态内存，静态内存会造成空间不够或者空间浪费的情况</li><li>数据结构选择链表，顺序表动态开辟内存是成倍开辟，会造成空间浪费</li></ol></blockquote><h5 id="一元多项式以及基本操作的实现"><a href="#一元多项式以及基本操作的实现" class="headerlink" title="一元多项式以及基本操作的实现"></a>一元多项式以及基本操作的实现</h5><p><strong>polynomial.h</strong></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;sList.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>数据结构是链表，要包含链表的头文件</p><p>(不过说实话，好像并没有用上链表的功能，只是用了链表作为结构体，除了用到了sList头问价中的#include<iostream>以及using namespace std之外好像啥也没用上)</p><p><strong>组成多项式的基本单位：单项式结点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Type</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> coef;<span class="comment">//系数</span></span><br><span class="line"><span class="type">int</span> exp;<span class="comment">//次数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">elemType data;<span class="comment">//数据</span></span><br><span class="line">Node* next;<span class="comment">//下一个结点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里，次数和系数被存放在了结构体Type</p><p>结点Node包括data和next，因为用的模板，所以data适用于任何数据类型，当然也包括Type</p><p>不是直接将次数和系数放到Node里是为了Node的复用性，Node作为链表结点只包含data和next两个成员</p><blockquote><p>这里既可以使用结构体也可以使用类，因为在C++中，类和结构体的唯一区别就是类的成员默认是私有的，结构体的默认是公有的（下面的也是</p></blockquote><p><strong>多项式及其加法的构想</strong></p><p><em>多项式的构想：</em></p><p>构建一个多项式就是输入每一个单项式的系数和次数，等到所有的单项式都输入完毕，多项式就构建好了</p><p>但是单项式一个一个输入比较麻烦，可以一口气全部输入完，最后输入一个结束标志表示所有的单项式都输入完了，停止多项式的构建</p><p>每个单项式含有两个数据，那就将输入的这一串数字每两个写入一个Node中，如果读取到的两个数字跟结束标志相符，则说明多项式构建好了</p><p>由于写入多项式的前提是已知所有单项式的系数和次数，只要把不是次数和系数的组合的两个数作为结束标志就可以了</p><p><em>加法的构想：</em></p><p>用a、b表示两个相加的多项式，用另一个多项式c作为多项式相加的结果</p><p>如果a、b多项式里有同类相，要合并之后作为结果，没有同类相的单项式直接作为结果</p><p><strong>多项式及加法的实现</strong></p><p><em>多项式类（结构体）的定义</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Polynomial</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node&lt;elemType&gt;* head;</span><br><span class="line">elemType stop_flag;<span class="comment">//多项式结束标志，用作判断多项式是否结束</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Polynomial</span>(<span class="type">const</span> elemType&amp; stop);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPoly</span><span class="params">()</span></span>;<span class="comment">//读入一个多项式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addPoly</span><span class="params">(<span class="type">const</span> Polynomial&amp; a, <span class="type">const</span> Polynomial&amp; b)</span></span>;<span class="comment">//相加函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dispPoly</span><span class="params">()</span></span>;<span class="comment">//显示一个多项式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="comment">//释放多项式空间（清空多项式,仅保留头结点</span></span><br><span class="line">~<span class="built_in">Polynomial</span>() &#123; <span class="built_in">clear</span>(); <span class="keyword">delete</span> head; &#125;;<span class="comment">//销毁所有动态内存</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>数据成员只需要有头和结束标志就可以，头是链表的头，有了头就可以找到链表的所有数据；结束标志用来判断多项式是否结束</p><p><em>获取多项式结束标志</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getStop为外部函数，是非类成员函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;<span class="comment">//从用户处获取结束标志</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getStop</span><span class="params">(elemType&amp; stopFlag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> c, e;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入系数、指数对作为结束标志，如&#x27;0 0&#x27;&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; c &gt;&gt; e;</span><br><span class="line">stopFlag.coef = c;</span><br><span class="line">stopFlag.exp = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的多项式的结束标志是可以相同的，获取一次结束标志就可以供所有多项式使用，因此没有必要将其作为成员函数</p></blockquote><p><em>个人认为这里有点强行构建模板类</em></p><p>在使用的时候，其实elemType只能是Type结构体或者Node结构体，因为在各个模板类和模板函数中，都用到了elemType的成员coef和exp，或者elemType的成员head，只有Type具有成员coef和exp，只有Node有head，直接使用具体的变量类型不更简单吗</p><p>而且这个是多项式的加法，并不会封装用于其他变量</p><p>相反，多项式的次数和系数更应该使用eleType或者直接用double，因为可能不止整型</p><p><strong>polynomial.cpp</strong></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;polynomial.h&quot;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">Polynomial&lt;elemType&gt;::<span class="built_in">Polynomial</span>(<span class="type">const</span> elemType &amp;stop) <span class="comment">//从用户处获取结束标志并初始化多项式</span></span><br><span class="line">&#123;</span><br><span class="line">    head = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;elemType&gt;();</span><br><span class="line">    stop_flag.coef = stop.coef;</span><br><span class="line">    stop_flag.exp = stop.exp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> Polynomial&lt;elemType&gt;::<span class="built_in">getPoly</span>() <span class="comment">//读入一个多项式</span></span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;elemType&gt; *p, *next;</span><br><span class="line">    elemType e;</span><br><span class="line"></span><br><span class="line">    p = head;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请按照升幂的顺序输入系数、次数对，并最后输入结束标志作结尾结束多项式的输入&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; e.coef &gt;&gt; e.exp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e.coef != stop_flag.coef || e.exp != stop_flag.exp) <span class="comment">//先判断有没有到多项式的结尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        next = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;elemType&gt;(); <span class="comment">//不断创建新结点来保存数据</span></span><br><span class="line">        next-&gt;data.coef = e.coef;</span><br><span class="line">        next-&gt;data.exp = e.exp;</span><br><span class="line"></span><br><span class="line">        p-&gt;next = next; <span class="comment">// p接上新结点</span></span><br><span class="line">        p = next;       <span class="comment">// p后移</span></span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; e.coef &gt;&gt; e.exp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意，在判断有没有到多项式结尾的时候的条件，是系数和次数同时一一等于结束标志对，即e.coef &#x3D;&#x3D; stop_flag.coef &amp;&amp; e.exp &#x3D;&#x3D; stop_flag.exp，换做while循环的条件就是：次数或系数有一个不同于结束标志就可以进入循环</p><p>也可以写成这样:</p><p>While(1）</p><p>{</p><p>​if(e.coef &#x3D;&#x3D; stop_flag.coef &amp;&amp; e.exp &#x3D;&#x3D; stop_flag.exp)</p><p>​break;</p><p>……….</p><p>}</p><p>直接在while处进行判断比较简便，但是要注意条件不要出错</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> Polynomial&lt;elemType&gt;::<span class="built_in">addPoly</span>(<span class="type">const</span> Polynomial &amp;a, <span class="type">const</span> Polynomial &amp;b) <span class="comment">//相加函数,a、b分别就是两个要相加的多项式</span></span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;elemType&gt; *pa, *pb, *pc; <span class="comment">//分别用在a、b、c三个链表上</span></span><br><span class="line">    Node&lt;elemType&gt; *New;          <span class="comment">//创建新结点，用来保存结果并插入到多项式c中</span></span><br><span class="line">    pa = a.head-&gt;next, pb = b.head-&gt;next;</span><br><span class="line">    pc = head; <span class="comment">//说明正在调用这个相加函数的对象是第三个多项式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pa &amp;&amp; pb) <span class="comment">//如果a、b两个多项式都没有走完</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pa-&gt;data.exp == pb-&gt;data.exp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pa-&gt;data.coef + pb-&gt;data.coef == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pa = pa-&gt;next;</span><br><span class="line">                pb = pb-&gt;next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                New = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;elemType&gt;();</span><br><span class="line"></span><br><span class="line">                New-&gt;data.coef = pa-&gt;data.coef + pb-&gt;data.coef;</span><br><span class="line">                New-&gt;data.exp = pa-&gt;data.exp;</span><br><span class="line"></span><br><span class="line">                pa = pa-&gt;next;</span><br><span class="line">                pb = pb-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pa-&gt;data.exp &gt; pb-&gt;data.exp)</span><br><span class="line">        &#123;</span><br><span class="line">            New = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;elemType&gt;();</span><br><span class="line"></span><br><span class="line">            New-&gt;data.coef = pb-&gt;data.coef;</span><br><span class="line">            New-&gt;data.exp = pb-&gt;data.exp;</span><br><span class="line"></span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            New = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;elemType&gt;();</span><br><span class="line"></span><br><span class="line">            New-&gt;data.coef = pa-&gt;data.coef;</span><br><span class="line">            New-&gt;data.exp = pa-&gt;data.exp;</span><br><span class="line"></span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        New-&gt;next = <span class="literal">NULL</span>; <span class="comment">//将相加的结果作为新结点尾插到c中</span></span><br><span class="line">        pc-&gt;next = New;</span><br><span class="line">        pc = New;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跳出第一个whlie循环说明a、b中至少一个走完了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pa) <span class="comment">//如过a没走完</span></span><br><span class="line">    &#123;</span><br><span class="line">        New = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;elemType&gt;();</span><br><span class="line"></span><br><span class="line">        New-&gt;data.coef = pa-&gt;data.coef;</span><br><span class="line">        New-&gt;data.exp = pa-&gt;data.exp;</span><br><span class="line">        New-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        pc-&gt;next = New;</span><br><span class="line">        pc = New;</span><br><span class="line"></span><br><span class="line">        pa = pa-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pb) <span class="comment">//如过b没走完</span></span><br><span class="line">    &#123;</span><br><span class="line">        New = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;elemType&gt;();</span><br><span class="line"></span><br><span class="line">        New-&gt;data.coef = pb-&gt;data.coef;</span><br><span class="line">        New-&gt;data.exp = pb-&gt;data.exp;</span><br><span class="line">        New-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        pc-&gt;next = New;</span><br><span class="line">        pc = New;</span><br><span class="line"></span><br><span class="line">        pb = pb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> Polynomial&lt;elemType&gt;::<span class="built_in">dispPoly</span>() <span class="comment">//显示一个多项式</span></span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;elemType&gt; *p;</span><br><span class="line">    p = head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;多项式为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;多项式系数指数对分别为&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data.coef &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p-&gt;data.exp &lt;&lt; endl;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;到此结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> Polynomial&lt;elemType&gt;::<span class="built_in">clear</span>() <span class="comment">//释放多项式空间（清空多项式,仅保留头结点</span></span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;elemType&gt; *p = head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">测试用例test.cpp</span><br><span class="line"></span><br><span class="line">~~~cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;polynomial.cpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Type stop_flag;</span><br><span class="line">   <span class="built_in">getStop</span>(stop_flag);</span><br><span class="line"></span><br><span class="line">   <span class="function">Polynomial&lt;Type&gt; <span class="title">a</span><span class="params">(stop_flag)</span>, <span class="title">b</span><span class="params">(stop_flag)</span>, <span class="title">c</span><span class="params">(stop_flag)</span></span>;</span><br><span class="line"></span><br><span class="line">   a.<span class="built_in">getPoly</span>();</span><br><span class="line">   b.<span class="built_in">getPoly</span>();</span><br><span class="line"></span><br><span class="line">   c.<span class="built_in">addPoly</span>(a, b);</span><br><span class="line">   c.<span class="built_in">dispPoly</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>a&#x3D;7+3x+9x^8^+5x^17^</p><p>b&#x3D;8x+22x^7^-9x^8^</p><p>结果c应该是7+11x+22^7^+5x^17^</p><h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>That’s all, thanks for reading!💐</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_顺序表（C++</title>
      <link href="/chunyujin/bd5238f.html"/>
      <url>/chunyujin/bd5238f.html</url>
      
        <content type="html"><![CDATA[<h3 id="数据结构-SeqList顺序表（C-实现"><a href="#数据结构-SeqList顺序表（C-实现" class="headerlink" title="数据结构_SeqList顺序表（C++实现"></a>数据结构_SeqList顺序表（C++实现</h3><blockquote><p>前言：此类笔记仅用于个人复习，内容主要在于记录和体现个人理解，详细还请结合bite课件、录播、板书和代码。</p></blockquote><p>[toc]</p><h4 id="前言-amp-注意事项"><a href="#前言-amp-注意事项" class="headerlink" title="前言&amp;注意事项"></a>前言&amp;注意事项</h4><blockquote><ol><li><p>有些函数没有修改成员数据的要求，防止成员函数被修改，将只有读取要求的函数设为常函数（只读函数</p></li><li><p>用 C++实现，有很多优势，其中一个就是对象可以直接访问并修改数据成员，不用再想要修改的时候再传地址什么的</p></li><li><p>&#x3D;&#x3D;<strong>assert果然还是太暴力了</strong>，能不用就不用吧，但是一定要记住要判断 表指针 为空的情况&#x3D;&#x3D;</p><ol><li>&#x3D;&#x3D;可以抛出异常信号  (建议用这个，因为运行错误的时候知道原因&#x3D;&#x3D;</li><li>&#x3D;&#x3D;可以直接返回&#x3D;&#x3D;</li><li>判断指针head为空的方式</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head) <span class="comment">// if(!head)等价于if(head==NULL),head==NULL是head为空时等式成立，值为真</span></span><br><span class="line">  <span class="comment">// head为空的话head就相当于0（假），非空就是真，所以当head为空的时候，!head就是真</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();<span class="comment">//这里使用了抛出异常信号的方式,而且抛出的是一个匿名对象(因为要的是它的类型，没必要给对象命名了)</span></span><br><span class="line">               </span><br><span class="line"><span class="comment">//如果采用直接返回的方式</span></span><br><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">    <span class="keyword">return</span>;<span class="comment">//直接返回的话，在有返回类型的函数里面可能会报错</span></span><br><span class="line">               </span><br><span class="line"><span class="comment">//以上两者都可以终止函数，不过直接return只能用在无返回值函数上，return本质是终止函数运行并返回NULL</span></span><br></pre></td></tr></table></figure></li><li><p>其他注意事项在代码注释以及code日记中体现</p></li></ol></blockquote><h4 id="顺序表实现方法"><a href="#顺序表实现方法" class="headerlink" title="顺序表实现方法"></a>顺序表实现方法</h4><p>&#x3D;&#x3D;<strong>注意：这个是带哨兵位的头结点的顺序表！！</strong>&#x3D;&#x3D;</p><p>&#x3D;&#x3D;但是实际上完全没有必要在顺序表上用哨兵位！因为根本不需要找头结点！而且一般情况下顺序表就是不用的，所以用了哨兵位很容易搞混！！！！&#x3D;&#x3D;</p><p>是因为学校的数据结构教材用了才写上的！！教材不好</p><blockquote><p>seqList.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//专门作为异常信息的类（用于异常处理抛出）;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">outofsize</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;<span class="comment">//用于判断非法访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">nullPointer</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;<span class="comment">//用于判断空指针，此处主要用于判断 扩容是否失败 以及 头指针是否为空</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">seqList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">slDataType* elem;       <span class="comment">//用数组实现顺序表</span></span><br><span class="line"><span class="type">int</span> size;               <span class="comment">//顺序表实际大小</span></span><br><span class="line"><span class="type">int</span> capacity;           <span class="comment">//顺序表容量（能存储的除了哨兵位的头结点之外的实际有效数据的个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doubleCapacity</span><span class="params">()</span></span>; <span class="comment">//扩容函数；不过这里没必要单独写出来，只有在添加数据的时候有可能会调用到，其他时候不会用到，所以不会产生函数的复用，不用单独构建这个函数，直接包含在添加数据的函数里面就行</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">seqList</span>(<span class="type">int</span> Size = <span class="number">10</span>); <span class="comment">//初始化顺序表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">seqListEmpty</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//判空，空则返回真，否则返回假</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">seqListFull</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//判满</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">seqListPushHead</span><span class="params">(slDataType x)</span></span>; <span class="comment">//头插</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">seqListPushBack</span><span class="params">(slDataType x)</span></span>; <span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">seqListPopHead</span><span class="params">()</span></span>; <span class="comment">//头删</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">seqListPopBack</span><span class="params">()</span></span>; <span class="comment">//尾删</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">seqListInsert</span><span class="params">(<span class="type">int</span> pos, slDataType&amp; data)</span></span>; <span class="comment">//在任意位置pos插入；此处对元素数据运用了引用，不用再构建形参局部变量，可以减少一点空间开辟，不过个人感觉没有也无伤大雅</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">seqListErase</span><span class="params">(<span class="type">int</span> pos)</span></span>; <span class="comment">//删除pos的元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">seqListRemove</span><span class="params">(<span class="type">int</span> pos, slDataType&amp; e)</span></span>; <span class="comment">//删除pos处的元素，并赋值给e（这里才体现引用的用处</span></span><br><span class="line"></span><br><span class="line"><span class="function">slDataType <span class="title">seqListGet</span><span class="params">(<span class="type">int</span> pos)</span> <span class="type">const</span></span>; <span class="comment">//返回pos处的元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">seqListFind</span><span class="params">(slDataType&amp; data)</span> <span class="type">const</span></span>; <span class="comment">//返回值等于data的元素的位置,没有则返回0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">seqListLength</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//返回顺序表长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">seqListDestory</span><span class="params">()</span></span>; <span class="comment">//清除顺序表，使其成为空表</span></span><br><span class="line"></span><br><span class="line">~<span class="built_in">seqList</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;; <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>seqList.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;seqList.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line">seqList&lt;slDataType&gt;::<span class="built_in">seqList</span>(<span class="type">int</span> Size)<span class="comment">//初始化顺序表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;elem = <span class="keyword">new</span> slDataType[Size];<span class="comment">//开辟动态数组</span></span><br><span class="line"><span class="keyword">if</span> (!elem)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"><span class="keyword">this</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;capacity = Size<span class="number">-1</span>;<span class="comment">//保留第一个元素作为哨兵位的头结点（不过个人认为在顺序表这里没有必要，链表那里才能体现出哨兵位头结点的好处）</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqList&lt;slDataType&gt;::<span class="built_in">doubleCapacity</span>()<span class="comment">//扩容函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(elem);<span class="comment">//感觉判空的时候不如直接用assert，因为为了判空就用异常处理有些大材小用，而且只在判空的时候用assert，这样就直到程序一中断就说明是空指针</span></span><br><span class="line"><span class="comment">//所以关于指针可能为空的情况，我在除了这个函数之外的地方都用的assert，这个用异常处理结构太麻烦了,直接暴力检查就ok</span></span><br><span class="line"></span><br><span class="line">slDataType* newElem = <span class="keyword">new</span> slDataType[capacity * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!newElem)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= size; i++)<span class="comment">//注意，因为是有哨兵位的，所以i的范围是1（头）到size（尾）</span></span><br><span class="line">&#123;</span><br><span class="line">newElem[i] = elem[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> []elem;</span><br><span class="line">elem = newElem;</span><br><span class="line">capacity = capacity * <span class="number">2</span> - <span class="number">1</span>;<span class="comment">//第一个结点要留给哨兵位，capacity是实际能存储的有效数据的个数</span></span><br><span class="line"><span class="comment">//到了这里，感觉写顺序表用哨兵位的头结点真的是，麻烦又没有必要</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line"><span class="type">bool</span> seqList&lt;slDataType&gt;::<span class="built_in">seqListEmpty</span>()<span class="type">const</span><span class="comment">//判空，空则返回真，否则返回假</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!elem)</span><br><span class="line">     <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line"><span class="type">bool</span> seqList&lt;slDataType&gt;::<span class="built_in">seqListFull</span>()<span class="type">const</span><span class="comment">//判满</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!elem)</span><br><span class="line">     <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> size == capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqList&lt;slDataType&gt;::<span class="built_in">seqListPushHead</span>(slDataType x)<span class="comment">//头插</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!elem)</span><br><span class="line">     <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size == capacity)</span><br><span class="line"><span class="built_in">doubleCapacity</span>();<span class="comment">//顺序表满了就扩容</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = size + <span class="number">1</span>; i &gt; <span class="number">1</span>; i --)</span><br><span class="line">&#123;</span><br><span class="line">elem[i] = elem[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">elem[<span class="number">1</span>] = x;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqList&lt;slDataType&gt;::<span class="built_in">seqListPushBack</span>(slDataType x)<span class="comment">//尾插</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!elem)</span><br><span class="line">     <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size == capacity)</span><br><span class="line"><span class="built_in">doubleCapacity</span>();</span><br><span class="line">size++;</span><br><span class="line">elem[size] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqList&lt;slDataType&gt;::<span class="built_in">seqListPopHead</span>()<span class="comment">//头删</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!elem)</span><br><span class="line">     <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">elem[i] = elem[i + <span class="number">1</span>];</span><br><span class="line">size--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullList</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqList&lt;slDataType&gt;::<span class="built_in">seqListPopBack</span>()<span class="comment">//尾删</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!elem)</span><br><span class="line">     <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">size--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullList</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意是带哨兵位头结点的顺序表！！！&#x3D;&#x3D;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqList&lt;slDataType&gt;::<span class="built_in">seqListInsert</span>(<span class="type">int</span> pos, slDataType&amp; data)<span class="comment">//在任意位置pos插入</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!elem)</span><br><span class="line">     <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos &gt; size + <span class="number">1</span> || pos &lt; <span class="number">1</span>)<span class="comment">//pos=1的时候是头插，=size+1的时候是尾插</span></span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">outofsize</span>();</span><br><span class="line"><span class="keyword">if</span> (size == capacity)</span><br><span class="line"><span class="built_in">doubleCapacity</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = size + <span class="number">1</span>; i &gt; pos; i--)</span><br><span class="line">&#123;</span><br><span class="line">elem[i] = elem[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">elem[pos] = data;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqList&lt;slDataType&gt;::<span class="built_in">seqListErase</span>(<span class="type">int</span> pos)<span class="comment">//删除pos的元素</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!elem)</span><br><span class="line">     <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos &gt; size + <span class="number">1</span> || pos &lt; <span class="number">1</span>)<span class="comment">//pos=1的时候是头删，=size+1的时候是尾删</span></span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">outofsize</span>();</span><br><span class="line"><span class="keyword">if</span> (size != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt; size; i++)</span><br><span class="line">elem[i] = elem[i + <span class="number">1</span>];</span><br><span class="line">size--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullList</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqList&lt;slDataType&gt;::<span class="built_in">seqListRemove</span>(<span class="type">int</span> pos, slDataType&amp; e)<span class="comment">//删除pos处的元素，并赋值给e（这里才体现引用的用处</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!elem)</span><br><span class="line">     <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos &gt; size + <span class="number">1</span> || pos &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">outofsize</span>();</span><br><span class="line"></span><br><span class="line">e = elem[pos];</span><br><span class="line"><span class="built_in">seqListErase</span>(pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line">slDataType seqList&lt;slDataType&gt;::<span class="built_in">seqListGet</span>(<span class="type">int</span> pos)<span class="type">const</span><span class="comment">//返回pos处的元素</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!elem)</span><br><span class="line">     <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos &gt; size + <span class="number">1</span> || pos &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">outofsize</span>();</span><br><span class="line"><span class="keyword">return</span> elem[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line"><span class="type">int</span> seqList&lt;slDataType&gt;::<span class="built_in">seqListFind</span>(slDataType&amp; data)<span class="type">const</span><span class="comment">//返回值等于data的元素的位置，没有则返回0（这里采用了一个比较有意思的方式</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!elem)</span><br><span class="line">     <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">elem[<span class="number">0</span>] = data;<span class="comment">//将需要查找的值赋给哨兵位头结点，哨兵位头结点中的数据不属于顺序表中的数据</span></span><br><span class="line"><span class="keyword">for</span> (i = size; i &gt;= <span class="number">0</span>; i--)<span class="comment">//这样的话只需要遍历一遍就好了，没找到的话就会遍历到底，i就直接等于0，比较巧妙</span></span><br><span class="line"><span class="keyword">if</span> (elem[i] == data)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line"><span class="type">int</span> seqList&lt;slDataType&gt;::<span class="built_in">seqListLength</span>()<span class="type">const</span><span class="comment">//返回顺序表长度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!elem)</span><br><span class="line">     <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqList&lt;slDataType&gt;::<span class="built_in">seqListDestory</span>()<span class="comment">//清除顺序表，使其成为空表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!elem)</span><br><span class="line">     <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"><span class="keyword">delete</span>[]elem;</span><br><span class="line">elem = <span class="literal">NULL</span>;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p> 这里只有一点比较重要，并且关系到以后的C++中关于动态内存释放的处理：</p><p> 由于C++中有析构函数，所以不必要额外使用函数来进行动态内存的释放，将销毁动态内存的工作交给析构函数就可以，所以可以有别的函数来做别的工作，比如上面的顺序表，除了完全销毁顺序表之外，还可以清空顺序表（clear函数）：</p><p> 顺序表的头结点也是动态开辟的，但是可以不销毁它，保留下来，这样这个头还在，其他的空间被销毁了，就使得原来的顺序表被清空，再次写入数据的话不用再初始化顺序表，直接用原来的这个头结点就可以</p><p> 在析构函数中，又可以复用clear函数，然后只需要delete掉头结点就可以</p></blockquote><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>&#x3D;&#x3D;注意，本次用的是上面写的seqList，所以是带哨兵位头结点的！所以数组权重跟常规情况不太一样！不过思路无碍&#x3D;&#x3D;</p><p>&#x3D;&#x3D;下面这些函数都是直接在上面👆写好的顺序表头文件中作为成员函数声明的，并在另一个文件中定义的&#x3D;&#x3D;</p><blockquote><p>当然也可以不用作为成员函数，而是重新写一个头文件和源文件，并在头文件中包含单链表的源文件来使用写好的顺序表</p><p>但是因为题目大都是在现有顺序表的基础上进行操作，也就是对顺序表进行操作，不如直接写成顺序表的成员函数，直接在顺序表中调用更方便</p></blockquote><p>1.设计一个函数用来删除大于等于x且小于y的元素,要求要用较高的效率，且空间复杂度为1</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设计一个函数用来删除大于等于x且小于y的元素,要求要用较高的效率，且空间复杂度为1</span></span><br><span class="line"><span class="comment">//这个函数已经声明在了seqList.h中了（否则没法用私有成员，写起来就有点麻烦</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;<span class="comment">//其实不用函数模板，因为题目的要求的前提就是元素是整型，但是因为是成员函数，所以。。。。</span></span><br><span class="line"><span class="type">void</span> seqList&lt;slDataType&gt;::<span class="built_in">del_x_y</span>(<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= size; i++)<span class="comment">//因为本次的顺序表用的是哨兵位的头结点，所以权重从1开始，size为最后一个</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (elem[i] &gt;= x &amp;&amp; elem[i] &lt; y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != j)</span><br><span class="line">            &#123;</span><br><span class="line">                elem[j] = elem[i];</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    size = j;<span class="comment">//这一步也很有特点，本来顺序表中超过size但是小于capacity的空间本来就是存着数据的，赋值只是用数据覆盖原来的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数设计的非常巧妙，时间复杂度也很低，仅为O(N)</p><p>i就相当于一个侦察兵走在后面，把后面符合要求的元素的值向前赋值给到j的位置</p><p>就叫这个方法为<strong>侦察兵法</strong>吧</p></blockquote><p>2.设有一个顺序表，含有2n个整数，其中n个正数，n个负数，设计一个算法，使L中呈现正数负数相间排列。要求时间符复杂度O(N)，空间为1</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设顺序表中由2n数据，n个正数，n个负数，希望用时间复杂度O(n),和空间复杂度O(1),来将顺序表变成正负相间的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqList&lt;slDataType&gt;::<span class="built_in">Switch</span>(<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="number">2</span> * n &amp;&amp; j &lt;= <span class="number">2</span> * n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (elem[i] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (elem[j] &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">                j += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (elem[j] &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                j += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> k = elem[i];</span><br><span class="line">                elem[i] = elem[j];</span><br><span class="line">                elem[j] = k;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">                j += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：</p><p>用两个指针，一个为i，专门指向奇数位置，一个j，指向偶数位置；i、j分别负责判断自己位子上是否为正数、负数。如果i上元素正数，i指向下一个奇数位置；否则停下等j，等到j指向的元素不是负数的时候，i、j上的元素值互换，然后i、j指向自己的下一个。</p></blockquote><p>3.假设两个 元素依值递增有序排列 的线性表A、B分别表示两个集合，求这两个集合的交、并、差，并且要求结果的集合也是递增的有序线性表</p><blockquote><p>一定要注意，a、b都是有序的，这一点很好用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设两个 元素依值递增有序排列 的线性表A、B分别表示两个集合，求这两个集合的 交集 ,并且要求结果的集合也是递增的有序线性表</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqList&lt;slDataType&gt;::<span class="built_in">Same</span>(seqList &amp;a, seqList &amp;b)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (i &lt;= a.<span class="built_in">seqListLength</span>())</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (a.<span class="built_in">seqListGet</span>(i) == b.<span class="built_in">seqListGet</span>(j))</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">seqListPushBack</span>(a.<span class="built_in">seqListGet</span>(i));</span><br><span class="line">         i++;</span><br><span class="line">         j++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">while</span> (a.<span class="built_in">seqListGet</span>(i) &gt; b.<span class="built_in">seqListGet</span>(j))</span><br><span class="line">             j++;</span><br><span class="line">         <span class="keyword">while</span> (a.<span class="built_in">seqListGet</span>(i) &lt; b.<span class="built_in">seqListGet</span>(j))</span><br><span class="line">             i++;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果相等，就入结果；如果a大，就让b后移，再判断；如果b大，就让a后移，再判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设两个 元素依值递增有序排列 的线性表A、B分别表示两个集合，求这两个集合的 并集 ,并且要求结果的集合也是递增的有序线性表</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqList&lt;slDataType&gt;::<span class="built_in">Add</span>(seqList &amp;a, seqList &amp;b)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (i &lt;= a.<span class="built_in">seqListLength</span>() &amp;&amp; j &lt;= b.<span class="built_in">seqListLength</span>())</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">seqListGet</span>(i) &lt;= b.<span class="built_in">seqListGet</span>(j))</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">seqListPushBack</span>(a.<span class="built_in">seqListGet</span>(i));</span><br><span class="line">         i++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (a.<span class="built_in">seqListGet</span>(i) &gt; b.<span class="built_in">seqListGet</span>(j))</span><br><span class="line">     &#123;</span><br><span class="line">         j++;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (i &lt;= a.<span class="built_in">seqListLength</span>())</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">seqListPushBack</span>(a.<span class="built_in">seqListGet</span>(i));</span><br><span class="line">     i++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (j &lt;= b.<span class="built_in">seqListLength</span>())</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">seqListPushBack</span>(b.<span class="built_in">seqListGet</span>(j));</span><br><span class="line">     j++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以a为基础，小于等于b的时候，说明是b中没有的或者是跟b一样的，入结果；大于b的时候，就后移a；如果a后移到最后都没有比b大的，就说明b后面的全都是a中没有的，就把b中的后面的所有的入结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设两个 元素依值递增有序排列 的线性表A、B分别表示两个集合，求这两个集合的 差集 ,并且要求结果的集合也是递增的有序线性表</span></span><br><span class="line"><span class="comment">// a和b的差集，就是a-b，就是a-a交b</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqList&lt;slDataType&gt;::<span class="built_in">Difference</span>(seqList &amp;a, seqList &amp;b)</span><br><span class="line">&#123;</span><br><span class="line"> seqList c;</span><br><span class="line"> c.<span class="built_in">Same</span>(a, b); <span class="comment">// c是ab的交集</span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> i = <span class="number">1</span>, k = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (i &lt;= a.<span class="built_in">seqListLength</span>())</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">while</span> (a.<span class="built_in">seqListGet</span>(i) &lt; c.<span class="built_in">seqListGet</span>(k) &amp;&amp; i &lt;= a.<span class="built_in">seqListLength</span>())<span class="comment">//a里的元素比交集小，就放到结果里，然后再判断a中的下一个</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">seqListPushBack</span>(a.<span class="built_in">seqListGet</span>(i));</span><br><span class="line">         i++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span> (a.<span class="built_in">seqListGet</span>(i) &gt; c.<span class="built_in">seqListGet</span>(k) &amp;&amp; i &lt;= a.<span class="built_in">seqListLength</span>())<span class="comment">//a里的元素比交集大，也放到结果里，a以后的元素一定都不小于交集中现在指向的元素，交集应指向下一个元素（如果现在这个不是最后一个的话</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">seqListPushBack</span>(a.<span class="built_in">seqListGet</span>(i));</span><br><span class="line">         i++;</span><br><span class="line">         <span class="keyword">if</span> (k &lt; c.<span class="built_in">seqListLength</span>())</span><br><span class="line">             k++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果相等，则不入结果，往后比较</span></span><br><span class="line">     i++;</span><br><span class="line">     <span class="keyword">if</span> (k &lt; c.<span class="built_in">seqListLength</span>())</span><br><span class="line">         k++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>4.假设一个顺序表L中所有元素为整数，设计一个算法调整该顺序表，使表中所有小于0的元素放在大于等于0的元素的后面</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设一个顺序表L中所有元素为整数，设计一个算法调整该顺序表，使表中所有小于0的元素放在大于等于0的元素的后面</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqList&lt;slDataType&gt;::<span class="built_in">Change</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=size;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(elem[j]&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k=elem[j];</span><br><span class="line">            elem[j]=elem[i];</span><br><span class="line">            elem[i]=k;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>侦察兵法</strong>，j当侦察兵，如果遇到了小于0的，就跟i进行交换，确保了i经过之后都变成了比0小的</p></blockquote><p>5.设顺序表A中前m个有序，后n个有序，试设计一算法使得整个顺序表有序</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设顺序表A中前m个有序，后n个有序，试设计一算法使得整个顺序表有序</span></span><br><span class="line"><span class="comment">//假设让新顺序表成为递增的：先判断怎么有序的，如果都是递增或者递减，就比较之后让小的进入新顺序表</span></span><br><span class="line"><span class="comment">//如果一个递增一个递减，就让递增的正着，递减的反着，进行比较，然后进入新顺序表</span></span><br><span class="line"><span class="comment">//最后新顺序表赋值给原顺序表</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">slDataType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqList&lt;slDataType&gt;::<span class="built_in">sort_sort</span>(<span class="type">int</span> m, <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    seqList New;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (elem[<span class="number">1</span>] &lt;= elem[<span class="number">2</span>]) <span class="comment">//如果前m个递增</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (elem[m + <span class="number">1</span>] &lt;= elem[m + <span class="number">2</span>]) <span class="comment">//如果后n个递增</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = <span class="number">1</span>;</span><br><span class="line">            j = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= m &amp;&amp; j &lt;= m + n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (elem[i] &lt;= elem[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    New.<span class="built_in">seqListPushBack</span>(elem[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    New.<span class="built_in">seqListPushBack</span>(elem[j]);</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= m)</span><br><span class="line">            &#123;</span><br><span class="line">                New.<span class="built_in">seqListPushBack</span>(elem[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &lt;= m + n)</span><br><span class="line">            &#123;</span><br><span class="line">                New.<span class="built_in">seqListPushBack</span>(elem[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//如果后n个递减</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = <span class="number">1</span>;</span><br><span class="line">            j = m + n;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= m &amp;&amp; j &gt;= m + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (elem[i] &lt;= elem[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    New.<span class="built_in">seqListPushBack</span>(elem[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    New.<span class="built_in">seqListPushBack</span>(elem[j]);</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= m)</span><br><span class="line">            &#123;</span><br><span class="line">                New.<span class="built_in">seqListPushBack</span>(elem[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= m + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                New.<span class="built_in">seqListPushBack</span>(elem[j]);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//如果前m个递减</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (elem[m + <span class="number">1</span>] &lt;= elem[m + <span class="number">2</span>]) <span class="comment">//如果后n个递增</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = m;</span><br><span class="line">            j = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &lt;= m + n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (elem[i] &lt;= elem[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    New.<span class="built_in">seqListPushBack</span>(elem[i]);</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    New.<span class="built_in">seqListPushBack</span>(elem[j]);</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                New.<span class="built_in">seqListPushBack</span>(elem[i]);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &lt;= m + n)</span><br><span class="line">            &#123;</span><br><span class="line">                New.<span class="built_in">seqListPushBack</span>(elem[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//如果后n个递减</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = m;</span><br><span class="line">            j = m + n;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= m + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (elem[i] &lt;= elem[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    New.<span class="built_in">seqListPushBack</span>(elem[i]);</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    New.<span class="built_in">seqListPushBack</span>(elem[j]);</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                New.<span class="built_in">seqListPushBack</span>(elem[i]);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= m + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                New.<span class="built_in">seqListPushBack</span>(elem[j]);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt;= m + n)</span><br><span class="line">    &#123;</span><br><span class="line">        elem[k] = New.<span class="built_in">seqListGet</span>(k);</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析见注释</p></blockquote><h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>That’s all, thanks for reading!💐</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_顺序栈（C++</title>
      <link href="/chunyujin/c000c11f.html"/>
      <url>/chunyujin/c000c11f.html</url>
      
        <content type="html"><![CDATA[<h3 id="数据结构-顺序栈（C-实现"><a href="#数据结构-顺序栈（C-实现" class="headerlink" title="数据结构_顺序栈（C++实现"></a>数据结构_顺序栈（C++实现</h3><blockquote><p>前言：此类笔记仅用于个人复习，内容主要在于记录和体现个人理解，详细还请结合bite课件、录播、板书和代码。</p></blockquote><p>[toc]</p><hr><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>没什么好说的</p><blockquote><ol><li><p>栈的实现可以用顺序结构（数组）实现—–数组栈，也可以用链式结构（链表）实现—–链式栈  。两者除了在结构上不同，还有一点不同就是数组栈是栈底在前面（首结点），栈顶在后面（尾结点），通过尾插尾删入栈出栈，链式栈是栈顶在前面，栈底在后面，通过头插头删入栈出栈，与数组栈方向相反。</p><p>最常用也可以说最好用的大概是数组栈</p></li><li><p>&#x3D;&#x3D;<strong>assert果然还是太暴力了</strong>，能不用就不用吧，但是一定要记住要判断 指针 为空的情况&#x3D;&#x3D;</p><ol><li>&#x3D;&#x3D;可以抛出异常信号  (建议用这个，因为运行错误的时候知道原因&#x3D;&#x3D;</li><li>&#x3D;&#x3D;可以直接返回&#x3D;&#x3D;</li><li>判断指针head为空的方式</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head) <span class="comment">// if(!head)等价于if(head==NULL),head==NULL是head为空时等式成立，值为真</span></span><br><span class="line">  <span class="comment">// head为空的话head就相当于0（假），非空就是真，所以当head为空的时候，!head就是真</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">nullPointer</span>();<span class="comment">//这里使用了抛出异常信号的方式,而且抛出的是一个匿名对象(因为要的是它的类型，没必要给对象命名了)</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">//如果采用直接返回的方式</span></span><br><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">    <span class="keyword">return</span>;<span class="comment">//直接返回的话，在有返回类型的函数里面可能会报错</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">//以上两者都可以终止函数，不过直接return只能用在无返回值函数上，return本质是终止函数运行并返回NULL</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><blockquote><p><strong>seqStack.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">nullPointer</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;; <span class="comment">//用来判断空指针，此处主要用于判断扩容是否失败 以及 顺序表头指针是否为空</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">outofBound</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;; <span class="comment">//用于判断越界</span></span><br><span class="line"><span class="comment">//用作异常处理信号而定义的两个空类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">seqStack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">elemType *array;</span><br><span class="line"><span class="type">int</span> Top;      <span class="comment">//栈顶下标</span></span><br><span class="line"><span class="type">int</span> Capacity; <span class="comment">//栈最大值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doubleSpace</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">seqStack</span>(<span class="type">int</span> initSize = <span class="number">100</span>);                   <span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (Top == <span class="number">-1</span>); &#125;;          <span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (Top == Capacity - <span class="number">1</span>); &#125;; <span class="comment">//判满</span></span><br><span class="line"><span class="function">elemType <span class="title">top</span><span class="params">()</span></span>;                                 <span class="comment">//返回栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> elemType &amp;e)</span></span>;                   <span class="comment">//元素压栈；用const防止被篡改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;                                     <span class="comment">//栈顶元素出栈</span></span><br><span class="line">~<span class="built_in">seqStack</span>() &#123; <span class="keyword">delete</span>[] array; &#125;;                <span class="comment">//销毁栈</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>seqStack.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;seqStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">seqStack&lt;elemType&gt;::<span class="built_in">seqStack</span>(<span class="type">int</span> initSize) <span class="comment">//初始化</span></span><br><span class="line">&#123;</span><br><span class="line">array = <span class="keyword">new</span> <span class="built_in">elemType</span>(initSize);</span><br><span class="line"><span class="keyword">if</span> (!array)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line">Top = <span class="number">-1</span>;</span><br><span class="line">Capacity = initSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqStack&lt;elemType&gt;::<span class="built_in">doubleSpace</span>() <span class="comment">//扩容</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!array) <span class="comment">// assert只用于判断assay是否为空指针，这样就能明确错误来源</span></span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line">elemType *tmp = <span class="keyword">new</span> elemType[Capacity * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!tmp)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= Top; i++) <span class="comment">//往新空间里逐一复制结点</span></span><br><span class="line">tmp[i] = array[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] array;</span><br><span class="line">array = tmp;</span><br><span class="line"></span><br><span class="line">Capacity = Capacity * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">elemType seqStack&lt;elemType&gt;::<span class="built_in">top</span>() <span class="comment">//返回栈顶元素</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!array)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">outofBound</span>();</span><br><span class="line"><span class="keyword">return</span> array[Top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqStack&lt;elemType&gt;::<span class="built_in">push</span>(<span class="type">const</span> elemType &amp;e) <span class="comment">//压栈</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!array)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isFull</span>())</span><br><span class="line"><span class="built_in">doubleSpace</span>();</span><br><span class="line">array[++Top] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqStack&lt;elemType&gt;::<span class="built_in">pop</span>() <span class="comment">//出栈</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!array)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPointer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Top == <span class="number">-1</span>) <span class="comment">//或者if(isEmpty)</span></span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">outofBound</span>();</span><br><span class="line"></span><br><span class="line">Top--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p><strong>有些函数直接作为了上面实现的顺序栈的成员函数，用的时候别忘了在seqStack.h中声明</strong></p><p>1.现有一个元素均为整数的栈，使用另一个临时栈对其进行非递减排序</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqStack&lt;elemType&gt;::<span class="built_in">sort</span>()</span><br><span class="line">&#123;</span><br><span class="line">    seqStack tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = Top; k &gt; <span class="number">-1</span>; k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> K = <span class="built_in">top</span>();</span><br><span class="line">        <span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">isEmpty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            tmp.<span class="built_in">push</span>(K);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!tmp.<span class="built_in">isEmpty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (K &lt;= tmp.<span class="built_in">top</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">push</span>(tmp.<span class="built_in">top</span>());</span><br><span class="line">                    tmp.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.<span class="built_in">push</span>(K);</span><br><span class="line">            <span class="type">int</span> q = Top;</span><br><span class="line">            <span class="keyword">while</span> (q &gt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.<span class="built_in">push</span>(<span class="built_in">top</span>());</span><br><span class="line">                <span class="built_in">pop</span>();</span><br><span class="line">                q--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!tmp.<span class="built_in">isEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">push</span>(tmp.<span class="built_in">top</span>());</span><br><span class="line">        tmp.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>要求对栈进行非递减排序，就是栈底最大，栈顶最小</p><p>思路就是把主栈元素依次出到临时栈来进行排序，在临时栈中排成栈底最小，栈顶最大</p><p>主栈栈顶大于等于临时栈顶，直接出主栈入临时栈</p><p>小于临时栈顶，主栈栈顶先出栈赋值给k，临时栈逐个出栈到主栈，直到临时栈顶小于k，k入临时栈，在将之前放到主栈的临时栈元素放回临时栈</p></blockquote></blockquote><ol start="2"><li></li></ol><p>设计算法判别表达式中的括号是否配对出现， 平衡的表达式中’{‘、’}’，’(‘、’)’，’[‘、’]’ 应成对按序出现。</p><p> 例如”{[()]{()}{<a href="">()()</a>}}” 是括号匹配的表达式， 而”[({}])”是括号不匹配的表达式</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> seqStack&lt;elemType&gt;::<span class="built_in">parentheses</span>(string s)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> size = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; size; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[x] == <span class="string">&#x27;(&#x27;</span> || s[x] == <span class="string">&#x27;&#123;&#x27;</span> || s[x] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">push</span>(s[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[x] == <span class="string">&#x27;)&#x27;</span> || s[x] == <span class="string">&#x27;&#125;&#x27;</span> || s[x] == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[x] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; <span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                <span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[x] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; <span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                <span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[x] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; <span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                <span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isEmpty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bite讲过了</p></blockquote><ol start="3"><li></li></ol><p>用两个栈实现队列</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    seqStack&lt;elemType&gt; a, b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> elemType &amp;x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        b.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">while</span> (!b.<span class="built_in">isEmpty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                a.<span class="built_in">push</span>(b.<span class="built_in">top</span>());</span><br><span class="line">                b.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">elemType <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">while</span> (!b.<span class="built_in">isEmpty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                a.<span class="built_in">push</span>(b.<span class="built_in">top</span>());</span><br><span class="line">                b.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a.<span class="built_in">isEmpty</span>() &amp;&amp; b.<span class="built_in">isEmpty</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原理：一个栈负责入队列，一个栈负责出队列，一旦出队列栈为空，就把入队列栈中所有元素都出到出队列栈</p></blockquote><ol start="4"><li></li></ol><p>给定一个整型的顺序表， 表示在同一行的行星。 对于其中的元素， 正负值代表其一维的移动方向， 可以理解为正数代表行星向右移动， 负数代表行星向左移动。 方向相同的行星不会碰撞， 如果两个行星相向而行则会相互碰撞， 则较小的行星（绝对值代表行星大小）会爆炸， 大小相同时两者都会爆炸。 请设计程序给出行星碰撞后的结果。<br>例如： [4， 5， -3]， 5 与-3 发生碰撞， -3 爆炸而 5 幸存， 再没有负数即向左运动行星，碰撞结束结果为[4， 5]； [7， 1， -7]， 1 与-7碰撞， 1 爆炸而-7 幸存， 7 再与-7 碰撞， 两者都爆炸， 结果为[]。 注意如果是[-1,1]， 由于-1 向左而 1 向右， 两者不会碰撞。  </p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqStack&lt;elemType&gt;::<span class="built_in">planet</span>()</span><br><span class="line">&#123;</span><br><span class="line">    seqStack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">isEmpty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(<span class="built_in">top</span>());</span><br><span class="line">            <span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">top</span>() &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">top</span>() &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    s.<span class="built_in">push</span>(<span class="built_in">top</span>());</span><br><span class="line">                    <span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s.<span class="built_in">top</span>() + <span class="built_in">top</span>() &gt; <span class="number">0</span>)</span><br><span class="line">                        s.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (s.<span class="built_in">top</span>() + <span class="built_in">top</span>() &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        s.<span class="built_in">pop</span>();</span><br><span class="line">                        <span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">top</span>());</span><br><span class="line">                <span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">isEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">push</span>(s.<span class="built_in">top</span>());</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：（有点 类似中缀式转后缀式）</p><p>这个顺序表就是主栈，再创建一个临时栈</p><p>临时栈为空，主栈栈顶进临时栈；主栈栈顶是小于0的，进临时栈；主栈栈顶大于0，临时栈小于零，判断他俩的和，大于零说明主栈栈顶绝对值大，保留主栈栈顶，临时栈顶出栈，否则反之，如果和等0，则两边都出栈。最后主栈空了就临时栈出栈到主栈</p><p>因为结果保存在了栈里，输出的时候顺序是反的，不过只要再写一个逆置的函数就可以，比如把栈元素放到队列了，再出队列到栈就可以了</p></blockquote><ol start="5"><li></li></ol><p>现有一个柱状图中，其中每个矩形柱子皆为相邻，且宽度相等，默认为 1，现在需要知道在这个柱形图中能够找到的最大矩形的面积。数据用一组非负的整数来表示，代表每根柱形的高度，请算出最大矩形的面积。</p><p>例如，已知每根柱形的宽度为 1，若给出的非负整数为[3,2,7,5,4,1]。图中的阴影部分为 最大矩形的面积，即 12 个单位的面积。</p> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210120036203.png" alt="截屏2022-10-11 21.47.51" style="zoom: 33%;" /><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Rectangle</span><span class="params">(seqStack&lt;<span class="type">int</span>&gt; now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    seqStack&lt;<span class="type">int</span>&gt; pass;</span><br><span class="line">    seqStack&lt;<span class="type">int</span>&gt; elem;</span><br><span class="line">    <span class="type">int</span> rectangle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!now.<span class="built_in">isEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d = now.<span class="built_in">top</span>();</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        now.<span class="built_in">pop</span>();</span><br><span class="line">        elem.<span class="built_in">push</span>(d);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pass.<span class="built_in">isEmpty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pass.<span class="built_in">top</span>() &gt;= d)</span><br><span class="line">            &#123;</span><br><span class="line">                elem.<span class="built_in">push</span>(pass.<span class="built_in">top</span>());</span><br><span class="line">                pass.<span class="built_in">pop</span>();</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!now.<span class="built_in">isEmpty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (now.<span class="built_in">top</span>() &gt;= d)</span><br><span class="line">            &#123;</span><br><span class="line">                elem.<span class="built_in">push</span>(now.<span class="built_in">top</span>());</span><br><span class="line">                now.<span class="built_in">pop</span>();</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> r = d * (<span class="number">1</span> + p + n);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; rectangle)</span><br><span class="line">            rectangle = r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            now.<span class="built_in">push</span>(elem.<span class="built_in">top</span>());</span><br><span class="line">            elem.<span class="built_in">pop</span>();</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!elem.<span class="built_in">isEmpty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            pass.<span class="built_in">push</span>(elem.<span class="built_in">top</span>());</span><br><span class="line">            elem.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rectangle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用栈</p><p>一个现在栈now（也是形参）</p><p>开两个临时站”临时站elem“、”过去栈pass“</p><p>如果判断一个元素能形成的矩形的面积，要往它的左右相邻看（不能中断），如果有左、右大于它，就能和左、右构成矩形，也就是这个矩形的高是这个元素，宽是构成矩形的元素的个数</p><p>元素是now栈的栈顶，pass栈里存放的是判断过的元素，也就是正在判断的元素的右面的元素，而正在判断的元素左边的元素就是now里的</p><p>先将判断的元素出栈，赋值给d，并入栈到elem，elem是一个用来集合符合左右大于判断的元素的元素的栈，elem里的元素都是能构成矩形的元素</p><p>先判断 被判断的元素右面有没有可以和它组成矩形的元素，也就是从pass里找，如果栈顶大于，就出pass到elem中，再看pass的新栈顶，直到pass栈顶小于被判断的元素。pass每出一个元素到elem中，就用p计数，p++。p用来记录被判断的元素右面有几个可以和它组成矩形的元素。</p><p>再看 被判断的元素左面，也就是从now里找，因为被判断的元素已经出now了，所以现在now里是新栈顶，如果now栈顶大于被判断的元素，就出now到elem，再看新栈顶，直到now栈顶小于被判断的元素。用n计数出now到elem的元素个数。</p><p>现在就可以计算当前被判断的元素能组成的矩形面积了：高（d） *  宽（p+n+1），其中1是被判断的元素自己，p+n+1就是组成矩形的元素的个数，也就是elem里元素的个数</p><p>因为进elem的顺序是：</p><p>d、p个pass栈的、n个now栈的</p><p>而now、pass栈进了elem还得出来，因为elem只是起统计作用的，不能破坏原来now和pass的内容</p><p>因为elem的元素还要回到now和pass里</p><p>now最后进的，就先出，进了n个，就每次出一个，n–，直到n&#x3D;0，说明elem里now的元素都返回now了</p><p>elem里剩下的全部进pass就可以，因为elem栈底的d刚刚被判断过了，应该属于pass了，即元素出elem到pass直到elem空</p>  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210120036336.jpeg" alt="IMG_0648" style="zoom:40%;" /> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210120036665.jpeg" alt="IMG_0649" style="zoom:40%;" /><p> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210120036188.jpeg" alt="IMG_0650" style="zoom:40%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210120020565.jpeg" alt="IMG_0651" style="zoom:40%;" /></p></blockquote><h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>That’s all, thanks for reading!💐</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_栈和队列_作业</title>
      <link href="/chunyujin/50d8fc49.html"/>
      <url>/chunyujin/50d8fc49.html</url>
      
        <content type="html"><![CDATA[<h3 id="2022-10-10智慧树作业-栈和队列"><a href="#2022-10-10智慧树作业-栈和队列" class="headerlink" title="2022.10.10智慧树作业_栈和队列"></a>2022.10.10智慧树作业_栈和队列</h3><p>[toc]</p><h4 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h4><p>相同点：</p><p>在逻辑上都是线性结构，栈和队列本质就是特殊的线性表，都可以用链表或者顺序表进行存储</p><p>不同点：</p><p>栈、队列具有特定的性质，特定的运算规则</p><h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h4><p>1 2 3 4 5、1 2 3 5 4、1 2 4 3 5、1 2 4 5 3、1 2 5 4 3、1 3 2 4 5、1 3 2 5 4、1 3 4 2 5、1 3 4 5 2、1 3 5 4 2、1 4 3 2 5、1 4 3 5 2、1 4 5 3 2、1 5 4 3 2、2 1 3 4 5、2 1 3 5 4、2 1 4 3 5、2 1 4 5 3、2 1 5 4 3、2 3 1 4 5、2 3 1 5 4、2 3 4 1 5、2 3 4 5 1、2 3 5 4 1、2 4 3 1 5、2 4 3 5 1、2 4 5 3 1、2 5 4 3 1、3 2 1 4 5、3 2 1 5 4、3 2 4 1 5、3 2 4 5 1、3 2 5 4 1、3 4 2 1 5、3 4 2 5 1、3 4 5 2 1、3 5 4 2 1、4 3 2 1 5、4 3 2 5 1、4 3 5 2 1、4 5 3 2 1、5 4 3 2 1</p><h4 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h4><p>现有一个元素均为整数的栈，使用另一个临时栈对其进行非递减排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqStack&lt;elemType&gt;::<span class="built_in">sort</span>()</span><br><span class="line">&#123;</span><br><span class="line">    seqStack tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = Top; k &gt; <span class="number">-1</span>; k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> K = <span class="built_in">top</span>();</span><br><span class="line">        <span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">isEmpty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            tmp.<span class="built_in">push</span>(K);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!tmp.<span class="built_in">isEmpty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (K &lt;= tmp.<span class="built_in">top</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">push</span>(tmp.<span class="built_in">top</span>());</span><br><span class="line">                    tmp.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.<span class="built_in">push</span>(K);</span><br><span class="line">            <span class="type">int</span> q = Top;</span><br><span class="line">            <span class="keyword">while</span> (q &gt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.<span class="built_in">push</span>(<span class="built_in">top</span>());</span><br><span class="line">                <span class="built_in">pop</span>();</span><br><span class="line">                q--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!tmp.<span class="built_in">isEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">push</span>(tmp.<span class="built_in">top</span>());</span><br><span class="line">        tmp.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>要求对栈进行非递减排序，就是栈底最大，栈顶最小</p><p>思路就是把主栈元素依次出到临时栈来进行排序，在临时栈中排成栈底最小，栈顶最大</p><p>主栈栈顶大于等于临时栈顶，直接出主栈入临时栈</p><p>小于临时栈顶，主栈栈顶先出栈赋值给k，临时栈逐个出栈到主栈，直到临时栈顶小于k，k入临时栈，在将之前放到主栈的临时栈元素放回临时栈</p></blockquote><h4 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h4><p>设计算法判别表达式中的括号是否配对出现， 平衡的表达式中’{‘、’}’，’(‘、’)’，’[‘、’]’ 应成对按序出现。</p><p> 例如”{[()]{()}{<a href="">()()</a>}}” 是括号匹配的表达式， 而”[({}])”是括号不匹配的表达式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> seqStack&lt;elemType&gt;::<span class="built_in">parentheses</span>(string s)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> size = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; size; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[x] == <span class="string">&#x27;(&#x27;</span> || s[x] == <span class="string">&#x27;&#123;&#x27;</span> || s[x] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">push</span>(s[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[x] == <span class="string">&#x27;)&#x27;</span> || s[x] == <span class="string">&#x27;&#125;&#x27;</span> || s[x] == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[x] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; <span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                <span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[x] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; <span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                <span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[x] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; <span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                <span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isEmpty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h4><p>用两个栈实现队列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    seqStack&lt;elemType&gt; a, b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> elemType &amp;x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        b.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">while</span> (!b.<span class="built_in">isEmpty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                a.<span class="built_in">push</span>(b.<span class="built_in">top</span>());</span><br><span class="line">                b.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">elemType <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">while</span> (!b.<span class="built_in">isEmpty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                a.<span class="built_in">push</span>(b.<span class="built_in">top</span>());</span><br><span class="line">                b.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a.<span class="built_in">isEmpty</span>() &amp;&amp; b.<span class="built_in">isEmpty</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原理：一个栈负责入队列，一个栈负责出队列，一旦出队列栈为空，就把入队列栈中所有元素都出到出队列栈</p><h4 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h4><p>用两个队列实现栈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用两个队列实现栈</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt; <span class="comment">//先写一个求队列元素个数的函数，后面会用</span></span><br><span class="line"><span class="type">int</span> Queue&lt;elemType&gt;::<span class="built_in">size</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;elemType&gt; *p = head;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        x++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Queue&lt;elemType&gt; a, b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> elemType &amp;x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!a.<span class="built_in">isEmpty</span>())</span><br><span class="line">            a.<span class="built_in">pushQueue</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.<span class="built_in">pushQueue</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// assert(!a.isEmpty() &amp;&amp; !b.isEmpty());</span></span><br><span class="line">        Queue&lt;elemType&gt; *qEmpty = a.<span class="built_in">isEmpty</span>() ? &amp;a : &amp;b;</span><br><span class="line">        Queue&lt;elemType&gt; *qUnEmpty = a.<span class="built_in">isEmpty</span>() ? &amp;b : &amp;a;</span><br><span class="line">        <span class="keyword">while</span> (qUnEmpty-&gt;<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qEmpty-&gt;<span class="built_in">pushQueue</span>(qUnEmpty-&gt;<span class="built_in">getHead</span>());</span><br><span class="line">            qUnEmpty-&gt;<span class="built_in">popQueue</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        qUnEmpty-&gt;<span class="built_in">popQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">elemType <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// assert(a.isEmpty() &amp;&amp; !b.isEmpty());</span></span><br><span class="line">        Queue&lt;elemType&gt; *qEmpty = a.<span class="built_in">isEmpty</span>() ? &amp;a : &amp;b;</span><br><span class="line">        Queue&lt;elemType&gt; *qUnEmpty = a.<span class="built_in">isEmpty</span>() ? &amp;b : &amp;a;</span><br><span class="line">        <span class="keyword">while</span> (qUnEmpty-&gt;<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qEmpty-&gt;<span class="built_in">pushQueue</span>(qUnEmpty-&gt;<span class="built_in">getHead</span>());</span><br><span class="line">            qUnEmpty-&gt;<span class="built_in">popQueue</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x = qUnEmpty-&gt;<span class="built_in">getHead</span>();</span><br><span class="line">        qEmpty-&gt;<span class="built_in">pushQueue</span>(qUnEmpty-&gt;<span class="built_in">getHead</span>());</span><br><span class="line">        qUnEmpty-&gt;<span class="built_in">popQueue</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两个队列，一个总是空的，一个总是不空的</p><p>入栈就进非空队列，出栈把非空队列的前n个出到空队列，pop非空队列最后一个元素</p><p>非空队列就变成了空队列，空队列就变成了非队列</p><h4 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h4><p>现有一个整数队列， 需要将其前 k 个元素进行逆置， 剩余的元素保持原来的顺序。<br>例如队列[1， 2， 3， 4， 5， 6， 7， 8， 9]， 若 k 为 4， 则需要将队列调整为[4， 3， 2， 1， 5，6， 7， 8， 9]  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> Queue&lt;elemType&gt;::<span class="built_in">Reverse_k</span>(<span class="type">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    Queue&lt;elemType&gt; q;</span><br><span class="line">    seqStack&lt;elemType&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;k)<span class="comment">//前k个元素放到栈中</span></span><br><span class="line">    &#123;</span><br><span class="line">        s.<span class="built_in">push</span>(<span class="built_in">getHead</span>());</span><br><span class="line">        <span class="built_in">popQueue</span>();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(head)<span class="comment">//后n-k个元素放到临时队列中</span></span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">pushQueue</span>(<span class="built_in">getHead</span>());</span><br><span class="line">        <span class="built_in">popQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">isEmpty</span>())<span class="comment">//栈中的元素放到主队列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushQueue</span>(s.<span class="built_in">top</span>());</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.head!=<span class="literal">NULL</span>)<span class="comment">//临时队列的元素放到主队列中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushQueue</span>(q.<span class="built_in">getHead</span>());</span><br><span class="line">        q.<span class="built_in">popQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：前k个元素放到临时栈，后n-k个元素放到临时队列，再从临时栈中入到主栈，临时队列入到主栈</p><h4 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h4><p>给定一个整型的顺序表， 表示在同一行的行星。 对于其中的元素， 正负值代表其一维的移动方向， 可以理解为正数代表行星向右移动， 负数代表行星向左移动。 方向相同的行星不会碰撞， 如果两个行星相向而行则会相互碰撞， 则较小的行星（绝对值代表行星大小）会爆炸， 大小相同时两者都会爆炸。 请设计程序给出行星碰撞后的结果。<br>例如： [4， 5， -3]， 5 与-3 发生碰撞， -3 爆炸而 5 幸存， 再没有负数即向左运动行星，碰撞结束结果为[4， 5]； [7， 1， -7]， 1 与-7碰撞， 1 爆炸而-7 幸存， 7 再与-7 碰撞， 两者都爆炸， 结果为[]。 注意如果是[-1,1]， 由于-1 向左而 1 向右， 两者不会碰撞。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> seqStack&lt;elemType&gt;::<span class="built_in">planet</span>()</span><br><span class="line">&#123;</span><br><span class="line">    seqStack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">isEmpty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(<span class="built_in">top</span>());</span><br><span class="line">            <span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">top</span>() &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">top</span>() &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    s.<span class="built_in">push</span>(<span class="built_in">top</span>());</span><br><span class="line">                    <span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s.<span class="built_in">top</span>() + <span class="built_in">top</span>() &gt; <span class="number">0</span>)</span><br><span class="line">                        s.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (s.<span class="built_in">top</span>() + <span class="built_in">top</span>() &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        s.<span class="built_in">pop</span>();</span><br><span class="line">                        <span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">top</span>());</span><br><span class="line">                <span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">isEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">push</span>(s.<span class="built_in">top</span>());</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：（有点 类似中缀式转后缀式）</p><p>这个顺序表就是主栈，再创建一个临时栈</p><p>临时栈为空，主栈栈顶进临时栈；主栈栈顶是小于0的，进临时栈；主栈栈顶大于0，临时栈小于零，判断他俩的和，大于零说明主栈栈顶绝对值大，保留主栈栈顶，临时栈顶出栈，否则反之，如果和等0，则两边都出栈。最后主栈空了就临时栈出栈到主栈</p><p>因为结果保存在了栈里，输出的时候顺序是反的，不过只要再写一个逆置的函数就可以，比如把栈元素放到队列了，再出队列到栈就可以了</p><h4 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h4><p>现在有一批同学需要接收面试， 参加面试的同学按照先到先面试的原则接受面试官的考查。 本次面试中面试官最看重的是同学的成绩， 现在面试官小明需要你设计程序实现以下功能：<br>（1） 某位同学加入面试队伍， 输入其名字和成绩；<br>（2） 队伍最前端的同学的面试结束， 离开场地；<br>（3） 小明想知道当前面试队伍里最好成绩是多少。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">interview_team</span>; <span class="comment">//类的向前声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">interview_team</span>&lt;elemType&gt;; <span class="comment">//看作Node的友元类,友元类可以访问Node的私有成员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> point;</span><br><span class="line">    iNode&lt;elemType&gt; *next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">iNode</span>(string name = <span class="string">&quot;null&quot;</span>, <span class="type">int</span> point = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;point = point;</span><br><span class="line">        next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">interview_team</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    iNode&lt;elemType&gt; *head, *tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">interview_team</span>() &#123; head = tail = <span class="literal">NULL</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">i_push</span><span class="params">(string name, <span class="type">int</span> point)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head = tail = <span class="keyword">new</span> <span class="built_in">iNode</span>&lt;elemType&gt;(name, point);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next = <span class="keyword">new</span> <span class="built_in">iNode</span>&lt;elemType&gt;(name, point);</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">i_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        iNode&lt;elemType&gt; *p = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">delete</span> (p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">            tail == <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">i_best</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        iNode&lt;elemType&gt; *p = head;</span><br><span class="line">        <span class="type">int</span> best = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;point &gt; best)</span><br><span class="line">                best = p-&gt;point;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> best;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路：其实就是实现STL的队列中的部分功能</p><h4 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h4><p>现有一个柱状图中，其中每个矩形柱子皆为相邻，且宽度相等，默认为 1，现在需要知道在这个柱形图中能够找到的最大矩形的面积。数据用一组非负的整数来表示，代表每根柱形的高度，请算出最大矩形的面积。</p><p>例如，已知每根柱形的宽度为 1，若给出的非负整数为[3,2,7,5,4,1]。图中的阴影部分为 最大矩形的面积，即 12 个单位的面积。</p> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210112148459.png" alt="截屏2022-10-11 21.47.51" style="zoom: 33%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Rectangle</span><span class="params">(seqStack&lt;<span class="type">int</span>&gt; now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    seqStack&lt;<span class="type">int</span>&gt; pass;</span><br><span class="line">    seqStack&lt;<span class="type">int</span>&gt; elem;</span><br><span class="line">    <span class="type">int</span> rectangle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!now.<span class="built_in">isEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d = now.<span class="built_in">top</span>();</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        now.<span class="built_in">pop</span>();</span><br><span class="line">        elem.<span class="built_in">push</span>(d);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pass.<span class="built_in">isEmpty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pass.<span class="built_in">top</span>() &gt;= d)</span><br><span class="line">            &#123;</span><br><span class="line">                elem.<span class="built_in">push</span>(pass.<span class="built_in">top</span>());</span><br><span class="line">                pass.<span class="built_in">pop</span>();</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!now.<span class="built_in">isEmpty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (now.<span class="built_in">top</span>() &gt;= d)</span><br><span class="line">            &#123;</span><br><span class="line">                elem.<span class="built_in">push</span>(now.<span class="built_in">top</span>());</span><br><span class="line">                now.<span class="built_in">pop</span>();</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> r = d * (<span class="number">1</span> + p + n);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; rectangle)</span><br><span class="line">            rectangle = r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            now.<span class="built_in">push</span>(elem.<span class="built_in">top</span>());</span><br><span class="line">            elem.<span class="built_in">pop</span>();</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!elem.<span class="built_in">isEmpty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            pass.<span class="built_in">push</span>(elem.<span class="built_in">top</span>());</span><br><span class="line">            elem.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rectangle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用栈</p><p>一个现在栈now（也是形参）</p><p>开两个临时站”临时站elem“、”过去栈pass“</p><p>如果判断一个元素能形成的矩形的面积，要往它的左右相邻看（不能中断），如果有左、右大于它，就能和左、右构成矩形，也就是这个矩形的高是这个元素，宽是构成矩形的元素的个数</p><p>元素是now栈的栈顶，pass栈里存放的是判断过的元素，也就是正在判断的元素的右面的元素，而正在判断的元素左边的元素就是now里的</p><p>先将判断的元素出栈，赋值给d，并入栈到elem，elem是一个用来集合符合左右大于判断的元素的元素的栈，elem里的元素都是能构成矩形的元素</p><p>先判断 被判断的元素右面有没有可以和它组成矩形的元素，也就是从pass里找，如果栈顶大于，就出pass到elem中，再看pass的新栈顶，直到pass栈顶小于被判断的元素。pass每出一个元素到elem中，就用p计数，p++。p用来记录被判断的元素右面有几个可以和它组成矩形的元素。</p><p>再看 被判断的元素左面，也就是从now里找，因为被判断的元素已经出now了，所以现在now里是新栈顶，如果now栈顶大于被判断的元素，就出now到elem，再看新栈顶，直到now栈顶小于被判断的元素。用n计数出now到elem的元素个数。</p><p>现在就可以计算当前被判断的元素能组成的矩形面积了：高（d） *  宽（p+n+1），其中1是被判断的元素自己，p+n+1就是组成矩形的元素的个数，也就是elem里元素的个数</p><p>因为进elem的顺序是：</p><p>d、p个pass栈的、n个now栈的</p><p>而now、pass栈进了elem还得出来，因为elem只是起统计作用的，不能破坏原来now和pass的内容</p><p>因为elem的元素还要回到now和pass里</p><p>now最后进的，就先出，进了n个，就每次出一个，n–，直到n&#x3D;0，说明elem里now的元素都返回now了</p><p>elem里剩下的全部进pass就可以，因为elem栈底的d刚刚被判断过了，应该属于pass了，即元素出elem到pass直到elem空</p>  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210120020062.jpeg" alt="IMG_0648" style="zoom:40%;" /> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210120020753.jpeg" alt="IMG_0649" style="zoom:40%;" /><p> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210120022690.jpeg" alt="IMG_0650" style="zoom:40%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210120020565.jpeg" alt="IMG_0651" style="zoom:40%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_树、二叉树、森林的转换</title>
      <link href="/chunyujin/198a61ec.html"/>
      <url>/chunyujin/198a61ec.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h5 id="树-转-二叉树"><a href="#树-转-二叉树" class="headerlink" title="树 转 二叉树"></a>树 转 二叉树</h5><ol><li>加线。在所有兄弟结点之间加一条连线</li><li>抹线。对树中的每个结点，只保留与第一个孩子之间连线，删除与其他孩子的连线</li><li>整理。适当旋转一下，使之结构分明</li></ol><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210231055407.png" alt="截屏2022-10-23 10.53.13" style="zoom:50%;" /><h5 id="森林-转-二叉树"><a href="#森林-转-二叉树" class="headerlink" title="森林 转 二叉树"></a>森林 转 二叉树</h5><ol><li>把每棵树转换成二叉树</li><li>从第一棵二叉树开始，把后一棵二叉树作为前一棵二叉树根结点的右子树</li></ol><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210231058836.png" alt="截屏2022-10-23 10.58.09" style="zoom:50%;" /><h5 id="二叉树-转-树"><a href="#二叉树-转-树" class="headerlink" title="二叉树 转 树"></a>二叉树 转 树</h5><p>就是树 转 二叉树 的逆过程</p><ol><li>作为根结点的每个结点，与左孩子的右孩子以及这个右孩子的右孩子、右孩子的右孩子……建立连线</li><li>删除原来所有父结点与右孩子的连线</li><li>整理</li></ol><p>图：见 树 转 二叉树 的dcba顺序</p><h5 id="二叉树-转-森林"><a href="#二叉树-转-森林" class="headerlink" title="二叉树 转 森林"></a>二叉树 转 森林</h5><ol><li>删除原来所有父结点与右孩子结点的连线，得到分离的二叉树</li><li>将分离的每棵二叉树转化为树</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_线性表应用_稀疏矩阵</title>
      <link href="/chunyujin/cbfc2a79.html"/>
      <url>/chunyujin/cbfc2a79.html</url>
      
        <content type="html"><![CDATA[<h3 id="数据结构-线性表应用-稀疏矩阵"><a href="#数据结构-线性表应用-稀疏矩阵" class="headerlink" title="数据结构_线性表应用 _稀疏矩阵"></a>数据结构_线性表应用 _稀疏矩阵</h3><p>[toc]</p><h4 id="什么是稀疏矩阵"><a href="#什么是稀疏矩阵" class="headerlink" title="什么是稀疏矩阵"></a>什么是稀疏矩阵</h4><blockquote><p>如果一个矩阵中，0的数量远大于非0的数量（0超过一半以上），这个矩阵就是稀疏矩阵</p><p>由于全部都是重复的0，这种无用的重复值的存储会占据很多空间，造成浪费</p></blockquote><h4 id="如何简化系数矩阵的表示"><a href="#如何简化系数矩阵的表示" class="headerlink" title="如何简化系数矩阵的表示"></a>如何简化系数矩阵的表示</h4><blockquote><p>只需要存储非零的数据以及它在矩阵中的位置就可以</p><p>比如一个二维矩阵，就可以用一个三元组进行表示，（行，列，数据）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">triple</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> row,col;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>然后以三元组为基本元素，用顺序表或者链表就可以表示出稀疏矩阵了</p><h4 id="十字链表表示法"><a href="#十字链表表示法" class="headerlink" title="十字链表表示法"></a>十字链表表示法</h4><blockquote><p>由于用顺序表或者一般的链表，在表示稀疏矩阵的时候，不便于进行计算的操作</p><p>这里采用<font color=Red>十字链表</font>来表示</p><p>十字链表包括 数据域（data）、同列的下一个结点（down）、同行的下一个结点（right）</p> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/EE11C79765A37CD3D79BEF5E1B7B6E73.png" alt="img" style="zoom:25%;" /><p>用来表示稀疏矩阵的时候，data就是三元组</p> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/ED4E7F71E975295E0EC543183F2FE45D.png" alt="img" style="zoom:25%;" /><p>如果同列&#x2F;行中没有了下一个（非零）结点，那down&#x2F;right就指向NULL</p><p>画个图表示一下</p> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/CA0CE6F2CF4E36FA28F891988C384829.png" alt="img" style="zoom: 33%;" /></blockquote><h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>That’s all, thanks for reading!💐</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>butterfly修改白天模式下页脚图片亮暗程度</title>
      <link href="/chunyujin/f75eee43.html"/>
      <url>/chunyujin/f75eee43.html</url>
      
        <content type="html"><![CDATA[<p>打开文件themes&#x2F;butterfly&#x2F;source&#x2F;css&#x2F;_layout&#x2F;footer.styl</p><p>在大约第7行开始</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202302191803441.png" alt="截屏2023-02-19 18.03.19"></p><p>在“background-color”这一行中可以调整小数值的大小，来控制页脚图片颜色深度，小数值越大，颜色越深</p><p>修改前：</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202302191804884.png" alt="截屏2023-02-19 18.03.19"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202302191805179.jpg" alt="截屏2023-02-19 18.04.46"></p><p>修改后：</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202302191805674.png" alt="截屏2023-02-19 18.04.22"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202302191806534.jpg" alt="截屏2023-02-19 18.05.47"></p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开启页面模糊效果下修改深色模式下页头页脚亮度</title>
      <link href="/chunyujin/1cfcafc1.html"/>
      <url>/chunyujin/1cfcafc1.html</url>
      
        <content type="html"><![CDATA[<h1 id="开启页面模糊效果下修改深色模式下页头页脚亮度"><a href="#开启页面模糊效果下修改深色模式下页头页脚亮度" class="headerlink" title="开启页面模糊效果下修改深色模式下页头页脚亮度"></a>开启页面模糊效果下修改深色模式下页头页脚亮度</h1><p>如果魔改了主页面，开启了模糊效果，那么在修改深色模式下主页封面和页脚就不能只靠修改&#x2F;themes&#x2F;sourcs&#x2F;css&#x2F;_mode&#x2F;darkmode.styl的信息来实现了</p><p>因为在darkmode.styl中，页头页脚和背景，同属于background，也就是说修改的时候这三者是一起修改的，但是由于魔改模糊效果之后，对于背景的设置(准确来说是页头页脚的设置)会覆盖掉darkmode.styl中的效果，所以在darkmode.styl中修改background的时候，只能影响到深色模式下背景图片的深度，而无法影响页头页脚</p><blockquote><p>如何修改主页和文章页面的页头页脚的深度：</p><p>在魔改页面模糊效果之后往往在主题配置文件themes&#x2F;butterfly&#x2F;_config.yml的inject的head处会有引用，我们找到这处引用，看到引用的文件，我的是&#x2F;css&#x2F;custom.css，我们打开这个文件即可</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301212254550.png" alt="截屏2023-01-21 22.47.28"></p><p>在themes&#x2F;butterfly&#x2F;source&#x2F;css&#x2F;custom.css中，找到此处(只管未注释的内容，注释是笔者自己家加的)</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301212256703.png" alt="截屏2023-01-21 22.47.11"></p><p>修改为以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[data-theme=&quot;dark&quot;] #footer::before &#123; /* footer也就是页脚 */</span><br><span class="line">  background:  rgba(0, 0, 0, 0.3); /* 原来是此处transparent !important，也就是纯透明，不暗化；</span><br><span class="line">  现在被改成了自定义的；当然也可以用*var(--trans-dark)，也就是跟上面一样，用上面预设好的*/</span><br><span class="line">&#125;</span><br><span class="line">[data-theme=&quot;dark&quot;] #page-header::before &#123; /* pafe-header也就是页头 */</span><br><span class="line">  background:  rgba(0, 0, 0, 0.4); /* 原来是此处transparent !important，也就是纯透明，不暗化；</span><br><span class="line">  现在被改成了自定义的；当然也可以用*var(--trans-dark)，也就是跟上面一样，用上面预设好的*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中raga中的前三个值是遮罩的颜色，深色模式一般就用黑色，第四个值代表的是遮罩的深度，取值范围为0~1，值越大深度越大，读者可以自己更改</p></blockquote><p>效果：</p><p>修改前：</p><p>页头页脚过亮，看不清文字</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301212304897.jpg" alt="截屏2023-01-21 23.01.41"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301212304882.jpg" alt="截屏2023-01-21 23.01.49"></p><p>修改后：</p><p>亮度适中</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301212305510.jpg" alt="截屏2023-01-21 23.01.56"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301212305351.jpg" alt="截屏2023-01-21 23.02.02"></p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git！从零开始连接远程仓库</title>
      <link href="/chunyujin/b51810cf.html"/>
      <url>/chunyujin/b51810cf.html</url>
      
        <content type="html"><![CDATA[<h2 id="Git！从零开始用连接远程仓库！！-全平台"><a href="#Git！从零开始用连接远程仓库！！-全平台" class="headerlink" title="Git！从零开始用连接远程仓库！！[全平台]"></a>Git！从零开始用连接远程仓库！！[全平台]</h2><p>[toc]</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>无论你正在使用的是macOS、Linux还是Windows，总是可以使用Git这个无人争锋的 <u>版本控制系统</u>软件 进行本地仓库的构建以及将本地仓库和远程仓库(GItHub、GItee等)链接</p><p>因为原理都是一样的！</p></blockquote><p><mark style="background-color:pink">所以实际操作都用高亮（就像是这段文字）标识出来并设为标题，方便快速操作</mark></p><p><mark style="background-color:yellow">没有标明是在macOS、Linux还是Windows系统，说明操作基本是一样的</mark></p><p>因为在下是苦bee大学僧，经常去教室上课，mac又是放在宿舍里的，所以有些非单一场景独占的掩饰有时是mac终端，有时是Windows Git Bash，这两者除了外观不一样，基本操作都是一样的～～</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><blockquote><p>macOS和Linux的用户电脑如今一般都自带Git～</p><p>Windows用户到官网中进行安装Git即可～</p><p><mark style="background-color:yellow">macOS、Linux的终端，与Windows的Git Bash窗口，操作命令完全是一致的！因为macOS的终端包含Git，而Windows的Git就是Git呀~</mark></p></blockquote><p>连接远程仓库有两种方式，一种是通过HTTPS与远程仓库进行连接，一种是SSH与远程仓库进行连接</p><p>HTTPS连接时每次都要输入Gitee的用户名和密码，这里用SSH进行连接，将本地Git与远程Gitee关联，进而进行本地仓库与远程仓库的连接</p><h3 id="SSH连接远程仓库"><a href="#SSH连接远程仓库" class="headerlink" title="SSH连接远程仓库"></a>SSH连接远程仓库</h3><p>下面让在下来展示从建立仓库到连接远程仓库的过程～～</p><h3 id="🌱步骤一➡️配置你的Git个人用户信息"><a href="#🌱步骤一➡️配置你的Git个人用户信息" class="headerlink" title="🌱步骤一➡️配置你的Git个人用户信息"></a><mark style="background-color:pink">🌱步骤一➡️配置你的Git个人用户信息</mark></h3><blockquote><p>git作为一个软件，而且是作为一个版本控制的软件，每每都会涉及到文件的更改，我们对于文件的每一次更改都保存在了Git里面，所以，知道 更改文件的人是谁 是肥肠重要滴～</p><p>在git里，你需要先配置好自己的用户名和邮箱，这样你才是一个值得被信任的用户～到时候连接人家的远程仓库，人家才敢跟你连接(如果有的话～)</p></blockquote><p>Git 提供了一个叫做 <code>git config</code> 的命令，是专门用来 配置 和 读取 相应的工作环境变量的</p><blockquote><p>git的工作环境就是git正在工作的环境嘛（</p><p>也就是你在什么地方正在使用git，如果你在终端打开了git，那么它的工作环境就是当前整个电脑下，如果是在电脑的某个文件文件夹目录下，那git的工作环境就是在这个文件夹目录下～</p><p>工作环境变量就是工作环境的一些信息，用户信息就属于工作环境变量～</p></blockquote><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a><strong>步骤：</strong></h4><ol><li><strong>配置个人用户名和邮箱的命令：</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email 你的邮箱</span><br></pre></td></tr></table></figure><blockquote><p>–global选项的意思是“全局”，也就是说更改的配置就在你的用户主目录</p><p>为了以后不用每个目录底下都配置一遍用户信息，我们当然选择进行全局配置鸟～</p></blockquote><ol start="2"><li><strong>配置好了之后就可以看自己的用户信息:</strong></li></ol><p>可以选择将所有的信息列出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p>也可以选择查看某个信息，比如只查看用户名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br></pre></td></tr></table></figure><p>如果不知道之前自己有没有配置用户信息，可以用查看信息的命令查看一下～～</p><blockquote><p>除了用户名和邮箱，还可以配置用户密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.password 你的密码</span><br></pre></td></tr></table></figure></blockquote><h4 id="具体操作："><a href="#具体操作：" class="headerlink" title="具体操作："></a><mark style="background-color:lime"><strong>具体操作：</strong></mark></h4><h5 id="macos和Linux下："><a href="#macos和Linux下：" class="headerlink" title="macos和Linux下："></a><strong>macos和Linux下：</strong></h5><blockquote><ul><li>打开一个新的<strong>终端</strong>界面</li></ul><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301141031052.png" alt="截屏2023-01-14 10.31.16" style="zoom:33%;" /><p>或</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301141032962.png" alt="截屏2023-01-14 10.32.22" style="zoom: 33%;" /><ul><li><strong>输入配置用户信息的指令</strong></li></ul><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046709.png" alt="截屏2022-10-19 17.14.58 Redacted" style="zoom:50%;" /><ul><li><strong>检查一下是否配置好</strong></li></ul><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046835.png" alt="截屏2022-10-19 17.15.05 Redacted" style="zoom:50%;" /><p>如果灰色标记标出来的三行信息跟自己刚才的配置的一样，说明成功了哦～</p></blockquote><h5 id="Windows下："><a href="#Windows下：" class="headerlink" title="Windows下："></a>Windows下：</h5><blockquote><ul><li><p>打开<strong>Git Bash</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046894.png" alt="image-20221020000813500" style="zoom:80%;" /></li><li><p><strong>输入配置用户信息的指令</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046946.png" alt="image-20221020002543410" style="zoom:80%;" /></li><li><p><strong>检查一下是否配置好</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046091.png" alt="image-20221020002655079" style="zoom:80%;" /></li></ul></blockquote><p>🎉恭喜，到这里，Git需要配置的前期工作已经完成了🎉</p><hr><h6 id="如何修改用户的配置【见最下方的补充】"><a href="#如何修改用户的配置【见最下方的补充】" class="headerlink" title="如何修改用户的配置【见最下方的补充】"></a><a href="#%5B%E8%A1%A5%E5%85%85%5D%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE">如何修改用户的配置</a>【见最下方的补充】</h6><hr><h3 id="🌱步骤二➡️拥有-x2F-建立一个本地仓库，并将本地文件夹文件提交进本地仓库"><a href="#🌱步骤二➡️拥有-x2F-建立一个本地仓库，并将本地文件夹文件提交进本地仓库" class="headerlink" title="🌱步骤二➡️拥有&#x2F;建立一个本地仓库，并将本地文件夹文件提交进本地仓库"></a><mark style="background-color:pink">🌱步骤二➡️拥有&#x2F;建立一个本地仓库，并将本地文件夹文件提交进本地仓库</mark></h3><blockquote><p>你可以新建空的文件夹作为试验，建立一个Git的仓库，也可以用一个已经保存了文件的文件夹建成一个Git仓库</p><p>因为这都是一样的，都只是一个 <strong>将已有的文件夹</strong> 设定为 <strong>一个Git仓库</strong> 的过程</p></blockquote><p><strong>这里我就用我已经拥有的文件夹来开始</strong></p><h4 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a><strong>步骤：</strong></h4><ol><li><strong>在你想要建立成仓库的文件夹打开Git</strong></li><li><strong>将这个文件夹初始化为一个Git本地仓库</strong></li></ol><p>命令为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>如果显示了 Initialized empty Git repository in …….</p><p>说明你的仓库已经初始化好了，现在有了一个空的位于当前文件夹的空仓库</p><hr><h6 id="如何查看仓库的状态【见最下方的补充】"><a href="#如何查看仓库的状态【见最下方的补充】" class="headerlink" title="如何查看仓库的状态【见最下方的补充】"></a><a href="#%5B%E8%A1%A5%E5%85%85%5D%E6%9F%A5%E7%9C%8B%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81">如何查看仓库的状态</a>【见最下方的补充】</h6><hr><ol start="3"><li><p><strong>将文件夹里的 一个文件或者所有文件 提交到Git仓库中</strong></p><ol><li>将文件添加到GIt的缓存区</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .         # 如果你想要将文件夹里所有的文件都提交到Git仓库，可以用 . 来表示当前文件夹（当前文件夹就含有所有文件不是吗</span><br><span class="line">git add 文件名(如果不是文件夹还要包涵文件后缀)       # 如果你想提交单个文件/文件夹</span><br></pre></td></tr></table></figure><blockquote><ol><li>“ .”是相对路径的写法，表示当前目录，当前目录就是现在打开的这个刚创建了一个Git仓库的文件夹呀～</li><li>为什么要先放到GIt缓存区：因为安全，放到了缓存区之后再正式提交到Git本地仓库，有了可以撤回的空间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached 文件       # 撤回刚才放到缓存区的文件</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li><p>查看一下此时仓库的状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status #查看当前仓库的状态</span><br></pre></td></tr></table></figure><p>会发现有Changes to be committed的提示</p></li></ol><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230314102715824.png" alt="image-20230314102715824" style="zoom: 80%;" /><p>​说明缓存区内有文件未提交到Git仓库</p><ol start="3"><li>将缓存区提交到Git仓库</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;提交时你想要添加的说明&quot;</span><br></pre></td></tr></table></figure><blockquote><p>”说明“是必须添加的内容，因为Git的一个作用就是追踪你对于仓库的操作，记录你何时因为什么原因更新了仓库文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046311.png" alt="截屏2022-10-21 01.00.35" style="zoom:50%;" /></blockquote></li></ol><h4 id="具体操作：-1"><a href="#具体操作：-1" class="headerlink" title="具体操作："></a><mark style="background-color:lime">具体操作：</mark></h4><h5 id="macOS和Linux下："><a href="#macOS和Linux下：" class="headerlink" title="macOS和Linux下："></a>macOS和Linux下：</h5><blockquote><ul><li><p><strong>进入到想要建立成仓库的文件夹终端下：</strong></p><p>有两种方法：</p><p>方法一：用鼠标</p><p>鼠标移动到文件夹上，右击鼠标，找到“服务”</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046536.png" alt="截屏2022-10-19 19.31.47" style="zoom:50%;" /><p>“新建位于文件夹位置的终端标签页” 和 “新建位于文件夹位置的终端窗口” 都可以</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046598.png" alt="截屏2022-10-19 19.33.31 Redacted" style="zoom:50%;" /><p>此时发现进入到了文件夹的终端窗口</p><p>  方法二：用终端命令行</p><p>首先我们需要知道文件夹的路径</p><p>如果不知道可以打开一个终端窗口，并将文件夹拖进去，就可以得到这个文件夹的路径了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046704.png" alt="截屏2022-10-19 19.36.55 Redacted" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046766.png" alt="截屏2022-10-19 19.37.17 Redacted" style="zoom:50%;" /><p>我们将这个文件夹的路径复制一下</p><p>在终端中用cd指令就可以打开文件夹下的终端了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd 你刚刚复制的文件夹路径</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046821.png" alt="截屏2022-10-19 19.37.57 Redacted" style="zoom:50%;" />&gt;</p><blockquote><p>cd指令可以直接在终端中进入指定的文件路径</p></blockquote></li><li><p><strong>文件夹初始化为Git仓库</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046884.png" alt="截屏2022-10-19 19.47.11 Redacted" style="zoom:50%;" /></li><li><p>查看一下这个Git仓库状态</p><p>～如果文件夹原来没东西，应该是这样的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046936.png" alt="截屏2022-10-19 19.53.52 Redacted" style="zoom:50%;" /><p>~如果文件夹内有东西（我的CLion文件夹里放入的是hello.c），应该是这样的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046015.png" alt="截屏2022-10-19 19.55.49 Redacted" style="zoom:50%;" /><blockquote><p>关于“Unteacked files:“的信息，在<a href="#2.%E6%9F%A5%E7%9C%8B%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81">补充的内容：2.查看仓库状态</a>中有说明</p></blockquote></li><li><p>如果文件夹中原来没有文件，现在可以放入一个文件，以便测试一下下一步的操作</p><p>我的CLion文件夹里已经放入了一个 hello.c</p></li><li><p><strong>将文件夹中的 所有文件或者单个文件 添加到Git缓冲区</strong></p><p>此处我添加所有的文件（文件夹里其实也就一个hello.c文件）</p><p>并查看一下Git仓库状态</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046046.png" alt="截屏2022-10-19 19.50.17 Redacted" style="zoom:50%;" /><p>说明hello.c这个文件添加到了缓存区</p><blockquote><p>并且Git还细心提示可以用</p></blockquote></li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git rm --cached 文件</span><br></pre></td></tr></table></figure><p>来<strong>撤销刚才添加到缓存区的文件</strong></p></blockquote><ul><li><p><strong>将缓存区的文件提交到Git仓库</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046116.png" alt="截屏2022-10-19 20.01.47 Redacted" style="zoom:50%;" /><p>我添加的说明是”This is a test”，想添加什么都可以，尽量用英文</p><p>查看一下仓库状态</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046189.png" alt="截屏2022-10-19 20.03.10 Redacted" style="zoom:50%;" /><p>”nothing to commit, working tree clean“无事可做，工作树干净</p><p>意思是之前的文件都提交了，现在没有需要提交的文件了，工作树（缓存区）很干净（因为缓存区都提交了</p></li></ul></blockquote><h5 id="Windows下：-1"><a href="#Windows下：-1" class="headerlink" title="Windows下："></a>Windows下：</h5><blockquote><ul><li><p>找到想要设为Git本地仓库的文件夹，右击，点击<strong>Git Bash Here</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046246.png" alt="image-20221020002832274" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046313.png" alt="image-20221020003438024" style="zoom:80%;" /><p>这样就在Git中进入了文件夹</p></li><li><p><strong>文件夹初始化为Git仓库</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046369.png" alt="image-20221020003654246" style="zoom:80%;" /></li><li><p>查看一下这个Git仓库的状态</p><p>如果文件夹中原来没有文件，应该是这样的~</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046445.png" alt="image-20221020003829168" style="zoom:80%;" /><p>如果文件夹中原来有文件（比如我的CLion文件夹原来有一个hello.c文件)，是这样的~</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046499.png" alt="image-20221020005253111" style="zoom:80%;" /><blockquote><p>关于“Unteacked files:“的信息，在<a href="#2.%E6%9F%A5%E7%9C%8B%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81">补充的内容：2.查看仓库状态</a>有说明</p></blockquote></li><li><p>如果文件夹中原来没有文件，现在可以放入一个文件，以便测试一下下一步的操作</p><p>我的CLion文件夹里已经放入了一个 hello.c</p></li><li><p><strong>将文件夹中的 所有文件或者单个文件 添加到Git缓冲区</strong></p><p>此处我添加所有的文件（文件夹里其实也就一个hello.c文件）</p><p>并查看一下Git仓库状态</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046563.png" alt="image-20221020010248818" style="zoom:80%;" /><p>说明hello.c这个文件添加到了缓存区</p><blockquote><p>并且Git还细心提示可以用 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached 文件</span><br></pre></td></tr></table></figure><p>来撤销刚才添加到缓存区的文件</p></blockquote></li><li><p><strong>将缓存区的文件提交到Git仓库</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046613.png" alt="image-20221020010408321" style="zoom:80%;" /><p>我添加的说明是”This is a test”，想添加什么都可以，尽量用英文</p><p>查看一下仓库状态</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046665.png" alt="image-20221020010442512" style="zoom:80%;" /><p>”nothing to commit, working tree clean“无事可做，工作树干净</p><p>意思是之前的文件都提交了，现在没有需要提交的文件了，工作树（缓存区）很干净（因为缓存区都提交了</p></li></ul></blockquote><p>🎉恭喜，到这一步，你已经有了一个Git本地仓库，并学会了如何往仓库中提交文件🎉</p><hr><h6 id="仓库的分支—-在查看仓库的时候，第一行中的”On-branch-XXX”是什么【见最下方的补充】"><a href="#仓库的分支—-在查看仓库的时候，第一行中的”On-branch-XXX”是什么【见最下方的补充】" class="headerlink" title="仓库的分支—-在查看仓库的时候，第一行中的”On branch XXX”是什么【见最下方的补充】"></a><a href="#%5B%E8%A1%A5%E5%85%85%5D%5B%E9%87%8D%E7%82%B9%5D%E4%BB%93%E5%BA%93%E7%9A%84%E5%88%86%E6%94%AF">仓库的分支—-在查看仓库的时候，第一行中的”On branch XXX”是什么</a>【见最下方的补充】</h6><hr><h3 id="🌱步骤三➡️拥有-x2F-建立一个远程仓库，并与本地仓库连接-—-Gitee为例"><a href="#🌱步骤三➡️拥有-x2F-建立一个远程仓库，并与本地仓库连接-—-Gitee为例" class="headerlink" title="🌱步骤三➡️拥有&#x2F;建立一个远程仓库，并与本地仓库连接 —-Gitee为例"></a><mark style="background-color:pink">🌱步骤三➡️拥有&#x2F;建立一个远程仓库，并与本地仓库连接 —-Gitee为例</mark></h3><ul><li>公有仓库和私有仓库的区别：公有仓库所有人可见，私有仓库只有仓库成员可见</li><li>所有可见仓库的用户都具有读取仓库内容的权利(pull、clone)，公有仓库所有人可见，故任何仓库都可以获取共有仓库的数据；私有仓库对外首先是不可见的，所以只有仓库成员可见，自然只有仓库成员有读取仓库的权利【能看到仓库，就能读取，看不到，当然不能读取】</li><li>只有被仓库认证的成员即仓库成员才可以修改仓库的内容(比如上传push到远程仓库)，仓库的创建者(拥有者)自然是仓库成员，如果想要添加仓库成员，由仓库创建者进行添加</li><li>Gitee相当于一个远端机器，我们可以在Gitee官网登陆上自己的账户来管理Gitee账户及其下的各个仓库。也可以使用本地的Git与远端Gitee通过某种方式进行关联，这样本地机器可以连接到远端Gitee机器，从而具有修改Gitee账户下所有仓库的权利，也就是说本地Git可以将数据写入(推送）到远端Gitee账户下的仓库里了。<ul><li>本地Git与远端Git进行关联是通过SSH Key实现的。SSH Key分为SSH Public Key和SSH Private Key，即SSH公钥和密钥。公钥和密钥可以相互匹配。如果要将Gitee与Git关联，要将Gitee里添加上本地Git的公钥。这样当本地Git申请连接远程Gitee的时候，Gitee会用添加到它里面的公钥去匹配本地Git密钥，如果能通过匹配，则Gitee通过申请，本地Git就能连上Gitee了。（如果本地Git用户设置了密码，在Gitee拿着公钥申请本地Git密钥的时候，要输入本地Git密码才能获取到密钥，否则本地Git不予权限）</li><li>一个Gitee可以关联多个本地机器（一个人可能有多个电脑，但只有一个Gitee账户</li></ul></li><li>仓库可以与其它的仓库进行数据交流(下拉、推送、克隆等)操作，只要给定仓库的地址，并具有相应数据操作的权限就可以。一个仓库还可以与另一个仓库进行连接，这样这两个仓库之间就有了比较固定的关系，再进行数据交流的时候不用再指定仓库地址，只要表明是已连接的仓库就可以。</li></ul><h4 id="1-本地Git关联远端Gitee"><a href="#1-本地Git关联远端Gitee" class="headerlink" title="1.本地Git关联远端Gitee"></a><mark style="background-color:lime">1.本地Git关联远端Gitee</mark></h4><h6 id="1⃣️获取本地Git的SSH-公钥"><a href="#1⃣️获取本地Git的SSH-公钥" class="headerlink" title="1⃣️获取本地Git的SSH 公钥"></a>1⃣️获取本地Git的SSH 公钥</h6><h6 id="macOS和Linux下获取本地Git的SSH-公钥："><a href="#macOS和Linux下获取本地Git的SSH-公钥：" class="headerlink" title="macOS和Linux下获取本地Git的SSH 公钥："></a>macOS和Linux下获取本地Git的SSH 公钥：</h6><blockquote><ul><li><p>打开一个终端</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046938.png" alt="image-20221020151601824" style="zoom:80%;" /></li><li><p>以防万一，先测试一下Git是否安装了SSH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh</span><br></pre></td></tr></table></figure><p>如果出现了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046002.png" alt="截屏2022-10-19 21.01.32 Redacted" style="zoom:50%;" /><p>说明带有SSH，否则自行下载安装（在终端中输出<code>sudo apt-get install ssh</code>即可）</p></li><li><p>紧接着，输入以下指令【注意，如果确定本地ssh已经生成了密钥和公钥，请跳过这一步】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230314103046849.png" alt="image-20230314103046849" style="zoom:80%;" /><p>一路按回车就可以</p><p>就会在<strong>安装了SSH的路径</strong>上生成<strong>id-rsa (密钥文件</strong>)和<strong>id-rsa.pub (公钥文件)</strong></p></li><li><p>macOS和Linux的SSH路径在~&#x2F;.ssh下</p><blockquote><p>~的意思是个人文件夹</p><p>就是   &#x2F;Users&#x2F;你自己的用户名</p><p>所以~&#x2F;.ssh 就是 &#x2F;User&#x2F;你自己的用户名&#x2F;.ssh</p></blockquote></li><li><p>获得SSH公钥：</p><p><strong>方法一:</strong></p><p>打开一个终端，在终端中输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /User/你自己的用户名/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046064.png" alt="截屏2022-10-19 21.45.49 Redacted Redacted" style="zoom:50%;" /><p><strong><u>中间的这一大段的就是本地Git的SSH 公钥，复制它即可</u></strong></p><p><strong>方法二：</strong></p><p>打开一个终端，直接用cd指令进入到.ssh文件夹下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046169.png" alt="截屏2022-10-20 00.02.44 Redacted" style="zoom:50%;" /><p><strong><u>中间的这一大段就是本地Git的SSH 公钥，复制它即可</u></strong></p></li><li><p>🎉这一步就完成了</p></li></ul></blockquote><h6 id="Windows下获取本地Git的SSH-key公钥："><a href="#Windows下获取本地Git的SSH-key公钥：" class="headerlink" title="Windows下获取本地Git的SSH key公钥："></a>Windows下获取本地Git的SSH key公钥：</h6><blockquote><ul><li><p>打开Git Bash</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046309.png" alt="image-20221020151305597" style="zoom:80%;" /></li><li><p>以防万一，先看一下Git有没有安装SSH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh</span><br></pre></td></tr></table></figure><p>如果出现了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046366.png" alt="image-20221020150100500" style="zoom:80%;" /><p>说明安装了SSH，否则请自行下载安装（在Git Bash中输入<code>sudo apt-get install ssh</code>即可）</p></li><li><p>紧接着，输入以下指令 【注意，如果确定本地ssh已经生成了密钥和公钥，请跳过这一步】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230314102326065.png" alt="image-20230314102326065" style="zoom: 80%;" /><p>一路按回车就可以</p><p>就会在<strong>安装了SSH的路径</strong>上生成<strong>id-rsa (密钥文件</strong>)和<strong>id-rsa.pub (公钥文件)</strong></p></li><li><p>Windows的SSH路径在~&#x2F;.ssh下</p><blockquote><p>~的意思是个人文件夹</p><p>就是   &#x2F;Users&#x2F;你自己的用户名</p><p>所以~&#x2F;.ssh 就是 &#x2F;User&#x2F;你自己的用户名&#x2F;.ssh</p></blockquote></li><li><p><strong>获得SSH公钥：</strong></p><p><strong>方法一:</strong></p><p>在Git Bash中输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /User/你自己的用户名/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046410.png" style="zoom:80%;" /><p><strong><u>中间的这一大段就是本地Git的SSH 公钥，复制它即可</u></strong></p><p><strong>方法二：</strong></p><p>在Git Bash中，直接用cd指令进入到.ssh文件夹下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046482.png" alt="image-20221020151035414" style="zoom:80%;" /><p><strong><u>中间的这一大段就是本地Git的SSH 公钥，复制它即可</u></strong></p></li></ul></blockquote><h6 id="2⃣️将本地Git的SSH-key公钥添加到远程Gitee："><a href="#2⃣️将本地Git的SSH-key公钥添加到远程Gitee：" class="headerlink" title="2⃣️将本地Git的SSH key公钥添加到远程Gitee："></a>2⃣️将本地Git的SSH key公钥添加到远程Gitee：</h6><blockquote><ul><li><p>点击GItee的<strong>头像-设置</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046574.png" alt="截屏2022-10-19 22.56.01" style="zoom:50%;" /></li><li><p>点击左侧的<strong>SHH公钥</strong>（因为我已经添加了一个公钥了，所以显示的是公钥数为1，否则是0）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046666.png" alt="截屏2022-10-19 22.56.33 Redacted" style="zoom:50%;" /></li><li><p>将之前获得的SSH 公钥填进第二个框，第一个框就自动填充了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046723.png" alt="截屏2022-10-19 22.42.12" style="zoom:40%;" /></li><li><p>添加好了就是这样的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046838.png" alt="截屏2022-10-19 22.48.15 Redacted" style="zoom:50%;" /></li></ul></blockquote><h4 id="2-本地仓库连接远程仓库"><a href="#2-本地仓库连接远程仓库" class="headerlink" title="2.本地仓库连接远程仓库"></a><mark style="background-color:lime">2.本地仓库连接远程仓库</mark></h4><h5 id="建立一个远程仓库（如果有了的话就不用了）"><a href="#建立一个远程仓库（如果有了的话就不用了）" class="headerlink" title="建立一个远程仓库（如果有了的话就不用了）"></a>建立一个远程仓库（如果有了的话就不用了）</h5><blockquote><ul><li><p>进入到Gitee官网，网页右上角会发现</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046713.png" alt="截屏2022-10-19 22.27.47" style="zoom: 40%;" /></li><li><p>填写仓库名称，”初始化仓库“的选项勾不勾都是可以的</p></li><li><p>在仓库的权限方面，若设为开源&#x2F;共有，则任何人都对于仓库拥有读(pull,clone)写(push)权限；设为私有，只有仓库拥有者具有写的权限，其他人只具有可读权限</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046789.png" alt="截屏2022-10-19 22.29.13 Redacted" style="zoom:50%;" /></li><li><p>进入到仓库中会是这样的（如果勾选了“初始化仓库”，仓库中会有下图的文件，没有的话就没有）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046868.png" alt="截屏2022-10-19 22.29.39 Redacted" style="zoom:50%;" /></li><li><p>这样一个远程仓库就建立好了</p></li></ul></blockquote><h5 id="本地仓库连接远程仓库："><a href="#本地仓库连接远程仓库：" class="headerlink" title="本地仓库连接远程仓库："></a>本地仓库连接远程仓库：</h5><blockquote><ul><li><p>获取Gitee仓库的ssh，直接复制</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046966.png" alt="截屏2022-10-19 22.59.35 Redacted"></p></li><li><p>在本地Git仓库里输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin 你刚才复制的Gitee仓库的链接</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046981.png" alt="截屏2022-10-19 23.04.34 Redacted" style="zoom:50%;" /><p>没有报错说明连接上了</p></li></ul></blockquote><hr><h6 id="如何查看隐藏文件【见最下方的补充】"><a href="#如何查看隐藏文件【见最下方的补充】" class="headerlink" title="如何查看隐藏文件【见最下方的补充】"></a><a href="#%5B%E8%A1%A5%E5%85%85%5D%E6%9F%A5%E7%9C%8B%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6">如何查看隐藏文件</a>【见最下方的补充】</h6><hr><h3 id="🌱步骤四➡️pull-和-push-本地仓库与远程仓库的文件提交和获取"><a href="#🌱步骤四➡️pull-和-push-本地仓库与远程仓库的文件提交和获取" class="headerlink" title="🌱步骤四➡️pull 和 push(本地仓库与远程仓库的文件提交和获取)"></a><mark style="background-color:pink">🌱步骤四➡️pull 和 push(本地仓库与远程仓库的文件提交和获取)</mark></h3><blockquote><p><strong>push：“推”，将本地仓库当前分支的文件 上传合并&#x2F;推送合并 到远程仓库某个分支</strong></p><p><strong>pull：“拉”，将远程仓库某个分支的文件 下拉合并&#x2F;获取合并 到本地仓库当前分支</strong></p></blockquote><h4 id="push："><a href="#push：" class="headerlink" title="push："></a>push：</h4><p>push是将本地仓库当前分支的内容上传合并到远程仓库的某个分支</p><p>因此要确保要上传的文件已经被添加到了本地仓库中</p><p>我们上面讲到了如何将文件添加到本地仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add 文件名 # 将文件添加到缓冲区</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果要将文件夹内所有文件都添加到缓冲区，执行 git add .</span></span><br><span class="line"></span><br><span class="line">git commit -m &quot;上传备注留言&quot; # 将缓冲区文件添加到本地仓库</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上传备注留言，本次提交的留言，比如如果这是第三次修改项目，可以留言<span class="string">&quot;change 3.0&quot;</span>，支持中文</span></span><br></pre></td></tr></table></figure><blockquote><p>可以使用<code>git status</code>指令查看仓库状态，见下面补充：[[补充]查看仓库状态](# [补充]查看仓库状态)</p></blockquote><p>然后使用上传命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master 远程仓库分支名</span><br></pre></td></tr></table></figure><p>例如：</p><p>我们现在将这个”测试用文件夹”master分支的仓库，push到已经连接的远程仓库test的master分支（要上传的文件已经添加到了本地仓库）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046029.png" alt="截屏2022-10-21 01.45.01" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046093.png" alt="截屏2022-10-21 01.44.30" style="zoom:50%;" /><p>可以看到远程仓库里已经有了本地仓库的所有文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046170.png" alt="截屏2022-10-21 01.47.20" style="zoom:50%;" /><h4 id="pull："><a href="#pull：" class="headerlink" title="pull："></a>pull：</h4><p>pull指令步骤就很简单了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin 远程仓库分支名</span><br></pre></td></tr></table></figure><p>例如：</p><p>我们随便在远程仓库添加一个文件，来模拟别的本地仓库push文件到远程仓库test</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046214.png" alt="截屏2022-10-21 01.49.21" style="zoom:50%;" /><p>现在在本地仓库pull远程仓库test的master分支仓库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046274.png" alt="截屏2022-10-21 01.52.04" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046329.png" alt="截屏2022-10-21 01.53.07" style="zoom:50%;" /><p>成功了（好耶</p><blockquote><p>⚠️<code>push</code>、<code>pull</code>总是取双方仓库每个文件的最新状态</p><p>⚠️因为是Git仓库，所以无论是<code>push</code>还是<code>pull</code>，都是对于仓库内的文件进行的下拉、提交，没有提交到仓库里的文件，Git是无权管理的</p><blockquote><p>比如，我在当前分支(master)CLion文件夹里添加了一个hello.c文件，并不把它提交到仓库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046385.png" alt="截屏2022-10-20 22.08.04" style="zoom:50%;" /><p>现在我将远程仓库master分支的所有文件下拉到本地仓库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046454.png" alt="截屏2022-10-20 22.09.05 Redacted" style="zoom:50%;" /><p>远程仓库的master分支里本来是没有hello.c文件的，而本地仓库master分支里也没有(因为没提交到仓库)，所以没有涉及到关于hello.c文件的跟踪，hello.c还是存在于CLion文件夹(但并不在本地仓库master分支里)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046385.png" alt="截屏2022-10-20 22.08.04" style="zoom:50%;" /><p>如果现在查看仓库状态</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046498.png" alt="截屏2022-10-20 22.12.02 Redacted" style="zoom:50%;" /><p>Look，确实是这样的</p><p>如果将hello.c添加到本地仓库master分支，再从远程仓库master分支pull到本地仓库当前分支</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046735.png" alt="截屏2022-10-20 22.14.15 Redacted" style="zoom:50%;" /><p>发现，诶？不对诶，怎么CLion文件夹中还有hello.c文件？</p><p>因为Git跟踪的hello.c状态，远程与本地相比，在本地的状态是最新的，因为远程：没跟踪到hello.c文件(连状态都没有)，本地：于XX日期XX时刻创建了hello.c文件，当然是本地的最新啦</p><p>那么，我们先将本地仓库push到远程仓库，再到远程仓库去删除这个hello.c文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046893.png" alt="截屏2022-10-20 22.19.34 Redacted" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046957.png" alt="截屏2022-10-20 22.19.45 Redacted" style="zoom:50%;" /><p>那这样远程仓库的hello.c状态就比本地仓库新了：于xxx时刻被删除</p><p>再次将远程仓库pull到本地仓库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046131.png" alt="截屏2022-10-20 22.22.35 Redacted" style="zoom:50%;" /><p>(界面往往包含很多信息，比如这个，显示hello.c的最新的状态是在远程仓库被删除了)</p><p>看一下本地CLion文件夹</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046186.png" alt="截屏2022-10-20 22.24.17" style="zoom:50%;" /><p>明白了吧～～</p></blockquote></blockquote><p>因为不止一个本地仓库可以访问远程仓库，所以如果你不知道自己本地仓库的版本比远程仓库是新还是旧</p><p>每次开始工作时建议先将远程仓库pull到本地仓库，因为pull和push总是取文件最新状态嘛～～</p><p><a href="https://blog.csdn.net/wys0127/article/details/123856744">git 为什么要先commit，然后pull，最后再push？而不是commit然后直接push？</a></p><p>🎉恭喜，到这一步，你已经掌握了如何在本地仓库和远程仓库进行文件提交和获取了🎉</p><h4 id="补充-git-clone-及其与git-pull的区别"><a href="#补充-git-clone-及其与git-pull的区别" class="headerlink" title="[补充] git clone 及其与git pull的区别"></a>[补充] git clone 及其与git pull的区别</h4><blockquote><ul><li><p>打开Gitee中自己刚创建的远程仓库页面，点击右侧的“克隆&#x2F;下载”，选取”HTTPS”或者”SSH”，点击“复制”</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301141103859.png" alt="截屏2023-01-14 11.02.38" style="zoom:50%;" /></li><li><p>打开本地仓库的Git bash&#x2F;终端，输入指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 刚刚复制的HTTPS或者SSH</span><br></pre></td></tr></table></figure><blockquote><p><code>git clone</code>命令的作用是将远程仓库克隆到本地</p></blockquote><ul><li><p>如果仓库是私有仓库，按道理说只有仓库成员才可见，所以需要验证本地用户信息</p><ul><li><p>如果本地Git没有关联这个私人仓库的Gitee，需要输入用户的Gitee用户名和密码来验证自己是该私有仓库的成员</p><p>用户名可以在Gitee网页中的个人主页上查看</p></li></ul><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301141110019.png" alt="截屏2023-01-14 11.08.16 Redacted" style="zoom:50%;" /><ul><li>如果本地Git关联了这个私有仓库的Gitee，则输入本地Git的密码即可clone</li></ul></li><li><p>如果仓库是公有仓库，直接可以clone</p></li></ul><p>出现类似上图就说明clone成功</p></li></ul></blockquote><blockquote><p><code>git pull</code>是获取仓库中某一个分支下的新的数据（如果有的话），并与本地分支数据进行合并</p><p><code>git clone</code>是将整个仓库下载下来，包括日记信息和各分支数据等</p></blockquote><h4 id="补充-如何修改用户配置"><a href="#补充-如何修改用户配置" class="headerlink" title="[补充]如何修改用户配置"></a>[补充]如何修改用户配置</h4><blockquote><p>如果单纯想要修改用户配置，只需要用添加用户配置的命令就可以了，因为新的配置会覆盖旧的配置</p></blockquote><blockquote><p>如果想要删除用户配置，比如删除用户名、邮箱、密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset user.name</span><br><span class="line">git config --global --unset user.email</span><br><span class="line">git config --global --unset user.password</span><br></pre></td></tr></table></figure><p>删除了用户名和邮箱，在连接远程仓库的时候可能会被认为本地Git不安全（因为都没有报上名来~~</p><p>删除了密码，则在进行一些操作时会跳过输入密码的环节，方便但是不是很安全，因为往往是在一些“确认要进行操作吗”的操作时需要你输入密码来确认，如果没有密码就直接跳过了~</p></blockquote><p>[点这里返回上次阅读的位置](# 如何修改用户的配置【见最下方的补充】)</p><h4 id="补充-查看仓库状态"><a href="#补充-查看仓库状态" class="headerlink" title="[补充]查看仓库状态"></a>[补充]查看仓库状态</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>这是一个使用很频繁的命令，有时候你就是想看看现在仓库处于什么状态，有时候你会忘记自己有没有将文件夹下已经更改的文件提交到Git仓库，等等等等，反正只要你想看一下仓库状态，就会用它～</p><blockquote><p>比如到现在为止，我们只是完成了仓库的初始化，还没有向仓库中提交任何文件</p><ul><li>如果文件夹中本来是没有文件的，我们查看一下仓库的状态</li></ul><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046235.png" alt="截屏2022-10-19 17.53.32 Redacted" style="zoom:50%;" /><p>可以看到 “No commits yet”（还没有任何提交）</p><ul><li>如果文件夹里原来是有文件的（比如一个文件hello.c），我们查看一下仓库的状态</li></ul><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046288.png" alt="截屏2022-10-19 19.19.26 Redacted" style="zoom:50%;" /><p>可以看到Git检测到文件夹里有一个新的文件”未被跟踪”（Untracked files ：）</p><p>在括号里提示了用什么命令来将hello.c文件放入缓存区</p><p>下面的红色的hello.c就是未被添加到缓存区的文件</p><blockquote><p>“跟踪”，因为Git本身是一个版本控制软件，说白了就是记录并保存下来你每次对于文件的更改（这个就叫跟踪，知道你什么时候修改的什么文件）</p><p><mark style="background-color:yellow"><strong>只有将修改了的文件添加到Git的缓存区，文件状态才能被Git跟踪</strong></mark></p><p><mark style="background-color:yellow">当你完成了所有的工作、已经不需要再对任何文件进行更改，就执行最后一步：将缓存区的文件提交到Git，这样仓库里的文件就会更新了</mark></p><blockquote><p>修改，当然是包括添加新文件、删除旧文件、更改现有文件等~</p></blockquote></blockquote></blockquote><h4 id="补充-重点-仓库的分支"><a href="#补充-重点-仓库的分支" class="headerlink" title="[补充] [重点] 仓库的分支"></a>[补充] [重点] 仓库的分支</h4><p>branch 即为“分支”</p><p>如果用户a和用户b同时对于项目进行修改，仓库为了防止两人的修改相互影响，会形成两条分支来分别保存a、b的修改，这样a、b对于项目的修改都在自己的那条分支上，等到ab的工作完成了，就可以选择统一将分支合并起来</p><blockquote><p>在仓库初始化(执行了<code>git init</code>)之后，会默认生成一个主分支master，也就是在Windows的Git Hash窗口中显示的这个绿色的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046347.png" alt="image-20221020171909705" style="zoom:80%;" /><p>在macOS和Linux下的终端里不会主动显示当前分支名字，但是也可以在某些地方看到</p><p>比如在查看仓库状态下(Windows的Git Bash里也一样)</p><p>当然，在这个终端窗口里，显示我的这个分支名字是main，那是因为我改名了hhh~</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046936.png" alt="截屏2022-10-19 19.53.52 Redacted" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046445.png" alt="image-20221020003829168" style="zoom:80%;" /></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p><strong>显示当前仓库下所有的分支</strong></p><p>这个命令可以查看当前仓库的所有分支，并用“ * ”标记出用户当前使用的分支</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046596.png" alt="image-20221020172917614" style="zoom:80%;" /><p>可以看到现在我只有一个分支master，并处在这个分支上</p></blockquote><blockquote><p>⚠️如果输入此指令之后，并没有正常显示，而是显示了END和一堆～，按q退出，然后输入<code> git config --global core.pager &#39;&#39;</code>即可</p><p>core.pager指定 Git 运行诸如<code>log</code>、<code>diff</code>等所使用的分页器，你能设置成用<code>more</code>或者任何你喜欢的分页器（默认用的是<code>less</code>）， 当然你也可以什么都不用，设置空字符串（如上面的这条指令设置），这样不管命令输出多少，都会在一页显示所有内容</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 新分支名称</span><br></pre></td></tr></table></figure><p><strong>增加一个分支</strong></p><p>这个命令会增加一个分支，新增的分支会复制原有分支的所有内容，保证新分支的初始内容和原分支一样</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046663.png" alt="image-20221020173709847" style="zoom:80%;" /><p>看到新增加了一个分支a</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 想要切换到的分支</span><br></pre></td></tr></table></figure><p><strong>切换当前分支</strong></p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046764.png" alt="image-20221020174000192" style="zoom:80%;" /><p>看到切换了分支（甚至在Git Bash中还会用蓝色的字体标出来当前分支，这还是很银杏化的~~</p><p>mac和Linux泪目….(不过这个应该是可以配置的)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 新分支名称</span><br></pre></td></tr></table></figure><p><strong>新增一个分支并切换到这个新分支</strong></p><p>就是上两个操作的简化~~</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046825.png" alt="image-20221020191116028" style="zoom:80%;" /></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 要合并到当前分支的分支名</span><br></pre></td></tr></table></figure><p>将某个分支合并到<strong>当前分支</strong></p><p>注意：只能将别的分支合并到当前分支，因此合并前要注意一下当前分支</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046943.png" alt="image-20221020191856740" style="zoom:80%;" /><p>可以看到，分支合并到master之后，原分支并不会被删除~</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d 要删除的分支名</span><br></pre></td></tr></table></figure><p>删除某个分支</p><p>前提：1.不能删除当前所在的分支，执行删除前记得切换分支</p><p>​2.如果一个分支在创建后<u>仓库内容被修改(提交到了Git仓库才能被追踪，才能判断被修改)</u>，并且<u>没有合并到其他分支</u>，是不允许被删除的</p><blockquote><p>在master分支下创建分支a和b</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046994.png" alt="image-20221020193904453" style="zoom:80%;" /><p>切换到分支a，在文件夹中创建一个hello.txt文件，但不提交到仓库里</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047046.png" alt="image-20221020194217899" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047219.png" alt="image-20221020194305055" style="zoom:80%;" /><p>然后切换到master，删除a，发现正常删除了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047280.png" alt="image-20221020201631869" style="zoom:80%;" /><p>但是如果分支a下，文件夹下添加的hello.txt文件提交到了Git里，再回到master分支删除分支a，就会报错，分支a尚未合并到其他分支</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047331.png" alt="image-20221020202208027" style="zoom:80%;" /></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D 要删除的分支名</span><br></pre></td></tr></table></figure><p>强制删除某个分支</p><p>”强制“在于可以删除 未合并到其他分支的 已修改的分支</p><blockquote><p>上面那张图片也说了，If you are sure you want to delete it, run ‘git branch -D a’</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047382.png" alt="image-20221020202701428" style="zoom:80%;" /></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag 标签/版本名称</span><br></pre></td></tr></table></figure><p>为当前的仓库状态添加一个标签，就像每次软件的版本一样~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><p>查看所有标签&#x2F;版本</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047440.png" alt="截屏2022-10-20 21.57.34 Redacted" style="zoom:50%;" /></blockquote><p><mark style="background-color:yellow"><strong>总结一个很重要的知识点</strong></mark></p><blockquote><p>如果我们在只有一个分支master的仓库，再添加一个分支a，并切换到分支a</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047509.png" alt="截屏2022-10-21 01.04.54" style="zoom:50%;" /><p>原来的时候仓库master分支里有一个test.txt文件，因为构建了一个分支，master分支里的所有文件也都复制到了a分支里</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047566.png" alt="截屏2022-10-21 01.05.41" style="zoom:50%;" /><p>现在我们正处在分支a，我们添加一个文件A.txt到分支a仓库里面</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047662.png" alt="截屏2022-10-21 01.08.08" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047725.png" alt="截屏2022-10-21 01.09.22" style="zoom:50%;" /><p>现在切换到master分支</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047769.png" alt="截屏2022-10-21 01.10.31" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047843.png" alt="截屏2022-10-21 01.11.01" style="zoom:50%;" /><ul><li><mark style="background-color:yellow"><strong>我们可以体会到：分支是相互独立的</strong></mark></li></ul><p>我们再切回到分支a</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047900.png" alt="截屏2022-10-21 01.12.38" style="zoom:50%;" /><p>嗯没错没毛病，A.txt又回来了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047954.png" alt="截屏2022-10-21 01.13.21" style="zoom:50%;" /><p>好，现在再在分支a的文件夹里添加一个B.txt，但是这次不提交到分支a的仓库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047024.png" alt="截屏2022-10-21 01.14.34" style="zoom:50%;" /><p>我们直接切换到分支master</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047080.png" alt="截屏2022-10-21 01.15.15" style="zoom:50%;" /><p>发现分支为master时的文件夹里，有B.txt</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047133.png" alt="截屏2022-10-21 01.16.00" style="zoom:50%;" /><p>这并不是因为B.txt从分支a的仓库复制到了分支master的仓库</p><p>而是因为B.txt既不属于分支a仓库，也不属于分支master</p><p>它并不存在于Git仓库里</p><ul><li><p><mark style="background-color:yellow"><strong>我们可以发现</strong></mark></p><p><mark style="background-color:yellow"><strong>Git仓库 不等于 整个文件夹，文件夹的文件提交到GIt仓库之后才属于仓库，否则只是一个存在于文件夹但是不存在于仓库的文件</strong></mark></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047204.png" alt="截屏2022-10-21 01.24.33" style="zoom:50%;" /></li></ul><p>现在我们切换回a分支</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047900.png" alt="截屏2022-10-21 01.12.38" style="zoom:50%;" /><p>好，之前不是在文件夹里创建了一个B.txt但是没有提交到分支a的仓库嘛</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047266.png" alt="截屏2022-10-21 01.28.55" style="zoom:50%;" /><p>现在我们将它添加到分支a的缓存区，但不提交到仓库里</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047327.png" alt="截屏2022-10-21 01.29.32" style="zoom:50%;" /><p>切换到master分支</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047387.png" alt="截屏2022-10-21 01.31.54 Redacted" style="zoom:50%;" /><p>可以发现切换的时候有一个关于B.txt的提示，并且master分支下，文件夹里还是有B.txt</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047445.png" alt="截屏2022-10-21 01.36.12" style="zoom:50%;" /><p>说明B.txt文件还是不属于Git仓库</p><p>但是能检测到B.txt的动向了，说明</p><ul><li><mark style="background-color:yellow"><strong>将文件添加到缓存区，只是给了Git跟踪文件状态的权利，但是文件并不会进入到Git仓库里，除非提交到仓库</strong></mark></li></ul></blockquote><p>[点这里返回刚在阅读的位置](#仓库的分支—-在查看仓库的时候，第一行中的”On branch XXX”是什么【见最下方的补充】)</p><h4 id="补充-查看隐藏文件"><a href="#补充-查看隐藏文件" class="headerlink" title="[补充]查看隐藏文件"></a>[补充]查看隐藏文件</h4><p>macOS和Linux下：</p><blockquote><p>以”.”开头的文件都是隐藏文件，我们可以先打开访达</p><p>在左侧列表中找到 位置 下的个人电脑的文件夹</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047501.png" alt="截屏2022-10-19 21.34.50" style="zoom: 50%;" /><p>打开Macintosh HD - 用户 - 自己用户名的文件夹</p><p>然后在这个文件夹里按下⇧ + ⌘ +. </p><p>就可以显示隐藏文件，再按一遍就可以关闭显示隐藏文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047598.png" alt="截屏2022-10-19 21.37.12" style="zoom:50%;" /></blockquote><p><a href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E3%80%90%E8%A7%81%E6%9C%80%E4%B8%8B%E6%96%B9%E7%9A%84%E8%A1%A5%E5%85%85%E3%80%91">点这里返回刚才阅读的位置</a></p><h4 id="补充-文件-gitignore"><a href="#补充-文件-gitignore" class="headerlink" title="[补充]文件.gitignore"></a>[补充]文件.gitignore</h4><p>.gitignore是本地Git仓库的一个隐藏文件，它的作用相当于黑名单，凡是在这个文件里包含的文件都不会被上传到远端仓库。</p><blockquote><p>.gitignore文件里的黑名单文件是可以用通配符来表示的</p></blockquote><h4 id="补充-另一种链接远端仓库的方式（不需要提交公钥）"><a href="#补充-另一种链接远端仓库的方式（不需要提交公钥）" class="headerlink" title="[补充]另一种链接远端仓库的方式（不需要提交公钥）"></a>[补充]另一种链接远端仓库的方式（不需要提交公钥）</h4><ol><li><p>创建好一个本地仓库</p></li><li><p>&#96;&#96;&#96;shell<br>git clone 远端仓库的http(在Gitee中会找到，跟ssh位置一样)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   第一次链接是会要求输入远端仓库的账户和密码，也就是Gitee的用户名和密码</span><br><span class="line"></span><br><span class="line">3. push和pull的操作：</span><br><span class="line"></span><br><span class="line">   ```shell</span><br><span class="line">   git push </span><br><span class="line">   git pull</span><br></pre></td></tr></table></figure><p>操作时可能需要gitee账户的密码</p></li></ol><p>参考文章：《从0开始的Github》</p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>菜单栏页面内的顶部图片展示</title>
      <link href="/chunyujin/8566742c.html"/>
      <url>/chunyujin/8566742c.html</url>
      
        <content type="html"><![CDATA[<h1 id="菜单栏页面内的顶部图片展示"><a href="#菜单栏页面内的顶部图片展示" class="headerlink" title="菜单栏页面内的顶部图片展示"></a>菜单栏页面内的顶部图片展示</h1><p>在source中有中每个页面的配置文件夹，如tags、categories、music等：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301121932556.png" alt="截屏2023-01-12 19.32.14" style="zoom: 33%;" /><p>打开一个文件夹，比如tags，都会有index.md配置文件：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301121935996.png" alt="截屏2023-01-12 19.28.42" style="zoom:50%;" /><p>里面的top_img对应的就是页面的顶部图片：</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303071212590.png" alt="202301121936911"></p><p>有些页面是有子页面的，比如tags、category等就有子页面</p><p>以tags为例，tags有各种标签，打开一个进去就会进入到相关的文章</p><p>在主题配置文件_config.yml中的设置中可以更改子页面的标签：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301121937303.png" alt="截屏2023-01-12 19.29.17" style="zoom:50%;" /><p>115行是tags默认的每个子页面的顶部图片，也可以分别调控每个tag的顶部图片：</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303071213834.png" alt="202301121938002"></p><p>例如头像、主页面顶部图片、时间轴(archive)顶部图片等的配置也在主题配置文件_config.yml中，只要在里面能找到相关配置，就可以进行修改</p><blockquote><p>像是music、about等没有子页面的标签，直接就在对应的文件夹下的inedx.md文件里进行顶部图片的配置即可</p><p>不用在主题配置文件_config.yml里进行调配(这里面也没有对应的选项)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_常用指令&amp;权限管理</title>
      <link href="/chunyujin/1c776eb1.html"/>
      <url>/chunyujin/1c776eb1.html</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><h4 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h4><h5 id="文件的分类"><a href="#文件的分类" class="headerlink" title="文件的分类"></a>文件的分类</h5><blockquote><p><strong>普通文件</strong>，文件属性为[-]</p><p><strong>目录文件</strong>，属性为[d]，文件夹(目录)也是一种文件，是内容为文件的文件，是能用 # cd指令进入的</p><p><strong>块设备文件</strong>，属性为[b]，表示为装置文件里面的可供储存的接口设备(可随机存取装置)，比如硬盘、光驱等。例如一号硬盘的代码是 &#x2F;dev&#x2F;hda1等文件</p><p><strong>字符设备文件</strong>，属性为[c]，表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)、屏幕等</p><p><strong>套接字文件</strong>，属性为[s]，这类文件通常用在网络数据连接，可以启动一个程序来监听客户端的要求，客户端就可以通过套接字来进行数据通信。最常在 &#x2F;var&#x2F;run目录中看到这种文件类型</p><p><strong>管道文件</strong>，属性为[p]，FIFO也是一种特殊的文件类型，它主要的目的是，解决多个程序同时存取一个文件所造成的错误。FIFO是first-in-first-out(先进先出)的缩写</p><p><strong>链接文件</strong>，属性为[l]，类似于Windows里的快捷方式和macOS的替身</p></blockquote><h5 id="文件-x3D-文件属性-文件内容"><a href="#文件-x3D-文件属性-文件内容" class="headerlink" title="文件 &#x3D; 文件属性 + 文件内容"></a>文件 &#x3D; 文件属性 + 文件内容</h5><blockquote><p>当我们在电脑上创建了一个空白文档的时候，查看一下文件的详细信息，会发现这个空白文档并不是占用了0内存，它是占用了内存的。因为要存储这个文档的属性</p><p>文件属性：包括创建时间、修改日期、种类、拥有者、大小等等</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212291208514.png" alt="截屏2022-12-29 12.08.43" style="zoom:50%;" /></blockquote><h5 id="常用的单词："><a href="#常用的单词：" class="headerlink" title="常用的单词："></a>常用的单词：</h5><blockquote><p>command 命令</p><p>option 选项</p><p>dirname 目录名</p></blockquote><h4 id="建议有不懂的指令就去man查找！"><a href="#建议有不懂的指令就去man查找！" class="headerlink" title="建议有不懂的指令就去man查找！"></a>建议有不懂的指令就去man查找！</h4><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><p>一个指令由基本指令、选项、目标、其他内容组成的，除基本指令外的内容都并不是必须的，内容对应相应功能</p><p>一条指令可以添加多个选项，意味着一条指令实现多种功能的结合</p><p>**<mark>凡是放方括号里的内容都代表不是必须的，可以不存在</mark>**，括号外的内容都是必须的</p><p><strong>指令中，选项的位置正常来讲是可以移动的，并不是固定的必须要按照某种顺序出现在某个位置</strong></p><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><p><code>ls [选项] [指定文件]</code></p><h5 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h5><p>对于目录，该命令列出该目录下的所有文件；对于一般文件，将列出该文件。(默认是按照名称排序的)</p><p><mark>（如果不跟指定目录或文件，则默认是当前目录）</mark></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181010049.png" alt="截屏2022-12-18 10.10.52" style="zoom:50%;" /><h5 id="常用选项："><a href="#常用选项：" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-l # 列出各文件的详细信息。ls -l 可以简写成 ll</span><br><span class="line">-a # 列出所有文件， 包括以.开头的隐藏文件</span><br><span class="line">-d # 只显示指定目录，不显示目录内容</span><br><span class="line">-s(小写) # 显示文件的块数</span><br><span class="line">-S(大写) # 按大小降序排列</span><br><span class="line">-r # 反向排序</span><br><span class="line">-t # 按修改时间先后排序</span><br><span class="line">-h # 按用户易读的方式显示文件大小</span><br><span class="line">-k # 以k字节的形式输出大小(一般输出的时候就是以这种方式输出的，用处不是很大)</span><br><span class="line">-R # 列出所有子目录的文件(递归)</span><br><span class="line">-1 # 一行只输出一个文件</span><br><span class="line">-n # 用数字的UID、GID代替owner、group名称</span><br><span class="line">-i # 显示文件的inode(索引节点)</span><br><span class="line">-F # 在每个文件名后附上一个字符以说明该文件的类型，*表示可执行程序，/表示目录，@表示符号连接，|表示FIFOs，=表示套接字(sockets)。（目录类型识别）</span><br></pre></td></tr></table></figure><blockquote><p><strong><mark>-l</mark> ：列出各文件的详细信息。<u>ls -l 可以简写成 ll</u></strong></p><div><center><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181050726.png" alt="image-20221218105015699" style="zoom:30%;" /><br>Linux文件默认是按照名称排序的</center></div><p><strong><mark>-a</mark> ：列出所有文件， 包括以.开头的隐藏文件。例如：ls -a [指定目标]</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181011049.png" alt="截屏2022-12-18 10.11.38" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181015520.png" alt="截屏2022-12-18 10.15.19" style="zoom:50%;" /><blockquote><p>可以看出当前目录.和上级目录..是作为隐藏文件保存的</p><p><strong>注意：当前目录.和上级目录..算是当前目录的子目录！</strong></p><p>所以会显示当前目录.的子目录个数是7，分别是：当前目录.，上级目录..，code，date，dir1，dir1-bak，test1</p><p>显示code目录中的子目录个数是3，但是实际上一看code中只有一个子目录hellobite，这就是因为code的当前目录和上级目录也算作了code的子目录，而当前目录和上级目录是隐藏文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181038966.png" alt="截屏2022-12-18 10.38.42" style="zoom:50%;" /><p>同样，显示code的子目录hellobite含有的子目录的个数是2，但是实际上查看发现hellobite中没有子目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181039261.png" alt="截屏2022-12-18 10.39.46" style="zoom:50%;" /></blockquote><p><strong><mark>-d</mark> ：只显示指定目录，不显示目录内容</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181016521.png" alt="截屏2022-12-18 10.16.52" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181013186.png" alt="截屏2022-12-18 10.13.50" style="zoom:50%;" /><p><strong><mark>-s</mark>（小写 ：显示文件的块数</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181216093.png" alt="截屏2022-12-18 12.16.51" style="zoom:50%;" /><p><strong><mark>-S</mark>（大写：按大小降序排列</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181232314.png" alt="截屏2022-12-18 12.32.31" style="zoom:50%;" /><p><strong><mark>-r</mark> ：反向排序</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181530665.png" alt="截屏2022-12-18 15.30.32" style="zoom:50%;" /><p><strong><mark>-t</mark> ： 按修改时间先后排序</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181706732.png" alt="image-20221218170624706" style="zoom:50%;" /><p><strong><mark>-h</mark> ：按用户易读的方式显示文件大小</strong></p><p>就是换算了一下单位</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181640118.png" alt="截屏2022-12-18 16.40.15" style="zoom:50%;" /><p><strong><mark>-R</mark> ： 列出所有子目录的文件(递归)</strong></p><center class = "half">        <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181722837.png" alt="截屏2022-12-18 17.22.03" style="zoom:40%;" />                <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181723755.png" alt="iShot_2022-12-18_17.21.42" style="zoom:35%;" /></center>**<mark>-1</mark> ： 一行只输出一个文件**<img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181736886.png" alt="截屏2022-12-18 17.36.33" style="zoom:50%;" /><p><mark>-n</mark>：用数字的UID、GID代替owner、group名称</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181741224.png" alt="截屏2022-12-18 17.41.47" style="zoom:50%;" /><p><mark>-i</mark>：显示文件的inode(索引节点)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181929066.png" alt="截屏2022-12-18 19.29.50" style="zoom:50%;" /><p><mark>-F</mark>：在每个文件名后附上一个字符以说明该文件的类型，*表示可执行程序，&#x2F;表示目录，@表示符号连接，|表示FIFOs，&#x3D;表示套接字(sockets)。（目录类型识别）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212190918116.png" alt="截屏2022-12-19 09.17.01" style="zoom:50%;" /></blockquote><h4 id="文件块-简介"><a href="#文件块-简介" class="headerlink" title="文件块(简介)"></a>文件块(简介)</h4><p>(后续会详细学习)</p><p>Linux系统的心脏部分就是其文件系统，文件系统提供了层次结构的目录和文件。</p><p>一般情况下，文件系统将磁盘空间划分为<font color = red>每1024个字节一组，也称为一块</font>（有的Linux将512字节划为一块），编号从0到整个内存的最大块数。</p><p>文件访问系统访问磁盘的时候基本单位是4kb，也就是说是4个块为一个基本单位</p><p>所以在查看文件的总块数的时候会发现都是4的倍数</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181216093.png" alt="截屏2022-12-18 12.16.51" style="zoom:50%;" /><h4 id="inode索引节点-简介"><a href="#inode索引节点-简介" class="headerlink" title="inode索引节点(简介)"></a>inode索引节点(简介)</h4><p>(后续会详细学习)</p><p>用来存放档案和目录的基本信息，包含时间、档名、使用者及群组等</p><h4 id="UID和GID-简介"><a href="#UID和GID-简介" class="headerlink" title="UID和GID(简介)"></a>UID和GID(简介)</h4><p>(后续会详细学习)</p><p>登陆 Linux 系统时，虽然输入的是自己的用户名和密码，但其实 Linux 并不认识你的用户名称，它只认识用户名对应的 ID 号（也就是一串数字）。Linux 系统将所有用户的名称与 ID 的对应关系都存储在 &#x2F;etc&#x2F;passwd 文件中</p><blockquote><p>说白了，用户名并无实际作用，仅是为了方便用户的记忆而已。</p></blockquote><p>Linux 系统中，每个用户的 ID 细分为 2 种，分别是用户 ID（User ID，简称 UID）和组 ID（Group ID，简称 GID），这与文件有拥有者和拥有群组两种属性相对应</p><p>每个文件都有自己的拥有者 ID 和群组 ID，当显示文件属性时，系统会根据 &#x2F;etc&#x2F;passwd 和 &#x2F;etc&#x2F;group 文件中的内容，分别找到 UID 和 GID 对应的用户名和群组名，然后显示出来</p><center><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181915000.gif" /></center><blockquote><p>&#x2F;etc&#x2F;passwd 文件和 &#x2F;etc&#x2F;group 文件，后续文章会做详细讲解，这里只需要知道，在 &#x2F;etc&#x2F;passwd 文件中，利用 UID 可以找到对应的用户名；在 &#x2F;etc&#x2F;group 文件中，利用 GID 可以找到对应的群组名</p></blockquote><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><p><code>pwd</code></p><h5 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h5><p>显示用户当前所在目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212190925534.png" alt="image-20221219092508502" style="zoom:50%;" /><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><h5 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h5><p><code>cd [指定目录]</code></p><h5 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a>功能：</h5><p>进入到指定目录下</p><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd .. # 返回上级目录(相对路径)</span><br><span class="line">cd /home/litao/linux/ # 绝对路径 </span><br><span class="line">cd ../day02/ # 相对路径</span><br><span class="line">cd ~ # 进入用户家目录</span><br><span class="line">cd - # 返回最近访问的目录</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212190929706.png" alt="截屏2022-12-19 09.29.01" style="zoom:50%;" /><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><h5 id="语法：-3"><a href="#语法：-3" class="headerlink" title="语法："></a>语法：</h5><p><code>date [option]......[+format]</code></p><p>option用来设置时间</p><p>format用来显示时间</p><h5 id="功能：-3"><a href="#功能：-3" class="headerlink" title="功能："></a>功能：</h5><p>显示与设定系统的日期与时间</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221219111457827.png" alt="image-20221219111457827" style="zoom:80%;" /><h5 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h5><ol><li>显示时间：</li></ol><p>使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中常用的标记列表如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+%Y # 显示完整年份(0000~9999)</span><br><span class="line">+%m # 显示月份(1~12)</span><br><span class="line">+%d # 显示天(01~31)</span><br><span class="line">+%F # 显示年月日，相当于指令 +%Y-%m-%d</span><br><span class="line">+%H # 显示小时(00~23)</span><br><span class="line">+%M # 显示分钟(00~59)</span><br><span class="line">+%S # 显示秒(00~61)</span><br><span class="line">+%X # 显示时分秒，相当于指令 +%H:%M:%S</span><br></pre></td></tr></table></figure><center>  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191246406.png" alt="截屏2022-12-19 12.46.55" style="zoom:50%;" />  <br>  Mac的终端默认是中文所以输出的最后一行是中文的</center><ol start="2"><li>设定时间</li></ol><p>只有root才有权限设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">date -s # 设置当前时间，只有root权限才能设置，其他只能查看。</span><br><span class="line">date -s 20080523 # 设置成20080523，这样会把具体时间设置成空00:00:00 </span><br><span class="line">date -s 01:01:01 # 设置具体时间，不会对日期做更改</span><br><span class="line">date -s &quot;01:01:01 2008-05-23&quot; # 这样可以设置全部时间</span><br><span class="line">date -s &quot;01:01:01 20080523&quot; # 这样可以设置全部时间</span><br><span class="line">date -s &quot;2008-05-23 01:01:01&quot; # 这样可以设置全部时间</span><br><span class="line">date -s &quot;20080523 01:01:01&quot; # 这样可以设置全部时间</span><br></pre></td></tr></table></figure><p>3.时间戳转换</p><p>Unix时间戳(英文为Unix epoch, Unix time, POSIX time 或 Unix timestamp)是从1970年1月1日(UTC&#x2F;GMT的 午夜)开始所经过的秒数，不考虑闰秒</p><p>时间-&gt;时间戳：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date +%s </span><br></pre></td></tr></table></figure><p>时间戳-&gt;时间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -d@时间戳时间</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191256969.png" alt="截屏2022-12-19 12.56.52" style="zoom:50%;" /><h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><h5 id="语法：-4"><a href="#语法：-4" class="headerlink" title="语法："></a>语法：</h5><p><code>cal [option] [月份] [年份]</code></p><h5 id="功能：-4"><a href="#功能：-4" class="headerlink" title="功能："></a>功能：</h5><p>查看并输出指定年份的指定月份的日历</p><p>省略月份则输出指定年份整年的日历(如果只有一个参数，只能表示年份)</p><p>都省略则输出系统时间所在月的日历</p><h5 id="常用选项：-1"><a href="#常用选项：-1" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-3 # 显示指定日期所在的前一个月份、当前月份、后一个月份的日历</span><br><span class="line">-j # 显示指定日期在当前年中的第几天(从1月1号开始算)</span><br><span class="line">-y # 显示一整年12个月的日历</span><br></pre></td></tr></table></figure><figure class="half">  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222248298.png" alt="截屏2022-12-22 22.42.54" style="zoom:40%;" />  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222248633.png" alt="截屏2022-12-22 22.47.35" style="zoom: 40%;" /></figure><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><h5 id="语法：-5"><a href="#语法：-5" class="headerlink" title="语法："></a>语法：</h5><p><code>touch [选项]……[文件]……</code></p><h5 id="功能：-5"><a href="#功能：-5" class="headerlink" title="功能："></a>功能：</h5><ol><li>如果文件已存在，更改文件(包括目录文件)的时间记录，包括存取时间和修改时间</li><li>如果文件不存在，创建这个文件(不能新建目录)</li></ol><center class = "half">  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191000119.png" alt="截屏2022-12-19 09.59.53" style="zoom:45%;" />  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191000049.png" alt="截屏2022-12-19 10.00.01" style="zoom:45%;" />  </center><h5 id="常用选项：-2"><a href="#常用选项：-2" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-a，--time=atime，--time=access，--time=use # 只更改存取时间</span><br><span class="line">-m，--time=mtime，--time=modify # 只更改修改时间</span><br><span class="line">-c，--no-creat # 不创建文件</span><br><span class="line">-d [时间] # 将时间记录改为给定的时间，时间可以使用各种不同的格式</span><br><span class="line">-t [时间] # 将时间记录改为给定的时间，时间必须使用[[YY]YY]MMDDhhmm[.SS]，不再放括号里的是必须有的，方括号里的是可以省略的</span><br><span class="line">-r [参考文件] # 将时间记录改为跟参考文件一样的时间</span><br><span class="line">-f # 会被忽略处理，是为了与其他 unix 系统的相容性而保留</span><br></pre></td></tr></table></figure><blockquote><p><mark>-a</mark></p><p>无法直观展示</p><p><mark>-m</mark></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191004398.png" alt="image-20221219100439373" style="zoom:50%;" /><p><mark>-c</mark></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191005165.png" alt="image-20221219100520143" style="zoom:50%;" /><p><mark>-d [时间]</mark></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191008543.png" alt="截屏2022-12-19 10.07.57" style="zoom:50%;" /><p><mark>-t</mark> [时间]</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191713110.png" alt="截屏2022-12-19 17.13.54" style="zoom:50%;" /></blockquote><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><h5 id="语法：-6"><a href="#语法：-6" class="headerlink" title="语法："></a>语法：</h5><p><code>mkdir [-p] DIRNAME</code></p><h5 id="功能：-6"><a href="#功能：-6" class="headerlink" title="功能："></a>功能：</h5><p>在当前目录下创建一个名为DIRNAME的目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191720623.png" alt="截屏2022-12-19 17.20.02" style="zoom:50%;" /><h5 id="常用选项：-3"><a href="#常用选项：-3" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p # 后跟一个路径。如果路径中有不存在的目录，则会创建出这些不存在的路径。也就是可以一次性创建一个路径，多个目录。（或--parents）</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191725268.png" alt="截屏2022-12-19 17.25.07" style="zoom:50%;" /><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><h5 id="语法：-7"><a href="#语法：-7" class="headerlink" title="语法："></a>语法：</h5><p><code>rmdir [-p] 目录</code></p><h5 id="适用对象："><a href="#适用对象：" class="headerlink" title="适用对象："></a>适用对象：</h5><p>具有指定目录的权限的所有使用者</p><h5 id="功能：-7"><a href="#功能：-7" class="headerlink" title="功能："></a>功能：</h5><p>删除指定目录，目录必须是空的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191733118.png" alt="截屏2022-12-19 17.33.29" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191736474.png" alt="截屏2022-12-19 17.36.12" style="zoom:50%;" /><h5 id="常用选项：-4"><a href="#常用选项：-4" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-p # 当指定目录被删除后它的父目录变成空的话，连同父目录一起删除</span><br><span class="line">* # 借助通配符*，满足匹配条件的文件都会被复制。</span><br><span class="line">? # 同上</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191739720.png" alt="截屏2022-12-19 17.39.04" style="zoom:50%;" /><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><h5 id="语法：-8"><a href="#语法：-8" class="headerlink" title="语法："></a>语法：</h5><p><code>rm [option] 文件</code></p><h5 id="适用对象：-1"><a href="#适用对象：-1" class="headerlink" title="适用对象："></a>适用对象：</h5><p>所有使用者</p><h5 id="功能：-8"><a href="#功能：-8" class="headerlink" title="功能："></a>功能：</h5><p>删除文件，搭配选项可以删除目录</p><p>注意，文件一旦删除无法恢复！</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212200955025.png" alt="截屏2022-12-20 09.55.42" style="zoom:50%;" /><h5 id="常用选项：-5"><a href="#常用选项：-5" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-r # 删除目录及其下所有文件</span><br><span class="line">* # 借助通配符*，满足匹配条件的文件都会被复制。</span><br><span class="line">? # 同上</span><br><span class="line">-f # 即使文件属性为只读(即写保护)，亦直接删除，无需逐一确认</span><br><span class="line">-i # 删除前逐一询问确认</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201000703.png" alt="截屏2022-12-20 10.00.09" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201003511.png" alt="截屏2022-12-20 10.03.31" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201000976.png" alt="截屏2022-12-20 10.00.26" style="zoom:50%;" /><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><h5 id="语法：-9"><a href="#语法：-9" class="headerlink" title="语法："></a>语法：</h5><p><code>man [option] command</code></p><h5 id="功能：-9"><a href="#功能：-9" class="headerlink" title="功能："></a>功能：</h5><p>查找指定命令的用法</p><h5 id="补充说明："><a href="#补充说明：" class="headerlink" title="补充说明："></a>补充说明：</h5><ol><li><p>Linux手册是联机手册，进行联机查找</p></li><li><p>执行<code>man man</code>指令可以查询man的详细信息，包括用法、每章节的内容分类等</p></li><li><p>帮助文档分为8章：</p><blockquote><p>1 是普通的命令 </p><p>2 是系统调用,如open,write之类的(通过这个，至少可以很方便的查到调用这个函数，需要加什么头文 件) </p><p>3 是库函数,如printf,fread</p><p>4 是特殊文件,也就是&#x2F;dev下的各种设备文件 </p><p>5 是指文件的格式,比如passwd, 就会说明这个文件中各个字段的含义 </p><p>6 是给游戏留的,由各个游戏自己定义</p><p>7 是附件还有一些变量,比如向environ这种全局变量在这里就有说明 </p><p>8 是系统管理用的命令,这些命令只能由root使用,如ifconfig </p></blockquote></li><li><p>man 命令中常用按键以及用途</p><table><thead><tr><th>按键</th><th>用途</th></tr></thead><tbody><tr><td>空格键</td><td>向下翻一页</td></tr><tr><td>PaGe down</td><td>向下翻一页</td></tr><tr><td>PaGe up</td><td>向上翻一页</td></tr><tr><td>home</td><td>直接前往首页</td></tr><tr><td>end</td><td>直接前往尾页</td></tr><tr><td>&#x2F;</td><td>从上至下搜索某个关键词，如“&#x2F;linux”</td></tr><tr><td>？</td><td>从下至上搜索某个关键词，如“?linux”</td></tr><tr><td>n</td><td>定位到下一个搜索到的关键词</td></tr><tr><td>N</td><td>定位到上一个搜索到的关键词</td></tr><tr><td>q</td><td>退出帮助文档</td></tr><tr><td>鼠标滚轮</td><td>上下翻页</td></tr></tbody></table></li></ol><h5 id="常用选项：-6"><a href="#常用选项：-6" class="headerlink" title="常用选项："></a><a href="https://cloud.tencent.com/developer/article/1725969">常用选项：</a></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num # 只在第num章节中进行查找</span><br><span class="line">-k # 后面的command可以是缺省的，进行模糊查找</span><br><span class="line">-a，--all # 寻找所有匹配的手册页</span><br><span class="line">-f，--whatis # 相当于whatis</span><br><span class="line">-i，--ignore-case # 查找手册页时不区分大小写(默认)</span><br><span class="line">-I，--match-case # 区分大小写</span><br></pre></td></tr></table></figure><h4 id="whatis"><a href="#whatis" class="headerlink" title="whatis"></a>whatis</h4><p>Linux 中的 <code>whatis</code> 命令可以从它的字面意思可以看出来，就是“这是什么”，通过它可以知道某命令是用来干什么的，而且是用很简短的方式来描述。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201055267.png" alt="截屏2022-12-20 10.55.10" style="zoom:50%;" /><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><h5 id="语法：-10"><a href="#语法：-10" class="headerlink" title="语法："></a>语法：</h5><p><code>cp [option] 源文件 指定目录下的目标文件</code></p><h5 id="功能：-10"><a href="#功能：-10" class="headerlink" title="功能："></a>功能：</h5><p>将 源文件 在指定目录下 复制出指定文件</p><blockquote><p>如果省略指定目录，则默认是当前目录</p><p>如果省略目标文件，则会在指定目录下复制出跟源文件同名的文件</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201625241.png" alt="截屏2022-12-20 16.25.29" style="zoom:50%;" /><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><ol><li><p>本质过程是根据源文件复制创建出一个新的文件，所以如果目标文件跟已存在的文件重名，会覆盖已存在的文件(且默认不会询问)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201628004.png" alt="截屏2022-12-20 16.28.04" style="zoom:50%;" /></li><li><p>如果要复制目录，则必须加上<code>-r</code>选项，</p></li><li><p>指定文件的类型必须跟源文件类型一样，普通文件只能复制出普通文件，源文件只能复制出源文件</p></li><li><p>可以一次性复制多个源文件，各个源文件之间用空格间隔，最后跟一个指定目录，各个源文件会复制到指定目录中去</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201630006.png" alt="截屏2022-12-20 16.30.35" style="zoom:50%;" /></li></ol><h5 id="常用选项：-7"><a href="#常用选项：-7" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-r # 复制目录(并递归复制该源目录下所有的子目录和文件)</span><br><span class="line">-f，--force # 强制复制，且覆盖已经存在的文件之前不询问用户。如果文件不能打开，可以用它强行复制</span><br><span class="line">-i，--interactive # 在覆盖已存在的文件之前选询问用户(与-f相反)</span><br><span class="line">-u # 当源文件比目标文件新时才会复制，否则不复制成目标文件</span><br><span class="line">* # 借助通配符*，满足匹配条件的文件都会被复制。</span><br><span class="line">? # 同上</span><br></pre></td></tr></table></figure><h4 id="通配符-简介"><a href="#通配符-简介" class="headerlink" title="通配符(简介)"></a>通配符(简介)</h4><p>(后续会详细学习)</p><p>linux常用通配符有* ，？，[ ]，[^]，[:space:]，[:punct:]，[:lower:]，[:upper:]，[:digit:]，[:alnum:]等等</p><p>它是由shell解析，并且一般用于匹配文件名，实际上就是shell解释器去解析的特殊符号</p><blockquote><blockquote><ol><li><p><strong><mark>通配符不仅会匹配当前目录下的满足条件的文件，还会<u>递归匹配</u>子目录下的满足条件的文件</mark></strong></p></li><li><p><strong><mark>开始字符和结束字符都可以省略</mark></strong></p><blockquote><p>在匹配文件的时候，被匹配的文件名会被分成三部分：开始字符、中间字符、结束字符</p><p>分别对应文件名的开头、中间、结尾</p><blockquote><p>如果开始字符被省略，那么被匹配的字符就变成了：中间字符、结束字符</p><p>则文件名的开头、中间都被视为中间字符，结尾被视为结束字符</p><p>匹配时寻找 文件名结尾 跟 结束字符 相同，且 文件名开头和中间 满足中间字符要求 的文件</p><p>(比如有的通配符要求中间只能有一个字符，那么只有文件名结尾跟结束字符相同，且除了文件名结尾之外的部分(也就是开头和中间)只有一个字符的才能满足匹配要求)</p></blockquote><blockquote><p>如果结束字符被省略，那么被匹配的字符就变成了：开始字符、结束字符</p><p>那么文件名的开头被视为开始字符，中间和结尾被视为结束字符</p><p>匹配时寻找 文件名开头 跟 开始字符 相同，且 文件名中间和结尾 满足中间字符要求 的文件</p></blockquote><blockquote><p>如果开始字符和结束字符都被省略，被匹配的字符只有中间字符</p><p>整个文件名都被视为中间字符，所有 满足中间字符要求 的文件名都会被匹配上</p></blockquote></blockquote></li></ol></blockquote><p>**<mark><em>：匹配任意多个字符</mark></em>*</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开始字符*结束字符 # 会匹配满足 文件名开头 和 文件名结尾 分别与开始字符和结束字符相同的、中间有任意多个字符的文件</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201812569.png" alt="截屏2022-12-20 18.12.08" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201940130.jpeg" alt="IMG_0865" style="zoom:40%;" /><p><strong><mark>?：匹配任意一个字符</mark></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开始字符?结束字符 # 会匹配满足 文件名开头 和 文件名结尾 分别与开始字符和结束字符相同的、中间只有一个字符的文件。</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202250451.png" alt="截屏2022-12-20 22.50.14" style="zoom:50%;" /><p><strong><mark>[…]：匹配中括号内出现的任意一个字符</mark></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开始字符[…]结束字符 # 会匹配满足 文件名开头 和 文件名结尾 分别与开始字符和结束字符相同的、中间存在于[]内且只有一个字符的文件</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202311425.png" alt="截屏2022-12-20 23.11.52" style="zoom:50%;" /><p><strong><mark>[!…]：不匹配中括号内出现的任意一个字符</mark></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开始字符[!…]结束字符 # 会匹配满足 文件名开头 和 文件名结尾 分别与开始字符和结束字符相同的、中间不存在于[]内且只有一个字符的文件</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202317821.png" alt="截屏2022-12-20 23.17.01" style="zoom:50%;" /></blockquote><p><strong><mark>通配符可以作为一个选项，在非常多的命令中都可以用到，用来匹配文件名</mark></strong></p><p>一般出现在要shell命令或脚本中，匹配特定的文件名</p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><h5 id="语法：-11"><a href="#语法：-11" class="headerlink" title="语法："></a>语法：</h5><p><code>mv [option] 源文件 指定目录</code></p><p><code>mv [option] 源文件 文件名</code>(文件名也可以是指定目录下的某个文件的文件名，但是这样不是多此一举了吗)</p><h5 id="功能：-11"><a href="#功能：-11" class="headerlink" title="功能："></a>功能：</h5><p>将 源文件 <strong>移动</strong> 到指定目录下。如果指定目录下存在与源文件重名的文件，则默认会被刚移动进来的源文件覆盖掉</p><p>将 源文件 <strong>改名</strong>为 给定的文件名。如果当前目录下已经存在与给定文件名重名的文件，则默认会被新改过名的源文件覆盖掉</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202331000.png" alt="截屏2022-12-20 23.31.16" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202343117.png" alt="截屏2022-12-20 23.43.13" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202333934.png" alt="截屏2022-12-20 23.33.52" style="zoom:50%;" /><h5 id="常用选项：-8"><a href="#常用选项：-8" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-f # force强制，在移动或改名时，如果出现了重名情况，不会询问而是直接复覆盖</span><br><span class="line">-i # 在移动或改名时，如果出现了重名情况，会询问是否覆盖</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202348339.png" alt="截屏2022-12-20 23.48.30" style="zoom:50%;" /><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><h5 id="语法：-12"><a href="#语法：-12" class="headerlink" title="语法："></a>语法：</h5><p><code>cat [选项] [目标文件]</code></p><h5 id="功能：-12"><a href="#功能：-12" class="headerlink" title="功能："></a>功能：</h5><p>输出内容到指定输出设备(默认指定输出设备是显示器)：</p><p>如果目标文件没被省略，<strong>打印&#x2F;输出</strong>目标文件的内容</p><p>如果目标文件被省略，则是<strong>打印&#x2F;输出</strong>刚刚从键盘上输入的内容(Linux下一切皆文件，默认将键盘视为了文件)，ctrl + c结束</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202353491.png" alt="image-20221220235315449" style="zoom:50%;" /><h5 id="常用选项：-9"><a href="#常用选项：-9" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-b # 对非空输出行编号 </span><br><span class="line">-n # 对输出的所有行编号</span><br><span class="line">-s # 不输出多行空行 </span><br></pre></td></tr></table></figure><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><h5 id="语法：-13"><a href="#语法：-13" class="headerlink" title="语法："></a>语法：</h5><p><code>more [选项] 文件</code></p><h5 id="功能：-13"><a href="#功能：-13" class="headerlink" title="功能："></a>功能：</h5><p>类似于cat，但是逐页后翻逐页<strong>打印&#x2F;输出</strong>，并可以查看前面已<strong>打印&#x2F;输出</strong>的内容，支持跳转</p><h5 id="按键用途："><a href="#按键用途：" class="headerlink" title="按键用途："></a>按键用途：</h5><blockquote><table><thead><tr><th>按键</th><th>用途</th></tr></thead><tbody><tr><td>空格space，f，ctrl+f</td><td>向下滚动一屏(后翻，下一页)</td></tr><tr><td>b(意味着back)，ctrl+b</td><td>向上滚动一屏(前翻，上一页)</td></tr><tr><td>q</td><td>退出查看</td></tr><tr><td>enter</td><td>向下n行，需要定义。默认为1行</td></tr><tr><td>&#x3D;</td><td>输出当前的行号</td></tr><tr><td>!命令</td><td>调用shell，并执行命令</td></tr><tr><td>v</td><td>调用vi编辑器</td></tr></tbody></table></blockquote><blockquote><p>向后翻页</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212211159652.gif" alt="Dec-21-2022 11-58-30" style="zoom: 80%;" /><p>向前翻页，按q退出</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212211200255.gif" alt="Dec-21-2022 11-59-56" style="zoom:80%;" /><p>文件内容是被打印出来的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212211204121.gif" alt="Dec-21-2022 12-03-52" style="zoom:80%;" /></blockquote><h5 id="常用选项：-10"><a href="#常用选项：-10" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+NUM # 从文件的第NUM行开始打印</span><br><span class="line">-NUM # 每页只输出NUM行</span><br><span class="line">+/STRING # 在目标文件中寻找含有字符串STRING的一行，并从它的前两行开始打印</span><br><span class="line">-p # 不滚屏，清屏并打印文本</span><br><span class="line">-c # 不滚屏，打印文本并清理行尾</span><br><span class="line">-u # 不打印文件中的下划线</span><br><span class="line">-s # 压缩多个连续空行为一个空行</span><br><span class="line">-d # 显示帮助，提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能</span><br><span class="line">-f # 统计逻辑行数而不是屏幕行数</span><br><span class="line">-l # 忽略ctrl+l(换页)字符，抑制换页(form feed)后的暂停</span><br></pre></td></tr></table></figure><h5 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h5><p>cat和more指令的本质是将文件内容<mark><strong>打印</strong></mark>出来。</p><p>因此实际上只能不断打印输出文件后面的内容，对于文件前面的内容，只能通过翻页的方式查看已经打印出来的。</p><p>当用 more +NUM，从第NUM行开始查看的时候，NUM行之前的内容由于没有被打印出来，所以无法查看到。</p><p><mark>所以cat和more指令更像是文件内容打印指令，而不是正统的文件内容查看指令。</mark></p><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><h5 id="说明：-2"><a href="#说明：-2" class="headerlink" title="说明："></a>说明：</h5><p><mark>Linux正统的文件内容查看工具</mark></p><p>less是进入文件内部加载，进行浏览查看，而不是将文件内容打印出来再进行查看</p><p>less在查看之前不会加载整个文件，只加载浏览位置的内容</p><p>less可以随意浏览文件内容，可以用上下、翻页(pagedown\pageup)、空格、回车、b、f等按键 随意前后移动查看，功能强大，用法具有弹性</p><blockquote><p>前后移动查看</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212211220727.gif" alt="Dec-21-2022 12-20-22" style="zoom:80%;" /><p>退出，发现less并不是将文件内容打印出来，而是进入文件加载，进行浏览查看</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212211223871.gif" alt="Dec-21-2022 12-22-53" style="zoom:80%;" /></blockquote><h5 id="语法：-14"><a href="#语法：-14" class="headerlink" title="语法："></a>语法：</h5><p><code>less [option] 文件</code></p><h5 id="按键用途：-1"><a href="#按键用途：-1" class="headerlink" title="按键用途："></a>按键用途：</h5><table><thead><tr><th>按键</th><th>用途</th></tr></thead><tbody><tr><td>按键</td><td>用途</td></tr><tr><td>空格space，f，ctrl+f，pageup</td><td>向下滚动一屏(后翻，下一页)</td></tr><tr><td>b(意味着back)，ctrl+b，pagedown</td><td>向上滚动一屏(前翻，上一页)</td></tr><tr><td>d，ctrl + d</td><td>向下滚动半屏</td></tr><tr><td>u，ctrl + u</td><td>向上移动半屏</td></tr><tr><td>↓，j</td><td>向下滚动一行</td></tr><tr><td>↑，k</td><td>向上滚动一行</td></tr><tr><td>g</td><td>移动到第一行</td></tr><tr><td>NUMg</td><td>移动到文件的第NUM行</td></tr><tr><td>G</td><td>移动到最后一行</td></tr><tr><td>enter</td><td>向下n行，需要定义。默认为1行</td></tr><tr><td>q，ZZ</td><td>退出查看</td></tr><tr><td>&#x2F;STRING</td><td>向下搜索“STRING”</td></tr><tr><td>?STRING</td><td>向上搜索“STRING”</td></tr><tr><td>n</td><td>重复前一个搜索（与 &#x2F; 或 ? 有关）</td></tr><tr><td>N</td><td>反向重复前一个搜索（与 &#x2F; 或 ? 有关）</td></tr><tr><td>ma</td><td>使用a标记文本的当前位置</td></tr><tr><td>a</td><td>跳转到a标记处</td></tr><tr><td>h</td><td>显示less的帮助文档</td></tr><tr><td>!命令</td><td>调用shell，并执行命令</td></tr><tr><td>v</td><td>调用vi编辑器</td></tr></tbody></table><h5 id="常用选项-可以在浏览文件时使用"><a href="#常用选项-可以在浏览文件时使用" class="headerlink" title="常用选项(可以在浏览文件时使用):"></a>常用选项(可以在浏览文件时使用):</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-i # 忽略搜索时的大小写</span><br><span class="line">-N # 显示每行的行号，再用一次会取消显示每行的行号</span><br></pre></td></tr></table></figure><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><h5 id="语法：-15"><a href="#语法：-15" class="headerlink" title="语法："></a>语法：</h5><p><code>head [option] 文件</code></p><h5 id="功能：-14"><a href="#功能：-14" class="headerlink" title="功能："></a>功能：</h5><p>从指定文件的开头开始输出到标准输出，到文件的某位置结束。默认打印前10行</p><h5 id="常用选项：-11"><a href="#常用选项：-11" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-n +NUM # 打印前NUM行，可以简写成 -n NUM 或 -nNUM 或者 -NUM</span><br><span class="line">-n -NUM # 从第一行开始打印，到倒数第NUM行停止。</span><br><span class="line">-c +SIZE # 从头开始打印，到SIZE个字节停止。可以简写成 -c SIZE 或 -cSIZE</span><br><span class="line">-c -SIZE # 从头开始打印，到倒数第SIZE个字节停止。</span><br><span class="line">-q # 不显示详细处理信息，比如文件名 (默认就是隐藏的)</span><br><span class="line">-v # 显示详细处理信息</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222148587.png" alt="image-20221222214831555" style="zoom:50%;" /><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><h5 id="语法：-16"><a href="#语法：-16" class="headerlink" title="语法："></a>语法：</h5><p><code>tail [option] [文件]</code></p><h5 id="功能：-15"><a href="#功能：-15" class="headerlink" title="功能："></a>功能：</h5><p>有指定文件时，用于从文件某位置开始输出到标准输出，到文件末尾结束。默认打印文件的最后10行。</p><p>无指定文件时，作为输入信息进行处理。</p><p>常用来查看日志文件。</p><h5 id="常用选项：-12"><a href="#常用选项：-12" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-n -NUM # 从倒数第NUM行开始输出，到结尾结束。可以简写成 -n NUM 或 -nNUM 或 -NUM。</span><br><span class="line">-n +NUM # 从正数第NUM行开始输出，到结尾结束。</span><br><span class="line">-c -SIZE # 从倒数第SIZE个字节开始输出，到结尾结束。可以简写成 -c SIZE 或 -cSIZE</span><br><span class="line">-c +SIZE # 从正数第SIZE个字节开始输出，到结尾结束。</span><br><span class="line">-f # 循环读取</span><br><span class="line">-p # 不显示详细处理信息，比如文件名(默认就是不显示的)</span><br><span class="line">-v # 显示详细的处理信息</span><br><span class="line">-s S # 与-f合用，表示在每反复的间隔休息S秒</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222152371.png" alt="截屏2022-12-22 21.52.01" style="zoom:50%;" /><blockquote><p>现在创建了一个一共100行的文件，请取出第50行</p><center>  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222153309.png" alt="截屏2022-12-22 21.53.18" style="zoom:50%;" /><br>生成1到100的序列并输出重定向到文件atest</center><p>方法一：</p><blockquote><p>将atest的前50行输出重定向到新文件tmp中</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222157524.png" alt="截屏2022-12-22 21.57.55" style="zoom:50%;" /><p>输出tmp的最后一行</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222158536.png" alt="截屏2022-12-22 21.58.37" style="zoom:50%;" /></blockquote><p>方法二：</p><blockquote><p>利用管道，输出atest的前五十行的最后一行s</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222159422.png" alt="截屏2022-12-22 21.59.30" style="zoom:50%;" /></blockquote></blockquote><h4 id="管道-简介"><a href="#管道-简介" class="headerlink" title="管道(简介)"></a>管道(简介)</h4><p>将两个或者多个命令（程序或者进程）连接到一起，把一个命令的输出作为下一个命令的输入，以这种方式连接的两个或者多个命令就形成了<strong>管道（pipe）</strong></p><p>管道可以级联多个命令，将上一个命令的输出作为下一个命令的输入，实现流水线式的操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command1 | command2</span><br><span class="line">command1 | command2 |......| commandN </span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212220959035.png" alt="截屏2022-12-22 09.59.25" style="zoom:50%;" /><p>当在两个命令之间设置管道时，管道符<code>|</code>左边命令的输出就变成了右边命令的输入。只要第一个命令向标准输出写入，而第二个命令是从标准输入读取，那么这两个命令就可以形成一个管道。大部分的 Linux 命令都可以用来形成管道。</p><blockquote><p>这里需要注意，command1 必须有正确输出，而 command2 必须可以处理 command2 的输出结果；而且 command2 只能处理 command1 的正确输出结果，不能处理 command1 的错误信息。</p></blockquote><p>多个被级联起来的命令就像是组成了几条管道联通起来，数据资源在里面进行了传输，非常形象</p><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><h5 id="语法：-17"><a href="#语法：-17" class="headerlink" title="语法："></a>语法：</h5><p><code>echo [option] 输出内容 [输出重定向]</code></p><h5 id="功能：-16"><a href="#功能：-16" class="headerlink" title="功能："></a>功能：</h5><p>将内容输出到到标准输出(默认输出设备是显示器，可以通过输出重定向进行更改输出设备)</p><h5 id="常用选项：-13"><a href="#常用选项：-13" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-e # 支持反斜杠控制的字符转换(具体参见下表)</span><br><span class="line">-n # 取消输出后行末的换行符号(内容输出后换行)</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222100949.png" alt="截屏2022-12-22 21.00.02" style="zoom:50%;" /><center>控制字符表⬇️</center><table><thead><tr><th>控制字符</th><th>作 用</th></tr></thead><tbody><tr><td>\</td><td>输出\本身</td></tr><tr><td>\a</td><td>输出警告音</td></tr><tr><td>\b</td><td>退格键，也就是向左删除键</td></tr><tr><td>\c</td><td>取消输出行末的换行符。和“-n”选项一致</td></tr><tr><td>\e</td><td>Esc键</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\r</td><td>回车键</td></tr><tr><td>\t</td><td>制表符，也就是Tab键</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\Onnn</td><td>按照八进制 ASCII 码表输出字符。其中 0 为数字 0，nnn 是三位八进制数</td></tr><tr><td>\xhh</td><td>按照十六进制 ASCH 码表输出字符。其中 hh 是两位十六进制数</td></tr></tbody></table><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222106931.png" alt="截屏2022-12-22 21.06.54" style="zoom:50%;" /><p>echo经常搭配输出重定向使用，将输入输出到指定文件中，而且如果指定文件不存在，还会创建出来(输出重定向的作用)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222108421.png" alt="截屏2022-12-22 21.08.08" style="zoom:50%;" /><p><a href="http://c.biancheng.net/linux/echo.html">更高级的玩法还看这里</a></p><h4 id="重定向-简介"><a href="#重定向-简介" class="headerlink" title="重定向(简介)"></a>重定向(简介)</h4><p>Linux 中标准的<strong>输入设备&#x2F;标准输入 默认是 键盘</strong>，标准的<strong>输出设备&#x2F;标准输入 默认是 显示器</strong></p><ul><li>输入重定向：指的是重新指定设备来代替键盘作为新的输入设备；</li><li>输出重定向：指的是重新指定设备来代替显示器作为新的输出设备。</li></ul><blockquote><p>新的输入设备：通常是指文件或者命令的执行结果</p><p>新的输出设备：通常是指文件</p></blockquote><p><strong>输入重定向：</strong></p><blockquote><table><thead><tr><th>命令符号格式</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将指定文件作为命令的输入设备</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>表示从标准输入设备（键盘）中读入，直到遇到分界符才停止（读入的数据不包括分界符），这里的分界符其实就是自定义的字符串</td></tr><tr><td>命令 &lt; 文件 1 &gt; 文件 2</td><td>将文件 1 作为命令的输入设备，该命令的执行结果输出到文件 2 中。</td></tr></tbody></table><p>命令 &lt; 文件：用文件代替默认输入设备(键盘)的输入</p><blockquote><p>当使用cat命令时，如果不加目标文件，会从默认输入设备上获取输入并输出到默认输出设备</p><p>更改默认输入设备为指定文件(这就跟cat命令后面加目标文件一个效果了)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212221723418.png" alt="截屏2022-12-22 17.23.54" style="zoom:50%;" /></blockquote><p>命令 &lt;&lt; 分界符：</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212221724262.png" alt="截屏2022-12-22 17.24.45" style="zoom:50%;" /></blockquote><p>命令 &lt; 文件 1 &gt; 文件 2：是输入重定向和输出重定向的结合使用</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212221727249.png" alt="截屏2022-12-22 17.27.12" style="zoom:50%;" /></blockquote></blockquote><p><strong>输出重定向：</strong></p><p>使用频率更高，将命令的结果重定向输出到指定的新输出设备(即文件)中</p><p><strong><mark>注意</mark>如果指定的文件是不存在的，输出重定向的时候会创建出这个文件</strong></p><p>输出重定向按<u>性质</u> 分为 标准输出重定向和 错误输出重定向 两种</p><blockquote><p>当命令正确执行时，会产生正确的输出结果，此时将正确的输出结果作为输出设备时是标准输出重定向</p><p>当命令执行失败时，会产生错误输出信息，此时将错误输出信息作为输出设备时时错误输出重定向</p><p>两种在写法上没有区别，只是按照命令的执行成功与否进行了分类</p></blockquote><p>输出重定向按<u>用法</u> 分为 清空写入重定向(&gt;) 和 追加写入重定向(&gt;&gt;)</p><blockquote><p>清空写入重定向(&gt;)：将命令的结果重定向输出到指定的文件中，如果该文件原来已经包含数据，会清空原有数据，再写入新数据</p><p>追加写入重定向(&gt;&gt;)：将命令的结果重定向输出到指定的文件中，如果该文件原来已经包含数据，新数据会写入原有数据的后面</p></blockquote><blockquote><table><thead><tr><th>命令符号格式</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，会清空原有数据，再写入新数据。</td></tr><tr><td>命令 2&gt; 文件</td><td>将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，会清空原有数据，再写入新数据。<br />注意，”2&gt;”是固定格式</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，新数据将写入到原有内容的后面。</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，新数据将写入到原有内容的后面。<br />注意，”2&gt;”是固定格式</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或者 命令 &amp;&gt;&gt; 文件</td><td>将标准输出或者错误输出写入到指定文件，如果该文件中已包含数据，新数据将写入到原有内容的后面。<br />注意，第一种写法中，最后的 “2&gt;&amp;1” 是一体的，可以认为是固定写法。</td></tr></tbody></table><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222048427.png" alt="截屏2022-12-22 20.47.56" style="zoom:50%;" /></blockquote><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><h5 id="语法：-18"><a href="#语法：-18" class="headerlink" title="语法："></a>语法：</h5><p><code>find [pathname] [option]</code></p><h5 id="功能：-17"><a href="#功能：-17" class="headerlink" title="功能："></a>功能：</h5><p>在指定目录下查找文件</p><p>任何位于选项参数之前的字符串都被视为指定目录</p><p>如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p><h5 id="常用选项：-14"><a href="#常用选项：-14" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-name &quot;NAME&quot; # 在指定目录和子目录下查找文件名为NAME的文件，双引号可以省略。可以结合通配符使用，这个时候加上双引号搜索到的才是是全面的</span><br><span class="line">-type TYPE # 文件类型是TYPE的文件。f是普通文件，d是目录</span><br></pre></td></tr></table></figure><blockquote><p>查看更多用法<a href="https://www.runoob.com/linux/linux-comm-find.html">点这里</a></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212241118537.png" alt="截屏2022-12-24 11.18.40" style="zoom:50%;" /><blockquote><p>Linux下find命令提供了相当多的查找条件，功能很强大。由于find具有强大的功能，所以它的选项也很 多，其中大部分选项都值得我们花时间来了解一下。</p><p>即使系统中含有网络文件系统( NFS)，find命令在该文件系统中同样有效，只你具有相应的权限。</p><p>在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系 统可能会花费很长的时间(这里是指30G字节以上的文件系统)。 </p></blockquote></blockquote><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>行文本过滤工具</p><h5 id="语法：-19"><a href="#语法：-19" class="headerlink" title="语法："></a>语法：</h5><p><code>grep [option] &quot;STRING&quot; 指定文件</code></p><h5 id="功能：-18"><a href="#功能：-18" class="headerlink" title="功能："></a>功能：</h5><p>用于查找指定文件里包含STRING的行，将其打印出来</p><p>双引号可以省略</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212241130543.png" alt="截屏2022-12-24 11.30.14" style="zoom:50%;" /><h5 id="常用选项：-15"><a href="#常用选项：-15" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-i # 查找时忽略大小写</span><br><span class="line">-n # 顺便输出在文件中的行号</span><br><span class="line">-v # 反向选择，即打印出不包含被查找的字符串的行</span><br></pre></td></tr></table></figure><figure style=half>  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212241150576.png" alt="截屏2022-12-24 11.49.36" style="zoom:50%;" />  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212241150581.png" alt="截屏2022-12-24 11.49.46" style="zoom:50%;" /></figure><h3 id="打包-和-压缩："><a href="#打包-和-压缩：" class="headerlink" title="打包 和 压缩："></a>打包 和 压缩：</h3><p><mark>打包</mark>：也称归档、备份，指的是一个文件或者目录的集合，而这个集合被存储在一个文件中。打包文件没有经过压缩，因此占用的空间就是打包文件中所有文件的总空间。</p><blockquote><p>将多个文件打包形成一个包</p></blockquote><p><mark>压缩</mark>：利用算法将文件进行处理，以达到保留最大文件信息而让文件体积变小的目的。</p><blockquote><p>只能将一个文件压缩成一个压缩包</p></blockquote><p>打包就像是将行李放进行李箱。压缩就像是为了减少行李的大小，用收纳法将行李的体积折叠的尽可能小，这样就能在箱子里放入更多的行李，也可以将打包好的行李进行收纳，这样行李占用的体积就更小，可以用更小的行李箱。</p><p>压缩是将文件的大小减小，起到减少资源占用的作用。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212261737354.jpeg" alt="IMG_0891" style="zoom:50%;" /><p>如果想一次性压缩许多零零散散的文件或目录，就得要先把它们打成一个包，然后把这个包压缩。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212261747026.jpeg" alt="IMG_0892" style="zoom:50%;" /><p>压缩软件打包压缩格式界面：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212261740678.jpeg" alt="截屏2022-12-26 17.36.56" style="zoom:50%;" /><h3 id="关于普通文件类型的说明："><a href="#关于普通文件类型的说明：" class="headerlink" title="关于普通文件类型的说明："></a>关于普通文件类型的说明：</h3><p>文件的分类就分为<a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB">上面介绍的几类</a></p><p>在Linux中，并不以文件的后缀来区分文件类型，无论是<code>.c</code> <code>.cpp</code> <code> .zip</code> <code> .tar</code> <code>.txt</code>等，都是普通文件类型，文件后缀只是在处理文件的时候进行区分，比如只有<code>.zip</code>等才能解压，<code>.c</code> <code> .cpp</code>等才能编译等。它们都是普通文件。</p><h3 id="zip-x2F-unzip压缩"><a href="#zip-x2F-unzip压缩" class="headerlink" title="zip&#x2F;unzip压缩"></a>zip&#x2F;unzip压缩</h3><p>压缩包拓展名&#x2F;后缀 是<code>.zip</code></p><h5 id="语法-x2F-功能："><a href="#语法-x2F-功能：" class="headerlink" title="语法&#x2F;功能："></a>语法&#x2F;功能：</h5><p><code>zip [option] ZIPNAME 目标文件 </code>：将目标文件压缩为名称为ZIPNAME的压缩包。压缩包的<code>.zip</code>后缀可带可不带，会自动补上</p><p><code>unzip [option] 指定压缩包  </code>：将压缩包解压到当前目录下。若当前目录下有文件与解压后文件重名，会进行询问是否覆盖。注意，解压后文件的名称是压缩前文件的名称，并不是压缩包的名称。</p><h5 id="常用选项：-16"><a href="#常用选项：-16" class="headerlink" title="常用选项："></a>常用选项：</h5><p>zip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-r # 递归处理，将指定目录下的所有文件和子目录一并处理，分别形成单独的压缩包</span><br><span class="line">-m # 将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中</span><br><span class="line">-v # 显示详细的压缩过程信息(默认)</span><br><span class="line">-q # 在压缩的时候不显示命令的执行过程</span><br><span class="line">-数字 # 压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好</span><br><span class="line">-u # 更新压缩文件，即往压缩文件中添加新文件</span><br></pre></td></tr></table></figure><p>unzip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-d 指定目录 # 将压缩包解压到指定目录</span><br><span class="line">-n # 解压时不覆盖已经存在的文件</span><br><span class="line">-o # 解压时覆盖已经存在的文件，且不向用户询问</span><br><span class="line">-v # 不解压，只是查看压缩包的详细信息，包括压缩包中包含的文件大小、文件名、压缩比等</span><br><span class="line">-t # 不解压，测试压缩包有损坏</span><br><span class="line">-x 文件列表 # 解压，但不包含文件列表中的指定文件</span><br></pre></td></tr></table></figure><h4 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h4><p>只能压缩普通文件。</p><p>就算指定了目录，也是将目录下的所有普通文件一一单独压缩出来。压缩文件的拓展名&#x2F;后缀是<code>.gz</code></p><blockquote><p>gzip压缩完之后源文件会被删除</p></blockquote><h5 id="语法-x2F-功能：-1"><a href="#语法-x2F-功能：-1" class="headerlink" title="语法&#x2F;功能："></a>语法&#x2F;功能：</h5><p><code>gzip [option] 指定文件</code></p><blockquote><p>gzip命令十分简单，不需要指定压缩后的文件的名称，压缩后文件的名称是 <code>源文件名.gz</code></p></blockquote><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令:"></a>常用命令:</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-c # 将压缩数据输出到标准输出中，并保留源文件。可以将数据重定向到压缩包中，这样在不删除源文件的同时还不会将数据打印到屏幕上</span><br><span class="line">-d # 对压缩包解压</span><br><span class="line">-f # 强行压缩或解压文件，不理会文件名或者硬连接是否存在以及该文件是否为符号连接。</span><br><span class="line">-r # 递归压缩指定目录下及其子目录下的所有普通文件</span><br><span class="line">-v # 压缩和解压时，显示压缩包的文件名和压缩比等详细信息</span><br><span class="line">-l # 显示每个压缩文件的大小、压缩比，未压缩文件的大小、未压缩文件的名称等详细信息</span><br><span class="line">-数字 # 压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好</span><br><span class="line">-h # 显示帮助</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212251324128.png" alt="截屏2022-12-25 13.23.46" style="zoom:50%;" /><h4 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h4><p>只能压缩普通文件。</p><p>就算指定了目录，也是将目录下的所有普通文件一一单独压缩出来。压缩文件的拓展名&#x2F;后缀是<code>.bz2</code></p><p>从理论上来讲，bzip2的算法比gzip更先进、压缩比更好；而gzip的压缩速度相对来讲更快</p><blockquote><p>bzip2压缩完之后源文件会被删除</p></blockquote><h5 id="语法：-20"><a href="#语法：-20" class="headerlink" title="语法："></a>语法：</h5><p><code>bzip2 [option] 指定文件</code></p><blockquote><p>gzip命令十分简单，不需要指定压缩后的文件的名称，压缩后文件的名称是 <code>源文件名.bz2</code></p></blockquote><h5 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-c # 将压缩和解压的结果送到标准输出</span><br><span class="line">-d # 解压</span><br><span class="line">-f # 压缩或解压时，若出现输出文件与现有文件重名，会直接覆盖。(默认是不会覆盖的)</span><br><span class="line">-h # 显示帮助</span><br><span class="line">-k # 在压缩或解压后不会删除源文件</span><br><span class="line">-s # 强制进行压缩</span><br><span class="line">-V # 显示版本信息</span><br></pre></td></tr></table></figure><h3 id="tar打包-x2F-解包"><a href="#tar打包-x2F-解包" class="headerlink" title="tar打包&#x2F;解包"></a>tar打包&#x2F;解包</h3><h5 id="语法：-21"><a href="#语法：-21" class="headerlink" title="语法："></a>语法：</h5><p><code>tar [option] 指定文件</code></p><h4 id="打包："><a href="#打包：" class="headerlink" title="打包："></a>打包：</h4><p>也称归档、备份</p><p>打包并不是压缩，只是将文件打包到一个集合中，但是如果想要将一堆文件进行压缩的话，首先就得先把这堆零零散散的文件打一个包，这样才方便压缩。所以打包是很重要的。打包后的文件后缀为<code>.tar</code></p><h5 id="常用选项：-17"><a href="#常用选项：-17" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-c # 进行打包的指令</span><br><span class="line">-f TARNAME # 指定包的文件名为TARNAME。注意要加上.tar后缀</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本质上是将打包好的内容输出到名为TARNAME的tar包中</span></span><br><span class="line">-v # 显示详细过程信息</span><br><span class="line">-A # 追加tar文件到打包文件中</span><br><span class="line">-z TARGZIPNAME # 询问是否在打包后同时进行gzip压缩，并将压缩包命名为TARGZIPNAME。注意要加上后缀.tar.gz</span><br><span class="line">-j TARBZIP2NAME # 询问是否在打包后同时进行bzip2压缩，并将压缩包命名为TAEBZIP2NAME。要加后缀.tar.bz2</span><br><span class="line">-p # 打包的时候保留源文件的属性（权限等）</span><br><span class="line">-N &quot;YYYY/MM/DD&quot; # 打包比某日期新的文件</span><br><span class="line">--exclude 文件 # 打包时不打包该文件</span><br><span class="line">-u # 更新原压缩包的文件</span><br></pre></td></tr></table></figure><h5 id="说明：-3"><a href="#说明：-3" class="headerlink" title="说明："></a>说明：</h5><blockquote><ol><li>-cfv 常视作打包的习惯用法</li><li>tar命令的选项中 <code>-</code> 是可加可不加的，比如 <code>-cfv</code> 和 <code>cfv</code> 是一样的</li><li>tar可以将多个文件进行打包，文件之间用空格间隔开就可以。</li><li>tar也可以将目录下的所有文件都打包，例如将date目录下的所有文件都打包：<code>tar -cvf date.tar ./date/</code></li><li>通常都是在打包时同时进行gzip或者bzip2压缩</li><li><u>要注意，一般情况Linux命令的选项是可以不管顺序的，但是在这里</u>，-f后面紧跟包的名称，所以压缩的时候要把-f放在选项最后，否则会报错</li></ol></blockquote><h5 id="应用举例："><a href="#应用举例：" class="headerlink" title="应用举例："></a>应用举例：</h5><blockquote><ol><li><p>将 .&#x2F;test 目录下的文件全部打包为<code>test.tar</code></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271109047.png" alt="截屏2022-12-27 11.09.06" style="zoom:50%;" /></li><li><p>将test目录下的文件全部打包并压缩为<code>tt.tar.gz</code></p><blockquote><p>注意选项的顺序，-f要放在选项的最后面，否则会报错</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271116816.png" alt="image-20221227111606770" style="zoom:50%;" /></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271116841.png" alt="截屏2022-12-27 11.16.26" style="zoom:50%;" /></li><li><p>打包 .&#x2F;test 和 .&#x2F;date并压缩为<code>myfile.tar.gz</code>，但是不打包.&#x2F;test中的date</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271124056.png" alt="截屏2022-12-27 11.24.12" style="zoom:50%;" /></li><li><p>将用户目录下的所有文件备份并压缩，且保留其权限</p><p>(使用的相对路径，也可以使用绝对路径)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271217612.png" alt="截屏2022-12-27 12.17.13" style="zoom:50%;" /><blockquote><p>在最后一行会提示：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271217195.png" alt="截屏2022-12-27 12.17.34" style="zoom:50%;" /><p>这是因为我们将用户目录中的所有文件都备份并压缩了，在执行完命令之后，会在当前目录下生成压缩包</p><p>而当前目录就是用户目录，所以压缩包声明在了用户目录下</p><p>原来的目标文件，也是用户目录，所以原来的目标文件内容发生了变化，就会给出这个提示</p><p>如果再执行一次这个命令(使用的绝对路径，也可以使用相对路径)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271223698.png" alt="截屏2022-12-27 12.23.07" style="zoom:50%;" /><p>会在压缩的时候显示</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271224909.png" alt="截屏2022-12-27 12.23.57" style="zoom:50%;" /><p>因为在压缩之前已经有了yujin.tar.gz这个文件，在压缩用户目录的时候会将它压缩，然后在压缩完用户目录之后又会生成yujin.tar.gz这个压缩包，相当于时间先后、新旧文件的更改，所以会给出这种说明</p></blockquote></li><li><p>在test目录下，比2022&#x2F;12&#x2F;26新的文件才会被打包</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271232344.png" alt="截屏2022-12-27 12.32.14" style="zoom:50%;" /><blockquote><p>命令的最后面可以是<code>./test</code>也可以是<code>./test/</code>或者<code>test</code>、 <code>test/</code></p></blockquote></li></ol></blockquote><h4 id="解包："><a href="#解包：" class="headerlink" title="解包："></a>解包：</h4><h5 id="常用选项：-18"><a href="#常用选项：-18" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-t # 不解包，直接查看tar包里的内容</span><br><span class="line">-x # 解包</span><br><span class="line">-v # 显示详细过程信息</span><br><span class="line">-f # 查看或解包.tar时带上这个选项</span><br><span class="line">-z # 如果压缩包是.tar.gz，那么查看或者解包的时候要加上这个选项</span><br><span class="line">-j # 如果压缩包是.tar.bz2，那么查看或者解包的时候要加上这个选项</span><br><span class="line">-C 指定目录 # 解压到指定目录。如果不带此选项，默认是解包到当前目录</span><br></pre></td></tr></table></figure><h5 id="应用举例：-1"><a href="#应用举例：-1" class="headerlink" title="应用举例："></a>应用举例：</h5><blockquote><ol><li><p>查看上面压缩的<code>mylife.tar.gz</code>中的文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271147961.png" alt="截屏2022-12-27 11.47.24" style="zoom:50%;" /></li><li><p>将<code>test.tar</code>解包到date目录下</p><p>可以先进入到指定目录，再解压到当前目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271152042.png" alt="截屏2022-12-27 11.52.25" style="zoom:50%;" /><p>也可以用选项-C直接解压到指定目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271240994.png" alt="image-20221227124038949" style="zoom:50%;" /></li><li><p>只想将<code>test.tar.gz</code>中的dir1解开到当前目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271813984.png" alt="截屏2022-12-27 18.13.21" style="zoom:50%;" /><blockquote><p>可以看到，解压出的文件是按照原来的层级形成的，解压出test目录下的dir1目录下的mytest.c</p></blockquote></li><li><p>将a目录进行打包，并立即在dir1目录下解开它(这就相当于将a目录移动到dir1目录下，跟cp类似)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271749705.png" alt="截屏2022-12-27 17.49.53" style="zoom:50%;" /><blockquote><p>运用了管道，将前一个命令的输出作为后一个命令的输入</p><p>这里的单独的<code>-</code>意思是标准输入输出(standard input , standard output)</p><p>在前面的命令中，是将a目录进行打包，然后输出到-f 后面的文件中，-f后面跟的是-，也就是标准输出，所以就是将打包好的a目录输出到了标准输出</p><p>在后面的命令中，-xvf 后面跟的是 - ，也就是要解压的包是标准输出上的，并解压到dir1</p><p>这样就用管道命令和标准输入输出实现了</p></blockquote></li></ol></blockquote><h3 id="bc"><a href="#bc" class="headerlink" title="bc"></a>bc</h3><p>可以很方便进行浮点运算，用的时候man一下查找用法即可，此处不再赘述</p><h3 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h3><h5 id="语法：-22"><a href="#语法：-22" class="headerlink" title="语法："></a>语法：</h5><p><code>uname [option]</code></p><h5 id="功能：-19"><a href="#功能：-19" class="headerlink" title="功能："></a>功能：</h5><p>显示电脑的操作系统等信息</p><h5 id="常用选项：-19"><a href="#常用选项：-19" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a # 输出所有详细信息，依次为内核名称、主机名、内核版本号、内核版本、硬件名、处理器类型、硬件平台信息、操作系统名称</span><br></pre></td></tr></table></figure><h3 id="几个重要的热键"><a href="#几个重要的热键" class="headerlink" title="几个重要的热键"></a>几个重要的热键</h3><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>Tab</td><td>命令补全、档案补齐</td></tr><tr><td>ctrl + c</td><td>终止当前进程</td></tr><tr><td>ctrl + d</td><td>代表“键盘输入结束(End of file,EOF,End of input)“的意思；<br />另外，也可以取代exit命令来登出Linux账户</td></tr></tbody></table><p><u>更多快捷键请见linuxJournal中的快捷键整理</u></p><h2 id="Linux权限的概念"><a href="#Linux权限的概念" class="headerlink" title="Linux权限的概念"></a>Linux权限的概念</h2><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>Linux中有两种用户：超级用户(root)、普通用户</p><blockquote><p>超级用户：可以在Linux系统内做任何事情，不受限制。命令提示符是：#</p><p>普通用户：在Linux下做有限的事情。命令提示符是：$</p></blockquote><h4 id="用户切换指令：su"><a href="#用户切换指令：su" class="headerlink" title="用户切换指令：su"></a>用户切换指令：su</h4><h5 id="语法：-23"><a href="#语法：-23" class="headerlink" title="语法："></a>语法：</h5><p><code>su [USERNAME]</code></p><h5 id="功能：-20"><a href="#功能：-20" class="headerlink" title="功能："></a>功能：</h5><p>切换用户</p><h5 id="说明：-4"><a href="#说明：-4" class="headerlink" title="说明："></a>说明：</h5><p>当只使用su命令的时候，是切换到root用户，输入root用户的密码</p><p>当使用 su USERNAME 的时候，是切换到名称为USERNAME的普通用户，并要输入那个用户的密码；如果是从root切换到别的普通用户，不需要输入密码</p><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><h5 id="语法：-24"><a href="#语法：-24" class="headerlink" title="语法："></a>语法：</h5><p><code>sudo [option] 指令</code></p><h5 id="功能：-21"><a href="#功能：-21" class="headerlink" title="功能："></a>功能：</h5><p>以root身份执行当前指令</p><h5 id="说明：-5"><a href="#说明：-5" class="headerlink" title="说明："></a>说明：</h5><p>不会切换身份，只是用root身份执行指令，当前用户(使用sudo命令的用户)不变，相当于在执行指令的时候暂时提高了权限</p><h5 id="常用选项：-20"><a href="#常用选项：-20" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-u USERNAME # 以USERNAME身份执行当前命令</span><br><span class="line">-l # 显示当前用户(使用sudo命令的用户)的权限</span><br></pre></td></tr></table></figure><h4 id="用户创建指令：useradd"><a href="#用户创建指令：useradd" class="headerlink" title="用户创建指令：useradd"></a>用户创建指令：useradd</h4><p>root权限下</p><h5 id="语法：-25"><a href="#语法：-25" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd USERNAME</span><br></pre></td></tr></table></figure><h4 id="用户密码设定指令：passwd"><a href="#用户密码设定指令：passwd" class="headerlink" title="用户密码设定指令：passwd"></a>用户密码设定指令：passwd</h4><p>root权限下</p><h5 id="语法：-26"><a href="#语法：-26" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd USERNAME PASSWORD</span><br></pre></td></tr></table></figure><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><h4 id="文件访问者的分类："><a href="#文件访问者的分类：" class="headerlink" title="文件访问者的分类："></a>文件访问者的分类：</h4><p>访问文件的人有三种</p><blockquote><p>文件的所有者：u——User</p><p>文件所有者所在组的用户：g——Group</p><p>其他用户：o——Others</p></blockquote><p>其中，文件的创建者不一定就是文件的所有者，文件的所有权是可以转让的</p><p>Group，在工作中，一般是以团队进行的，文件的所有者是属于某一个团队的，这个团队的人有时就需要访问这个文件，文件所有者可以创建一个Group，指定在Group里的所有人对于这个文件的访问权限。文件所有者本人本身就是一个团队，他可以往团队里加人。</p><p>Others就是不属于前两者的人。</p><h4 id="文件类型和访问权限-文件属性-："><a href="#文件类型和访问权限-文件属性-：" class="headerlink" title="文件类型和访问权限(文件属性)："></a>文件类型和访问权限(文件属性)：</h4><p>在使用<code>ll</code>命令的时候会展示出文件的详细信息</p><div><center><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181050726.png" alt="image-20221218105015699" style="zoom:30%;" /><br>Linux文件默认是按照名称排序的</center></div><p>文件属性包括文件类型和文件权限，文件类型就是文件的种类，包括普通文件、目录文件等，详细在一开始有讲过<a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB">在这里可以查看一下</a></p><p>文件权限就是，文件访问者对于文件的访问权限是如何的</p><blockquote><ul><li><p>读(r):Read 对文件而言，具有读取文件内容的权限；对目录来说，具有ls浏览该目录信息的权限</p></li><li><p>写(w):Write 对文件而言，具有修改文件内容的权限；对目录来说具有创建删除移动目录内文件的权限 </p></li><li><p>执行(x):execute 对文件而言，具有执行文件的权限；对目录来说，具有cd进入目录的权限</p></li><li><p>“-“表示不具有该项权限</p></li></ul><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212281710542.png" alt="截屏2022-12-28 17.10.03" style="zoom: 33%;" /></blockquote><h4 id="文件权限的表示方法："><a href="#文件权限的表示方法：" class="headerlink" title="文件权限的表示方法："></a>文件权限的表示方法：</h4><ol><li><p>字符表示方法</p><table><thead><tr><th align="center">Linux字符表示</th><th align="center">权限说明</th><th align="center">Linux字符表示</th><th align="center">权限说明</th></tr></thead><tbody><tr><td align="center">r–</td><td align="center">只读</td><td align="center">-w-</td><td align="center">仅可写</td></tr><tr><td align="center">–x</td><td align="center">仅可执行</td><td align="center">rw-</td><td align="center">可读可写</td></tr><tr><td align="center">-wx</td><td align="center">可写可执行</td><td align="center">r-x</td><td align="center">可读可执行</td></tr><tr><td align="center">rwx</td><td align="center">全部权限</td><td align="center">—</td><td align="center">无任何权限</td></tr></tbody></table></li><li><p>8进制数值表示方法</p><p>对于权限的顺序，可以排列为r、w、x</p><p>对于权限的有无，可以用二进制表示，0表示没有这个权限，1表示有这个权限</p><p>故r、w、x这三个权限可以用三个二进制数表示，而三个二进制数又能被一个八进制数表示</p><table><thead><tr><th>权限符号</th><th>二进制</th><th>八进制</th></tr></thead><tbody><tr><td>—</td><td>000</td><td>0</td></tr><tr><td>r–</td><td>100</td><td>4</td></tr><tr><td>-w-</td><td>010</td><td>2</td></tr><tr><td>–r</td><td>001</td><td>1</td></tr><tr><td>rw-</td><td>110</td><td>6</td></tr><tr><td>r-x</td><td>101</td><td>5</td></tr><tr><td>-wx</td><td>011</td><td>3</td></tr><tr><td>rwx</td><td>111</td><td>7</td></tr></tbody></table></li></ol><h4 id="文件访问权限的设置方法："><a href="#文件访问权限的设置方法：" class="headerlink" title="文件访问权限的设置方法："></a>文件访问权限的设置方法：</h4><h5 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h5><h6 id="功能：-22"><a href="#功能：-22" class="headerlink" title="功能："></a>功能：</h6><p>设置文件的访问权限</p><h6 id="语法：-27"><a href="#语法：-27" class="headerlink" title="语法："></a>语法：</h6><p><code>chmod [option] 权限 文件</code></p><h6 id="说明：-6"><a href="#说明：-6" class="headerlink" title="说明："></a>说明：</h6><p>只有文件所有者和root用户才能修改文件访问权限的权限</p><h6 id="常用选项：-21"><a href="#常用选项：-21" class="headerlink" title="常用选项："></a>常用选项：</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R # 递归修改目录文件的权限</span><br></pre></td></tr></table></figure><h6 id="权限格式一："><a href="#权限格式一：" class="headerlink" title="权限格式一："></a>权限格式一：</h6><p>用户表示符 +或-或&#x3D; 文件权限字符</p><blockquote><p>用户表示符：</p><ul><li>u拥有者</li><li>g同组者</li><li>o其他用户</li><li>a所有用户</li></ul><p>+：向用户增加(追加)权限</p><p>-：向用户取消(减少)权限</p><p>&#x3D;：向用户赋予权限，也就是用户只有被赋予的权限</p></blockquote><blockquote><p>向hello.txt的拥有者追加执行权限</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282037692.png" alt="截屏2022-12-28 20.36.43" style="zoom:50%;" /><p>向hello.txt的同组者减少可写权限</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282040631.png" alt="截屏2022-12-28 20.40.03" style="zoom:50%;" /><p>向hello.txt的其他人只赋予可写权限</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282041865.png" alt="截屏2022-12-28 20.41.15" style="zoom:50%;" /><blockquote><p>可以看到others原来是有rw权限，但是被赋予w权限之后，就只有w权限了</p></blockquote></blockquote><h6 id="权限格式二："><a href="#权限格式二：" class="headerlink" title="权限格式二："></a>权限格式二：</h6><p>三个8进制数表示权限   （方便常用）</p><blockquote><p>第一个八进制数表示user的权限</p><p>第二个表示group的权限</p><p>第三个表示other的权限</p><p>跟文件的权限对应</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212281710542.png" alt="截屏2022-12-28 17.10.03" style="zoom: 25%;" /></blockquote><blockquote><p>将hello.txt的文件权限设置为rwx rwx rwx</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282045567.png" alt="截屏2022-12-28 20.45.01" style="zoom:50%;" /><blockquote><p>rwx对应的二进制就是111，对应的八进制数就是7</p></blockquote><p>将hello.txt的文件权限设置为555</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282049750.png" alt="截屏2022-12-28 20.49.33" style="zoom:50%;" /><blockquote><p>5对应的权限就是101即r-x</p></blockquote><p>将hello.txt的文件权限设置为754</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282050739.png" alt="截屏2022-12-28 20.50.54" style="zoom:50%;" /></blockquote><h5 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h5><h6 id="功能：-23"><a href="#功能：-23" class="headerlink" title="功能："></a>功能：</h6><p>修改文件的拥有者</p><h6 id="语法：-28"><a href="#语法：-28" class="headerlink" title="语法："></a>语法：</h6><p><code>chown [option] 用户名 文件名</code></p><h6 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h6><p>只有root用户才有权限使用这个命令</p><h6 id="常用选项：-22"><a href="#常用选项：-22" class="headerlink" title="常用选项："></a>常用选项：</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-v # 显示详细过程信息</span><br><span class="line">-R # 递归更改目录的拥有者</span><br><span class="line">-help # 查看用法帮助</span><br><span class="line">-f # 忽略错误信息</span><br></pre></td></tr></table></figure><h6 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h6><blockquote><p>把hello.txt的所属权从yujin转给chenyujin</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282101595.png" alt="截屏2022-12-28 21.01.19" style="zoom:50%;" /></blockquote><h5 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h5><h6 id="功能：-24"><a href="#功能：-24" class="headerlink" title="功能："></a>功能：</h6><p>修改文件所属组 </p><h6 id="语法：-29"><a href="#语法：-29" class="headerlink" title="语法："></a>语法：</h6><p><code>chgrp [option] 用户组名 文件名</code></p><h6 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h6><p>与chown不同，只要是文件原组里的用户，就可以修改文件的所属组</p><h6 id="常用选项：-23"><a href="#常用选项：-23" class="headerlink" title="常用选项："></a>常用选项：</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-v # 显示详细过程信息</span><br><span class="line">-c # 效果类似&quot;-v&quot;参数，但仅显示更改的部分。</span><br><span class="line">-R # 递归更改目录的拥有者</span><br></pre></td></tr></table></figure><h5 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h5><h6 id="功能：-25"><a href="#功能：-25" class="headerlink" title="功能："></a>功能：</h6><p>查看或修改文件权限掩码</p><h6 id="语法：-30"><a href="#语法：-30" class="headerlink" title="语法："></a>语法：</h6><p><code>umask 权限掩码值</code></p><h6 id="说明：-7"><a href="#说明：-7" class="headerlink" title="说明："></a>说明：</h6><p>将现有的默认权限减去权限掩码，即可产生创建文件时的预设权限</p><h5 id="权限掩码-简介"><a href="#权限掩码-简介" class="headerlink" title="权限掩码(简介)"></a>权限掩码(简介)</h5><p>英文名：unmask</p><p>在创建目录文件的时候，默认权限是775</p><p>在创建普通文件的时候，默认权限是664</p><p>（不同系统上可能有差别，此处以centOS7为例</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212171711414.png" alt="202212171709806" style="zoom:50%;" /><p>但是实际上：</p><blockquote><ol><li>普通目录的默认起始预设权限是777，普通文件的默认起始预设权限是666</li><li>权限掩码umask会在用户创建目录或者文件时拿掉一些默认起始权限，得到的才是创建之后的默认权限</li></ol><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask # 查看权限掩码</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212171704218.png" alt="截屏2022-12-17 17.03.59" style="zoom:50%;" /><p>当前系统下的权限掩码是0002（第一位不用看，代表特殊权限，此处暂不讨论。当然，在写权限的时候是可以带上的，比如0777</p><p>系统会拿掉权限掩码对应的权限，002则对应着owner: 0, grouper: 0, other: 2</p><p>意味着other会被拿掉2权限(2是八进制数，对应的二进制数是010，也就是w权限)</p><p>对于目录，ohter的默认起始权限是<strong>7</strong>(也就是111,rwx)，被拿掉<strong>2</strong>(也就是010,w)之后就变成了<strong>5</strong>(也就是101,rx)，所以创建出的目录的默认权限就变成了775</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212171731199.png" alt="截屏2022-12-17 17.31.22" style="zoom:40%;" /><p>对于文件，other的默认起始权限是<strong>6</strong>(110,rw)，被拿掉<strong>2</strong>(010,w)之后就变成了<strong>4</strong>(100,r)，所以创建出的文件默认权限就是664</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212171732621.png" alt="截屏2022-12-17 17.32.26" style="zoom:40%;" /></blockquote><p>注意，权限掩码是“拿掉”权限，而不是进行二进制减法，比如初始权限是111 110 110，权限掩码是000 000 001，得到的默认权限是111 110 110，而不是111 110 101，因为最后一位本来就没有权限，权限掩码只是拿掉权限，本来就没有权限，拿掉了还是没有权限</p></blockquote><h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><h5 id="功能：-26"><a href="#功能：-26" class="headerlink" title="功能："></a>功能：</h5><p>查看文件类型</p><h5 id="语法：-31"><a href="#语法：-31" class="headerlink" title="语法："></a>语法：</h5><p><code>file [option] 文件</code></p><h5 id="常用选项：-24"><a href="#常用选项：-24" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-c # 显示详细执行过程，便于排错或分析程序执行的情形 </span><br><span class="line">-z # 尝试去解读压缩文件的内容</span><br></pre></td></tr></table></figure><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282224254.png" alt="截屏2022-12-28 22.24.01" style="zoom:50%;" /></blockquote><h4 id="粘滞位"><a href="#粘滞位" class="headerlink" title="粘滞位"></a>粘滞位</h4><p>让我们回顾一下目录的权限：</p><blockquote><ul><li><p>读(r):Read 对目录来说，具有ls浏览该目录信息的权限</p></li><li><p>写(w):Write 对目录来说具有创建删除移动目录内文件的权限 </p></li><li><p>执行(x):execute 对目录来说，具有cd进入目录的权限</p></li></ul></blockquote><p>那这样的话，只要用户具有目录的w权限，就能删除目录中的文件。</p><p>那么问题来了，当张三和李四对于一个目录都有w的权限的时候，张三创建了一个文件，结果被李四删除了！我张三创建的文件你李四凭什么给我删除了！？这不科学呀</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282254005.png" alt="截屏2022-12-28 22.53.59" style="zoom:50%;" /><blockquote><p>这里yujin具有work目录的w权限(属于others)，他将work里root创建的root_work删除了</p></blockquote><p>为了解决这个不科学的问题，就出现了粘滞位</p><h5 id="说明-amp-功能-amp-用法："><a href="#说明-amp-功能-amp-用法：" class="headerlink" title="说明&amp;功能&amp;用法："></a>说明&amp;功能&amp;用法：</h5><p>目录的所有者可以对目录添加粘滞位，加上了粘滞位的目录，具有w权限的用户不能删除目录下别人的文件了，只能删除自己的文件</p><p><code>chmod +t 目录</code></p><blockquote><p>只有 root 和 目录所有者 才能给目录加上粘滞位</p></blockquote><blockquote><p>将work目录加上粘滞位之后，yujin就没办法删除root创建的文件root_work2了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282310392.png" alt="image-20221228231028314" style="zoom:50%;" /></blockquote><p><strong>当一个目录被加上粘滞位的时候，该目录下的文件只能由</strong></p><blockquote><ol><li><strong>root删除</strong></li><li><strong>该目录的所有者删除</strong></li><li><strong>该文件的所有者删除</strong></li></ol></blockquote><h4 id="关于权限的总结"><a href="#关于权限的总结" class="headerlink" title="关于权限的总结"></a>关于权限的总结</h4><blockquote><ul><li>目录的可执行权限是表示你可否在目录下执行命令</li><li>如果目录没有-x权限，则无法对目录执行任何命令，甚至无法cd 进入目, 即使目录仍然有-r 读权限(这 个地方很容易犯错，认为有读权限就可以进入目录读取目录下的文件) </li><li>而如果目录具有-x权限，但没有-r权限，则用户可以执行命令，可以cd进入目录。但由于没有目录的读 权限,所以在目录下，即使可以执行ls命令，但仍然没有权限读出目录下的文档。</li></ul></blockquote><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="stat命令"><a href="#stat命令" class="headerlink" title="stat命令"></a>stat命令</h4><h5 id="语法：-32"><a href="#语法：-32" class="headerlink" title="语法："></a>语法：</h5><p><code>stat [option] 文件</code></p><h5 id="功能：-27"><a href="#功能：-27" class="headerlink" title="功能："></a>功能：</h5><p>详细查看文件信息(比ll命令更详细)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301121111211.png" alt="截屏2023-01-12 11.11.49" style="zoom:50%;" /><h5 id="说明：-8"><a href="#说明：-8" class="headerlink" title="说明："></a>说明：</h5><p>上面的图片是系统的语言是中文汉化后</p><p>下面是正常情况下的显示</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301121113718.png" alt="截屏2023-01-12 11.12.12" style="zoom:50%;" /><blockquote><p>Access、Modify、Change三个记录了文件的时间，简称ACM</p><p>Access记录的是文件的访问时间</p><p>众所周知，文件 &#x3D; 内容 + 属性</p><p>Modify记录的是文件内容的修改时间</p><p>Change记录的是文件属性(访问权限等)的修改时间</p><p>另外，文件内容的修改有时候会影响文件的属性，比如文件的内容增加了之后，文件的size就会改变，size就是文件的属性，所以当修改文件的内容之后，很有可能Modify和Change同时进行更改了</p></blockquote><blockquote><p>可能还会发现一个问题，就是当一个文件被修改之后，文件的修改时间发生了改变，但是文件的访问时间没有发生改变。修改文件的时候一定是访问了文件的，为什么访问时间没有变呢？</p><p>这是因为在文件操作中，访问的次数远比修改等操作的次数多，它是文件最频繁的操作，如果每次都记录访问时间的话，计算机会大量更新Access时间，会定期将数据在磁盘上进行刷新，这是一个慢效率的事情。因此在比较新一点的Linux内核中，对于Access的记录规则发生了修改，在文件访问累积到一定数量之后才会更新Access的值</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决butterfly在深色模式下页头页脚封面过暗</title>
      <link href="/chunyujin/dffbd9e1.html"/>
      <url>/chunyujin/dffbd9e1.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本方法适用于未进行页面魔改的，如果进行了页面魔改，<a href="http://chunyujin.top/chunyujin/1cfcafc1.html">请跳转到此处</a></p></blockquote><p>在<code>/themes/butterfly/source/css/_mode/darkmode.styl </code></p><p>调整第48行括号里的小数点后的数值，默认是.9，数值越大越暗</p><h5 id="before"><a href="#before" class="headerlink" title="before:"></a>before:</h5><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061850337.png"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303071207624.png" alt="202301061848023"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303071208252.png" alt="202301061848940"></p><h5 id="after："><a href="#after：" class="headerlink" title="after："></a>after：</h5><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301212314224.png" alt="截屏2023-01-21 22.54.11"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303071203425.png" alt="202301061851886"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303071210552.png" alt="202301061851284"></p><p><a href="http://chunyujin.top/chunyujin/5b04b880.html">相关问题链接：解决黑色模式下文章预览封面及内部图片过暗</a></p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宏实现#pragma once&amp;#ifndef</title>
      <link href="/chunyujin/5f33e850.html"/>
      <url>/chunyujin/5f33e850.html</url>
      
        <content type="html"><![CDATA[<p>为了避免同一个头文件被包含(include)多次，C&#x2F;C++中有两种宏实现的方式：一种是#pragma once方式</p><p>一种是#ifndef的方式</p><p>有些编译器只支持其中的一种。</p><p>在能够支持这两种方式的编译器是，两者并没有太大的区别，但是两者仍然有一些细微的区别。</p><p><a href="https://blog.csdn.net/qq_43907537/article/details/107938459?ops_request_misc=&request_id=&biz_id=102&utm_term=?ops_request_misc=&request_id=&biz_id=102&utm_term=&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-107938459.nonecase&spm=1018.2226.3001.4187#pragma%20once&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-107938459.nonecase">#pragma once用法</a></p><p><a href="https://blog.csdn.net/qq_35027690/article/details/125865367">#ifndef, #define, #endif 理解</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电脑正确坐姿：健康才是是第一生产力</title>
      <link href="/chunyujin/768897a3.html"/>
      <url>/chunyujin/768897a3.html</url>
      
        <content type="html"><![CDATA[<p>🧑🏻‍💻</p><h3 id="电脑正确坐姿-健康才是是第一生产力！！"><a href="#电脑正确坐姿-健康才是是第一生产力！！" class="headerlink" title="电脑正确坐姿_健康才是是第一生产力！！"></a>电脑正确坐姿_健康才是是第一生产力！！</h3><blockquote><p>以下所有都只是建议，要根据自己情况来就行</p></blockquote><h4 id="挺直腰背。腰背可以靠在靠背上，放松，让靠背承力"><a href="#挺直腰背。腰背可以靠在靠背上，放松，让靠背承力" class="headerlink" title="挺直腰背。腰背可以靠在靠背上，放松，让靠背承力"></a>挺直腰背。腰背可以靠在靠背上，放松，让靠背承力</h4><h4 id="放松肩部肌肉，不要耸肩，颈肩背不要前倾，不要用肩膀承力"><a href="#放松肩部肌肉，不要耸肩，颈肩背不要前倾，不要用肩膀承力" class="headerlink" title="放松肩部肌肉，不要耸肩，颈肩背不要前倾，不要用肩膀承力"></a>放松肩部肌肉，不要耸肩，颈肩背不要前倾，不要用肩膀承力</h4><p>避免含胸驼背！！</p><p>建议购买人体工学椅或升降桌，调整高度到自己舒服的位置</p><h4 id="调整键盘位置：，大臂放松，自然下垂于身体两侧，键盘不要离身体太远，使大臂与小臂呈大约90～120度-键盘太远会导致前倾-；键盘高度最好位于肚脐高度附近，小臂自然舒适放在桌面上，使不会耸肩，不会使肩膀、大臂前倾，还能使视线能自然看到双手和键盘【根据自身舒适情况调整"><a href="#调整键盘位置：，大臂放松，自然下垂于身体两侧，键盘不要离身体太远，使大臂与小臂呈大约90～120度-键盘太远会导致前倾-；键盘高度最好位于肚脐高度附近，小臂自然舒适放在桌面上，使不会耸肩，不会使肩膀、大臂前倾，还能使视线能自然看到双手和键盘【根据自身舒适情况调整" class="headerlink" title="调整键盘位置：，大臂放松，自然下垂于身体两侧，键盘不要离身体太远，使大臂与小臂呈大约90～120度(键盘太远会导致前倾)；键盘高度最好位于肚脐高度附近，小臂自然舒适放在桌面上，使不会耸肩，不会使肩膀、大臂前倾，还能使视线能自然看到双手和键盘【根据自身舒适情况调整"></a>调整键盘位置：，大臂放松，自然下垂于身体两侧，键盘不要离身体太远，使大臂与小臂呈大约90～120度(键盘太远会导致前倾)；键盘高度最好位于肚脐高度附近，小臂自然舒适放在桌面上，使不会耸肩，不会使肩膀、大臂前倾，还能使视线能自然看到双手和键盘【根据自身舒适情况调整</h4><h4 id="保证视线平视显示器而不低头；与显示器保持合适距离，一般建议在1-5～2倍显示器高度之间，这样才能使观感舒适（比如27寸显示器高度为35～37cm，建议眼睛距离显示器52-5～70cm之间以达到舒适的观感"><a href="#保证视线平视显示器而不低头；与显示器保持合适距离，一般建议在1-5～2倍显示器高度之间，这样才能使观感舒适（比如27寸显示器高度为35～37cm，建议眼睛距离显示器52-5～70cm之间以达到舒适的观感" class="headerlink" title="保证视线平视显示器而不低头；与显示器保持合适距离，一般建议在1.5～2倍显示器高度之间，这样才能使观感舒适（比如27寸显示器高度为35～37cm，建议眼睛距离显示器52.5～70cm之间以达到舒适的观感"></a>保证视线平视显示器而不低头；与显示器保持合适距离，一般建议在1.5～2倍显示器高度之间，这样才能使观感舒适（比如27寸显示器高度为35～37cm，建议眼睛距离显示器52.5～70cm之间以达到舒适的观感</h4><p>如果显示器高度不够，可以购买增高支架或者桌面置物架来增高</p><h4 id="达到观感、腰背、肩膀、手臂、腰部都能十分舒适的平衡点"><a href="#达到观感、腰背、肩膀、手臂、腰部都能十分舒适的平衡点" class="headerlink" title="达到观感、腰背、肩膀、手臂、腰部都能十分舒适的平衡点"></a>达到观感、腰背、肩膀、手臂、腰部都能十分舒适的平衡点</h4><h3 id="总之，核心就是舒服：肩膀舒服，脖子舒服，腰部舒服，眼睛舒服，使用键鼠方便。"><a href="#总之，核心就是舒服：肩膀舒服，脖子舒服，腰部舒服，眼睛舒服，使用键鼠方便。" class="headerlink" title="总之，核心就是舒服：肩膀舒服，脖子舒服，腰部舒服，眼睛舒服，使用键鼠方便。"></a>总之，核心就是舒服：肩膀舒服，脖子舒服，腰部舒服，眼睛舒服，使用键鼠方便。</h3><h5 id="购买建议："><a href="#购买建议：" class="headerlink" title="购买建议："></a>购买建议：</h5><blockquote><p>人体工学椅</p><p>显示器支架臂</p></blockquote><hr><h4 id="关于为什么要把键盘放在桌面上而不是键盘托盘上："><a href="#关于为什么要把键盘放在桌面上而不是键盘托盘上：" class="headerlink" title="关于为什么要把键盘放在桌面上而不是键盘托盘上："></a>关于为什么要把键盘放在桌面上而不是键盘托盘上：</h4><p>[知乎链接](既然大家都喜欢把键盘放在桌子上，为什么电脑桌还要设计托盘？ - 华而无为的回答 - 知乎 <a href="https://www.zhihu.com/answer/2808056675">https://www.zhihu.com/answer/2808056675</a>)</p><p>最近本人一直在被这个问题纠结。本人在学校的时候宿舍使用了人体工学椅，可以调节高度到健康的位置。但是家里的办公桌是大电脑桌，有一个键盘托盘，桌子高度75cm，电脑托盘高度是60cm，本人身高较高，当键盘放在桌子上的时候，键盘会略微高于手肘，但是将手肘放到桌子上的时候，颈肩肘都是可以得到放松的，这属于比较小的误差吧。当键盘放在托盘上的时候，会感觉不习惯，而且本人用的是很薄的键盘，打字要去够才能够到。</p><ol><li><p>起始电脑托盘的存在属于电脑桌这个外设跟不上电子产品发展，电脑托盘属于落后的产物，电脑桌的传统设计在国内也没有更改过。电脑桌的基本设计理念一直延续着它刚诞生的情况，现在很多新的人体工程电脑桌要不就是升降的，要不就是不带键盘托盘的。</p></li><li><p>另一个方面，看现在的键盘，比较传统的薄膜键盘和机械键盘的厚度基本上是和上世纪的键盘厚度一样， 放到键盘托盘上还是可以比较容易敲击的；现在生产的比较新的薄膜键盘，都是极薄设计的，这种设计就是在桌面上用的比较爽的。 </p></li><li><p>当你将键盘放在托盘上的时候，你的姿势会维持在一个固定的角度，就像是身体被卡在了那里，虽然姿势满足健康坐姿，但是久坐之后对于身体是很不好的。当键盘鼠标放在桌子上的时候，可以很轻松调整自己的坐姿和更改键盘的位置，避免久坐不动的现象。</p></li><li><p>将键盘放到托盘里，人会里显示器很远，看不清显示器</p></li><li><p>将键盘放在托盘里，人很难看到键盘(要低头)，而且手感会下降(玄学，但是尝试一下会发现放在托盘里敲键盘的姿势是缩着手从上而下敲击键盘，感受不到键盘的手感)，视觉上不舒服，心理上不舒服(这一点对强迫症比较重要～～～)</p></li></ol><p>对于正确的电脑桌前坐姿而言，只要能满足健康的坐姿，建议还是将键盘放在桌子上的。如果不满足条件，可以通过调整座位高度或桌子高度实现。</p><p>现在去淘宝搜索人体工学办公桌，也都是舍弃了电脑托盘的设计居多，很少再见到带托盘的了，除非是在家具城买的老式的办公桌子。</p>]]></content>
      
      
      <categories>
          
          <category> 健康 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 健康 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Linux</title>
      <link href="/chunyujin/7ef7519f.html"/>
      <url>/chunyujin/7ef7519f.html</url>
      
        <content type="html"><![CDATA[<h3 id="Linux是一种开源的操作系统"><a href="#Linux是一种开源的操作系统" class="headerlink" title="Linux是一种开源的操作系统"></a>Linux是一种开源的操作系统</h3><h4 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h4><p>计算机本质是许多硬件组成的一个整体</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212180856455.png" alt="image-20221218085649201" style="zoom:50%;" /><blockquote><p>设备驱动直接控制计算机的硬件，用户通过应用软件使用计算机</p><p>应用程序会调用多种设备驱动，驱动程序提供给应用程序接口，供应用程序调用接口来使用硬件</p><p>一个计算机上会有很多硬件，所以会有很多设备驱动，每个硬件对应的设备驱动也不一样；每个应用程序都会与很多设备驱动对接，还会经常有多个应用占用同一个硬件的情况，如何进行资源管理和分配是对于设计者来说是一件很麻烦的事情。</p><p>于是就有了操作系统，操作系统是用来管理软件和硬件的对接，并将硬件驱动程序的接口抽象化，行成一套简单的接口给上层的应用程序使用。</p><p>另外，设备驱动是嵌入到操作系统里的，上面讲的只是为了体现这几者的关系。</p></blockquote><p>世界三大操作系统：Windows，macOS，Linux</p><p>Windows是世界上市场份额占比最大的终端操作系统；macOS是基于Unix内核的操作系统；Linux是开源的操作系统，被广泛用于服务器、嵌入式，并且智能手机上的android操作系统正是基于Linux开发的子系统。</p><h4 id="为什么是开源"><a href="#为什么是开源" class="headerlink" title="为什么是开源"></a>为什么是开源</h4><p>开源是Linus大神的非常强烈的信念，当时在接触MINIX的时候，被MINIX只允许用在教育上的使用很不满，于是他便开始编写自己的开源操作系统，并一直坚持开源理念。</p><p>开源，即<u>开放源代码</u></p><p>这意味着任何人都可以使用，但请记得注明来源。</p><blockquote><p><strong>开放源代码</strong>（英语：Open Source）是一种在电脑程序出品前和开发中提供其内部代码的做法。</p><p>开放源代码在互联网上获得广泛使用，参加者需要大量更新电脑源代码。开放源代码使得生产模块、通信管道、交互社群获得改善。随后，一个新著作权、软件授权条款、域名和消费者提供创建的，一个新词开源软件诞生。</p><p>开源模型概念包括同时间不同时程和方法来生产，相对而言，更加集中式的软体设计模型，例如典型的商业软体公司。一个开源软体开发的主要原则和惯例是易货贸易和合作的同侪生产，经由免费公开的最终产品、原始信息、蓝图和文件。这逐渐应用在其它领域，例如生物技术。———<em>来源<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81">维基百科</a></em></p></blockquote><p>代码开源，意味着更安全、更高效、更稳定</p><p>因为全部的使用者都在使用且知悉源代码，一旦出现问题会被用户群体立即指出，甚至用户群体可以立即给出各种解决方案！</p><p>代码闭源则只能由商业公司内部维护</p><h3 id="Linux的应用场景"><a href="#Linux的应用场景" class="headerlink" title="Linux的应用场景"></a>Linux的应用场景</h3><p>服务器后台</p><p>嵌入式、树莓派</p><p>智能家电</p><p>车载系统</p><p>物联网</p><p>手机、平板电脑</p><p>……</p><p>一切都是基于Linux的开源特性</p><p>还有就是Linux确实很好用</p><p>这为无数人提供了便利！</p><h3 id="生动的补充"><a href="#生动的补充" class="headerlink" title="生动的补充"></a>生动的补充</h3><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212180928015.png" alt="image-20221218092828996"></p><h3 id="Linux下一切皆文件！！！"><a href="#Linux下一切皆文件！！！" class="headerlink" title="Linux下一切皆文件！！！"></a>Linux下一切皆文件！！！</h3>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinGw配置(Windows电脑)</title>
      <link href="/chunyujin/1ee5d0ce.html"/>
      <url>/chunyujin/1ee5d0ce.html</url>
      
        <content type="html"><![CDATA[<h4 id="安装MinGW"><a href="#安装MinGW" class="headerlink" title="安装MinGW"></a>安装MinGW</h4><p>相比在 Linux 平台上安装 GCC 编译环境，在 Windows 平台上安装 MinGW 是比较简单的，只需经历以下几个过程。</p><ol><li><p>打开 <a href="https://osdn.net/projects/mingw/">MinGW 官网</a>（点击即可进入官网），下载 MinGW 安装包。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215731250.png" alt="image-20221215215731250" style="zoom:67%;" /></li><li><p>下载完成后，会得到一个名为 mingw-get-setup.exe 的安装包，双击打开它，可以看到如下的对话框：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215752602.png" alt="image-20221215215752602" style="zoom:67%;" /></li><li><p>直接点击“Install”，进入下面的对话框，自定义安装位置，然后选择continue</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215808186.png" alt="image-20221215215808186" style="zoom:67%;" /></li><li><p>进入安装 MinGW 配置器的界面。安装完成之后，得到一个名为 “MinGW Installer Manager” 的软件，借助它，可以随时根据需要修改 GCC 编译器的配置。点击“continue”,会自动弹出配置界面，如下所示：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215823311.png" alt="image-20221215215823311" style="zoom:67%;" /></li><li><p>为使 GCC 同时支持编译 C 语言和 C++，需勾选图中标注的 2 项。我们知道，GCC 还支持其它编程语言，读者可借助此配置器，随时实际需要安装自己需要的编译环境。勾选完成后，在菜单栏中选择<code>Installation -&gt; Apply Changes</code>，弹出如下对话框：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215851706.png" alt="image-20221215215851706" style="zoom:67%;" /></li></ol><p>选择“Apply”。然后耐心等待，直至安装成功，即可关闭此界面。注意，整个安装过程中可能会提示某些组件下载失败，但没关系，后续需要时，可以通过 MinGw Installer（图 4 所示）安装界面中的 “All Packages”选项中，手动选择指定的安装包进行安装。</p><h4 id="添加到环境变量"><a href="#添加到环境变量" class="headerlink" title="添加到环境变量"></a>添加到环境变量</h4><p>打开<code>我的电脑</code>-&gt;<code>属性</code>-&gt;<code>高级系统设置</code>-&gt;<code>“高级”中的环境变量</code></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213001922.png" alt="image-20221215213001922" style="zoom:67%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213141396.png" alt="image-20221215213141396" style="zoom: 67%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213248912.png" alt="image-20221215213248912" style="zoom:67%;" /><p>在上方的“用户变量”的Path变量中添加MinGW的bin的位置</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213407962.png" alt="image-20221215213407962" style="zoom:67%;" /><blockquote><p>也可以在下方的“系统变量”的Path中添加MinGW的bin的位置</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213829809.png" alt="image-20221215213829809" style="zoom:67%;" /><p>环境变量、系统变量、用户变量的关系：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215214853021.png" alt="image-20221215214853021" style="zoom: 50%;" /><p>环境变量只是一个总称，代表了系统变量和用户变量，因此我们说环境变量都是指的系统变量和用户变量。系统变量就是系统级别的变量，用户需要使用系统变量。如果系统变量被修改了，而任何系统用户都在用系统变量，因此每个系统用户都将受到影响。用户变量运行在系统变量之上的，每个用户拥有不同的用户变量，不同用户的用户变量之间是并列的，也是互不干扰的。</p></blockquote><h4 id="检验配置完成"><a href="#检验配置完成" class="headerlink" title="检验配置完成"></a>检验配置完成</h4><p>打开命令行提示符，输入<code>gcc -v</code>或者<code>g++ -v</code></p><p>出现下面则说明成功</p><p><img>(<a href="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-12-15%20220238.png">https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-12-15%20220238.png</a>)</p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> MinGw </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MinGw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NotePad++配置</title>
      <link href="/chunyujin/55caa4ef.html"/>
      <url>/chunyujin/55caa4ef.html</url>
      
        <content type="html"><![CDATA[<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>安装MinGW并添加到环境变量：</p><p><a href="http://chunyujin.top/chunyujin/1ee5d0ce.html">点此查看步骤(建议右键选择在新窗口中打开)</a></p><p>创建一个cpp文件并写一段测试代码</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215200029209.png" alt="image-20221215200029209"></p><p>点击顶部菜单栏的“运行”或者直接按F5</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215200205821.png" alt="image-20221215200205821"></p><p>输入一下宏定义命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd /k pushd &quot;$(CURRENT_DIRECTORY)&quot; &amp;&amp; g++ -o &quot;$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp;&amp; &quot;$(NAME_PART)&quot;.exe &amp; PAUSE &amp; EXIT</span><br></pre></td></tr></table></figure><p>点击运行即可</p><p>建议选择“保存”按键，将宏定义保存到快捷键，比如<code>ctrl + alt + n</code>(跟vscode的coderunner插件一样的快捷键)，下次运行直接快捷键即可</p><blockquote><p><code>cmd /k</code>：<strong>打开</strong> cmd 控制台，运行完程序让其停留而不自动关闭。</p><p><code>pushd &quot;$(CURRENT_DIRECTORY)&quot;</code>：<strong>将工作路径更换到源文件所在的路径</strong>，例如’pushd E:\kkk’相当于 cmd 中先<code>e:</code>再<code>cd kkk</code>，这条命令在源代码要调用同目录文件而只写了相对路径时尤为重要。因为 Notepad++ 的默认工作路径是它自己的安装路径。</p><p><code>g++ -o &quot;$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot;</code>：调用环境变量中的编译器 g++.exe 来将源代码<strong>编译</strong>成同名 exe 文件并输出到相同路径。</p><p><code>&quot;$(NAME_PART)&quot;.exe</code>：<strong>运行</strong>源代码编译出的可执行文件。</p><p><code>PAUSE</code>：暂停，提示<strong>“按任意键继续”</strong>，配合下一条命令实现“按任意键关闭”的效果，两者都没有的话程序运行完就会秒关。</p><p><code>EXIT</code>：<strong>关闭</strong> cmd 控制台，没有的话按任意键会退到 cmd 命令台，等待输入下一条命令。</p><ul><li><p>$(CURRENT_DIRECTORY)代表文件所在目录的路径。</p></li><li><p>$(NAME_PART)表示该文件无后缀部分的文件名。</p></li><li><p>$(FULL_CURRENT_PATH)代表当前完整的文件路径。</p></li><li><p>双引号（半角）：用于防止目录或文件名中含空格的情况。</p></li><li><p>“&amp;&amp;”和“&amp;”：前者表示上一条命令正常执行完再执行下一条命令，非正常则不执行下一条；后者无顾虑。例如一分为六后的后两条子命令，表示不管源代码编译、运行是否成功，都会出现“按任意键继续”字样，并且按任意键后关闭 cmd 控制台。</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NotePad++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VsCode_C++环境搭建(Mac m1芯片版本)</title>
      <link href="/chunyujin/1580f89a.html"/>
      <url>/chunyujin/1580f89a.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/BYGAO/p/15135609.html">文章转载自百叶的自留地(2021年8月)，非商业用途，侵删</a></p><p>文末放了我的三个json文件配置，可以参考。</p><h2 id="1-下载VS-code"><a href="#1-下载VS-code" class="headerlink" title="1.下载VS code"></a>1.下载VS code</h2><p>VS code已针对m1 芯片进行了适配，去官网下载VS code Apple Silicon版并安装。</p><h2 id="2-确保clang已安装"><a href="#2-确保clang已安装" class="headerlink" title="2.确保clang已安装"></a>2.确保clang已安装</h2><p>在终端里输入<code>clang --version</code>查看是否已安装，若未安装，输入<code>xcode-select --install</code>读完条款输入agree安装即可。</p><h2 id="3-下载扩展"><a href="#3-下载扩展" class="headerlink" title="3.下载扩展"></a>3.下载扩展</h2><p>一共有三个扩展需要下载。<br>1.C&#x2F;C++<br>2.C++ Intellisense<br>3.CodeLLDB<br>4.Chinese(中文插件，可选)</p><h2 id="4-新建cpp文件"><a href="#4-新建cpp文件" class="headerlink" title="4.新建cpp文件"></a>4.新建cpp文件</h2><p>这里直接采用<a href="https://code.visualstudio.com/docs/cpp/config-clang-mac">微软官方文档</a>里的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; msg &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;from&quot;</span>, <span class="string">&quot;VS Code&quot;</span>, <span class="string">&quot;and the C++ extension!&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> string&amp; word : msg)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; word &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，在文件第10行输入<code>msg.</code>应该是能看到VS code跳出<code>assign</code>之类的提示的。</p><h2 id="5-配置文件"><a href="#5-配置文件" class="headerlink" title="5.配置文件"></a>5.配置文件</h2><h3 id="1-配置tasks-json文件"><a href="#1-配置tasks-json文件" class="headerlink" title="1.配置tasks.json文件"></a>1.配置tasks.json文件</h3><p>首先点击<code>终端</code>—<code>配置默认生成任务</code>—<code>C/C++ clang++</code>，会生成一个tasks.json文件，这是默认生成的，需要修改其中的<code>args</code>选项,添加一个<code>&quot;-std=c++17&quot;</code>，修改后为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;args&quot;</span>: [</span><br><span class="line"><span class="string">&quot;-g&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;file&#125;</span>&quot;</span>,</span><br><span class="line"><span class="string">&quot;-std=c++17&quot;</span>,</span><br><span class="line"><span class="string">&quot;-o&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;fileDirname&#125;</span>/<span class="variable">$&#123;fileBasenameNoExtension&#125;</span>&quot;</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>配置完后，会发现VS code提示语法错误，不要急，接下来就修正它。</p><h3 id="2-配置c-cpp-properties-json文件"><a href="#2-配置c-cpp-properties-json文件" class="headerlink" title="2.配置c_cpp_properties.json文件"></a>2.配置c_cpp_properties.json文件</h3><p>使用组合键<code>shift+command+p</code>（mac下shift就是<code>fn</code>键上面那个啦），调出<code>C/C++:编辑配置（json）</code>，会自动生成一个<code>c_cpp_properties.json</code>文件。</p><p>将<code>&quot;compilerPath&quot;: &quot;/usr/bin/clang&quot;,</code>修改为<code>&quot;compilerPath&quot;: &quot;/usr/bin/clang++&quot;,</code><br>将<code>&quot;&quot;cppStandard&quot;: &quot;c++98&quot;,</code>修改为<code>&quot;cppStandard&quot;: &quot;c++17&quot;,</code></p><p>其实只是将编译器修改为clang++，cpp标准修改为C++ 17.</p><h3 id="3-编译生成文件"><a href="#3-编译生成文件" class="headerlink" title="3.编译生成文件"></a>3.编译生成文件</h3><p>这么配置完后，其实VS code还是会报两个语法错误，不过这不要紧，这是因为还没更新的缘故。<br>点击<code>终端</code>—<code>运行生成任务</code>，运行完后会生成一个二进制文件，语法报错也没了，表示我们编译成功了。<br>如果想测试的话，新建一个终端，使用<code>./你的二进制文件名</code>，即可看到输出结果。</p><h3 id="4-配置launch-json文件"><a href="#4-配置launch-json文件" class="headerlink" title="4.配置launch.json文件"></a>4.配置launch.json文件</h3><p>点击<code>运行</code>—<code>添加配置</code>—<code>C++(GDB/LLDB)</code>—<code>clang++</code>，会生成一个<code>launch.json</code>文件。<br>将<code>&quot;type&quot;: &quot;cppdbg&quot;,</code>修改为<code>&quot;type&quot;: &quot;lldb&quot;,</code><br>至此，所有文件就配置完了。</p><h3 id="5-调试"><a href="#5-调试" class="headerlink" title="5.调试"></a>5.调试</h3><p>在文件的第10行放一个断点，点击<code>运行</code>—<code>启动调试</code>，就可以看到各种变量了。</p><h2 id="我的文件配置"><a href="#我的文件配置" class="headerlink" title="我的文件配置"></a>我的文件配置</h2><p>以下是我的三个json文件配置代码。<br><code>tasks.json</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line"><span class="string">&quot;tasks&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppbuild&quot;</span>,</span><br><span class="line"><span class="string">&quot;label&quot;</span>: <span class="string">&quot;C/C++: clang++ 生成活动文件&quot;</span>,</span><br><span class="line"><span class="string">&quot;command&quot;</span>: <span class="string">&quot;/usr/bin/clang++&quot;</span>,</span><br><span class="line"><span class="string">&quot;args&quot;</span>: [</span><br><span class="line"><span class="string">&quot;-g&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;file&#125;</span>&quot;</span>,</span><br><span class="line"><span class="string">&quot;-std=c++17&quot;</span>,</span><br><span class="line"><span class="string">&quot;-o&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;fileDirname&#125;</span>/<span class="variable">$&#123;fileBasenameNoExtension&#125;</span>&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;options&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;<span class="variable">$&#123;fileDirname&#125;</span>&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;problemMatcher&quot;</span>: [</span><br><span class="line"><span class="string">&quot;<span class="variable">$gcc</span>&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;group&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line"><span class="string">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;detail&quot;</span>: <span class="string">&quot;编译器: /usr/bin/clang++&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>c_cpp_properties.json</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Mac&quot;</span>,</span><br><span class="line">            <span class="string">&quot;includePath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;<span class="variable">$&#123;workspaceFolder&#125;</span>/**&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;defines&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;macFrameworkPath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;compilerPath&quot;</span>: <span class="string">&quot;/usr/bin/clang++&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cStandard&quot;</span>: <span class="string">&quot;c17&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cppStandard&quot;</span>: <span class="string">&quot;c++17&quot;</span>,</span><br><span class="line">            <span class="string">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;macos-clang-arm64&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>launch.json</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;clang++ - 生成和调试活动文件&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;lldb&quot;</span>,</span><br><span class="line">            <span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="string">&quot;program&quot;</span>: <span class="string">&quot;<span class="subst">$&#123;fileDirname&#125;</span>/<span class="subst">$&#123;fileBasenameNoExtension&#125;</span>&quot;</span>,</span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;<span class="subst">$&#123;fileDirname&#125;</span>&quot;</span>,</span><br><span class="line">            <span class="string">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;MIMode&quot;</span>: <span class="string">&quot;lldb&quot;</span>,</span><br><span class="line">            <span class="string">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;C/C++: clang++ 生成活动文件&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VsCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Calibre实现Kindle带封面传书</title>
      <link href="/chunyujin/35444f4.html"/>
      <url>/chunyujin/35444f4.html</url>
      
        <content type="html"><![CDATA[<h4 id="Kindle如何带封面传书"><a href="#Kindle如何带封面传书" class="headerlink" title="Kindle如何带封面传书"></a>Kindle如何带封面传书</h4><p>软件：Calibre</p><p>Kinlde传书以往分为两种方式，一种是邮件传输，另一种是数据线连接电脑传输</p><h5 id="邮件传书"><a href="#邮件传书" class="headerlink" title="邮件传书"></a>邮件传书</h5><blockquote><p>每部Kindle都有自己的邮箱，通过附件的方式给Kindle邮箱发送邮件就可以传书</p><p>但是Kinlde在2022年8月份就宣布停止mobi格式书籍的邮箱传输，并只支持epub</p><p>Kindle机器本身只支持azw格式，Kindle可以对mobi进行转换，成为azw格式</p><p>通过邮件传书，无论是mobi还是epub格式都是先通过线上转换，变成azw格式之后发送到kindle去的，而mobi格式通过邮箱传输可以保留原来的封面，epub格式则会失去封面，用邮箱传书的话要带封面只能用mobi格式</p><p>亚马逊以后将停止kindle邮箱传书，只能选择数据线传书</p></blockquote><h5 id="数据线传书"><a href="#数据线传书" class="headerlink" title="数据线传书"></a>数据线传书</h5><blockquote><p>mobi的书籍通过数据线传输之后会丢失封面，epub则因为Kindle硬件无法进行格式转换，无法读取。</p><p>网络上获取的资源一般都是mobi格式以及epub格式的</p></blockquote><p>以下是通过数据线带封面传书的步骤</p><p><strong>如果书籍带有封面，并且不需要更换，跳过2、3步骤，如果书籍没有封面或者封面不官方和美观，执行2、3步骤</strong></p><ol><li>将需要传输的书籍放到calibre里面</li><li><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202208231507207.png" alt="截屏2022-08-23 15.06.53" style="zoom:50%;" /></li><li><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202208231508238.png" alt="截屏2022-08-23 15.08.01" style="zoom:50%;" /></li><li><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202208231509350.png" alt="截屏2022-08-23 15.09.53" style="zoom:50%;" /></li><li>推出Kindle，但是不要关闭calibre</li><li>保持Kindle的wifi打开的状态，等待亚马逊删除封面</li><li>再次连接Kindle到电脑，等到calibre读取到Kindle，此时calibre会恢复刚刚导入到Kindle书籍的封面</li><li>大功告成，可以推出Kindle以及关闭calibre</li></ol><h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h5><blockquote><ol><li>关于“步骤6”中“亚马逊删除封面“，因为Kindle图书的正规获取渠道是亚马逊图书商城，对于图书的封面，亚马逊是从网络上获取的，网络获取分为邮件和亚马逊商城，通过邮件推送来的mobi格式的图书，自带封面信息，因此Kindle可以通过网络（邮件）下载到图书封面，从亚马逊图书商城里获得的图书，自然也会下载到图书封面信息。</li><li>通过数据线传输书籍，书籍信息中的封面信息无法作为元数据保存为图书信息，还会占用掉封片信息，因此需要等亚马逊删除掉封面之后再由calibre恢复（写入）元数据信息（书籍封面）</li><li>calibre的原理：</li></ol><blockquote><p>更改书籍的信息（元数据），从名称作者到封面</p><p>都可以自定义更改</p><p>并且还可以从官方根据书籍名称获取书籍元数据，并下载保存在图书中</p></blockquote></blockquote><h5 id="自己制作封面："><a href="#自己制作封面：" class="headerlink" title="自己制作封面："></a>自己制作封面：</h5><blockquote><blockquote><p>如果无法获取到在线的封面，可以自己制作封面，一般来说书籍中的第一页就是书的封面，我们可以在calibre双击打开书籍，然后截取封面。进入编辑原数据，将截图设定为封面</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212230933831.png" alt="截屏2022-12-23 09.31.25"  /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212230934612.png" alt="截屏2022-12-23 09.31.48"  /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212230934010.png" alt="截屏2022-12-23 09.31.59"  /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212230934909.png" alt="截屏2022-12-23 09.32.58"  /><p>完成之后不要忘了点左下角的确定</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212230934041.png" alt="截屏2022-12-23 09.33.07" style="zoom:50%;" /></blockquote><p>信息来源</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202208231555992.png" alt="截屏2022-08-23 15.33.18" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Kindle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kindle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_历史命令</title>
      <link href="/chunyujin/6694219c.html"/>
      <url>/chunyujin/6694219c.html</url>
      
        <content type="html"><![CDATA[<h3 id="Linux会保存用户的历史指令"><a href="#Linux会保存用户的历史指令" class="headerlink" title="Linux会保存用户的历史指令"></a>Linux会保存用户的历史指令</h3><p>历史指令保存在用户目录下的.bash_history文件(历史记录文件)中，并且每条指令都用时间戳的形式记录了执行时刻</p><p>当用户通过shell进入Linux系统时，Linux系统会先将.bash_history中的保存的之前的历史指令读取到历史记录缓存区中，在用户正常退出shell之前，执行的所有指令也会先记录在缓存区中，当用户正常退出shell(exit或者control+d)时，shell进程会自动将历史记录缓存区中的所有历史记录写入到.bash_history中</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209114140665.png" alt="image-20221209114140665"></p><h4 id="查看历史缓冲区"><a href="#查看历史缓冲区" class="headerlink" title="查看历史缓冲区"></a>查看历史缓冲区</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history #查看历史记录缓存区中保存的历史指令</span><br></pre></td></tr></table></figure><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20221209112431.png" alt="QQ截图20221209112431"  /><p>从最开始到现在为止</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20221209112449.png"></p></blockquote><h5 id="通过键盘上下键快捷查看历史缓冲区"><a href="#通过键盘上下键快捷查看历史缓冲区" class="headerlink" title="通过键盘上下键快捷查看历史缓冲区"></a>通过键盘上下键快捷查看历史缓冲区</h5><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E5%BD%95%E5%B1%8F20221209120917.gif" alt="QQ录屏20221209120917"></p><h5 id="定量查看历史缓冲区的历史指令"><a href="#定量查看历史缓冲区的历史指令" class="headerlink" title="定量查看历史缓冲区的历史指令"></a>定量查看历史缓冲区的历史指令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history &lt;数字&gt; #查看缓冲区中最近的n条历史指令</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209172316597.png" alt="image-20221209172316597"></p><h4 id="手动写入-bash-history"><a href="#手动写入-bash-history" class="headerlink" title="手动写入.bash_history"></a>手动写入.bash_history</h4><p>如果执行了几条指令，比如执行两次<code>ls</code>和<code>ll</code>，查看一下历史缓存区</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209115827151.png" alt="image-20221209115827151"></p><p>再查看.bash_history，发现没有记录在里面，因为历史记录保存在了历史缓存区，当退出shell的时候才会自动从缓存区写入.bash_history</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209115907240.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history -w #手动将历史缓存写入用户目录下的.bash_history</span><br></pre></td></tr></table></figure><p>正常情况下，只有在 Shell 正常退出时，才会将缓冲区内容保存到.bash_history。如果想主动保存缓冲区的历史记录，执行 <code>-w</code> 选项即可</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209120133565.png" alt="image-20221209120133565"></p><h4 id="清除历史缓冲区"><a href="#清除历史缓冲区" class="headerlink" title="清除历史缓冲区"></a>清除历史缓冲区</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history -c #清除历史缓冲区</span><br></pre></td></tr></table></figure><p>历史缓冲区写入.bash_history其实就是用新内容覆盖掉原有内容，所以清除历史缓冲区就是清除本次登录用户时的所有操作的记录，不会删除之前的历史记录</p><h4 id="重复执行缓冲区历史指令"><a href="#重复执行缓冲区历史指令" class="headerlink" title="重复执行缓冲区历史指令"></a>重复执行缓冲区历史指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!&lt;数字&gt; #重复执行缓冲区中的第n条历史指令</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209173229978.png" alt="image-20221209173229978"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!-&lt;数字&gt; #重复执行缓冲区中倒数第n行历史指令</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209174342766.png" alt="image-20221209174342766"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!! #重复执行上一条命令</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209174410518.png" alt="image-20221209174410518"></p><h4 id="搜索历史命令"><a href="#搜索历史命令" class="headerlink" title="搜索历史命令"></a>搜索历史命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快捷键：ctrl + r# 输入残缺指令，搜索对应完整历史指令</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212121356384.gif" alt="Dec-12-2022 13-56-09"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_map&amp;pair类</title>
      <link href="/chunyujin/899a3eaf.html"/>
      <url>/chunyujin/899a3eaf.html</url>
      
        <content type="html"><![CDATA[<h4 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h4><blockquote><p>STL中的容器分为序列式容器(vector、list、array、deque、forward_list)和关联式容器(map、multimap、set、multiset)</p><p>序列式容器的特点是保存元素时只保存元素本身，不会对存储的元素进行自动排序，元素排列的顺序取决于存储它们的顺序</p><p>关联式容器在存储元素的时候还会存储另一个跟元素相关的值，称为“键”，元素和它的“键”作为一个整体“键值对”存储在关联式容器中，关联式容器自动根据“键”的大小将元素作升序排序；另外，可以根据元素的“键”找到对应的元素。</p></blockquote><h4 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h4><blockquote><p>pair是C++STL标准库中的一个类模版，定义在头文件 <code>&lt;utility&gt;</code> 中</p><p>是专门用来表示“键值对”的类型</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_auto关键字</title>
      <link href="/chunyujin/b4979a36.html"/>
      <url>/chunyujin/b4979a36.html</url>
      
        <content type="html"><![CDATA[<p><a href="http://c.biancheng.net/view/3718.html">auto关键字(类型推导)</a></p><p>当STL的模板类型实例化的时候，如果实例化的类型是模版类型，那么使用迭代器是会报错的</p><p>比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; i;<span class="comment">//vecter的实例化类型是int</span></span><br><span class="line">vector&lt;T&gt; v;<span class="comment">//vector的实例化类型是模版类型T</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator I = i.<span class="built_in">begin</span>();<span class="comment">//正确</span></span><br><span class="line">  veector&lt;T&gt;::iterator V = v.<span class="built_in">begin</span>();<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为在模板参数T实例化之前，模板类型为int的vector明确了自己的类型就是int，故迭代器可以根据类型执行相应的关于空间的操作。而模版类型为T的vector尚不知道T究竟是什么类型，所以迭代器无法通过类型来执行操作</p></blockquote><p>auto关键字是在程序编译时自动推导出变量的类型，可以很自然地和泛型编程结合而不用去提前考虑变量的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;T&gt; v;<span class="comment">//vector的实例化类型是模版类型T</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> V = v.<span class="built_in">begin</span>();<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>auto会在最后编译的时候，会判断变量的类型。在编译时，一旦调用函数，T类型就已经实例化，并且v是vector，vector.begin()函数返回的就是vector的迭代器，因此编译器会推导出此时V的类型</p><p>&#x3D;&#x3D;因此auto可以将泛型编程(模板)跟STL很好地结合&#x3D;&#x3D;</p></blockquote><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212041341428.png" alt="iShot_2022-12-04_13.40.14"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_所有函数都可直接调用</title>
      <link href="/chunyujin/5656723d.html"/>
      <url>/chunyujin/5656723d.html</url>
      
        <content type="html"><![CDATA[<p>无论函数是否有返回值，都可以直接调用</p><p>并不是说有返回值的函数在调用的时候必须用一个变量去承接返回值</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_vector常用用法</title>
      <link href="/chunyujin/170bba21.html"/>
      <url>/chunyujin/170bba21.html</url>
      
        <content type="html"><![CDATA[<h6 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a><a href="http://c.biancheng.net/view/6749.html">常用用法</a></h6><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212031057955.png" alt="iShot_2022-12-03_10.57.40"></p><h6 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a><a href="http://c.biancheng.net/view/6846.html">删除元素</a></h6><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212041438569.png" alt="iShot_2022-12-04_14.38.37"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_模板</title>
      <link href="/chunyujin/a0e18b05.html"/>
      <url>/chunyujin/a0e18b05.html</url>
      
        <content type="html"><![CDATA[<p>C&amp;C++中的模板是泛型编程的基础</p><p>泛型编程是一种编程风格，其中算法以尽可能抽象的方式编写，而不依赖于将在其上执行这些算法的数据形式。算法与数据形式分离。</p><p>C++中模板分为两种，一种是模板函数，一种是模板类。</p><p>使用模板参数构建出的函数就是模板函数，使用模板参数构建出的类就是模板类。</p><p>(所以可以看出重要的地方是模板参数)</p><p>在写了一个模板函数之后，编译时，编译器会根据用户给出的模板参数的实例化来自动生成相应的函数（类模板同理</p><p>模板的使用体现了C++程序的复用性和多态性</p><p>（函数重载也体现了多态性，但是函数重载是比较有限的，能覆盖的不同参数是有限的）</p><p>多态性：静态多态(模板)(编译时多态)，动态多态(继承)(运行时多态)</p><h6 id="x3D-x3D-模板参数分为三类-x3D-x3D"><a href="#x3D-x3D-模板参数分为三类-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;模板参数分为三类&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>模板参数分为三类</strong>&#x3D;&#x3D;</h6><ol><li>类型参数</li></ol><blockquote><p>通过 关键字 typename 或者 class 引入(两者基本上是等价的)</p></blockquote><ol start="2"><li>非类型参数</li></ol><blockquote><p>模板参数不局限于类型，类型的值也可以作为模板参数，通过 关键字 值的类型 引入</p><p>目前C++只支持 <u>整形</u> &#x2F; <u>枚举类型</u> &#x2F; <u>指针类型</u>(可以是原始数据类型的指针、派生数据类型的指针、对象的指针、对象的成员的指针) &#x2F; <u>引用类型</u>(可以是原始数据类型的引用、派生数据类型的引用、对象的引用)</p></blockquote><ol start="3"><li>模板型模板参数</li></ol><h6 id="x3D-x3D-模板参数支持缺省-x3D-x3D"><a href="#x3D-x3D-模板参数支持缺省-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;模板参数支持缺省&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>模板参数支持缺省</strong>&#x3D;&#x3D;</h6><blockquote><p>但是要注意的是，缺省参数的使用不要忘了按照规范形式，比如在类或函数声明时加了缺省值，在实现时就不要加了</p><p>(缺省值在声明时添加，在实现时就不添加了)</p><p>还有，缺省要从右往左缺省</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212031014022.png" alt="截屏2022-12-03 10.14.22"></p></blockquote><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221202104949903.png" alt="image-20221202104949903"></p><p><a href="https://blog.csdn.net/zhizhengguan/article/details/115869685">https://blog.csdn.net/zhizhengguan/article/details/115869685</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_模板不支持分离编译</title>
      <link href="/chunyujin/ad941677.html"/>
      <url>/chunyujin/ad941677.html</url>
      
        <content type="html"><![CDATA[<h3 id="C-模板不支持分离编译！！"><a href="#C-模板不支持分离编译！！" class="headerlink" title="C++模板不支持分离编译！！"></a>C++模板不支持分离编译！！</h3><p>一般情况下，自定义变量和函数的时候，在头文件中声明，在源文件中实现，在链接过程中会将分离开的声明和实现进行链接起来</p><p>但是&#x3D;&#x3D;<strong>模板变量和函数是不支持分离编译，也就是说模板的定义(声明+实现)必须在同一个文件里</strong>&#x3D;&#x3D;(一般建议在声明模板的地方定义模板，也就是头文件中)</p><p>模板是不支持声明和定义放到两个文件中的</p><blockquote><p>这就是为什么当模版是分离编译的时候，在main文件中包含模版的头文件的时候，编译时会报错：函数为定义。因为无法将模版的声明和实现进行链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有些语句后面不用加分号</title>
      <link href="/chunyujin/6e7957f9.html"/>
      <url>/chunyujin/6e7957f9.html</url>
      
        <content type="html"><![CDATA[<p>if(){}</p><p>while(){}</p><p>for(){}</p><p>int xx(){}</p><p>if语句、while循环、for循环、函数定义是，{}是语句的一部分，后面不用跟分号</p><p>函数的只声明不定义的时候需要语句最后要加分号</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212021945977.png" alt="截屏2022-12-02 19.42.03"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>size_t</title>
      <link href="/chunyujin/8883767d.html"/>
      <url>/chunyujin/8883767d.html</url>
      
        <content type="html"><![CDATA[<p>size_t在各种头文件中都有定义</p><blockquote><p>&lt;stddef.h&gt;, &lt;stdio.h&gt;, &lt;stdlib.h&gt;, &lt;string.h&gt;, &lt;time.h&gt;, &lt;wchar.h&gt;</p></blockquote><p>size_t类型表示C中&#x3D;&#x3D;任何对象能达到的最大长度&#x3D;&#x3D;，它是无符号整数数据类型</p><p>size_t并不是一个具体的大小的数据，而是要看系统，系统的对象长度最大为多少，size_t的大小就是多少。所以size_t类型方便在于系统之间移植使用。</p><p>比如在32位系统上，size_t类型就是 unsgned int 类型的typedf（即别名），也就是32位无符号整数；在64位系统上，size_t类型被定义为unsigned long long的typedef。</p><p>通常在用做下标或者长度变量时建议使用size_t，因为它始终是无符号的数。</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JB全家桶快捷键&amp;操作</title>
      <link href="/chunyujin/1d504d03.html"/>
      <url>/chunyujin/1d504d03.html</url>
      
        <content type="html"><![CDATA[<h4 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h4><p>⌃  + R</p><p>ctrl + R</p><h4 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h4><p>⌘ + ⌥  + L</p><p>win + alt + L　</p><h4 id="批量更改变量、函数名称"><a href="#批量更改变量、函数名称" class="headerlink" title="批量更改变量、函数名称"></a>批量更改变量、函数名称</h4><p>光标<strong>移动到</strong>变量、函数名称上</p><p>⇧  + F6</p><p>Shift + F6</p><h4 id="CLion-vscode风格代码高亮插件"><a href="#CLion-vscode风格代码高亮插件" class="headerlink" title="CLion_vscode风格代码高亮插件"></a>CLion_vscode风格代码高亮插件</h4><p>vscode dark原版风格</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303031846341.png" alt="截屏2023-03-03 18.45.45"></p><p>vscode dark plus 风格（个人认为黑色不如上面更纯粹，高亮也稍逊一点）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210272216897.png" alt="截屏2022-10-27 22.16.17" style="zoom:50%;" /><h4 id="CLion-vscode风格代码样式-用于格式化样式"><a href="#CLion-vscode风格代码样式-用于格式化样式" class="headerlink" title="CLion_vscode风格代码样式(用于格式化样式)"></a>CLion_vscode风格代码样式(用于格式化样式)</h4><p>Microsoft风格（vscode</p><p>舒服😌</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210272214080.png" alt="截屏2022-10-27 22.10.18" style="zoom:50%;" /><p>设置解引用符号*的位置</p><p>第一种舒服😌</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210301112448.png" alt="截屏2022-10-30 11.10.27" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210301112444.png" alt="截屏2022-10-30 11.10.50" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210301112437.png" alt="截屏2022-10-30 11.11.03" style="zoom:50%;" /><h4 id="设置背景"><a href="#设置背景" class="headerlink" title="设置背景"></a>设置背景</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210272217806.png" alt="截屏2022-10-27 22.16.48" style="zoom:50%;" /><h4 id="如果在CLion外部更改了项目中的文件的属性"><a href="#如果在CLion外部更改了项目中的文件的属性" class="headerlink" title="如果在CLion外部更改了项目中的文件的属性"></a>如果在CLion外部更改了项目中的文件的属性</h4><p><strong>比如我在CLion外部将原本的main.c改名成为了GuessingGame.c</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031163458930.png" alt="image-20221031163458930" style="zoom: 80%;" /><p>clion会报错</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031163348563.png" alt="image-20221031163348563" style="zoom: 80%;" /><p>发现CmakeLists.txt文件包含的文件是aaa main.c而不是aaa GuessingGame.c，说明并没有将GuessingGame.c包含在项目里</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031163553021.png" alt="image-20221031163553021" style="zoom:80%;" /><p>将第6行括号里的main.c改成GuesingGame.c即可</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031164432573.png" alt="image-20221031164432573" style="zoom:80%;" /><blockquote><p>注意，如果不是替换掉main.c，而只是添加GuessingGame.c的话，CLion中其实main.c是不存在的，那么就找不到main.c，当然也会报错</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031165612625.png" alt="image-20221031165612535" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031165619957.png" alt="image-20221031165619808" style="zoom:80%;" /></blockquote><p>然后会发现提示CMake项目需要重新加载，重新加载即可</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E5%9B%BE%E7%89%8720221031164540.jpg" alt="QQ图片20221031164540" style="zoom:80%;" /><p><strong>同样，如果在CLion外部，将文件添加到项目中，在CLion中也会报错</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031164230637.png" alt="image-20221031164230449" style="zoom:67%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031164247033.png" alt="image-20221031164247033" style="zoom:67%;" /><p>在CmakeLists.txt文件中添加上这几个文件就可以</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031165652840.png" alt="image-20221031165652840" style="zoom:80%;" /><blockquote><p>&#x3D;&#x3D;<strong>注意在CmakeLists.txt中添加文件的写法格式，上图就是正确的格式</strong>&#x3D;&#x3D;</p></blockquote><p>如果是在CLion内部新建头文件或者源文件，在添加的时候，勾选上添加到目标即可</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211102142435.png" alt="截屏2022-11-10 21.40.22" style="zoom:50%;" /><p>忘记勾选也没事，在CmakeLists.txt文件中添加上就可以</p><h4 id="可以直接将没有配置环境的文件夹直接在CLion中打开"><a href="#可以直接将没有配置环境的文件夹直接在CLion中打开" class="headerlink" title="可以直接将没有配置环境的文件夹直接在CLion中打开"></a>可以直接将没有配置环境的文件夹直接在CLion中打开</h4><p>众所周知，CLion会对每一个项目配置环境，前提是这是CLion的项目</p><p>如果一个文件夹不是CLion的项目，我们在CLion中打开，CLion会提示是否配置环境</p><p>(CLion项目中的环境配置文件↓)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-10-31%20170055.png" alt="屏幕截图 2022-10-31 170055" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E5%9B%BE%E7%89%8720221031170119.jpg" alt="QQ图片20221031170119" style="zoom:80%;" /><p>如果一个不是CLion项目的文件夹（也就是说没有配置环境），在CLion中打开</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031170502825.png" alt="image-20221031170502825" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031170513665.png" alt="image-20221031170513665" style="zoom:80%;" /><p>会提示是否创建CMake项目</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031170644553.png" alt="image-20221031170644553" style="zoom:80%;" /><p>选择“创建”即可</p><p>这样CLion就会在文件夹中生成环境文件了，文件夹就变成了一个CLion项目</p><h4 id="Windows下CLion运行结果中文输出是乱码"><a href="#Windows下CLion运行结果中文输出是乱码" class="headerlink" title="Windows下CLion运行结果中文输出是乱码"></a>Windows下CLion运行结果中文输出是乱码</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241018113104441.png" alt="image-20241018113104441" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241018113315192.png" alt="image-20241018113315192" /><p>去掉勾选即可</p><h4 id="彩虹括号-插件"><a href="#彩虹括号-插件" class="headerlink" title="彩虹括号 插件"></a>彩虹括号 插件</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211120940116.png" alt="截屏2022-11-12 09.40.19" style="zoom:50%;" /><p>会让编译器代码高亮变慢，所以已经卸载……</p><h4 id="PyCharm的解释器"><a href="#PyCharm的解释器" class="headerlink" title="PyCharm的解释器"></a>PyCharm的解释器</h4><p><strong>使用系统本地解释器：</strong></p><p>源文件直接可以跨平台，再使用本地系统的解释器进行解释即可，不需要在项目里添加解释器文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202304021047890.png" alt="截屏2023-04-02 10.47.19" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202304021049462.png" alt="截屏2023-04-02 10.47.27" style="zoom:50%;" /><p>只需要检查一下当前解释器是不是系统本地的即可</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202304021612683.png" alt="截屏2023-04-02 16.11.05" style="zoom:50%;" /><p><strong>使用虚拟解释器：</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202304021616897.png" alt="截屏2023-04-02 16.16.16" style="zoom:50%;" /><p><strong>两者的区别：</strong></p><p>虚拟环境是根据项目来的，不同的项目之间的环境是独立的，这样在引入库的时候，各个项目之间是独立的，不会相互影响，不会将库引入到系统本地中，而是在项目里，避免了互相影响和冗杂。但是项目大小会比使用本地环境的项目大一些。</p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> IDE </category>
          
          <category> JetBrains </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JetBrains </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数原则&amp;交互&amp;耦合</title>
      <link href="/chunyujin/8d125c1d.html"/>
      <url>/chunyujin/8d125c1d.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212010740120.png" alt="截屏2022-12-01 07.39.50"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>条件编译</title>
      <link href="/chunyujin/68bc2fec.html"/>
      <url>/chunyujin/68bc2fec.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/7692959">条件编译-百度百科</a></p><p><a href="http://c.biancheng.net/view/289.html">条件编译- C语言中文网</a></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211301126439.png" alt="iShot_2022-11-30_11.19.02"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>库文件&amp;静态库&amp;动态库</title>
      <link href="/chunyujin/bba9c8e0.html"/>
      <url>/chunyujin/bba9c8e0.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E5%BA%93%E6%96%87%E4%BB%B6/2550595">库文件-百度百科</a></p><p><a href="https://blog.csdn.net/junxuezheng/article/details/100557176">库、动态库和静态库（.dll，.so，.lib，.a）知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/71372182">浅谈静态库和动态库_知乎</a></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211292044221.png" alt="截屏2022-11-29 20.43.42"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211292010960.png" alt="iShot_2022-11-29_20.10.12"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言为何不支持重载</title>
      <link href="/chunyujin/fcea8946.html"/>
      <url>/chunyujin/fcea8946.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/580630581">C语言为什么不支持函数重载?c++又是如何支持的?</a></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211291556357.png" alt="iShot_2022-11-29_15.55.49"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_类型&amp;变量&amp;类和对象</title>
      <link href="/chunyujin/a5010295.html"/>
      <url>/chunyujin/a5010295.html</url>
      
        <content type="html"><![CDATA[<h3 id="数据类型-type"><a href="#数据类型-type" class="headerlink" title="数据类型(type)"></a>数据类型(type)</h3><p>简称类型</p><p>是具有相同特征的数据的集合，是一个抽象<strong>概念</strong></p><blockquote><p>C++的数据类型主要分为三种：</p><p><strong>原始数据类型</strong>：内置或预定义的数据类型，用户可以直接使用它们声明变量。例如：int，char，float，bool等</p><blockquote><p>整数、字符、布尔型、浮点、双浮点数、void、宽字符 等</p></blockquote><p><strong>派生数据类型</strong>：从原始或内置数据类型派生的数据类型</p><blockquote><p>函数</p><p>数组</p><p>指针</p><p>引用</p></blockquote><p><strong>用户自定义类型</strong>：这些数据类型由用户自己定义</p><blockquote><p>类</p><p>结构体</p><p>union：在并集中，所有成员共享相同的内存位置</p><p>枚举类型</p><p>typedef：为 复杂的声明 定义 简单的别名</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/20200401135258635.png" alt="20200401135258635" style="zoom:67%;" /></blockquote><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><blockquote><p>变量：数据保存在计算机中，是存储在内存中的某一块空间上，这块用来存储数据的空间就是变量，给这块空间命的名就是变量名</p><blockquote><p>变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。<a href="https://www.runoob.com/cprogramming/c-variables.html">C变量</a></p></blockquote></blockquote><p>变量类型就是存储在变量中的数据的数据类型</p><p>变量的值就是变量这块空间中存储的数据的值</p><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><blockquote><p>变量的定义，告知编译器 在内存申请一块空间 用来存储数据，数据类型是什么，空间名(即变量) 叫什么，数据的值 是什么</p><p>变量的声明，只告知编译器 在内存申请一块空间 用来存储数据，数据类型是什么，空间名(即变量) 叫什么，关于数据的值，则没有说明</p></blockquote><blockquote><p>变量的定义和声明都会在内存中申请出一块空间，区别在于是否赋予变量(中的数据)具体的值</p></blockquote><blockquote><p>无论是声明还是定义，都要指定 变量的类型，因为要按照数据类型在内存中申请对应的具体大小的空间</p></blockquote><h3 id="用户自定义类型的定义"><a href="#用户自定义类型的定义" class="headerlink" title="用户自定义类型的定义"></a>用户自定义类型的定义</h3><h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><blockquote><p>函数的定义，告知编译器 函数的返回值类型、函数名、参数、函数的实现</p><p>函数的声明，只告知编译器 函数的返回值类型、函数名、参数，不进行函数的实现</p></blockquote><p>函数的定义 &#x3D; 函数的声明 + 函数的实现</p><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><blockquote><p>类的定义，告知编译器 类的名称、类的私有成员、类的公有成员、类的成员变量的声明、类的成员函数的定义</p><p>类的声明，告知编译器 类的名称、类的私有成员、类的公有成员、类的成员变量的声明、类的成员函数的声明，不进行类的成员函数的实现</p><p>类的实现，就是类的成员函数的实现</p></blockquote><p>类的定义 &#x3D; 类的声明 + 类的(成员函数)的实现</p><blockquote><p>类和函数，有声明但没有实现，则是未定义，编译器会报错类或函数未定义(undefined)</p><p>没有声明，则编译器会报错未声明(unclear)</p></blockquote><p><strong>一般来说，在定义函数和类时，在头文件中声明，在源文件中实现</strong></p><blockquote><p>不过模版类不支持分离编译(见另一篇日记)，因此要在同一个文件中(一般是头文件)完成定义</p></blockquote><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><blockquote><p> 类是一种用户自定义类型</p><p>STL是一个 标准 模板类 库</p></blockquote><p>类是一个数据类型，是一个抽象的概念</p><p>对象是类的实例化，对象是变量</p><blockquote><p>类是封装对象的属性和行为的载体，而对象的属性以成员变量的形式存在。对象的方法以成员方法的形式存在，在成员方法内定义的变量为局部变量</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>节点和结点</title>
      <link href="/chunyujin/624685c8.html"/>
      <url>/chunyujin/624685c8.html</url>
      
        <content type="html"><![CDATA[<h3 id="节点和结点"><a href="#节点和结点" class="headerlink" title="节点和结点"></a>节点和结点</h3><blockquote><p>节点和结点的区别有：</p><p>节点是一个实体具有处理的能力；而结点是一个交叉点，是一个标记</p><p>一般算法中的点都称为&#x3D;&#x3D;结点&#x3D;&#x3D;</p><p>节点被认为是一个实体，有处理能力，比如网络上的一台计算机；而结点则只是一个交叉点，像”结绳记事”，打个结，做个标记，仅此而已</p><p>还有就是，要记住：一般算法中点的都是&#x3D;&#x3D;结点&#x3D;&#x3D;。</p><p> 我们在数据结构的图形表示中，对于数据集合中的每一个数据元素用中间标有元素值的方框表示，一般称它为数据结点，简称结点</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_STL用法[持续更新]</title>
      <link href="/chunyujin/de6e9320.html"/>
      <url>/chunyujin/de6e9320.html</url>
      
        <content type="html"><![CDATA[<h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p><a href="http://c.biancheng.net/view/6749.html">vector容器详解</a></p><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p><a href="http://c.biancheng.net/view/2236.html">string用法详解</a></p><p><a href="https://blog.csdn.net/weixin_44267044/article/details/103578226">c++在string末尾添加字符或字符串</a></p><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><p><a href="http://c.biancheng.net/view/478.html">stack用法详解</a></p><h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><p><a href="http://c.biancheng.net/view/479.html">queue用法详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重点!_头文件&amp;源文件&amp;编译&amp;链接</title>
      <link href="/chunyujin/e0e64692.html"/>
      <url>/chunyujin/e0e64692.html</url>
      
        <content type="html"><![CDATA[<h2 id="重点-头文件-amp-源文件-amp-编译-amp-链接"><a href="#重点-头文件-amp-源文件-amp-编译-amp-链接" class="headerlink" title="[重点!]头文件&amp;源文件&amp;编译&amp;链接"></a>[重点!]头文件&amp;源文件&amp;编译&amp;链接</h2><h4 id="C-x2F-C-支持分离式编译：一个程序可以分成多个部分保存在各个文件-头文件、源文件-中，在链接之前，各个文件-无论源文件还是头文件-是相互独立、没有关联的"><a href="#C-x2F-C-支持分离式编译：一个程序可以分成多个部分保存在各个文件-头文件、源文件-中，在链接之前，各个文件-无论源文件还是头文件-是相互独立、没有关联的" class="headerlink" title="C&#x2F;C++支持分离式编译：一个程序可以分成多个部分保存在各个文件(头文件、源文件)中，在链接之前，各个文件(无论源文件还是头文件)是相互独立、没有关联的"></a><strong>C&#x2F;C++支持分离式编译：一个程序可以分成多个部分保存在各个文件(头文件、源文件)中，在链接之前，各个文件(无论源文件还是头文件)是相互独立、没有关联的</strong></h4><blockquote><p>分离式编译是指一个完整的程序或项目由若干个源文件共同实现，每个源文件单独编译生成目标文件，最后将该项目中的所有目标文件连接成一个单一的可执行文件的过程。</p></blockquote><blockquote><p>在这里插一嘴：</p><p>&#x3D;&#x3D;<strong>#include</strong>&#x3D;&#x3D;的作用</p><p>这是一个宏定义，众所周知，宏定义就是替换，比如a.cpp中要包含a.h，写作#include”a.h”</p><p>这一行就是将#include后的”a.h”替换为a.h中的所有代码</p><blockquote><p>头文件里的内容就在这里“展开”了</p></blockquote><p><strong>但这并不能说明a.cpp和a.h是有关联的，只是a.cpp中包含了a.h，包含并不意味着有关联</strong></p><p>因为#incldue是宏定义，是替换，跟其他的宏定义一样，比如#define N 100</p></blockquote><h4 id="众所周知，-x3D-x3D-在定义变量-自定义-或者函数时，头文件保存变量-自定义-和函数的声明，源文件保存变量和函数的实现-x3D-x3D"><a href="#众所周知，-x3D-x3D-在定义变量-自定义-或者函数时，头文件保存变量-自定义-和函数的声明，源文件保存变量和函数的实现-x3D-x3D" class="headerlink" title="众所周知，&#x3D;&#x3D;在定义变量(自定义)或者函数时，头文件保存变量(自定义)和函数的声明，源文件保存变量和函数的实现&#x3D;&#x3D;"></a>众所周知，&#x3D;&#x3D;在定义变量(自定义)或者函数时，头文件保存变量(自定义)和函数的<u>声明</u>，源文件保存变量和函数的<u>实现</u>&#x3D;&#x3D;</h4><blockquote><p>头文件的作用</p><p>C&#x2F;C++编译采用的是分离编译模式。在一个项目中，有多个源文件存在，但是它们总会有一些相同的内容，比如用户自定义类型、全局变量、全局函数的声明等。将这些内容抽取出来放到头文件中，提供给各个源文件包含，就可以避免想相同内容的重复书写，提高编程效率和代码安全性。所以，设立头文件的目的主要是：提供全局变量、全局函数的声明或公用数据类型的定义，从而实现分离编译和代码复用。 </p><p>概括的说，头文件有如下三个作用。  </p><ol><li>加强类型检查，提高类型安全性。  使用头文件，可有效地保证自定义类型的一致性。虽然，在语法上，同一个数据类型（如一个class）在不同的源文件中书写多次是允许的，程序员认为他们是同一个自定义类型，但是，由于数据类型不具有外部连接特性，编译器并不关心该类型的多个版本之间是否一致，这样有可能会导致逻辑错误的发生。</li><li>减少公用代码的重复书写，提高编程效率。  程序开发过程中，对某些数据类型或者接口进行修改是在所难免的，使用头文件，只需要修改头文件中的内容，就可以保证修改在所有源文件中生效，从而避免了繁琐易错的重复修改。</li><li>提供保密和代码重用的手段。  头文件也是C++代码重用机制中不可缺少的一种手段，在很多场合，源代码不便（或不准）向用户公布，只要向用户提供头文件和二进制库即可。<u>用户只需要按照头文件的接口声明来调用库函数，而不必关心接口的具体实现，编译器会从库中连接相应的实现代码。</u>（封装性）</li></ol></blockquote><p>但是其实头文件和源文件并没有关联</p><p>比如在a.h中声明了一个类a，包含成员变量和成员函数的声明，在a.cpp中包含类a成员函数的定义(实现)</p><p>其实在编写的时候，a.h和a.cpp没有关联，编译器并不知道它俩的关系</p><p>a.cpp中对于类a的成员函数进行了定义，但a.cpp中并没有类a的声明</p><p>而a.h和a.cpp并没有关联，也就是说编译器不知道a.cpp中的类a在哪儿声明的，而类a如果没有声明，这就是一个错误</p><p>所以这就是为什么a.cpp一定要包含a.h</p><blockquote><p>如果再有一个b.h和b.cpp以及一个包含main函数的main.cpp</p><p>如果b中想要使用类a，则在b.h中包含类a的声明和定义就可以</p><p>我们知道，main.cpp中想要使用某个现有的变量或者函数，只要包含对应的<u>头文件</u>就可以</p><p>那么是不是只需要在b.h中包含头文件a.h（#include”a.h）就可以的</p><p>这是不可以的，因为a.h和a.cpp是没有关联的：a.h中只有a的声明，没有a的定义</p><blockquote><p>如果此时运行的话，在运行时会报错：缺少a的定义</p><p>但是如果不运行是不会报错的，因为a.h中虽然没有a的定义，但是有声明，并没有语法和逻辑错误</p><p>缺少a的定义是属于编译错误</p></blockquote><p>正确的做法是b.h中包含a.cpp而不是a.h</p><p>因为a.cpp中是对类a的成员函数的实现，而a.cpp中又包含a.h</p><p>话说回来，为什么main.cpp中可以包含头文件，不用包含源文件？因为<strong>链接</strong></p></blockquote><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>编译是对项目中所有的源文件（注意只是源文件，不是头文件）进行编译，将它们“翻译”成为机器能识别的机器语言，每个源文件被编译后会生成一个对应的目标文件，里面是源文件代码被翻译成的机器语言</p><p>头文件是不进行编译的，理由在下面</p><p>众所周知，main函数是程序的入口，要想执行程序，就要执行main函数</p><p>含有main函数的源文件，在这里我叫它main文件吧</p><p>main文件也是源文件，也和其他源文件一样，在编译的时候会进行编译</p><p>main文件中会包含头文件</p><p>可是头文件中只有声明，没有定义，那怎么能用对应的变量和函数呢</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>在编译之后，每个源文件都会生成一个目标文件</p><p>在执行程序时，编译之后，进行链接</p><p>main文件中含有头文件，链接就是通过头文件，找到对应的实现头文件中声明的内容的源文件，再找到这些源文件的目标文件，将这些目标文件跟main文件的目标文件“链接”起来，形成一个结合体打包起来——可执行文件</p><p>所以，因为有链接这一步，main文件中只包含头文件就行，因为链接时可以找到对应的源文件</p><p>而且链接是对于main文件而言的，也就是这一步只能用在main文件上，将main文件的目标文件 与 main文件包含的头文件对应的源文件的目标文件 结合起来</p><p>跟编译不同，一般的源文件不执行链接这个步骤，因为这是没有意义的，只有main文件是程序的接口</p><h4 id="x3D-x3D-总结-x3D-x3D"><a href="#x3D-x3D-总结-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><blockquote><ol><li></li></ol><blockquote><p>&#x3D;&#x3D;<strong>只有main文件才能只包含头文件，不包含源文件</strong>&#x3D;&#x3D;</p><p>&#x3D;&#x3D;<strong>只有库函数或者库里的类被一般源文件调用的时候，一般的源文件可以只包含对应的库头文件</strong>&#x3D;&#x3D;&#x3D;&#x3D;<strong>一般的源文件想要调用别的 自定义的类 或者 自定义的函数 的时候，要在其头文件中包含对应的源文件而不是头文件</strong>&#x3D;&#x3D;</p></blockquote><ol start="2"><li></li></ol><blockquote><p>&#x3D;&#x3D;<strong>在定义变量(自定义)或者函数时，头文件保存变量(自定义)和函数的<u>声明</u>，源文件保存变量和函数的实现</strong>&#x3D;&#x3D;</p></blockquote></blockquote><blockquote><p>源文件如何根据#include来包含头文件：</p><ol><li>系统库自带的头文件(库文件)用尖括号括起来，这样编译器会在系统库文件目录下查找。 </li><li>用户自定义的文件用双引号括起来，编译器首先会在用户目录下查找，然后在到C++安装目录（比如VC中可以指定和修改库文件查找路径，Unix和Linux中可以通过环境变量来设定）中查找，最后在系统文件中查找。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_vector访问元素的几种方式</title>
      <link href="/chunyujin/4e5ebe5e.html"/>
      <url>/chunyujin/4e5ebe5e.html</url>
      
        <content type="html"><![CDATA[<h2 id="C-STL-vector容器访问元素的几种方式"><a href="#C-STL-vector容器访问元素的几种方式" class="headerlink" title="C++ STL vector容器访问元素的几种方式"></a><a href="http://c.biancheng.net/view/6816.html">C++ STL vector容器访问元素的几种方式</a></h2><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20221116085628.png" alt="QQ截图20221116085628"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_取整函数</title>
      <link href="/chunyujin/d3194531.html"/>
      <url>/chunyujin/d3194531.html</url>
      
        <content type="html"><![CDATA[<h3 id="C-取整函数"><a href="#C-取整函数" class="headerlink" title="C++取整函数"></a>C++取整函数</h3><h5 id="都包含在头文件cmath中"><a href="#都包含在头文件cmath中" class="headerlink" title="都包含在头文件cmath中"></a>都包含在头文件cmath中</h5><p>#include<cmath></p><h5 id="向上取整：ceil"><a href="#向上取整：ceil" class="headerlink" title="向上取整：ceil()"></a>向上取整：ceil()</h5><p>画图很好理解</p><p>无论是整数还是负数，向上取整就是向上(x轴正方向)找距离最近的整数</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211061133486.jpeg" alt="IMG_0725" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211061133405.jpeg" alt="IMG_0726" style="zoom:50%;" /><blockquote><p>ceil(1.3)</p><p>结果是2</p><p>ceil(-1.2)</p><p>结果是-1</p></blockquote><h5 id="向下取整：floor"><a href="#向下取整：floor" class="headerlink" title="向下取整：floor()"></a>向下取整：floor()</h5><p>又叫 “地板算法”</p><p>无论是整数还是负数，向上取整就是向下(x轴负方向)找距离最近的整数</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211061136576.jpeg" alt="IMG_0723" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211061136193.jpeg" alt="IMG_0724" style="zoom:50%;" /><blockquote><p>ceil(1.3)</p><p>结果是1</p><p>ceil(-1.2)</p><p>结果是-2</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>震惊!_类内成员函数可以访问本类对象的私有成员</title>
      <link href="/chunyujin/3fe5c396.html"/>
      <url>/chunyujin/3fe5c396.html</url>
      
        <content type="html"><![CDATA[<h3 id="震惊-类内成员函数可以访问本类对象的私有成员"><a href="#震惊-类内成员函数可以访问本类对象的私有成员" class="headerlink" title="[震惊!]类内成员函数可以访问本类对象的私有成员"></a>[震惊!]类内成员函数可以访问本类对象的私有成员</h3><p>sList是一个类</p><p>私有成员是head，有一个成员函数的形参是本类对象(的引用，引不引用不影响结论和原因)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210301200183.png" alt="截屏2022-10-30 11.33.24" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210301200702.png" alt="截屏2022-10-30 11.33.38" style="zoom:50%;" /><h6 id="x3D-x3D-为什么呢！head明明是b的私有成员，为什么可以被访问了！！？？-x3D-x3D"><a href="#x3D-x3D-为什么呢！head明明是b的私有成员，为什么可以被访问了！！？？-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;为什么呢！head明明是b的私有成员，为什么可以被访问了！！？？&#x3D;&#x3D;"></a>&#x3D;&#x3D;为什么呢！head明明是b的私有成员，为什么可以被访问了！！？？&#x3D;&#x3D;</h6><p>因为！</p><p><strong>对象b是sList类的，而这个intersection函数是sList的成员函数</strong></p><p><strong>head虽然是sList类的对象的私有成员，但是是在sList类内访问的</strong></p><p>&#x3D;&#x3D;<strong>就是 在类内访问了本类(的实例化对象)的私有成员，这当然是可以的！ 因为这是在类内访问的，又不是在类外</strong>&#x3D;&#x3D;</p><p>这说明了，类的成员的访问权限，是对于&#x3D;&#x3D;类&#x3D;&#x3D;而言的，决定在&#x3D;&#x3D;类&#x3D;&#x3D;外是否可被访问</p><p>而非对于对象来说的（因为对象不同但是都是属于同一种类，类的实例化对象的成员，本来就是类的成员，只是抽象和实例化的问题</p><p>这非常合理地体现了 类 的封装性</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210301200083.png" alt="截屏2022-10-30 11.45.50" style="zoom:50%;" /><p>这个就是不行的，在类外访问了</p><blockquote><p>这一点是非常好用的，可以利用这一点</p><p>&#x3D;&#x3D;用成员函数肆无忌惮地访问对象的私有成员！&#x3D;&#x3D;只要声明函数是类的成员函数，将外部同类对象设为形参(或加个引用)就可以了！！</p><p>不必再为如何访问到同类外部对象的私有成员而苦思了！</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210312112520.PNG" alt="IMG_2368" style="zoom: 33%;" />]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开辟新空间与普通声明定义的一个区别</title>
      <link href="/chunyujin/2e648a29.html"/>
      <url>/chunyujin/2e648a29.html</url>
      
        <content type="html"><![CDATA[<h4 id="开辟新空间与普通声明定义的一个区别"><a href="#开辟新空间与普通声明定义的一个区别" class="headerlink" title="开辟新空间与普通声明定义的一个区别"></a>开辟新空间与普通声明定义的一个区别</h4><p>如果在一个循环中，有一个语句是普通声明定义一个变量，在循环中，其实每次都是使用的同一个空间，只是在循环中反复覆盖这个空间的数据</p><p>而开辟新空间(C++的new，C的malloc等)是每次在敦区开辟一个新的空间，而且如果不手动释放，在程序结束之前一直都在占用。（所以有的时候需要手动释放，防止堆上的空间都被占用导致开辟不出新空间）</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210291419187.png" alt="截屏2022-10-29 14.14.50"></p><p>上面的代码是在一个while循环里的，Book是一个链表的结点类，数据域有IBSN、name、price</p><p>本意是想要每次都在链表尾插</p><p>如果划线的写成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Book <span class="title">b</span><span class="params">(ISBN,name,price)</span></span>;</span><br></pre></td></tr></table></figure><p>其实每次循环用的都是同一块空间，是在链表的同一个结点上反复更改数据域的ISBN、name、price而已，因为b并不是产生的新结点，b用的是原来的地址，没有分配新的空间</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表怎么排序</title>
      <link href="/chunyujin/d43e1a90.html"/>
      <url>/chunyujin/d43e1a90.html</url>
      
        <content type="html"><![CDATA[<h4 id="链表怎么排序"><a href="#链表怎么排序" class="headerlink" title="链表怎么排序"></a>链表怎么排序</h4><h5 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h5><p>只交换结点的数据域，不更改指针域</p><p>这样就可以采用各种排序方式了，冒泡、选择等，根据链表的特性进行一定的更改就可以</p><h5 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h5><p>将链表放到顺序表，对顺序表排序，将顺序表每个结点的数据域依次赋值给链表的每个结点的数据域</p><p>也是不用更改指针域</p><p>参考来源</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210291314360.png" alt="iShot_2022-10-29_13.14.22" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_与Shell的关系</title>
      <link href="/chunyujin/a64800cc.html"/>
      <url>/chunyujin/a64800cc.html</url>
      
        <content type="html"><![CDATA[<p>一个完整的计算机，整体结构如下图：</p><img src="https://img-blog.csdnimg.cn/67f4c5c0392d42bb949f4d5f71790a46.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZmF0ZmF0bW9tbw==,size_8,color_FFFFFF,t_70,g_se,x_16" alt="img" /><p>①我们的计算机由硬件组成，包括CPU、内存、主板、磁盘、各种外设等等。当这台计算机没有安装任何软件，只是一个硬件的集合体时，也叫做 裸机(纯硬件)。</p><p>②操作系统是系统软件，操作系统的内核控制着和管理计算机上的所有硬件和软件，从而进行任务调度、资源分配等。操作系统起到承上启下的作用。</p><p>③我们平时使用的应用软件(或叫应用程序)，如QQ音乐、英雄联盟等，是基于操作系统开发的，可以理解为在操作系统的上层。这些程序的开发往往调用了操作系统提供的接口，离开了操作系统是无法独立运行的。</p><p><strong>Shell是一个特殊的应用程序，介于操作系统内核和用户之间，是一个“命令解释器”，负责接受用户输入的指令并进行解释，将需要执行的操作传递给内核执行，并输出执行结果返回给用户。</strong></p><p><strong>在linux早期是没有图形化界面的，与系统进行交互的唯一方式就是通过shell提供的命令行界面(command-line interface, CLI)。同样在工作中，需要通过本机登录内网开发机，使用命令行界面进行开发，从而保障安全性。</strong></p><p>命令行界面只接受文本输入。我们想使用shell进行开发，则需要深入了解shell的命令，后续文章会对shell命令进行详细的介绍，本专栏主要针对想入门shell的新同学，有问题欢迎评论或私信，共同交流，一般周末公司不加班都会回复~~~</p><p>PS : 在厂里搬砖，基本都是在linux机器上进行开发的。很多同学在校时大多在机子上装个Pycharm之类的IDE就足够完成科研任务了，这也使得刚工作后不太熟悉linux开发的节奏。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_快捷键&amp;热键</title>
      <link href="/chunyujin/bd04c738.html"/>
      <url>/chunyujin/bd04c738.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-光标移动"><a href="#1-光标移动" class="headerlink" title="1. 光标移动"></a>1. 光标移动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ctrl + &lt;      # 移动到前一个单词开头</span><br><span class="line">ctrl + &gt;      # 移动到后一个单词结尾</span><br><span class="line">ctrl + A      # 移动到开头</span><br><span class="line">ctrl + E      # 移动到结尾</span><br><span class="line">alt  + B      # 向左移动一个单词</span><br><span class="line">alt  + F      # 向右移动一个单词</span><br><span class="line">ctrl + B      # 向左移动一个字符</span><br><span class="line">ctrl + F      # 向右移动一个字符</span><br><span class="line">esc  + B      # 向左移动一个单词</span><br><span class="line">esc  + F      # 向右移动一个单词</span><br><span class="line">ctrl + XX     # 在上次光和当前光标所在字符间跳转</span><br><span class="line">esc  + T      # 交换光标位置前的两个单词</span><br></pre></td></tr></table></figure><h2 id="2-拷贝-x2F-剪切-x2F-粘贴-x2F-删除"><a href="#2-拷贝-x2F-剪切-x2F-粘贴-x2F-删除" class="headerlink" title="2. 拷贝&#x2F;剪切&#x2F;粘贴&#x2F;删除"></a>2. 拷贝&#x2F;剪切&#x2F;粘贴&#x2F;删除</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* ctrl/shift + Insert # whindows下复制粘贴文本 </span><br><span class="line">* cmd + c/v # macOS下复制粘贴文本</span><br><span class="line">  ctrl + K      # 剪切光标后所有字符</span><br><span class="line">  ctrl + U      # 剪切光标前所有字符</span><br><span class="line">  ctrl + Y      # 粘贴ctrl+U/K剪切的内容</span><br><span class="line">  ctrl + W      # 删除光标前一个单词</span><br><span class="line">  ctrl + D      # 删除光标所在字符(光标右侧) #不建议使用</span><br><span class="line">  ctrl + H      # 删除光标前字符(光标左侧)</span><br></pre></td></tr></table></figure><h2 id="3-撤销"><a href="#3-撤销" class="headerlink" title="3. 撤销"></a>3. 撤销</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* ctrl + _      # 撤销操作</span><br><span class="line">  ctrl + ?      # 撤消前一次输入</span><br><span class="line">  alt  + R      # 撤消前一次动作</span><br></pre></td></tr></table></figure><h2 id="4-替换"><a href="#4-替换" class="headerlink" title="4. 替换"></a>4. 替换</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* ctrl + T      # 将光标当前字符与前面一个字符替换</span><br></pre></td></tr></table></figure><h2 id="5-历史命令编辑"><a href="#5-历史命令编辑" class="headerlink" title="5. 历史命令编辑"></a>5. 历史命令编辑</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  ctrl + P      # 上条输入的命令(相当于上键)</span><br><span class="line">  ctrl + N      # 上条历史命(相当于下键)</span><br><span class="line">  alt  + &gt;      # 上一次执行命令</span><br><span class="line">* ctrl + R      # 输入残缺指令，搜索对应完整历史指令</span><br></pre></td></tr></table></figure><h2 id="6-控制命令"><a href="#6-控制命令" class="headerlink" title="6. 控制命令"></a>6. 控制命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* ctrl + L      # 清除屏幕，相当于clear</span><br><span class="line">* ctrl + C      # (强制)终止命令&amp;另起一行</span><br><span class="line">* ctrl + D      # 退出(比如用户登出、退出shell、退出终端)</span><br><span class="line">* ctrl + Z      # 暂停并挂起当前任务</span><br><span class="line">  ctrl + I      # 补全功能(类似Tab键)</span><br><span class="line">  ctrl + O      # 重复执行命令</span><br><span class="line">  alt  + &lt;数字&gt;  # 操作的次数</span><br><span class="line">  ctrl + S      # 锁住终端，阻止屏幕输出</span><br><span class="line">  ctrl + Q      # 解锁终端，允许屏幕输出</span><br></pre></td></tr></table></figure><h2 id="7-补全-x2F-补齐"><a href="#7-补全-x2F-补齐" class="headerlink" title="7.补全&#x2F;补齐"></a>7.补全&#x2F;补齐</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tab</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单击tab实现指令补全，仅当通过残缺的指令能确定唯一的完整指令时才可以实现补全</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">双击tab实现档案补全，当通过残缺的指令无法确定唯一完整指令时，显示所有对应指令</span></span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212121406831.gif" alt="Dec-12-2022 14-04-41"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212121406885.gif" alt="Dec-12-2022 14-05-29"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从CLion和VsCode的小发现到C++的编译</title>
      <link href="/chunyujin/f61f63a.html"/>
      <url>/chunyujin/f61f63a.html</url>
      
        <content type="html"><![CDATA[<h5 id="一场编译环境的配置让我简单思考了一下VsCode和CLion的一个小区别"><a href="#一场编译环境的配置让我简单思考了一下VsCode和CLion的一个小区别" class="headerlink" title="一场编译环境的配置让我简单思考了一下VsCode和CLion的一个小区别"></a>一场编译环境的配置让我简单思考了一下VsCode和CLion的一个小区别</h5><ul><li>CLion、VS2022一个界面只能容纳一个项目</li></ul><p>​因此一个界面只能打开一个项目</p><blockquote><p>好像是因为这两种编译器对每个项目都配置对应的环境（我猜的，因为每个项目里面有独立的配置文件</p></blockquote><ul><li>VsCode一个界面可以容纳多个项目，在”工作区”中通过不同的文件夹区分不同的项目</li></ul><p>​因此一个界面可以打开多个项目</p><blockquote><p>VsCode一个环境配置文件可以配置整个工作区中的所有文件的环境（只要工作区一级目录包含一个配置文件文件夹，工作区的所有项目都用这个文件夹，而且配置文件夹可以添加编译环境，因为一个工作区既可以编译C、C++，也可以编辑Python等，只需要下载相应的插件并将配置添加到配置文件夹就可以</p></blockquote><blockquote><p>任何程序，一个项目里面只能存在一个main函数</p></blockquote><blockquote><p>《C++ Primer Plus 第六版》1.4中写，Windows编译器如果要编译程序，要为程序创建一个项目才行，并将组成程序的文件添加到该项目中。项目中有编译器提供的IDE(集成开发环境)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210181521940.png" alt="截屏2022-10-18 15.18.36" style="zoom:40%;" /></blockquote><p>CLion、VS2022是名副其实的“编译器”</p><p>VsCode其实算是一个“编辑器”，通过各种插件来完成编译功能</p><p>所以就编辑而言，其实VsCode还是方便一点呢，一个窗口就能编辑多个项目了；而且vscode更轻量级，打开速度更快</p><p>但是就进行开发比较大的一个项目而言，还得是Clion、Xcode、VS2022，因为术业有专攻嘛~就开发、编译而言，还是它们更全面更强大</p><blockquote><p>Python因为不需要main函数，并且Python只有一种文件类型就是.py，一个.py文件就是一个项目。所以一个界面里也就没有容纳的项目个数之说啦</p><p>PyCharm一个界面就能存在所有的项目</p><p>Python的配置环境就是下载到本地的Python环境，PyCharm用的就是本地的Python环境，因此项目里不用包含环境配置文件（大概</p><p>这应该也是PyCharm一个界面可以同时存在多个项目的原因</p></blockquote><blockquote><p>CLion的Git并不是很讨喜，因为同步的时候一个窗口只能上传一个项目，所以一个项目就会占用一个仓库</p><p>相比之下，PyCharm和VsCode则可以保证一个仓库里面存在多个项目或者文件夹，还是很方便滴～</p></blockquote><p>编译器之类的都是程序猿攻城狮的工具</p><p>当然会用的工具越多越好呀～</p><p>学会在不同的编译环境下敲代码是一件好事～～</p><p>为啥要用好用的编译器，不直接敲命令行？</p><p>因为好用的编译器能提供代码补全、报错、调试、同步到Git等等等等非常好用的功能呀～～</p><p>越专业越好用呀～</p><h5 id="编写C-程序并让它运行的过程"><a href="#编写C-程序并让它运行的过程" class="headerlink" title="编写C++程序并让它运行的过程"></a>编写C++程序并让它运行的过程</h5><blockquote><p>具体步骤根据计算机环境和C++编译器是有区别的，但是都有以下大体的过程（from《C++ Primer Plus 第六版》1.4程序创建的技巧</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210181446645.png" alt="截屏2022-10-18 14.46.17" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210181447632.png" alt="截屏2022-10-18 14.46.10" style="zoom: 20%;" /><h5 id="UNIX下用CC命令行调用cfront编译器实现C-的编译过程"><a href="#UNIX下用CC命令行调用cfront编译器实现C-的编译过程" class="headerlink" title="UNIX下用CC命令行调用cfront编译器实现C++的编译过程"></a>UNIX下用CC命令行调用cfront编译器实现C++的编译过程</h5><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210181449714.png" alt="769b9e7578283e1b368621646ba2f3ae" style="zoom:50%;" /><p>Linux则是用的g++编译器，工作方式跟标准的UNIX编译器相近，此处主要是展示一下编译过程</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_new对象加括号和不加括号的区别</title>
      <link href="/chunyujin/166a8a1f.html"/>
      <url>/chunyujin/166a8a1f.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/a2796749/article/details/46908035">https://blog.csdn.net/a2796749/article/details/46908035</a></p><p>总结起来就是：<br>如果在使用new在堆上开辟某一类型的空间的时候</p><ul><li><p>如果是非自定义类型（int等），后面加括号的话，就以为了进行初始化，如果括号内有参数，就初始化为参数，如果没有参数（就是只有括号，什么都没有），就初始化为0</p></li><li><p>如果是自定义类型（类、结构体），后面加了括号的话，说明调用构造函数（也是初始化）</p><blockquote><p>首先回顾一下关于构造函数的知识：</p><p>构造函数是用来在对象创建的时候对对象进行初始化的</p><p>用户可以自定义构造函数</p><p>构造函数分为带参数的构造函数和不带参数的构造函数</p><p>带参数的构造函数使得每次创建对象的时候可以根据不同的参数对于对象进行不同的初始化</p><p>而众所周知，带参数的函数可以进行<strong>重载</strong>（函数可重名，通过参数的个数和类型进行区分，根据参数个数和类型调用对应的同名函数）<u>所以一个类中可以有多个构造函数</u>（构造函数都是重名的，没有类型，名称跟类名一样）；也可以构造<strong>参数缺省的函数（默认参数的构造函数）</strong></p><p>一个类中可以有多个构造函数，其中不需要输入参数的函数称为默认构造函数</p><p>&#x3D;&#x3D;<strong>默认构造函数一个类中只能有一个</strong>&#x3D;&#x3D;</p><p><strong>显然，无参构造函数是默认构造函数，参数全具有默认参数的函数（全缺省函数）也是默认构造函数，所以两者不能共存</strong></p><blockquote><p>而且有了全缺省的构造函数，就不能存在别的构造函数了（有全缺省构造函数的类不能重载构造函数）</p><p>因为全缺省的构造函数覆盖了任何可能的参数情况，再存在别的构造函数的时候就会产生歧义</p><p>无参：全缺省参数全都是用默认参数</p><p>有部分参数：缺少的参数用默认参数，不缺少的用给定的参数</p><p>含全部参数：全部都用给定的参数</p><p>比如一个含有三个int类成员变量abc的类S，如果定义了一个全缺省构造函数S(int A&#x3D;1,int B&#x3D;1,int C&#x3D;1)</p><p>也定义了一个含两个参数的构造函数S(int A,int B)，那么在定义对象S s(2,2)的时候，就会产生歧义，不知道应该调用哪个构造函数</p></blockquote><blockquote><p>另外也要注意别的可能产生的歧义出现，比如如果定义的是S(int A,int B&#x3D;1,int C&#x3D;1)和S(int A,int B)</p><p>那在定义对象定义对象S s(2,2)的时候，也会产生歧义</p></blockquote><p>如果用户没有自定义出默认构造函数，系统会用系统自己具有的默认构造函数（就叫系统默认构造函数吧）。系统默认构造函数的函数体是空的，不会进行任何操作，也就是说不会真正进行初始化，只是有这么个空函数而已。如果用户自定义了默认构造函数，系统就会用用户自定义的默认构造函数（有的资料称这是过程是系统合成构造函数，就是将用户自定义的构造函数设为默认构造函数）</p></blockquote><p>如果new的对象类型后面加括号的话，分为带参数和不带参数，如果类中用户自定义了带参数的构造函数，就可以在括号里带参数进行初始化；不带参数的话，如果用户自定义了默认构造函数，new创建出的对象就会调用默认构造函数进行初始化，如果用户没有自定义默认构造函数，系统就会调用系统默认构造函数对new出来的对象进行初始化。</p><p>如果不加括号，用户自定义了默认构造函数，new创建对象的时候会调用自定义的默认构造函数；用户没有自定义默认构造函数，new创建的对象就不会初始化</p><p>&#x3D;&#x3D;<strong>总结</strong>：&#x3D;&#x3D;</p><p>加括号一定会进行初始化；</p><p>不加括号，自定义了默认构造函数会初始化，没有就不会初始化</p></li></ul><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210092056231.png" alt="new 对象加括号和不加括号的区别_丿咫尺天涯的博客-CSDN博客"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_delete和free</title>
      <link href="/chunyujin/92cc59a4.html"/>
      <url>/chunyujin/92cc59a4.html</url>
      
        <content type="html"><![CDATA[<p>C++中堆区开辟和释放动态内存多用 new 和delete</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *x=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> *y=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> x;</span><br><span class="line"><span class="keyword">delete</span> []y;</span><br></pre></td></tr></table></figure><p>C中多用 malloc 和 free</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *x=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> *y=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">10</span>);</span><br><span class="line"><span class="built_in">free</span>(x);</span><br><span class="line"><span class="built_in">free</span>(y);</span><br></pre></td></tr></table></figure><p>以上两段代码，除了new的时候可以进行初始化之外，作用都是一样的</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表OJ特别篇</title>
      <link href="/chunyujin/d183517b.html"/>
      <url>/chunyujin/d183517b.html</url>
      
        <content type="html"><![CDATA[<h3 id="数据结构-链表OJ特别篇——环形链表"><a href="#数据结构-链表OJ特别篇——环形链表" class="headerlink" title="数据结构_链表OJ特别篇——环形链表"></a>数据结构_链表OJ特别篇——环形链表</h3><blockquote><p>前言：此类笔记仅用于个人复习，内容主要在于记录和体现个人理解，详细还请结合bite课件、录播、板书和代码。</p></blockquote><hr><p>[toc]</p><hr><p>环形链表有一个非常重要的特点，那就是一旦开始遍历，就无法停止，一直循环，会超出时间限制</p><p>常见的几种形式（圆圈内为存储的数据值）</p> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202207282048823.png" alt="PNG图像" style="zoom: 33%;" /><h4 id="解决这个题的一个比较常规的思路"><a href="#解决这个题的一个比较常规的思路" class="headerlink" title="解决这个题的一个比较常规的思路"></a>解决这个题的一个比较常规的思路</h4><blockquote><p><a href="https://leetcode.cn/problems/linked-list-cycle/description/">题目地址</a></p><p>设置一快一慢两个指针，快的指针每次走2步，慢的每次走1步</p><p>在慢的指针走到环的时候，快的指针早就到了环里了，因此可以看作快的指针跑到了慢的后面（类似于套圈吧</p><p>而且快的指针与慢的指针有差距，由于快的指针每次2步，慢的1步，因此差距在以每次为1的速度削减，直到最后减到0</p><p>此时指针相交</p><p>既然快的指针和慢的指针能相交，就说明了有环，否则快的指针一定先指向NULL，且两者一定不会相遇 </p><pre><code>&lt;img src=&quot;https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20220730201835.png&quot; alt=&quot;QQ截图20220730201835&quot; style=&quot;zoom: 75%;&quot; /&gt;</code></pre>  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20220730215140710.png" alt="image-20220730215140710" style="zoom:80%;" /></blockquote><h4 id="这个题的重点不在于这个题本身，而在于它衍生出来的疑问"><a href="#这个题的重点不在于这个题本身，而在于它衍生出来的疑问" class="headerlink" title="这个题的重点不在于这个题本身，而在于它衍生出来的疑问"></a>这个题的重点不在于这个题本身，而在于它衍生出来的疑问</h4><blockquote><blockquote><ol><li><strong>slow一次走1步，fast一次走3步，fast能追上slow吗？fast一次走4步呢？走n步呢？请证明</strong></li><li><strong>请求出链表环的入口点</strong></li></ol></blockquote><ol><li><strong>slow一次走1步，fast一次走3步，fast能追上slow吗？fast一次走4步呢？走n步呢？请证明</strong></li></ol><p>不一定能追上，特殊情况下可能永远追不上！</p><p>先看fast一次走3步的情况</p> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20220730202009.png" alt="QQ截图20220730202009" style="zoom:80%;" /><p>再看一次走4步和n步的情况 </p> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20220730202009.png" alt="QQ截图20220730202009" style="zoom: 80%;" /><p>因此fast走2步，slow走1步，两者步幅差为1，N和C一定是整数，一定能追上<br>其余情况要看N和C的大小<br>在没给出环的具体长度时， N和C都是不确定的</p><ol start="2"><li><strong>请求出链表环的入口点</strong></li></ol><p><a href="">此处为进阶的题目链接</a></p><p> 假设slow跟fast在meet结点相遇</p><p>【meet】 到 【环入口点】 的距离设为 X</p><p>【链表头】 到 【环入口点】的距离设为 L</p><p>【环】的长度设为 C</p> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/BA954234BAC806EE774153F076F067FC.png" alt="img" style="zoom: 50%;" /><p>根据上面的分析，slow一次走一步，fast一次走两步，那么</p><p>fast走过的路程的slow的2倍</p><p>slow跟fast相遇时，slow一定是处于刚进入环的第一圈</p><blockquote><p>因为二者一定会在距离差为负数（也就是fast跑到slow前面）之前相遇，而fast的速度又比slow快</p></blockquote><p>但是fast不知道已经跑了几圈了，假设fast跑了n圈</p><p>那么slow的路程为 L+X</p><p>fast的路程为 L+X+n*C</p><p>得到等式</p><p>2*(L+X)&#x3D;L+X+n *C</p><p>L+X&#x3D;n*C</p><p>L&#x3D;n*C-X</p><p>L的长度跟n*C-X的长度一样</p><p>也就是说从meet走上n圈再往回退X步，距离跟L一样</p><p>而从meet走上n圈再往回退X步，就是环入口点的位置</p><p>L也是从head到环入口点的距离</p><p>所以得到的结论就是</p><p><strong>如果从head和从meet同时出发，一次走一步，一定会相遇在环入口点</strong></p><p>（这个结论就无关了fast绕圈次数n还有环的长度C、不带环部分的长度L了，因为测试用例不同这些值就不同，但根据公式会得到客观结论）</p><blockquote>  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20220730214711257.png" alt="image-20220730214711257" style="zoom: 80%;" /></blockquote></blockquote><h3 id="链表OJ题库"><a href="#链表OJ题库" class="headerlink" title="链表OJ题库"></a>链表OJ题库</h3><p><a href="https://leetcode.cn/tag/linked-list/problemset/">LeetCode OJ链接</a></p><p><a href="https://www.nowcoder.com/exam/oj">牛客OJ链接</a></p><h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>That’s all, thanks for reading!💐</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调试真的真的十分重要且好用!!!</title>
      <link href="/chunyujin/c1238877.html"/>
      <url>/chunyujin/c1238877.html</url>
      
        <content type="html"><![CDATA[<p>记录一下，今天是2022&#x2F;10&#x2F;4</p><p>有一个问题，我找了半天，结果调试了一下就发现在哪儿出毛病了。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_函数中的数字作为参数时</title>
      <link href="/chunyujin/67b09a09.html"/>
      <url>/chunyujin/67b09a09.html</url>
      
        <content type="html"><![CDATA[<h5 id="x3D-x3D-一般来说-x3D-x3D-，函数中的参数为数字的时候，有三种情况："><a href="#x3D-x3D-一般来说-x3D-x3D-，函数中的参数为数字的时候，有三种情况：" class="headerlink" title="&#x3D;&#x3D;一般来说&#x3D;&#x3D;，函数中的参数为数字的时候，有三种情况："></a>&#x3D;&#x3D;一般来说&#x3D;&#x3D;，函数中的参数为数字的时候，有三种情况：</h5><ol><li>只是作为形参，比如尾插一个数字”1“</li><li><strong>作为”第几个“</strong>，比如一个字符串删除函数DelStr(s1,1,2)中的1，是删除第一个元素（注意，这里并不是权重，1并不是权重是1（这样的话就是指s2的第二个元素了），而是就是单纯地指第1个，<strong>一般在函数中都是单纯地指第几个而不是权重是几</strong></li><li>作为处理元素的个数，比如一个字符串删除函数DelStr(s1,2,3) 中的3，是指删除三个元素</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在模版类里使用自己时可以省略模版参数</title>
      <link href="/chunyujin/e8fa6ce6.html"/>
      <url>/chunyujin/e8fa6ce6.html</url>
      
        <content type="html"><![CDATA[<p>在模版类里使用自己(以及自己类型的指针、引用)可以省略模版参数不写</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211102228794.png" alt="截屏2022-11-10 22.27.03"></p><p>比如这个left 和 right 都是Node类型的指针</p><p>一般情况下，在使用模版类的时候，一定要写上模版参数，就像left的声明</p><p>但是如果是在本类调用自己，可以省略，像right的声明</p><blockquote><p>因为在实例化的时候知道自己的模版参数具体是什么了，都是自己内部的，不用声明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_异常处理</title>
      <link href="/chunyujin/68c7819c.html"/>
      <url>/chunyujin/68c7819c.html</url>
      
        <content type="html"><![CDATA[<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><blockquote><p>前言：此类笔记仅用于个人复习，内容主要在于记录和体现个人理解</p></blockquote><p>[toc]</p><h4 id="什么是异常处理"><a href="#什么是异常处理" class="headerlink" title="什么是异常处理"></a>什么是异常处理</h4><blockquote><p>在程序中可能会出现各种各样的异常，比如出现了错误，常见错误主要分为语法错误和编译错误，有的错误编译器是可以检查出来的，有的错误编译器检查不出来，；又比如违背正常情况，比如要求输入小写字母，但是实际输入大写的或者数字等，这种错误编译器一般不会检查出来。</p><p>在设计程序之前，应当分析各种可能出现的异常情况，并设定相应的识别、处理方式，这就是异常处理的任务</p><p>比如如果某个数除以0，这就是一个异常，要根据除数为0的这种异常情况进行一个判断和处理（比如报错并结束程序）</p><p>当然，也可以通过断言等方式来处理一些错误，当assert中的判别式结果为false的时候，就直接异常退出程序</p></blockquote><h4 id="C-中如何实现异常处理"><a href="#C-中如何实现异常处理" class="headerlink" title="C++中如何实现异常处理"></a>C++中如何实现异常处理</h4><p>C++的异常处理机制是由三个部分组成的：检查（try）、抛出（throw）、捕捉（catch）</p><p>“异常情况“是设计者人为认定判定的：如果想要检查一段代码，在这个代码段里面出现了我们不想要的异常情况，就需要抛出”这是一个异常情况“的信号，然后由相应的捕捉代码进行捕捉，一旦捕捉到抛出的异常，就会进入到用来处理这个异常的代码。</p><p>跟assert相比，异常处理机制显然更为温和，不会直接断死代码直接退出程序</p><h5 id="throw语句"><a href="#throw语句" class="headerlink" title="throw语句"></a>throw语句</h5><blockquote><p>形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> 表达式</span><br></pre></td></tr></table></figure><p>throw关键字抛出的表达式是什么样的数据由设计者自己定，可以是常规的变量，也可以是一串字符，也可以是自定义的变量</p><p>throw的关键在于表达式的结果的类型，而不是表达式的具体的值，但还是会将表达式作为“异常信号&#x2F;信息”（异常）整个抛出去，包括值</p><blockquote><p>一旦throw抛出异常，就会在进行异常处理之后，立即跳出throw所在的函数，回到上一级函数（比如main函数）</p></blockquote></blockquote><h5 id="try-catch结构"><a href="#try-catch结构" class="headerlink" title="try-catch结构"></a>try-catch结构</h5><blockquote><p>try关键字负责划定需要检查的代码区域，在区域内的代码段会接受检查，try和被检查的代码段被合称为try块</p><p>catch关键字用于接收throw抛出的异常，并针对异常进行相应处理，catch和被检查的代码段被合称为catch块</p><p>形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">被检查的代码段</span><br><span class="line">&#125;<span class="built_in">catch</span>(异常信息类型 变量名·一般情况下不写变量名·)&#123;</span><br><span class="line">处理异常的代码段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意</p><blockquote><ol><li>如果throw的表达式是类的话，可以不用单独实例化出一个对象，直接使用匿名对象，因为有的时候会定义一些空类来专门作为异常信息用，没必要为了异常信息实例化一个对象</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">outofsize</span>&#123;&#125;；<span class="comment">//这是一个空类，专门用来当异常信息的</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">outofsize</span>();<span class="comment">//使用的outofsize的匿名对象，格式是&quot;类名&quot;+&quot;()&quot;,其中()里面为初始化参数，跟正常类的定义不同，匿名对象再没有初始化参数的时候也要跟()</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="built_in">catch</span>(outofsize)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>被检查的代码段必须放在try里，否则不起作用</p></li><li><p>try-catch结构是一个整体，catch块必须紧跟try块，catch不能脱离try单独使用，且两者之间不能夹杂其他语句；但是try块是可以单独使用的，即只检查不处理，catch块在另一个函数里面</p></li><li><p>花括号不能省略</p></li><li><p>由于一段代码中可能存在多种错误情况，所以允许一个try块后面接多个catch块，以便匹配不同的异常信息</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="built_in">catch</span>()</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="built_in">catch</span>()</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">//以上省略了内容，主要体现结构</span></span><br></pre></td></tr></table></figure><ol start="6"><li>catch也只检查异常信息的类型，而不检查异常信息的值，根据异常信息的类型匹配相应的catch块，无论doule类型的值是多少，都只会匹配catch(double)；所以一般的catch写法括号内只有异常信息类型</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span>( <span class="type">double</span> )</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里发现，在函数的定义的时候也可以只写类型，不写变量，因为参数从左到右依次传入函数  </p></blockquote><p>​catch括号内还有另一种写法，即除了指定类型之外还指定变量名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span>(<span class="type">double</span> d)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这样catch在捕捉异常信息的时候，除了捕捉变量类型，还会捕捉变量的值，这样就可以在catch中使用这个值（当然，是拷贝的）</p><ol start="7"><li><p>如果catch括号内没有写变量类型，而是写了catch(…)，这表示这个catch块可以接受任何类型的异常信息</p></li><li><p>throw语句和try-catch块在同一个函数中，也可以不在同一个函数中。throw抛出异常信息之后，会先在本函数内让catch捕捉，如果本函数没有try-catch或者没有可以匹配的catch，则跳出本函数到上一个函数，直到找到最近的可匹配的catch</p></li><li><p>某些情况下，throw后面可以不加表达式，比如如果在catch块里有throw，则catch里的throw会将catch捕捉到的catch外的throw抛出的异常原样抛出，表示“本级函数的catch不处理这个异常，给上一级的catch块处理”</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span>(<span class="type">int</span>)</span><br><span class="line">&#123;<span class="comment">//其他语句</span></span><br><span class="line">    <span class="keyword">throw</span>;<span class="comment">//将以捕获的异常信息再次原样抛出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="10"><li>如果throw抛出的异常到最后都没有catch与之匹配，系统会调用一个系统函数terminate终止程序进行</li></ol></blockquote></blockquote><h4 id="几个例子"><a href="#几个例子" class="headerlink" title="几个例子"></a>几个例子</h4><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">triangle</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>,<span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">double</span> a,b,c;</span><br><span class="line">     cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">     <span class="keyword">try</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">while</span>(a&gt;<span class="number">0</span>&amp;&amp;b&gt;<span class="number">0</span>&amp;&amp;a&gt;<span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             cout&lt;&lt;<span class="built_in">triangle</span>(a,b,c)&lt;&lt;endl;<span class="comment">//try里包含了要被检查的函数</span></span><br><span class="line">             cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="built_in">catch</span>(<span class="type">double</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;,c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;,that is not a triangle&quot;</span> &lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">     cout&lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt;endl;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">triangle</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b,<span class="type">double</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">double</span> s = ( a+b+c )/<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">if</span>( a + b &lt;= c || b + c &lt;= a || a + c &lt;= b )</span><br><span class="line">         <span class="keyword">throw</span> a;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">sqrt</span>( s + (s-a) * (s-b) * (s-c) );<span class="comment">//如果在上面的throw中抛出了异常信息，则直接跳到上一级函数，这一行代码就不会生效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;<span class="comment">//表达式的类型本质是上是字符串，也就是char指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">  z = <span class="built_in">division</span>(x, y);</span><br><span class="line">  cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">&#125;<span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) <span class="comment">//既有变量类型又有变量名，就可以在下面使用捕捉到的异常信息</span></span><br><span class="line">&#123;</span><br><span class="line">  cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">outOfSize</span> &#123;&#125;;<span class="comment">//这里定义了一个空outOfSize类，只用作异常信号，不用与其他作用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">illegalType</span> &#123;&#125;;<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addWord</span><span class="params">(<span class="type">int</span>&amp;, <span class="type">char</span>*, <span class="type">char</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a[SIZE];</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Please keyonte a~z&quot;</span>&lt;&lt;endl;</span><br><span class="line">            cin &gt;&gt; b;</span><br><span class="line">            <span class="built_in">addWord</span>(x, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (outOfSize)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Outofsize!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (illegalType)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;IllegalType!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addWord</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">char</span>* a, <span class="type">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= SIZE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">outOfSize</span>();<span class="comment">//抛出的是outOfSize类的匿名对象</span></span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="string">&#x27;a&#x27;</span> || b&gt;<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">illegalType</span>();</span><br><span class="line">    a[x] = b;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>That’s all, thanks for reading!💐</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_cin&amp;cout</title>
      <link href="/chunyujin/d0ce2bfa.html"/>
      <url>/chunyujin/d0ce2bfa.html</url>
      
        <content type="html"><![CDATA[<h4 id="C-cin、cout怎么写"><a href="#C-cin、cout怎么写" class="headerlink" title="C++_cin、cout怎么写"></a>C++_cin、cout怎么写</h4><p>cout是输出流，变量a进入（输入）到输出流才能输出到屏幕，就是cout&lt;&lt;a</p><p>cin是输入流，让键盘上输入流进入（输入）到变量a才能给a赋上值，也就是cin&gt;&gt;a</p><p>另外，比如这个sstringstream类，是用来将string类转化成别的数据类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">stringToInt</span><span class="params">(string s)</span> <span class="comment">//将操作数字符串转变成int</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ss &lt;&lt; s;</span><br><span class="line">    ss &gt;&gt; i;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要将这个string类s输入入到stringstream类ss中，然后将转化结果从ss输入到i中</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_vs2022DeBug Error</title>
      <link href="/chunyujin/3bb17c40.html"/>
      <url>/chunyujin/3bb17c40.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/MIV5KC1_8NWP%7DDPB%7BUV%60QPC.png" alt="img"></p><p>这是由于从堆中释放空间内存之后，没有申请开辟，却又对那块空间执行了操作（包括再次释放</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>副本</title>
      <link href="/chunyujin/f14e76e5.html"/>
      <url>/chunyujin/f14e76e5.html</url>
      
        <content type="html"><![CDATA[<h4 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h4><p>副本这个词用得好啊</p><p>比如函数的形参就是实参的副本</p><p>副本就是拷贝出来的值</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于vs2022&amp;头文件和源文件的区别</title>
      <link href="/chunyujin/7c16d58.html"/>
      <url>/chunyujin/7c16d58.html</url>
      
        <content type="html"><![CDATA[<ol><li>关于vs2022</li></ol><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20220910100800098.png" alt="image-20220910100800098"  /><ol start="2"><li>头文件和源文件的区别</li></ol><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20220910101245438.png" alt="image-20220910101245438"></p><p>头文件用于函数、自定义类型声明，源文件用于定义、实现</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优秀代码的五大特性&amp;什么是封装</title>
      <link href="/chunyujin/4793f752.html"/>
      <url>/chunyujin/4793f752.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h5 id="优秀代码的五大特性"><a href="#优秀代码的五大特性" class="headerlink" title="优秀代码的五大特性"></a>优秀代码的五大特性</h5><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20220915194347910.png" alt="image-20220915194347910"></p><h5 id="什么是封装（封装的简介"><a href="#什么是封装（封装的简介" class="headerlink" title="什么是封装（封装的简介"></a>什么是封装（封装的简介</h5><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20220915195400299.png" alt="image-20220915195400299"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 能力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类和结构体的区别</title>
      <link href="/chunyujin/c4e745c8.html"/>
      <url>/chunyujin/c4e745c8.html</url>
      
        <content type="html"><![CDATA[<ol><li><p>C中的结构体不允许存在成员函数和this指针</p></li><li><p>C++中结构体和类的唯一区别就是结构体默认成员是公有的，类默认是私有的</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_delete</title>
      <link href="/chunyujin/6cf2f2d1.html"/>
      <url>/chunyujin/6cf2f2d1.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20220911105630568.png" alt="image-20220911105630568"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VsCode快捷键&amp;使用技巧</title>
      <link href="/chunyujin/d25e6d9b.html"/>
      <url>/chunyujin/d25e6d9b.html</url>
      
        <content type="html"><![CDATA[<h4 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h4><p>⌃ + ⌥ + N</p><p>ctrl + alt + N</p><h4 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h4><p>⌥ + ⇧ + F</p><p>alt + shift + F</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202209121909898.png" alt="截屏2022-09-12 18.49.36" style="zoom: 33%;" /><h4 id="批量更改变量、函数名称"><a href="#批量更改变量、函数名称" class="headerlink" title="批量更改变量、函数名称"></a>批量更改变量、函数名称</h4><p>光标选中名称</p><p>⌘ + ⇧ + L</p><p>ctrl + shift + L</p><h4 id="深浅模式跟随系统"><a href="#深浅模式跟随系统" class="headerlink" title="深浅模式跟随系统"></a>深浅模式跟随系统</h4><p>设置中搜索</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301071256453.png" alt="截屏2023-01-07 12.54.53"></p><h4 id="这个主题很酷"><a href="#这个主题很酷" class="headerlink" title="这个主题很酷"></a>这个主题很酷</h4><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301112322122.png" alt="截屏2023-01-11 23.22.02"></p><h4 id="切换终端、调试等快捷键"><a href="#切换终端、调试等快捷键" class="headerlink" title="切换终端、调试等快捷键"></a>切换终端、调试等快捷键</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301131836303.png" alt="截屏2023-01-13 18.36.01" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> IDE </category>
          
          <category> VsCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VsCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于vscode下使用终端进入vim看不到光标的问题</title>
      <link href="/chunyujin/f07d859c.html"/>
      <url>/chunyujin/f07d859c.html</url>
      
        <content type="html"><![CDATA[<p>关于vscode下使用终端进入vim时光标看不到光标的问题</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301091550584.png" alt="截屏2023-01-09 15.50.16" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301091550854.png" alt="截屏2023-01-09 15.49.55" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301091550988.png" alt="截屏2023-01-09 15.50.09" style="zoom:50%;" /><p>很大概率是vscode的主题配置导致的，默认的白色主题下看不到光标（如上）</p><p>换成默认的黑色主题之后就可以看到了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301091552533.png" alt="截屏2023-01-09 15.50.31" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> IDE </category>
          
          <category> VsCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VsCode </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
