<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浴巾的贼船</title>
  <icon>https://www.gravatar.com/avatar/4693869db7cae9524536dea3133cf541</icon>
  
  <link href="https://chunyujin.top/atom.xml" rel="self"/>
  
  <link href="https://chunyujin.top/"/>
  <updated>2024-10-22T07:03:25.544Z</updated>
  <id>https://chunyujin.top/</id>
  
  <author>
    <name>浴巾</name>
    <email>3029795434@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++11-智能指针</title>
    <link href="https://chunyujin.top/chunyujin/15763eb7.html"/>
    <id>https://chunyujin.top/chunyujin/15763eb7.html</id>
    <published>2024-10-22T07:03:00.000Z</published>
    <updated>2024-10-22T07:03:25.544Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内存安全-部分内容"><a href="#内存安全-部分内容" class="headerlink" title="内存安全(部分内容)"></a>内存安全(部分内容)</h4><h5 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h5><p>在内存中申请了空间，但是并没有在合适的时机释放它，就会造成内存泄露。</p><p>内存泄露本质上就是对内存的使用“只增不减”，内存的可用空间一点点减少、泄露出去，像是一个只漏水但是不进水的杯子。</p><p><strong>在内存中申请空间之后，并不会自动释放掉这块内存，内存的释放分两种情况：</strong></p><ol><li><u>开发者使用<code>delete</code>或<code>析构函数</code>进行手动释放。</u>(通常，内置类型delete，自定义类型使用析构。对自定义类型使用delete，也是会调用其析构函数)</li><li><u>程序结束后操作系统自动释放。</u><br>值得注意的是，等待程序结束后由操作系统自动释放，其实已经无关”安全”了，因为操作系统并不关系程序运行时内存究竟是如何分配的，它要做的就是在程序结束后将所有内存全部收回。</li></ol><p><strong>内存有必要手动释放吗？为什么不能等待操作系统自动回收呢？</strong></p><p>考虑一下边界&#x2F;极端情况：<br>使用工厂模式生产对象时，如果工厂一直生产对象，但是并不释放已使用完毕的对象，会造成内存的不断泄露。</p><p><mark>内存泄露的危害</mark></p><p>  <strong>1、频繁GC</strong>：系统分配给每个应用的内存资源都是有限的，内存泄漏导致其他组件可用的内存变少后，一方面会使得GC的频率加剧，再发生GC的时候，所有进程都必须等待，GC的频率越高，用户越容易感应到卡顿。另一方面内存变少，可能使得系统额外分配给该对象一些内存，而影响整个系统的运行情况。</p><p>  <strong>2、导致程序运行崩溃</strong>：一旦内存不足以为某些对象分配所需要的空间，将会导致程序崩溃，造成体验差。</p><h5 id="数组越界、指针越界、野指针"><a href="#数组越界、指针越界、野指针" class="headerlink" title="数组越界、指针越界、野指针"></a>数组越界、指针越界、野指针</h5><p><strong>数组越界、指针越界、野指针</strong>的原理与现象是比较类似的：</p><p>访问到了操作系统并未开辟的内存空间(一说“垃圾内存”)。</p><blockquote><p> 在初始化变量、申请内存空间的时候，操作系统除了将数据写入对应的内存，还有一个行为，就是设置该内存块的访问权限。</p></blockquote><p><mark>危害</mark></p><p>访问未分配访问权限的内存本身就是违法的，该内存中保存的数据又是未知的，因此这种情况下，根本不知道内存情况，是一种极其危险的状态。</p><p><strong>数组越界：</strong></p><blockquote><p>对于数组的访问，超过了其变量范围。<br>如通过下标访问时，下标超过了数组设定的大小；++或–操作时，超过了数组的最大、最小范围。</p></blockquote><p><strong>指针越界：</strong></p><blockquote><p>指针指向了超出其变量的作用范围。<br>如：</p><p>父类指针指向子类对象时，访问子类新增成员或方法或访问重写的方法(不允许，但是是否是由于指针越界引起，存疑)(只允许静态联翩)。</p><p>且对于子类重写了的方法的调用，会根据指针类型来判断，父类指针指向子类对象，调用的还是父类指针的成员函数实现方法，而非子类重写之后的方法。</p><p>解决方法：</p><ol><li>强制类型转换(可能失败，且不安全) </li><li>动态转换，dynamic_cast（安全）</li><li>对于访问重写的方法，可以提前设置为虚函数，此时执行的是重写后的。</li></ol></blockquote><p><strong>野指针：</strong></p><blockquote><p>指向了没有访问权限的内存的指针。通常见于：delete一块空间之后，指向该空间的指针没有置空，该指针就成为了野指针。</p></blockquote><p><mark>为了避免以上现象，程序员需要养成良好的编程习惯。</mark></p><h4 id="C-11智能指针"><a href="#C-11智能指针" class="headerlink" title="C++11智能指针"></a>C++11智能指针</h4><p>为了解决上述 因为申请内存空间而可能造成的<mark>内存泄露</mark>、<mark>野指针</mark>等问题，C++11新特性中，智能指针应运而生。</p><blockquote><p>智能指针对于内存的管理，是利用对象的生命周期进行的。</p><p>当智能指针离开作用域时，会自动正确地销毁动态分配的内存对象，防止出现内存泄露。</p></blockquote><h5 id="C-库中的智能指针"><a href="#C-库中的智能指针" class="headerlink" title="C++库中的智能指针"></a>C++库中的智能指针</h5><blockquote><p>头文件<code>#include &lt;memory&gt;</code></p></blockquote><h6 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h6><p>独占式指针，同一时刻只能有一个指针指向同一个对象。因此不允许unique_ptr之间进行拷贝，只能通过转移构造函数进行转移。</p><p>使用该指针管理独占性资源</p><blockquote><p>常用方法介绍：</p><ol><li><p><code>unique_ptr::get()</code> 获取其保存的原生指针，尽量不要使用</p></li><li><p><code>unique_ptr::bool()</code> 判断是否拥有指针</p></li><li><p><code>unique_ptr::release()</code> 释放所管理指针的所有权，返回原生指针。但并不销毁原生指针。通常用来初始化另一个智能指针。</p></li><li><p><code>unique_ptr::reset()</code> 释放并销毁原生指针。如果参数为一个新指针，将管理这个新指针。</p></li><li><p><code>unique_ptr::swap()</code>交换两个智能指针所指向的对象</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;A&gt; <span class="title">a1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">A *origin_a = a1.<span class="built_in">get</span>();<span class="comment">//错误示例：尽量不要暴露原生指针</span></span><br><span class="line"><span class="keyword">if</span>(a1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// a1 拥有指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;A&gt; <span class="title">a2</span><span class="params">(a1.release())</span></span>;<span class="comment">//常见用法，转义拥有权</span></span><br><span class="line">a2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">A</span>());<span class="comment">//释放并销毁原有对象，持有一个新对象</span></span><br><span class="line">a2.<span class="built_in">reset</span>();<span class="comment">//释放并销毁原有对象，等同于下面的写法</span></span><br><span class="line">a2 = <span class="literal">nullptr</span>;<span class="comment">//释放并销毁原有对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>初始化方法：</p><ol><li>直接初始化：<code>unique&lt;T&gt; myPtr(new T);</code> 可以， 但<strong>不能通过隐式转换来构造</strong>，如<code>unique&lt;T&gt; myPtr = new T()</code> 因为unique_ptr构造函数被声明为explicit。</li><li>移动构造：<code>unique&lt;T&gt; myOtherPtr = std::move(myPtr);</code> 但不允许复制构造，如<code>unique&lt;T&gt; myOther = myPtr</code>; 因为unique是个只移动类型。只允许承接，不允许复制。(只能通过右值引用的方式交接管理权，不能进行拷贝)</li><li>通过 <code>make_unique</code> 构造：<code>unique&lt;T&gt; myPtr = std::make_unique&lt;T&gt;();</code> &#x2F;&#x2F;C++14支持的语法。但是 make 都<strong>不支持添加删除器，或者初始化列表</strong>。</li><li>通过reset重置：如 <code>std::unique_ptr up; up.reset(new T())</code>;</li></ol></blockquote><h6 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h6><p>共享式指针，同一时刻可以有多个指针指向同一个对象</p><p><code>std::shared_ptr</code> 共同确保对象在不被需要时被销毁， 没有哪个特定的 <code>std::shared_ptr</code> 拥有该对象， 它的实现机制是引用计数，内部包含一个指向资源的裸指针，另一个指向该资源的引用计数 （控制块）的裸指针。</p><p>使用该指针管理共享型资源</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;A&gt; <span class="title">a1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">std::shared_ptr&lt;A&gt; a2 = a1;<span class="comment">//编译正常，允许所有权的共享</span></span><br></pre></td></tr></table></figure><blockquote><p>常用方法介绍：</p><ol><li><code>shared_ptr::get()</code>获取其保存的原生指针，尽量不要使用</li><li><code>shared_ptr::bool()</code> 判断是否拥有指针</li><li><code>shared_ptr::reset()</code> 释放并销毁原生指针。如果参数为一个新指针，将管理这个新指针</li><li><code>shared_ptr::unique()</code> 如果引用计数为 1，则返回 true，否则返回 false</li><li><code>shared_ptr::use_count()</code> 返回引用计数的大小</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;A&gt; <span class="title">a1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">std::shared_ptr&lt;A&gt; a2 = a1;<span class="comment">//编译正常，允许所有权的共享</span></span><br><span class="line"></span><br><span class="line">A *origin_a = a1.<span class="built_in">get</span>();<span class="comment">//错误示范：尽量不要暴露原生指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// a1 拥有指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a1.<span class="built_in">unique</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果返回true，引用计数为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> a1_use_count = a1.<span class="built_in">use_count</span>();<span class="comment">//引用计数数量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用<code>shared_ptr</code>可能会带来的问题：<mark>互相引用时会造成死锁，最终导致内存泄露</mark></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">A</span>()</span><br><span class="line">     &#123;</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ~<span class="built_in">A</span>()</span><br><span class="line">     &#123;</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">setB</span><span class="params">(std::shared_ptr&lt;B&gt; sp)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>-&gt;sp = sp;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     std::shared_ptr&lt;B&gt; sp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">B</span>()</span><br><span class="line">     &#123;</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ~<span class="built_in">B</span>()</span><br><span class="line">     &#123;</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">setA</span><span class="params">(std::shared_ptr&lt;A&gt; sp)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>-&gt;sp = sp;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     std::shared_ptr&lt;A&gt; sp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">std::shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line"> std::shared_ptr&lt;B&gt; pb = std::<span class="built_in">make_shared</span>&lt;B&gt;(); <span class="comment">//两种智能指针的创建方式</span></span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;pa count:&quot;</span> &lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;pb count:&quot;</span> &lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"> pa.<span class="built_in">reset</span>();</span><br><span class="line"> pb.<span class="built_in">reset</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241021151052851.png" alt="image-20241021151052851" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241021145916509.png" alt="image-20241021145916509" style="zoom:80%;" /><p>使用setA、setB设定好互相引用之后：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241021150011885.png" alt="image-20241021150011885" style="zoom:80%;" /><p>手动释放或者等待智能指针自动释放的时候，出对象A、B作用域之后，pa、pb执行释放，但是count的值为2，因此只能先断掉pa、pb并置空，并不会释放掉A、B的内存</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241021151136660.png" alt="image-20241021151136660" style="zoom:80%;" /><p>而失去了对于A、B的连接，直到程序结束前，都无法通过地址找到A、B了，内存泄露</p></blockquote></blockquote><h6 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h6><p>用来解决shared_ptr相互引用导致的死锁问题</p><blockquote><p>weak_ptr是一个弱指针，它是与shared_ptr配合使用的。</p><p>所谓弱指针，主要体现在，当使用weak_ptr指向一个对象时，并不会增加该对象的引用计数，同样的，weak_ptr无法直接调用原生指针的方法，必须将其转化为一个shared_ptr才可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;A&gt; <span class="title">a1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">std::weak_ptr&lt;A&gt; weak_a1 = a1;<span class="comment">//不增加引用计数</span></span><br></pre></td></tr></table></figure><p>weak_ptr最大的意义就在于解决了shared_ptr在相互引用时内存泄露的问题。</p><p>将循环引用的一方改为weak_ptr，解决内存泄露。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改上述代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">setB</span><span class="params">(std::weak_ptr&lt;B&gt; sp)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>-&gt;sp = sp;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     std::weak_ptr&lt;B&gt; sp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">setA</span><span class="params">(std::weak_ptr&lt;A&gt; sp)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>-&gt;sp = sp;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     std::weak_ptr&lt;A&gt; sp;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241021153601781.png" alt="image-20241021153601781" style="zoom:80%;" /></blockquote><h6 id="智能指针是如何避免野指针问题的？"><a href="#智能指针是如何避免野指针问题的？" class="headerlink" title="智能指针是如何避免野指针问题的？"></a><mark>智能指针是如何避免野指针问题的？</mark></h6><blockquote><p>首先，智能指针本身就是一个”智能“指针了，不需要用户去手动释放(delete)，而置空是delete的后续操作，因此从根本上来说，智能指针就不需要置空。没有前提，哪儿来的后续？</p><p>其次，如果想要手动主动释放智能指针，可以调用<code>reset()</code>方法，当参数为空时，认定为释放原内存，并将智能指针置空；如果参数为一个新的内存，则释放原内存，并接管新的内存。或者直接给智能指针置空，这一行为默认释放原内存、置空智能指针。</p></blockquote><h4 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h4><p>此处为之前做的一些笔记，关于智能指针的前置内容</p><blockquote><p><strong>当在堆内存中new出一块空间时：</strong></p><blockquote><ol><li>操作系统会在堆内存中申请一块空间，并将其设置为可用</li><li>在栈空间创建一个指针变量，承接堆内存申请的这块空间的地址</li></ol></blockquote><p><strong>当手动delete该空间时：</strong></p><blockquote><ol><li>操作系统会将该内存释放掉，本质上就是将使用权限回收，将该区域设置为不可用</li><li>此时，之前的指针指向的这块空间就是不可用的了，指针指向了一块不可用的指针，成为”野指针”</li><li>因此在delete之后，需要手动将指针置空，防止出现野指针。</li></ol></blockquote><p>当在堆内存开辟空间之后，只要不进行手动释放(delete)，内存一直会被占用，直到程序结束，释放所有空间。</p><blockquote><p>手动释放与程序结束自动释放存在区别：</p><p>自动释放：程序结束时，操作系统并不关心程序运行时到底进行了怎样的内存分配，要做的只是将所有的内存全部回收。</p><p>手动释放：在程序运行时，为了更合理利用内存空间(内存空间是有限的)，需要手动释放掉一些已创建但使用完毕、后续不会使用的内存。</p></blockquote><p>通常来看，只要能确保内存不会溢出，就算不进行手动释放(delete)，等待程序结束时，让操作系统自动释放程序内存，也是可以的吧？</p><p>可以，但是存在很大的安全隐患！</p><p>此前我们学习了“工厂模式”，简单来讲就是一个不断生产各种对象的工厂结构。<br>当这种工厂运作起来的时候，可能会源源不断生成对象，如果这个过程中，只进行new新空间，而不delete就空间，那么内存很快就会爆满，等不到程序正常退出，内存就已经溢出了。</p><p>没有delete，你可能是忘了，也可能是故意的，但是结构就是内存溢出。</p><p>就算没有溢出，也会占用大量的内存资源，从而引发其他可能的问题。</p><p>所以为了杜绝以上现象，程序员必须：有new就有delete。</p><blockquote><p>然而，delete了也不一定就确保了安全了：</p><ol><li>delete之后要记得将指针置空。</li><li>可能存在多个指向同一内存的指针，在某个指针delete之后，其余指针都变成野指针了，但是程序员可能不知道，在其他的地方使用其余指针进行了delete：delete的前提是需要用指针访问到想要销毁的内存空间，因此通过野指针访问未授权的空间，本身就是非法行为，程序直接就会崩溃。</li></ol><blockquote><p>问题出现在野指针，delete行为本身是正常的，比如多次delete一个空指针，是不会报错的。</p></blockquote></blockquote><p>智能指针主要解决的问题就是内存泄漏相关</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;内存安全-部分内容&quot;&gt;&lt;a href=&quot;#内存安全-部分内容&quot; class=&quot;headerlink&quot; title=&quot;内存安全(部分内容)&quot;&gt;&lt;/a&gt;内存安全(部分内容)&lt;/h4&gt;&lt;h5 id=&quot;内存泄露&quot;&gt;&lt;a href=&quot;#内存泄露&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Cpp" scheme="https://chunyujin.top/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://chunyujin.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++_迭代器&amp;范围for的本质</title>
    <link href="https://chunyujin.top/chunyujin/874d4093.html"/>
    <id>https://chunyujin.top/chunyujin/874d4093.html</id>
    <published>2024-10-14T05:27:00.000Z</published>
    <updated>2024-10-22T07:34:35.313Z</updated>
    
    <content type="html"><![CDATA[<h3 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器(iterator)"></a><a href="http://c.biancheng.net/view/338.html">迭代器(iterator)</a></h3><h4 id="什么是迭代器"><a href="#什么是迭代器" class="headerlink" title="什么是迭代器"></a>什么是迭代器</h4><p>迭代器与容器的关系，相当于指针与数组的关系</p><p>因为容器是封装起来的，不知道内部是如何实现的，所以通过在内存中的地址的原理访问和遍历容器，一般来说是不实际的</p><p>要访问容器(顺序容器、关联容器)中的元素，就需要通过迭代器进行；就如同访问数组中的元素需要通过指针进行一样</p><p>用迭代器访问元素的操作也和用指针访问数组的操作很像</p><p>迭代器按照定义方式分成以下四种</p><blockquote><ol><li><p>正向迭代器，定义方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容器类名::iterator 迭代器名;</span><br></pre></td></tr></table></figure></li><li><p>常量正向迭代器，定义方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容器类名::const_iterator 迭代器名;</span><br></pre></td></tr></table></figure></li><li><p>反向迭代器，定义方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容器类名::reverse_iterator 迭代器名;</span><br></pre></td></tr></table></figure></li><li><p>常量反向迭代器，定义方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容器类名::const_reverse_iterator 迭代器名;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="迭代器用法示例"><a href="#迭代器用法示例" class="headerlink" title="迭代器用法示例"></a>迭代器用法示例</h4><p>通过迭代器可以读取它指向的元素，<code>*迭代器名</code>就表示迭代器指向的元素。通过非常量迭代器还能修改其指向的元素。</p><p>迭代器都可以进行<code>++</code>操作。反向迭代器和正向迭代器的区别在于：</p><ul><li>对正向迭代器进行<code>++</code>操作时，迭代器会指向容器中的后一个元素；</li><li>而对反向迭代器进行<code>++</code>操作时，迭代器会指向容器中的前一个元素。</li></ul><p>下面的程序演示了如何通过迭代器<mark>遍历一个 vector 容器</mark>中的所有元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;  <span class="comment">//v是存放int类型变量的可变长数组，开始时没有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n&lt;<span class="number">5</span>; ++n)</span><br><span class="line">        v.<span class="built_in">push_back</span>(n);  <span class="comment">//push_back成员函数在vector容器尾部添加一个元素</span></span><br><span class="line">  </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator i;  <span class="comment">//定义正向迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i) <span class="comment">//用迭代器遍历容器</span></span><br><span class="line">    &#123;  </span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//*i 就是迭代器i指向的元素</span></span><br><span class="line">        *i *= <span class="number">2</span>;  <span class="comment">//每个元素变为原来的2倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//用反向迭代器遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::reverse_iterator j = v.<span class="built_in">rbegin</span>(); j != v.<span class="built_in">rend</span>(); ++j)</span><br><span class="line">        cout &lt;&lt; *j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>程序的输出结果是：<br>0 1 2 3 4<br>8 6 4 2 0</p><p>第 6 行，vector 容器有多个构造函数，如果用无参构造函数初始化，则容器一开始是空的。</p><p>第 10 行，begin 成员函数返回指向容器中第一个元素的迭代器。++i 使得 i 指向容器中的下一个元素。end 成员函数返回的不是指向最后一个元素的迭代器，而是指向最后一个元素后面的位置的迭代器，因此循环的终止条件是<code>i != v.end()</code>。</p><p>第 16 行定义了反向迭代器用以遍历容器。反向迭代器进行<code>++</code>操作后，会指向容器中的上一个元素。rbegin 成员函数返回指向容器中最后一个元素的迭代器，rend 成员函数返回指向容器中第一个元素前面的位置的迭代器，因此本循环实际上是从后往前遍历整个数组。</p><p>如果迭代器指向了容器中最后一个元素的后面或第一个元素的前面，再通过该迭代器访问元素，就有可能导致程序崩溃，这和访问 NULL 或未初始化的指针指向的地方类似。</p><p>第 10 行和第 16 行，写<code>++i</code>、<code>++j</code>相比于写<code>i++</code>、<code>j++</code>，程序的执行速度更快。</p><p>回顾<code>++</code>被重载成前置和后置运算符的例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CDemo CDemo::<span class="keyword">operator</span>++ ()</span><br><span class="line">&#123;  <span class="comment">//前置++</span></span><br><span class="line">    ++n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">CDemo CDemo::<span class="keyword">operator</span> ++(<span class="type">int</span> k)</span><br><span class="line">&#123;  <span class="comment">//后置++</span></span><br><span class="line">    <span class="function">CDemo <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;  <span class="comment">//记录修改前的对象</span></span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span> tmp;  <span class="comment">//返回修改前的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后置<code>++</code>要多生成一个局部对象 tmp，因此执行速度比前置的慢。同理，迭代器是一个对象，<a href="http://c.biancheng.net/stl/">STL</a> 在重载迭代器的<code>++</code>运算符时，后置形式也比前置形式慢。在次数很多的循环中，<code>++i</code>和<code>i++</code>可能就会造成运行时间上可观的差别了。因此，本教程在前面特别提到，对循环控制变量i，要养成写<code>++i</code>、不写<code>i++</code>的习惯。</p></blockquote><p>注意，容器适配器 stack、queue 和 priority_queue 没有迭代器。容器适配器有一些成员函数，可以用来对元素进行访问。</p><h4 id="迭代器的功能分类"><a href="#迭代器的功能分类" class="headerlink" title="迭代器的功能分类"></a>迭代器的功能分类</h4><p>不同容器的迭代器，其功能强弱有所不同。容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。例如，排序算法需要通过随机访问迭代器来访问容器中的元素，因此有的容器就不支持排序算法。</p><p>常用的迭代器按功能强弱分为输入、输出、正向、双向、随机访问五种，这里只介绍常用的三种。</p><blockquote><ol><li><p>正向迭代器。假设 p 是一个正向迭代器，则 p 支持以下操作：++p，p++，*p。此外，两个正向迭代器可以互相赋值，还可以用<code>==</code>和<code>!=</code>运算符进行比较。</p></li><li><p>双向迭代器。双向迭代器具有正向迭代器的全部功能。除此之外，若 p 是一个双向迭代器，则<code>--p</code>和<code>p--</code>都是有定义的。<code>--p</code>使得 p 朝和<code>++p</code>相反的方向移动。</p></li><li><p>随机访问迭代器。随机访问迭代器具有双向迭代器的全部功能。若 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p></li></ol><ul><li>p+&#x3D;i：使得 p 往后移动 i 个元素。</li><li>p-&#x3D;i：使得 p 往前移动 i 个元素。</li><li>p+i：返回 p 后面第 i 个元素的迭代器。</li><li>p-i：返回 p 前面第 i 个元素的迭代器。</li><li>p[i]：返回 p 后面第 i 个元素的引用。</li></ul><p>此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 运算符进行比较。<code>p1&lt;p2</code>的含义是：p1 经过若干次（至少一次）<code>++</code>操作后，就会等于 p2。其他比较方式的含义与此类似。</p><p>&#x3D;&#x3D;对于两个随机访问迭代器 p1、p2，表达式<code>p2-p1</code>也是有定义的，其返回值是 p2 所指向元素和 p1 所指向元素的序号(下标)之差（也可以说是 p2 和 p1 之间的元素个数减一）。&#x3D;&#x3D;</p><blockquote><p>例如在vector中返回某个元素的下标</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span><span class="comment">//std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span><span class="comment">//std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; temp = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = temp.<span class="built_in">begin</span>();</span><br><span class="line">it += <span class="number">2</span>;<span class="comment">//p+=i</span></span><br><span class="line"><span class="comment">//此时it对应的元素下标为</span></span><br><span class="line"><span class="type">int</span> index = it - temp.<span class="built_in">begin</span>();<span class="comment">//p2-p1</span></span><br><span class="line">cout &lt;&lt; index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出2</p></blockquote></blockquote><p>不同容器的迭代器的功能:</p><table><thead><tr><th>容器</th><th>迭代器功能</th></tr></thead><tbody><tr><td>vector</td><td>随机访问</td></tr><tr><td>deque</td><td>随机访问</td></tr><tr><td>list</td><td>双向</td></tr><tr><td>set &#x2F; multiset</td><td>双向</td></tr><tr><td>map &#x2F; multimap</td><td>双向</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr><tr><td>priority_queue</td><td>不支持迭代器</td></tr></tbody></table><blockquote><p>vector 的迭代器是随机迭代器，因此<mark>遍历 vector 容器</mark>有以下几种做法。下面的程序中，每个循环演示了一种做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//v被初始化成有100个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; v.<span class="built_in">size</span>() ; ++i) <span class="comment">//size返回元素个数</span></span><br><span class="line">        cout &lt;&lt; v[i]; <span class="comment">//像普通数组一样使用vector容器</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator i;</span><br><span class="line">    <span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span> (); ++i) <span class="comment">//用 != 比较两个迭代器</span></span><br><span class="line">        cout &lt;&lt; * i;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span> ();++i) <span class="comment">//用 &lt; 比较两个迭代器</span></span><br><span class="line">        cout &lt;&lt; * i;</span><br><span class="line">  </span><br><span class="line">    i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(i &lt; v.<span class="built_in">end</span>()) &#123; <span class="comment">//间隔一个输出</span></span><br><span class="line">        cout &lt;&lt; * i;</span><br><span class="line">        i += <span class="number">2</span>; <span class="comment">// 随机访问迭代器支持 &quot;+= 整数&quot;  的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>list 容器的迭代器是双向迭代器。</p><p>假设 v 和 i 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure><p>则以下代码是合法的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=v.<span class="built_in">begin</span>(); i!=v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">  cout &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p>以下代码则不合法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=v.<span class="built_in">begin</span>(); i&lt;v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">  cout &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p>因为双向迭代器不支持用 “&lt;” 进行比较。以下代码也不合法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">  cout &lt;&lt; v[i];</span><br></pre></td></tr></table></figure><p>因为 list 不支持随机访问迭代器的容器，也不支持用下标随机访问其元素。</p></blockquote><p><strong>&#x3D;&#x3D;在 <a href="http://c.biancheng.net/cplus/">C++</a> 中，数组也是容器。数组的迭代器就是指针，而且是随机访问迭代器。例如，对于数组 int a[10]，int * 类型的指针就是其迭代器。则 a、a+1、a+2 都是 a 的迭代器。&#x3D;&#x3D;</strong></p><h4 id="迭代器的辅助函数-好用"><a href="#迭代器的辅助函数-好用" class="headerlink" title="迭代器的辅助函数(好用)"></a>迭代器的辅助函数(好用)</h4><p>STL 中有用于操作迭代器的三个函数模板</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">advance</span>(p, n) </span><br></pre></td></tr></table></figure><p>使迭代器 p 向前或向后移动 n 个元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">distance</span>(p, q)</span><br></pre></td></tr></table></figure><p>计算两个迭代器之间的距离，即迭代器 p 经过多少次 + + 操作后和迭代器 q 相等。如果调用时 p 已经指向 q 的后面，则这个函数会陷入死循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">iter_swap</span>(p, q)</span><br></pre></td></tr></table></figure><p>用于交换两个迭代器 p、q 指向的值</p></blockquote><p>要使用上述模板，需要包含头文件 algorithm。下面的程序演示了这三个函数模板的 用法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">//要使用操作迭代器的函数模板，需要包含此文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    list &lt;<span class="type">int</span>&gt; <span class="built_in">lst</span>(a, a+<span class="number">5</span>);</span><br><span class="line">    list &lt;<span class="type">int</span>&gt;::iterator p = lst.<span class="built_in">begin</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">advance</span>(p, <span class="number">2</span>);  <span class="comment">//p向后移动两个元素，指向3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1)&quot;</span> &lt;&lt; *p &lt;&lt; endl;  <span class="comment">//输出 1)3</span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">advance</span>(p, <span class="number">-1</span>);  <span class="comment">//p向前移动一个元素，指向2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2)&quot;</span> &lt;&lt; *p &lt;&lt; endl;  <span class="comment">//输出 2)2</span></span><br><span class="line">  </span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator q = lst.<span class="built_in">end</span>();</span><br><span class="line">  </span><br><span class="line">    q--;  <span class="comment">//q 指向 5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3)&quot;</span> &lt;&lt; <span class="built_in">distance</span>(p, q) &lt;&lt; endl;  <span class="comment">//输出 3)3</span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">iter_swap</span>(p, q); <span class="comment">//交换 2 和 5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;4)&quot;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (p = lst.<span class="built_in">begin</span>(); p != lst.<span class="built_in">end</span>(); ++p)</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是：<br>\1) 3<br>\2) 2<br>\3) 3<br>\4) 1 5 3 4 2</p><h4 id="返回-随机访问迭代器中某个元素的-位置-序号-下标"><a href="#返回-随机访问迭代器中某个元素的-位置-序号-下标" class="headerlink" title="返回 随机访问迭代器中某个元素的 位置(序号)(下标)"></a>返回 随机访问迭代器中某个元素的 位置(序号)(下标)</h4><p>方法1⃣️用循环，从第1个元素开始找，直到找到对应的元素，返回下标</p><p>方法2⃣️利用<a href="http://c.biancheng.net/view/7489.html">find函数</a>，找到对应元素的迭代器，利用<a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%88%86%E7%B1%BB">“两个随机访问迭代器相减，返回值是两个迭代器对应的元素的序号(下标)之差”</a>，用该元素的迭代器减去容器首元素迭代器，返回值就是该元素的下标</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span><span class="comment">//std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span><span class="comment">//std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span><span class="comment">//std::find()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; temp = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>(), <span class="number">5</span>);<span class="comment">//value为要查找的值，该函数返回一个指向对应元素的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时it对应的元素下标为</span></span><br><span class="line"><span class="type">int</span> index = it - temp.<span class="built_in">begin</span>();</span><br><span class="line">cout &lt;&lt; index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>find函数是algorithm的库函数</p><p>find() 函数本质上是一个模板函数，用于在指定范围内查找和目标元素值相等的第一个元素。</p><p>如下为 find() 函数的语法格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InputIterator <span class="title">find</span> <span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，first 和 last 为输入迭代器，[first, last) 用于指定该函数的查找范围；value 为要查找的目标元素。</p><blockquote><p>正因为 first 和 last 的类型为输入迭代器，因此该函数适用于所有的序列式容器。</p></blockquote><p>该函数会<strong>返回</strong>一个<u>输入迭代器</u>，当 find() 函数查找成功时，其指向的是在 [first, last) 区域内查找到的第一个目标元素；如果查找失败，则该迭代器的指向和 last 相同。</p><blockquote><p>例如查找vector的元素时，first是vector.begin()，end是vector.end()</p><blockquote><p> vector.end()是指向容器的最后一个元素之后的&#x2F;0</p></blockquote></blockquote><p>值得一提的是，find() 函数的底层实现，其实就是用<code>==</code>运算符将 val 和 [first, last) 区域内的元素逐个进行比对。这也就意味着，[first, last) 区域内的元素必须支持<code>==</code>运算符。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::find</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//find() 函数作用于普通数组</span></span><br><span class="line"><span class="type">char</span> stl[] = <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line"><span class="comment">//调用 find() 查找第一个字符 &#x27;c&#x27;</span></span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">find</span>(stl, stl + <span class="built_in">strlen</span>(stl), <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="comment">//判断是否查找成功</span></span><br><span class="line"><span class="keyword">if</span> (p != stl + <span class="built_in">strlen</span>(stl))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//find() 函数作用于容器</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">it = <span class="built_in">find</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myvector.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;查找成功：&quot;</span> &lt;&lt; *it;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;查找失败&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.biancheng.net/stl/</span><br><span class="line">查找成功：30</span><br></pre></td></tr></table></figure><p>可以看到，find() 函数除了可以作用于序列式容器，还可以作用于普通数组(因为在C++中普通数组也是容器)</p><blockquote><p>补充：find() 函数的底层实现，C++ 标准库中给出了参数代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (first != last)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*first == val) <span class="keyword">return</span> first;</span><br><span class="line">++first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="迭代器的好处"><a href="#迭代器的好处" class="headerlink" title="迭代器的好处"></a>迭代器的好处</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212031252529.png" alt="截屏2022-12-03 12.51.56" /><h4 id="迭代器可以使用auto，更简便"><a href="#迭代器可以使用auto，更简便" class="headerlink" title="迭代器可以使用auto，更简便"></a>迭代器可以使用auto，更简便</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line">string::iterator it1 = s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> it2 = s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//二者是等同的</span></span><br></pre></td></tr></table></figure><h4 id="C-11范围for本质上就是替代了范围for"><a href="#C-11范围for本质上就是替代了范围for" class="headerlink" title="C++11范围for本质上就是替代了范围for"></a>C++11范围for本质上就是替代了范围for</h4><p>从汇编上就可以看出来</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E8%8C%83%E5%9B%B4for%E6%9C%AC%E8%B4%A8%E4%B8%8A%E5%B0%B1%E6%98%AF%E6%9B%BF%E4%BB%A3%E4%BA%86%E8%BF%AD%E4%BB%A3%E5%99%A8(%E4%BB%8E%E6%B1%87%E7%BC%96%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%87%BA%E6%9D%A5).png" alt="范围for本质上就是替代了迭代器(从汇编就可以看出来)" />]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;迭代器-iterator&quot;&gt;&lt;a href=&quot;#迭代器-iterator&quot; class=&quot;headerlink&quot; title=&quot;迭代器(iterator)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://c.biancheng.net/view/338.html&quot;&gt;迭代</summary>
      
    
    
    
    <category term="编程日志" scheme="https://chunyujin.top/categories/%E7%BC%96%E7%A8%8B%E6%97%A5%E5%BF%97/"/>
    
    <category term="C&amp;C++" scheme="https://chunyujin.top/categories/%E7%BC%96%E7%A8%8B%E6%97%A5%E5%BF%97/C-C/"/>
    
    
    <category term="C++" scheme="https://chunyujin.top/tags/C/"/>
    
    <category term="C++STL" scheme="https://chunyujin.top/tags/C-STL/"/>
    
  </entry>
  
  <entry>
    <title>static放置的位置</title>
    <link href="https://chunyujin.top/chunyujin/5583cd64.html"/>
    <id>https://chunyujin.top/chunyujin/5583cd64.html</id>
    <published>2024-10-11T07:53:00.000Z</published>
    <updated>2024-10-22T07:34:35.314Z</updated>
    
    <content type="html"><![CDATA[<p>在声明函数时，如果需要用静态关键字static，应该放到函数类型前面还是后面？</p><blockquote><p>通义千问的回答：<strong>建议放到返回类型的前面</strong><br>在C++中，<code>static</code>关键字可以用于多种上下文，包括函数声明。当用于类的成员函数时，<code>static</code>的位置（放在返回类型前面还是后面）并不会改变其语义，但通常有约定俗成的放置位置。</p><h3 id="放置位置"><a href="#放置位置" class="headerlink" title="放置位置"></a>放置位置</h3><ul><li><p><strong>放在返回类型前面</strong>：这是最常见的用法，也是推荐的做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">myStaticFunction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>放在返回类型后面</strong>：虽然语法上是允许的，但这样做并不常见，并且可能会降低代码的可读性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="type">static</span> <span class="title">myStaticFunction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="语义上的区别"><a href="#语义上的区别" class="headerlink" title="语义上的区别"></a>语义上的区别</h3><p>无论<code>static</code>放在哪里，它都表示该成员函数属于类本身而不是类的任何特定对象。这意味着：</p><ul><li>你不需要创建类的实例就可以调用静态成员函数。</li><li>静态成员函数不能访问非静态成员变量或非静态成员函数，因为它没有隐式的<code>this</code>指针。</li><li>静态成员函数只能访问静态成员变量和其他静态成员函数。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>尽管从技术角度来看，<code>static</code>关键字放在返回类型前面或后面都不会影响编译器对其的理解，但从编码风格和可读性的角度来看，通常建议将<code>static</code>放在返回类型之前。这符合大多数C++程序员的习惯，也使得代码更加清晰易懂。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在声明函数时，如果需要用静态关键字static，应该放到函数类型前面还是后面？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通义千问的回答：&lt;strong&gt;建议放到返回类型的前面&lt;/strong&gt;&lt;br&gt;在C++中，&lt;code&gt;static&lt;/code&gt;关键字可以用于多种上下文</summary>
      
    
    
    
    <category term="编程日志" scheme="https://chunyujin.top/categories/%E7%BC%96%E7%A8%8B%E6%97%A5%E5%BF%97/"/>
    
    <category term="C&amp;C++" scheme="https://chunyujin.top/categories/%E7%BC%96%E7%A8%8B%E6%97%A5%E5%BF%97/C-C/"/>
    
    
    <category term="C++" scheme="https://chunyujin.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>QString与QByteArray的区别与用途</title>
    <link href="https://chunyujin.top/chunyujin/3167b709.html"/>
    <id>https://chunyujin.top/chunyujin/3167b709.html</id>
    <published>2024-10-11T07:26:00.000Z</published>
    <updated>2024-10-22T07:34:35.280Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通义千问的回答：</p><p><code>QByteArray</code> 和 <code>QString</code> 都是 Qt 框架中用于处理文本和二进制数据的类，但它们的设计目的和服务的场景有所不同。</p><h3 id="QByteArray"><a href="#QByteArray" class="headerlink" title="QByteArray"></a>QByteArray</h3><ul><li><strong>类型</strong>：<code>QByteArray</code> 用来存储原始字节（raw bytes），可以包含任意二进制数据。</li><li><strong>编码</strong>：它不假定任何特定的字符编码。你可以使用它来处理任何类型的二进制数据，包括图像、音频文件或网络协议中的数据包等。</li><li><strong>性能</strong>：由于直接操作内存中的字节，对于需要高效处理的数据，<code>QByteArray</code> 提供了较高的性能。</li><li><strong>API</strong>：提供了许多与 C 字符串兼容的方法，比如 <code>data()</code> 返回一个指向内部数组的指针，使得它可以方便地与其他C API进行交互。</li><li><strong>用途</strong>：适合于网络编程、文件I&#x2F;O、图像处理等需要处理非文本数据的情况。</li></ul><h3 id="QString"><a href="#QString" class="headerlink" title="QString"></a>QString</h3><ul><li><strong>类型</strong>：<code>QString</code> 是专门设计来处理文本字符串的类。</li><li><strong>编码</strong>：默认情况下，<code>QString</code> 使用 UTF-16 编码（在某些平台上可能使用 UTF-8）来存储文本，这意味着它可以有效地处理 Unicode 文本，支持多种语言和特殊符号。</li><li><strong>功能</strong>：提供了丰富的字符串操作方法，如搜索、替换、分割、连接等。</li><li><strong>国际化</strong>：非常适合于构建国际化的应用程序，因为它能够很好地处理多语言环境下的文本。</li><li><strong>内存管理</strong>：自动处理内存分配和释放，避免了常见的内存泄漏问题。</li><li><strong>安全性</strong>：提供了一些安全特性，例如防止缓冲区溢出。</li><li><strong>用途</strong>：主要用于用户界面元素的标签、消息框的内容、配置文件的读写等涉及文本的地方。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>当你需要处理的是纯文本，尤其是当文本包含多语言字符时，应该使用 <code>QString</code>。</li><li>如果你正在处理二进制数据或者需要直接控制底层数据表示，那么 <code>QByteArray</code> 会是更好的选择。</li><li>在某些情况下，你可能需要在这两者之间进行转换。例如，从网络接收的数据可能是 <code>QByteArray</code> 形式，但在显示给用户之前，你可能需要将其转换为 <code>QString</code> 来正确显示文本内容。Qt 提供了便捷的方法来进行这种转换，如 <code>QString::fromUtf8(const QByteArray &amp;)</code> 和 <code>QByteArray::fromRawData(const char *unicode, int size)</code>、<code>QByteArray::fromStdString(const QString &amp;)</code> 等。</li></ul></blockquote><p>后需要补充的内容：在des加密算法中对于QString和QByteArray的应用说明</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;通义千问的回答：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;QByteArray&lt;/code&gt; 和 &lt;code&gt;QString&lt;/code&gt; 都是 Qt 框架中用于处理文本和二进制数据的类，但它们的设计目的和服务的场景有所不同。&lt;/p&gt;
&lt;h3 id=&quot;QByte</summary>
      
    
    
    
    <category term="Qt" scheme="https://chunyujin.top/categories/Qt/"/>
    
    
    <category term="Qt" scheme="https://chunyujin.top/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Typora+PicGo图床+阿里云OSS配置</title>
    <link href="https://chunyujin.top/chunyujin/e9887bd.html"/>
    <id>https://chunyujin.top/chunyujin/e9887bd.html</id>
    <published>2024-10-10T13:01:00.000Z</published>
    <updated>2024-10-22T07:34:35.295Z</updated>
    
    <content type="html"><![CDATA[<p>首先购买阿里云OSS服务</p><p>完成之后，打开RAM访问控制</p><p>点击 用户-创建用户</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230314101800121.png" alt="image-20230314101800121" style="zoom: 67%;" /><p>创建用户登录名称和显示名称</p><p>完成进入相关用户</p><p>点击“创建AccseeKey”</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303122001920.png" alt="截屏2023-03-12 20.01.28" style="zoom: 33%;" /><p>将信息保存下来</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303122002839.png" alt="IMG_0538" style="zoom: 33%;" /><p>之后点击 权限管理-新增授权</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303122000574.png" alt="ss" style="zoom:50%;" /><p>选择 整个云账号-授权主体</p><p>在“系统策略”里选择以下内容</p><p>点击确认，完成</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303122000150.png" alt="qq" style="zoom:50%;" /><p>打开Typora</p><p>打开设置，选择”插入图片时……”</p><p>按照一下进行勾选</p><p>在“上传服务设定”中选择PicGo，如果没有安装则进行下载，并在Typora中配置好路径</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303122007419.png" alt="截屏2023-03-12 20.06.58" style="zoom:33%;" /><p>打开PicGo</p><p>按照如下进行配置，前两项是在阿里云创建的AccessKey给出的信息</p><p>三四项根据阿里云OSS存储中自己设定好的的Bucket和存储区域来，或者直接按实例进行填写</p><p>存储路径按照阿里云OSS中填写</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303122008334.png" alt="截屏2022-09-14 11.41.25" style="zoom:50%;" /><p>回到Typora刚才的页面，点击“验证图片上传选项”</p><p>返回结果为成功则说明配置完成</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先购买阿里云OSS服务&lt;/p&gt;
&lt;p&gt;完成之后，打开RAM访问控制&lt;/p&gt;
&lt;p&gt;点击 用户-创建用户&lt;/p&gt;
&lt;img src=&quot;https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-2023031410</summary>
      
    
    
    
    <category term="Skill" scheme="https://chunyujin.top/categories/Skill/"/>
    
    <category term="Typora" scheme="https://chunyujin.top/categories/Skill/Typora/"/>
    
    
    <category term="Typora" scheme="https://chunyujin.top/tags/Typora/"/>
    
  </entry>
  
  <entry>
    <title>Hexo自动化提交-gulp压缩静态资源</title>
    <link href="https://chunyujin.top/chunyujin/49b78e.html"/>
    <id>https://chunyujin.top/chunyujin/49b78e.html</id>
    <published>2024-10-10T11:22:00.000Z</published>
    <updated>2024-10-22T07:34:35.286Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">gulp  #进行css压缩</span><br><span class="line">hexo deploy 或 hexo server</span><br></pre></td></tr></table></figure><h1 id="关于gulp"><a href="#关于gulp" class="headerlink" title="关于gulp"></a>关于gulp</h1><p>gulp可以对于网站静态文件进行压缩，缩小网站静态体积，加快加载速度</p><p><a href="https://chunyujin.top/chunyujin/9dba5c90">Hexo-gulp压缩静态资源加快加载速度 | 浴巾的贼船 (chunyujin.top)</a></p><h1 id="命令精简"><a href="#命令精简" class="headerlink" title="命令精简"></a>命令精简</h1><p>使用了gulp时候，构建发布需要四个命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">gulp</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><h1 id="自动化-很好用"><a href="#自动化-很好用" class="headerlink" title="自动化-很好用"></a>自动化-很好用</h1><p>这四个命令，可以都写在package.json。直接替换文件中对应位置的代码即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; gulp&quot;,</span><br><span class="line">  &quot;deploy&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo deploy&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建只需要执行<code>npm run build</code>，构建发布只需要执行<code>npm run deploy</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    <category term="Skill" scheme="https://chunyujin.top/categories/Skill/"/>
    
    <category term="Hexo" scheme="https://chunyujin.top/categories/Skill/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://chunyujin.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-Butterfly环境搭建</title>
    <link href="https://chunyujin.top/chunyujin/db7f9dc7.html"/>
    <id>https://chunyujin.top/chunyujin/db7f9dc7.html</id>
    <published>2024-10-10T10:17:00.000Z</published>
    <updated>2024-10-22T07:39:13.276Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ol><li><p>本教程只是环境搭建，并不涉及网站部署等，只涉及到电脑本地环境的创建。因为博主此前已经构建过一个基于Hexo-Butterfly主题的博客了，现在需求为在不同电脑搭建出网站部署环境，将网站源码上传到git上，实现在不同电脑上都可以更新网站的需求。</p></li><li><p>本教程基于Windows操作系统，macOS、Linux系统操作上都是大同小异，搭建方式基本都是从官网或终端进行软件的下载和安装。与Windows不同的是，macOS和Linux对于环境变量等的管理比较简单，所以比Windows操作系统下搭建环境更加简单一些。</p></li></ol><h3 id="终端工具的选择"><a href="#终端工具的选择" class="headerlink" title="终端工具的选择"></a>终端工具的选择</h3><p>Windows：有两个终端工具</p><ul><li>Windows Terminal。微软在win10后期新推出的终端工具。支持Windows命令，部分.ned和Linux shell命令。</li><li>”命令行提示符“cmd。比较古早的终端，只支持Windows命令。</li></ul><p>建议选择Windows powershell。因为后期可能会涉及到需要管理员权限的操作，届时直接使用管理员模式打开powershell即可。</p><blockquote><p>这里其实也可以使用cmd，快捷打开管理员模式的方法：</p><ol><li>win+r打开“运行”</li><li>输入cmd，不要点击回车</li><li>Ctrl+Shift+Enter打开cmd</li></ol><p>Windows  </p></blockquote><p>macOS、Linux：直接使用自带终端。可以随时进入root模式，很方便。</p><p>后期安装好之后，都会改为使用vscode中的终端。</p><p>前期Windows下不使用vscode的原因：软件安装时涉及到下载目录、管理员模式运行终端或者涉及到环境变量的配置等，需要一个灵活的终端窗口，且Windows终端的很多操作都是与当前工作目录强相关的，vscode就没那么灵活了，毕竟Windows的终端并不像mac和Linux一样那么全能。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li><p>Node。Node.js 是一个开源的、跨平台的 JavaScript 运行时环境。<a href="https://nodejs.cn/">Node.js 中文网 (nodejs.cn)</a></p></li><li><p>nvm。(Node Version Manager)是 Nodejs 版本管理器，它能让我们方便的对 Node.js 的版本进行切换。</p></li><li><p>npm。(Node Package Manager)，Node.js 的包管理器，安装 Node.js 之后自带 npm，无需单独安装</p></li><li><p>Hexo。一个由Node.js驱动的博客简单强大的博客框架。<a href="https://hexo.io/zh-cn/">Hexo</a></p></li><li><p>vscode。</p></li></ul><p>教程推荐：</p><ul><li><a href="https://www.cnblogs.com/qianguyihao/p/8492713.html">Node.js介绍和环境配置（含NVM、NPM、NVM的安装） - 千古壹号 - 博客园 (cnblogs.com)</a></li><li><a href="https://segmentfault.com/a/1190000011114680">node.js - 安装npm，nvm，node - 个人文章 - SegmentFault 思否</a></li></ul><h4 id="nvm安装"><a href="#nvm安装" class="headerlink" title="nvm安装"></a>nvm安装</h4><p><a href="https://github.com/coreybutler/nvm-windows/releases">Windows版安装地址 · Releases · coreybutler&#x2F;nvm-windows (github.com)</a>)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010151855178.png" alt="image-20241010151855178" /><p>下载之后解压到本地软件安装目录中</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010151944766.png" alt="image-20241010151944766" /><p>双击运行，开始安装</p><p>安装之后，会被自动添加到环境变量中。</p><p>在终端中测试安装是否成功：</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010152154711.png" alt="image-20241010152154711"></p><p>配置环境变量：</p><blockquote><p>正常来说，nvm安装之后会自动配置好环境变量：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010161247200.png" alt="image-20241010161247200" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010161331585.png" alt="image-20241010161331585" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010161411700.png" alt="image-20241010161411700" style="zoom:80%;" /></blockquote><h4 id="Node、npm安装"><a href="#Node、npm安装" class="headerlink" title="Node、npm安装"></a>Node、npm安装</h4><p><a href="https://www.nodejs.com.cn/download.html">Node.js 中文网 (nodejs.com.cn)</a></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241022150735487.png" alt="image-20241022150735487" style="zoom:67%;" /><p>下载.msi安装包，然后进行安装，设置安装目录，在安装中，会自动将node添加到环境变量，node安装完成，npm也安装完成了。</p><p><mark>需要注意的是，如果想使用node或者npm，需要在管理员模式下启用终端，否则会error</mark></p><p>测试node和npm安装成功：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010162147431.png" alt="image-20241010162147431" style="zoom:80%;" /><h4 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h4><p>需要将hexo使用npm安装到指定目录，因此先进入指定路径</p><h5 id="通过管理员模式进入指定目录的方法"><a href="#通过管理员模式进入指定目录的方法" class="headerlink" title="通过管理员模式进入指定目录的方法"></a>通过管理员模式进入指定目录的方法</h5><blockquote><p> 方法有很多，无非就是先用管理员模式打开终端，然后cd进入要安装的目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010162818276.png" alt="image-20241010162818276"  /><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010162847131.png" alt="image-20241010162847131"></p><p>注意如果路径有空格，需要用<code>&quot;&quot;</code>将路径包裹起来</p></blockquote><p>安装Hexo环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h5 id="更换npm源或安装cnpm"><a href="#更换npm源或安装cnpm" class="headerlink" title="更换npm源或安装cnpm"></a>更换npm源或安装cnpm</h5><blockquote><p>如果下载时卡住：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010163300272.png" alt="image-20241010163300272" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010163719938.png" alt="image-20241010163719938" /><p>原因：npm源在国外</p><p><strong>解决方案一：可以换为国内淘宝镜像源：</strong></p><p><a href="https://blog.csdn.net/XueZePeng18729875380/article/details/129519153">npm 使用淘宝镜像及切换回官方源_npm 淘宝源-CSDN博客</a></p><p>注意淘宝镜像源可能会有更新，网址会发生改变，请自己百度最新的镜像源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npmmirror.com/</span><br></pre></td></tr></table></figure><p>更换之后进行测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><p>返回结果为<code>https://registry.npm.taobao.org</code>则说明配置成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS D:\software\Hexo&gt; npm config set registry https://registry.npmmirror.com/</span><br><span class="line">PS D:\software\Hexo&gt; npm config get registry</span><br><span class="line">https://registry.npmmirror.com/</span><br></pre></td></tr></table></figure><p><strong>解决方案二：安装 cnpm 来替代 npm，cnpm是淘宝团队创建的为国内用户使用的npm替代品：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">注册模块镜像</span></span><br><span class="line"> npm set registry https://registry.npmmirror.com  </span><br><span class="line"> </span><br><span class="line"> // node-gyp 编译依赖的 node 源码镜像  </span><br><span class="line"> npm set disturl https://npmmirror.com/dist </span><br><span class="line"> </span><br><span class="line"> // 清空缓存  </span><br><span class="line"> npm cache clean --force  </span><br><span class="line"> </span><br><span class="line"> // 安装cnpm  </span><br><span class="line"> npm install -g cnpm --registry=https://registry.npmmirror.com </span><br></pre></td></tr></table></figure><p>安装完后最好查看其版本号cnpm -v或关闭命令提示符重新打开，安装完直接使用可能会出现错误</p><p>cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm</p><p><strong>npm 切换回官方源：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config delete registry</span><br></pre></td></tr></table></figure><p>或者直接修改为原本的源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npmjs.org/</span><br></pre></td></tr></table></figure></blockquote><p>书接上回，安装Hexo：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010171928006.png" alt="image-20241010171928006" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010171939117.png" alt="image-20241010171939117" style="zoom:80%;" /><p>安装之后可能又会发现新的问题：vscode或者Windows terminal的poweshell下使用<code>hexo -v</code>检查hexo安装，发现无法识别命令。而cmd执行则可以：</p><blockquote><p><strong>powershell不行</strong></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010172429032.png" alt="image-20241010172429032"></p><p><strong>cmd可以</strong></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010172513371.png" alt="image-20241010172513371"></p></blockquote><p>这个问题也可以描述为：powershell中无法执行命令&#x2F;脚本：<a href="https://zhuanlan.zhihu.com/p/553911329">命令行在cmd中能执行但是在PowerShell中报错 - 知乎 (zhihu.com)</a></p><p>在powershell中运行命令行查看系统权限：<code>Get-ExecutionPolicy -List</code></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010172720088.png" alt="image-20241010172720088" style="zoom:80%;" /><p>通过这个命令发现CurrentUser的权限是Undefined，那么就是权限的问题，就可以通过增加权限解决了</p><h5 id="增加Windows-terminal-powershell中CurrentUser权限以解决无法执行命令-x2F-脚本的问题："><a href="#增加Windows-terminal-powershell中CurrentUser权限以解决无法执行命令-x2F-脚本的问题：" class="headerlink" title="增加Windows terminal powershell中CurrentUser权限以解决无法执行命令&#x2F;脚本的问题："></a>增加Windows terminal powershell中CurrentUser权限以解决无法执行命令&#x2F;脚本的问题：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser</span><br></pre></td></tr></table></figure><p>之后执行<code>Get-ExecutionPolicy -List</code>再次查看权限：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010172937214.png" alt="image-20241010172937214" style="zoom:80%;" /><p>之后使用<code>hexo -v</code>检查一下安装：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010173004341.png" alt="image-20241010173004341" style="zoom:67%;" /><p>安装完成</p><h3 id="拉取仓库-最后配置"><a href="#拉取仓库-最后配置" class="headerlink" title="拉取仓库-最后配置"></a>拉取仓库-最后配置</h3><p>创建一个新的空文件夹用来存放博客项目，<code>git init</code>一下，将网站工程从git远端仓库上下拉回来</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010173558750.png" alt="image-20241010173558750"></p><p>因为博客是使用的GitHub运行的，因此还需要执行最后一步：</p><p>将本地ssh公钥添加到GitHub中</p><p>获取公钥：<a href="https://chunyujin.top/chunyujin/b51810cf">Git！从零开始连接远程仓库 | 浴巾的贼船 (chunyujin.top)</a></p><blockquote><p>如果本地没有产生过公钥，执行，下面命令，以前生成过，直接跳过这一步即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>然后一路回车。</p><p>获取本地公钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></blockquote><p>打开GitHub，登录进去，点击右上角头像，进入设置：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010174412262.png" alt="image-20241010174412262" /><p>点击右上角New SSH Key</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010174523081.png" alt="image-20241010174523081" /><p>创建一个标题，并将ssh key复制进下面：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010174624863.png" alt="image-20241010174624863" /><p>点击Add SSH key，然后输入GitHub密码进行确定</p><p>然后可以看到新添加上的了：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010174731187.png" alt="image-20241010174731187" /><p>如果绑定邮箱了，还会收到邮箱提示。</p><p>测试一下是否成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010174933309.png" alt="image-20241010174933309" /><p>现在就可以在vscode中打开项目根目录了</p><h4 id="关于初始化"><a href="#关于初始化" class="headerlink" title="关于初始化"></a>关于初始化</h4><p>博客项目只有在创建的时候进行一下初始化就可以，因为我这个博客很久之前就创建好了，并且初始化文件都会保存在一起放入了根目录，所以不需要再初始化，直接就可以使用了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【node_modules】：依赖包</span><br><span class="line">【scaffolds】：生成文章的一些模板</span><br><span class="line">【source】：用来存放你的文章</span><br><span class="line">【themes】：主题</span><br><span class="line">【.npmignore】：发布时忽略的文件（可忽略）</span><br><span class="line">【_config.landscape.yml】：主题的配置文件</span><br><span class="line">【_config.yml】：博客的配置文件</span><br><span class="line">【package.json】：项目名称、描述、版本、运行和开发等信息</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010175206195.png" alt="image-20241010175206195" /><p>直接vscode打开，就可以进行提交三板斧等操作了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010175404122.png" alt="image-20241010175404122" /><p>之后就可以发布项目到GitHub上进行运行了</p><h4 id="如果项目文件夹下报错“ERROR-Cannot-find-module-‘hexo’-from-”"><a href="#如果项目文件夹下报错“ERROR-Cannot-find-module-‘hexo’-from-”" class="headerlink" title="如果项目文件夹下报错“ERROR Cannot find module ‘hexo’ from ”"></a>如果项目文件夹下报错“ERROR Cannot find module ‘hexo’ from ”</h4><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010175951865.png" alt="image-20241010175951865"></p><p>根据最后一行的信息，说明没有安装相关的moudle，安装上即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --force</span><br></pre></td></tr></table></figure><blockquote><p>侧面反映了shell中解毒草药就在五步之内</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010180311742.png" alt="image-20241010180311742" /><p>执行一条hexo命令试试：</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20241010180425268.png" alt="image-20241010180425268"></p><p>完美！</p><p>最后还有一点：</p><h4 id="配置gulp压缩静态资源"><a href="#配置gulp压缩静态资源" class="headerlink" title="配置gulp压缩静态资源"></a>配置gulp压缩静态资源</h4><p><a href="https://chunyujin.top/chunyujin/9dba5c90">Hexo-gulp压缩静态资源加快加载速度 | 浴巾的贼船 (chunyujin.top)</a></p><h3 id="切记每次修改前git-pull，修改完之后git-push一下，保持同步，防止出错"><a href="#切记每次修改前git-pull，修改完之后git-push一下，保持同步，防止出错" class="headerlink" title="切记每次修改前git pull，修改完之后git push一下，保持同步，防止出错"></a>切记每次修改前git pull，修改完之后git push一下，保持同步，防止出错</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;本教程只是环境搭建，并不涉及网站部署等，只涉及到电脑本地环境的创建。因为博主此前已经构建过一个基于Hexo-Butterf</summary>
      
    
    
    
    <category term="Skill" scheme="https://chunyujin.top/categories/Skill/"/>
    
    <category term="Hexo" scheme="https://chunyujin.top/categories/Skill/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://chunyujin.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-gulp压缩静态资源加快加载速度</title>
    <link href="https://chunyujin.top/chunyujin/9dba5c90.html"/>
    <id>https://chunyujin.top/chunyujin/9dba5c90.html</id>
    <published>2024-10-10T10:16:00.000Z</published>
    <updated>2024-10-22T07:34:35.286Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章来源：<a href="https://akilar.top/posts/49b73b87/">使用gulp压缩博客静态资源 | Akilarの糖果屋</a></p></blockquote><p>1.安装Gulp插件：在博客根目录打开终端，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --global gulp-cli #全局安装gulp指令集</span><br><span class="line">npm install gulp --save #安装gulp插件</span><br></pre></td></tr></table></figure><p>2.安装各个下属插件以实现对各类静态资源的压缩：</p><ul><li>压缩HTML：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp-htmlclean --save-dev</span><br><span class="line">npm install gulp-html-minifier-terser --save-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用gulp-html-minifier-terser可以压缩HTML中的ES6语法</span></span><br></pre></td></tr></table></figure><ul><li>压缩CSS：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp-clean-css --save-dev</span><br></pre></td></tr></table></figure><ul><li>压缩JS：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp-terser --save-dev</span><br></pre></td></tr></table></figure><ul><li>压缩字体包：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp-terser --save-dev</span><br></pre></td></tr></table></figure><p>3.为Gulp创建<code>gulpfile.js</code>任务脚本。在博客根目录下新建<code>gulpfile.js</code><strong>并打开</strong>，输入以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">//用到的各个插件</span><br><span class="line">var gulp = require(&#x27;gulp&#x27;);</span><br><span class="line">var cleanCSS = require(&#x27;gulp-clean-css&#x27;);</span><br><span class="line">var htmlmin = require(&#x27;gulp-html-minifier-terser&#x27;);</span><br><span class="line">var htmlclean = require(&#x27;gulp-htmlclean&#x27;);</span><br><span class="line">var fontmin = require(&#x27;gulp-fontmin&#x27;);</span><br><span class="line">// gulp-tester</span><br><span class="line">var terser = require(&#x27;gulp-terser&#x27;);</span><br><span class="line">// 压缩js</span><br><span class="line">gulp.task(&#x27;compress&#x27;, async() =&gt;&#123;</span><br><span class="line">  gulp.src([&#x27;./public/**/*.js&#x27;, &#x27;!./public/**/*.min.js&#x27;])</span><br><span class="line">    .pipe(terser())</span><br><span class="line">    .pipe(gulp.dest(&#x27;./public&#x27;))</span><br><span class="line">&#125;);</span><br><span class="line">//压缩css</span><br><span class="line">gulp.task(&#x27;minify-css&#x27;, () =&gt; &#123;</span><br><span class="line">    return gulp.src([&#x27;./public/**/*.css&#x27;])</span><br><span class="line">        .pipe(cleanCSS(&#123;</span><br><span class="line">            compatibility: &#x27;ie11&#x27;</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&#x27;./public&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line">//压缩html</span><br><span class="line">gulp.task(&#x27;minify-html&#x27;, () =&gt; &#123;</span><br><span class="line">    return gulp.src(&#x27;./public/**/*.html&#x27;)</span><br><span class="line">        .pipe(htmlclean())</span><br><span class="line">        .pipe(htmlmin(&#123;</span><br><span class="line">            removeComments: true, //清除html注释</span><br><span class="line">            collapseWhitespace: true, //压缩html</span><br><span class="line">            collapseBooleanAttributes: true,</span><br><span class="line">            //省略布尔属性的值，例如：&lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt;</span><br><span class="line">            removeEmptyAttributes: true,</span><br><span class="line">            //删除所有空格作属性值，例如：&lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt;</span><br><span class="line">            removeScriptTypeAttributes: true,</span><br><span class="line">            //删除&lt;script&gt;的type=&quot;text/javascript&quot;</span><br><span class="line">            removeStyleLinkTypeAttributes: true,</span><br><span class="line">            //删除&lt;style&gt;和&lt;link&gt;的 type=&quot;text/css&quot;</span><br><span class="line">            minifyJS: true, //压缩页面 JS</span><br><span class="line">            minifyCSS: true, //压缩页面 CSS</span><br><span class="line">            minifyURLs: true  //压缩页面URL</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&#x27;./public&#x27;))</span><br><span class="line">&#125;);</span><br><span class="line">//压缩字体</span><br><span class="line">function minifyFont(text, cb) &#123;</span><br><span class="line">  gulp</span><br><span class="line">    .src(&#x27;./public/fonts/*.ttf&#x27;) //原字体所在目录</span><br><span class="line">    .pipe(fontmin(&#123;</span><br><span class="line">      text: text</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(&#x27;./public/fontsdest/&#x27;)) //压缩后的输出目录</span><br><span class="line">    .on(&#x27;end&#x27;, cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gulp.task(&#x27;mini-font&#x27;, (cb) =&gt; &#123;</span><br><span class="line">  var buffers = [];</span><br><span class="line">  gulp</span><br><span class="line">    .src([&#x27;./public/**/*.html&#x27;]) //HTML文件所在目录请根据自身情况修改</span><br><span class="line">    .on(&#x27;data&#x27;, function(file) &#123;</span><br><span class="line">      buffers.push(file.contents);</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(&#x27;end&#x27;, function() &#123;</span><br><span class="line">      var text = Buffer.concat(buffers).toString(&#x27;utf-8&#x27;);</span><br><span class="line">      minifyFont(text, cb);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">// 运行gulp命令时依次执行以下任务</span><br><span class="line">gulp.task(&#x27;default&#x27;, gulp.parallel(</span><br><span class="line">  &#x27;compress&#x27;, &#x27;minify-css&#x27;, &#x27;minify-html&#x27;,&#x27;mini-font&#x27;</span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>4.在每次运行完<code>hexo generate</code>生成静态页面后，运行<code>gulp</code>对其进行压缩。指令流程如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">gulp</span><br><span class="line">hexo server 或 hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章来源：&lt;a href=&quot;https://akilar.top/posts/49b73b87/&quot;&gt;使用gulp压缩博客静态资源 | Akilarの糖果屋&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.安装Gulp插件：在博客根目录打开终端</summary>
      
    
    
    
    <category term="Skill" scheme="https://chunyujin.top/categories/Skill/"/>
    
    <category term="Hexo" scheme="https://chunyujin.top/categories/Skill/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://chunyujin.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Qt-qrc机制</title>
    <link href="https://chunyujin.top/chunyujin/43f5e4df.html"/>
    <id>https://chunyujin.top/chunyujin/43f5e4df.html</id>
    <published>2024-09-13T07:56:00.000Z</published>
    <updated>2024-10-22T07:34:35.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Qt导入照片等资源的三种方式"><a href="#Qt导入照片等资源的三种方式" class="headerlink" title="Qt导入照片等资源的三种方式"></a>Qt导入照片等资源的三种方式</h2><ol><li><p>绝对路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">QIcon <span class="title">icon</span><span class="params">(<span class="string">&quot;D:/document/code/QT/LEARNING/QWidget_7/143894.jpg&quot;</span>)</span></span>;<span class="comment">//直接在栈上创建，而不是在堆上</span></span><br><span class="line">    <span class="comment">//之前推荐在堆上创建，主要是因为要确保当前空间的生命周期是足够的，要通过Qt对象树来释放对象。</span></span><br><span class="line">    <span class="comment">//QIcon自身是一个比较小的对象，创建出来了之后，就是要设置到某个QWidget里面，QIcon对象本身是否释放，都不影响最后的显示</span></span><br><span class="line">    <span class="comment">//另一方面，QIcon不支持对象树</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowIcon</span>(icon);</span><br><span class="line">    <span class="comment">//setWindoewIcon和setWindowTitle一样，也是顶层窗口设置才有效</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913150322120.png" alt="image-20240913150322120"></p></li><li><p>相对路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function">QIcon <span class="title">icon</span><span class="params">(<span class="string">&quot;../QWidget_7/143894.jpg&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//通过绝对路径的方式进行引用，是不科学的</span></span><br><span class="line">    <span class="comment">//因为写的程序最后是要发布到用户的电脑上的，无法确保，开发机上图片的路径和用户电脑上的路径完全一致</span></span><br><span class="line">    <span class="comment">//因此，相比于使用绝对路径的方式，使用相对路径是更好的</span></span><br><span class="line">    <span class="comment">//另外还需要注意，此处使用的./是可执行程序的路径，并不是项目工程的路径，因为程序运行时的工作路径，是可执行程序所在路径，并非工程所在的路径</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowIcon</span>(icon);</span><br><span class="line">    <span class="comment">//setWindoewIcon和setWindowTitle一样，也是顶层窗口设置才有效</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>qrc机制</p></li></ol><h3 id="qrc机制"><a href="#qrc机制" class="headerlink" title="qrc机制"></a>qrc机制</h3><p>​Qt引入qrc机制，从根本上解决两个问题：</p><ol><li>图片所在路径不一定在用户机上也存在 (绝对路径的缺点)</li><li>图片可能会在用户机上丢失 (相对路径的缺点)</li></ol><blockquote><p>原理：给Qt项目引入了一个额外的xml文件（后缀为.qrc），在这个xml中将要使用的图片资源导入进来，并且在xml中进行记录。Qt在编译项目的时候，会根据qrc中的图片信息，找到图片中的内容，提取出里面的二进制数据，将二进制数据转化为C++代码，最终编译到exe中。</p></blockquote><p>​qrc的缺点：无法导入太大的资源。</p><h4 id="qrc的用法"><a href="#qrc的用法" class="headerlink" title="qrc的用法"></a>qrc的用法</h4><h5 id="1-新建项目"><a href="#1-新建项目" class="headerlink" title="1.新建项目"></a>1.新建项目</h5><p>选择Qt -&gt; Qt Resource File，创建名称之后一致next即可。此处取名”resource“。</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913150531802.png" alt="image-20240913150531802"></p><p>创建完成后可以看到左侧项目列表中多了一个<code>Resources/resource.qrc</code></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913150750840.png" alt="image-20240913150750840"></p><p>双击之后进入界面</p><h5 id="2-新建前缀-Add-Prefix"><a href="#2-新建前缀-Add-Prefix" class="headerlink" title="2.新建前缀(Add Prefix)"></a>2.新建前缀(Add Prefix)</h5><p>前缀可以理解为Qt创建的一个虚拟目录</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913152038144.png" alt="image-20240913152038144"></p><p>自定义一下前缀的名称，然后在qrc文本编辑下就可以看到这个新建的虚拟目录了</p><h5 id="3-导入文件-Add-Files"><a href="#3-导入文件-Add-Files" class="headerlink" title="3.导入文件(Add Files)"></a>3.导入文件(Add Files)</h5><p>导入文件，即将文件放入刚创建好的前缀中。需要注意的是，文件必须来自于qrc文件同级目录下或同级目录下的子目录中，即必须先将需要导入的文件放入工程目录中才行。</p><p>点击Qt编辑区(Qt Editor)的<code>/test</code>，选择<code>Add Files</code>，选中要导入的文件</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913152625084.png" alt="image-20240913152625084"></p><p>导入完成后，可以看到&#x2F;test新增了刚导入的文件，选择该文件，可以设置别名，后去就可以直接用别名调用此文件了，十分方便</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913152802022.png" alt="image-20240913152802022"></p><p>保存一下qrc文件，可以看到左侧项目栏中增加了内容</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913152844830.png" alt="image-20240913152844830"></p><p>此时qrc文件已经变成了列表，双击没有办法对qrc进行编辑了。右击qrc文件，可以执行Add Prefix等操作，右击前缀，可以执行添加文件等操作。</p><p>右击qrc文件，还可以选择在编辑区中打开(Open in Editor)，此时又可以通过跟上面一样的操作来编辑qrc文件了。</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913153158610.png" alt="image-20240913153158610"></p><h5 id="4-引用文件"><a href="#4-引用文件" class="headerlink" title="4.引用文件"></a>4.引用文件</h5><p>在引用文件的时候，语法与绝对路径，相对路径一样，只是前面要加上冒号”:”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QIcon <span class="title">icon</span><span class="params">(<span class="string">&quot;:/test/Asuka&quot;</span>)</span></span>;<span class="comment">//使用qrc的时候，格式为&quot;: + 虚拟路径&quot;</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setWindowIcon</span>(icon);</span><br></pre></td></tr></table></figure><h6 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h6><p>前缀名可以加”&#x2F;“可以不加，因为qrc会自动补全</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913153615833.png" alt="image-20240913153615833"></p><p>前缀名也可以为空，同样，qrc也会自动补全”&#x2F;“</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913153702520.png" alt="image-20240913153702520"></p><p>引用文件的时候，前缀为空，就直接不用写了</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913153729525.png" alt="image-20240913153729525"></p><h4 id="探究qrc"><a href="#探究qrc" class="headerlink" title="探究qrc"></a>探究qrc</h4><p>进入可执行程序目录，会看到多了一个文件：qrc_resource.cpp</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913154911371.png" alt="image-20240913154911371"></p><p>qrc中导入文件资源，就会被转化成qrc_resource.cpp中的代码</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240913155337482.png" alt="image-20240913155337482"></p><p>当Qt项目进行编译的时候，该cpp文件就被一起编译到exe中了，当exe程序运行的时候，上述图片的数据也就被加载到内存中了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Qt导入照片等资源的三种方式&quot;&gt;&lt;a href=&quot;#Qt导入照片等资源的三种方式&quot; class=&quot;headerlink&quot; title=&quot;Qt导入照片等资源的三种方式&quot;&gt;&lt;/a&gt;Qt导入照片等资源的三种方式&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;绝对路径&lt;/p&gt;
&lt;fig</summary>
      
    
    
    
    <category term="Qt" scheme="https://chunyujin.top/categories/Qt/"/>
    
    
    <category term="Qt" scheme="https://chunyujin.top/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt信号与槽</title>
    <link href="https://chunyujin.top/chunyujin/96fd26bb.html"/>
    <id>https://chunyujin.top/chunyujin/96fd26bb.html</id>
    <published>2024-09-02T03:08:00.000Z</published>
    <updated>2024-10-22T07:34:35.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信号与槽"><a href="#信号与槽" class="headerlink" title="信号与槽"></a>信号与槽</h2><p><code>信号源</code>发出(某种类型的)<code>信号</code>，由<code>槽</code>接收信号，并执行对应的<code>信号处理方式</code></p><p>步骤：</p><ol><li>将槽与信号关联起来</li><li>编写好对于信号的响应行为&#x2F;处理方式(槽)</li><li>触发信号，槽接收到，执行设定好的处理方式</li></ol><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>QObject提供的静态的成员函数，用于将信号和槽进行关联</p><blockquote><p>Qt中提供的这些类，本身是存在一定的继承关系的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/81ec1050ac35b96bb35ca8981980404.jpg" alt="81ec1050ac35b96bb35ca8981980404" style="zoom:80%;" /></blockquote><p>原型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(<span class="type">const</span> QObject *sender,</span><br><span class="line">       <span class="type">const</span> <span class="type">char</span> *signal,</span><br><span class="line">       <span class="type">const</span> QObject *receiver,</span><br><span class="line">       <span class="type">const</span> <span class="type">char</span> *method,</span><br><span class="line">       Qt::ConnectionType type = Qt::AutoConnection)</span><br><span class="line"><span class="comment">//sender:信号源，信号是由那个空间发送出来的</span></span><br><span class="line"><span class="comment">//signal:发送的信号(信号函数)；函数指针</span></span><br><span class="line"><span class="comment">//receiver:槽，也就是信号接收对象，处理信号的对象(控件)</span></span><br><span class="line"><span class="comment">//method:接收信号的槽函数，处理信号的对象提供的处理方式(成员函数)；函数指针</span></span><br><span class="line"><span class="comment">//type:用于指定关联方式，通常不需要手动指定，有默认关联方式</span></span><br></pre></td></tr></table></figure><p>example：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//创建一个pushbutton对象，并初始化挂到对象树上，指明父对象是this</span></span><br><span class="line"></span><br><span class="line">    button-&gt;<span class="built_in">setText</span>(<span class="string">&quot;关闭&quot;</span>);</span><br><span class="line">    button-&gt;<span class="built_in">move</span>(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(button, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;Widget::close);</span><br><span class="line">    <span class="comment">//第二、四个参数应该是函数指针，成员函数取地址，得到的就是函数的指针了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ol><li><p>connect中第二个参数，是信号发出的信号，必须是信号源类(或其父类)中的成员函数(信号函数)，不能是无关类的成员函数。</p><p>本例中，信号源设置为了<code>QPushButton</code>类对象<code>button</code>，因此信号函数必须是<code>QPushButton</code>类(或其父类)中的成员函数，不能是别的类</p></li><li><p>connect中第三个参数，是槽，即接收信号的对象</p><p>此处设置为<code>this</code>，即<code>Widget</code>本身</p></li><li><p>connect中第四个参数，是槽函数，必须是槽(或其父类)中的成员函数(槽函数)，不能是无关类的成员函数</p><p>本例中，槽为<code>this</code>，即<code>Widget</code>，因此槽函数必须是<code>Widget</code>类(或其父类)中的成员函数。<code>close</code>为<code>QWidget</code>内置的槽函数，<code>Widget</code>继承自<code>QWidget</code>，也就继承了父类的槽函数</p></li><li><p><code>QPushButton::click</code>和<code>QPushButton::clicked</code>的区别：</p><ol><li><p><code>click</code>是模拟’’按钮点击’’的动作，<code>clicked</code>是接收’’按钮点击’’这一行为。</p><p>在本例中，我们是想要在”按钮被点击后，执行关闭窗口的行为”，也就是说要捕获到“按钮被点击了”这一行为，然后发出信号，进而被槽接收，在执行对应的处理行为。所以说应该用<code>clicked</code>。</p></li><li><p><code>click</code>是槽函数，<code>clicked</code>是信号函数。前者是用于执行动作的，后者适用于捕捉动作和行为、发出信号的。这也是槽函数和信号函数的不同的作用和用途。</p></li><li><p>tips：在Qt Creator中，可以通过查看代码补全时左侧的小图标来得知函数是 信号函数 还是 槽函数。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807135314848.png" alt="image-20240807135314848" style="zoom:80%;" /><blockquote><p>信号函数：图标很像是(遥控器)发送信号(电波)的样子</p><p>槽函数：图标上有凹槽</p></blockquote></li></ol></li><li><p>三个问题：</p><ol><li><p>怎么知道控件类里面有什么槽函数什么信号函数的？Qt里都提供了哪些内置的信号和槽可以让用户直接使用呢？</p><p><strong>多看文档！！</strong></p><p>在翻阅文档的时候，如果在当前类中没有找到对应的线索，不妨看看这个类的父类（的父类的父类…）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807141156575.png" alt="image-20240807141156575" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807141553836.png" alt="image-20240807141553836" style="zoom:80%;" /><p>QPushButton中没有找到click和clicked，去看看它的父类</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807141339271.png" alt="image-20240807141339271" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807141348894.png" alt="image-20240807141348894"  /><p>查阅文档的信号的时候，最重点的就是关注信号的发送时机（用户进行了啥样的操作，就能产生这个信号）</p></li><li><p>为什么<code>connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection)</code>原型中，函数指针是char*？不应该是根据函数不同，而设置不同的指针类型吗？</p><p>因为这个写法是Qt5之前的写法，在以前书写的时候，需要在信号函数指针和槽函数指针之前加上宏，将其转化为char*，长下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(button, <span class="built_in">SIGNAL</span>(&amp;QPushButton::clicked), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(&amp;Widget::close));</span><br></pre></td></tr></table></figure><p>Qt5开始，对上述写法进行了简化，不需要写SIGNAL和SLOT宏了，给connect提供了重载版本，在崇拜版本中，第二、四个参数变成了泛型参数，允许转入任意类型的<u>函数指针</u>了</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240808092507878.png" alt="image-20240808092507878"></p><blockquote><p>画横线的地方，是Qt封装的类型萃取器，</p></blockquote></li><li><p>信号函数和槽函数不取地址可以吗？</p><p>函数名取地址之后就是函数指针了。</p><p>在C中，如果要使用函数指针，可以直接用函数名，也可以取地址，尽管两个类型是不同的，但是地址值都是函数的首地址。</p><p>但是在C++和Qt中，强调了指针的类型了，函数名和函数指针的类型是不同的（如果函数类型为<code>void (int)</code>的话，那么对应的函数指针类型就是<code>void (*)(int)）</code>，尽管两个保存的地址值都相同，但是C++和Qt对类型加了限制，所以是不能通过的，必须取地址才可以。</p><blockquote><p>详细可以参考C++下的文章<a href="https://chunyujin.top/chunyujin/f389ecbc">C-指针进阶</a></p></blockquote></li></ol></li></ol></blockquote><h3 id="自定义信号和槽"><a href="#自定义信号和槽" class="headerlink" title="自定义信号和槽"></a>自定义信号和槽</h3><h5 id="自定义槽"><a href="#自定义槽" class="headerlink" title="自定义槽"></a>自定义槽</h5><p>两种方式：</p><blockquote><ol><li><p>手动编写声明定义</p><p>在头文件的类中加入槽的声明，在源文件中进行定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT<span class="comment">//某个类中如果要使用信号槽，那么类的开始必须要写上这个宏（Qt中的硬性规定，否则类在编译时会出错）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleMySignal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//自定义的槽的声明；slots为Qt中的关键字，用于说明下面的函数为槽函数；</span></span><br><span class="line">    <span class="comment">//slots前面可以根据情况添加public或private</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.cpp</span></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;Widget::handleMySignal);</span><br><span class="line"><span class="comment">//将ui界面中创建的对象&quot;pushButton&quot;的clicked信号与当前对象(widget)的自定义槽手动关联起来</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::handleMySignal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;自定义槽已经接收到了信号！！&quot;</span>);</span><br><span class="line">    <span class="comment">//自定义槽的定义</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在ui界面中自动生成某控件对象的信号转到的自定义槽</p><p>在ui界面中右击控件对象，弹出”转到槽“，点击之后进入选择界面</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240815135908956.png" alt="image-20240815135908956" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240815135929008.png" alt="image-20240815135929008" style="zoom:80%;" /><p>这个界面含义是”为下面的信号生成相关的自定义槽“，如：选择了<code>QAbstractButton</code>类的<code>clicked()</code>，则自动生成一个自定义槽，与此信号<mark>自动关联</mark>起来，此信号一发出，自定义槽则响应。</p><p>选择之后，头文件和源文件中自动生成了该自定义槽：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240815140813601.png" alt="image-20240815140813601" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240815141508087.png" alt="image-20240815141508087" style="zoom:80%;" /><blockquote><p>通过ui界面的方式自动生成的槽，是与ui控件对象的信号自动关联的，所以不需要再使用<code>connect</code>进行手动关联了</p></blockquote></li></ol></blockquote><p><strong>Qt中也允许自定义信号，但是槽函数作为响应，会更倾向于自定义，但是信号的触发一般就固定的几种（在GUI中，用户能进行哪些操作，是可以穷举的~），所以自定义信号相对较少</strong></p><h5 id="自定义信号"><a href="#自定义信号" class="headerlink" title="自定义信号"></a>自定义信号</h5><p>自定义信号用户只需要声明就可以了，自定义信号要放在关键字<code>signals</code>之下，这样Qt自动认为该函数为信号，并在内部自动生成函数定义(元编程)，用户无需干涉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT<span class="comment">//某个类中如果要使用信号槽，那么类的开始必须要写上这个宏（Qt中的硬性规定，否则类在编译时会出错）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line"></span><br><span class="line">signals:<span class="comment">//Qt自己扩展出来的关键字，会自动认为下面包含的函数为信号，并自动生成函数定义</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySignal</span><span class="params">()</span></span>;<span class="comment">//自定义信号，只需声明，无需实现，剩下的交给Qt来做</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于是自定义信号，并不是和Qt自带信号一样将行为与触发绑定起来(例如<code>PushButton类</code>自带的<code>clicked</code>信号，识别到按钮被点击，<code>clicked</code>信号就被自动发送出去)，所以自定义信号需要借助其他的方式进行”发射&#x2F;触发”，比如将自定义信号在函数中进行发射。在信号前面添加<code>emit</code>关键字，即可手动发射信号。</p><blockquote><ol><li><p>由于自定义信号并非Qt自带的信号，因此无法通过ui界面自动生成自定义槽函数，所以只能手动使用<code>connect</code>与槽进行关联。</p></li><li><p>信号与槽通过<code>connect</code>进行关联，只是建立了连接，使二者“产生了关系”，不代表信号已经发出来了。</p></li><li><p><code>emit</code> 手动发出信号，不止适用于自定义信号。<br>其实Qt5中<code>emit</code>什么都没做，真正的操作已经都包含在信号函数内部自动生成的定义中了；即使不写<code>emit</code>，函数也能发射出去。<br>即使如此，在实际开发中，还是建议加上<code>emit</code>，增加代码的可读性，可以明显地标识出：这里是发射自定义信号</p></li></ol></blockquote><p>下面一个例子：通过ui界面生成了一个<code>pushButton</code>对象的<code>clicked</code>信号转到的自定义槽，自定义槽执行的行为是发送一个自定义信号，该自定义信号再与另一个自定义槽手动关联起来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.cpp</span></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;Widget::mySignal, <span class="keyword">this</span>, &amp;Widget::handleMySignal);</span><br><span class="line">    <span class="comment">//建立连接，不代表信号已经发出来了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_pushButton_clicked</span><span class="params">()</span><span class="comment">//ui界面生成的转到槽，关联的信号是pushButton的clicked</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">mySignal</span><span class="params">()</span></span>;<span class="comment">//发送信号的行为可以在任意合适的代码中，不只可以在构造函数中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::handleMySignal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;自定义槽已经接收到自定义信号了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>pushButton</code>被点击之后，发送<code>clicked</code>信号，<code>on_pushButton_clicked</code>槽接收之后，执行发送<code>mySignal</code>信号的行为；<code>handleMySignal</code>槽接收到<code>mySignal</code>信号之后，更改窗口标题。</p></blockquote><h3 id="信号与槽的关联是多对多的"><a href="#信号与槽的关联是多对多的" class="headerlink" title="信号与槽的关联是多对多的"></a>信号与槽的关联是多对多的</h3><p>一个信号可以关联多个槽，一个槽也可以响应多个信号</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240815155439479.png" alt="image-20240815155439479" style="zoom:80%;" /><h3 id="带参数的信号和槽"><a href="#带参数的信号和槽" class="headerlink" title="带参数的信号和槽"></a>带参数的信号和槽</h3><p>信号和槽是可以带参数的，Qt自带的一些信号和槽是可以传参的；自定义信号和槽也是可以传参。</p><p>信号的参数列表会直接传递到connect关联的槽的参数列表，通过这种机制，就实现了从信号向槽传输数据</p><blockquote><p>在使用带信号信号和槽时，要确保：</p><ol><li>关联的信号和槽参数类型一致</li><li>关联的信号和槽参数数量可以不一样，但一定要确保信号参数&gt;&#x3D;槽参数，反之不行<br>&#x2F;&#x2F;为什么：因为槽可能会绑定多个信号，允许信号参数多于槽参数，使得槽可以兼容多个信号<br>&#x2F;&#x2F;个数不一致时，槽会根据参数顺序，拿到信号的前N个参数；至少会确保槽函数的每个参数都是有值的</li></ol></blockquote><p>更改一下上面的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.cpp</span></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;Widget::mySignal, <span class="keyword">this</span>, &amp;Widget::handleMySignal);</span><br><span class="line">    <span class="comment">//建立连接，不代表信号已经发出来了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_pushButton_clicked</span><span class="params">()</span><span class="comment">//ui界面生成的转到槽，关联的信号是pushButton的clicked</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">mySignal</span><span class="params">(<span class="string">&quot;&quot;</span>自定义槽已经接收到自定义信号了<span class="string">&quot;， &quot;</span>hello<span class="string">&quot;);</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function"></span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">void Widget::handleMySignal(QString text)//槽函数参数可以少于关联的信号参数，槽根据顺序取前N个</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">&#123;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">    this-&gt;setWindowTitle(text);</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function"></span></span></span></span><br></pre></td></tr></table></figure><h3 id="disconnect"><a href="#disconnect" class="headerlink" title="disconnect"></a>disconnect</h3><p>虽然说信号和槽可以多对多，但是有些场景下，多个信号和多个槽同时关联，可能会造成一些混乱，因此可以在适当的时机断开先前的关联，进而再创建新的关联</p><blockquote><p>主动断开，往往就是为了新的绑定</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;Widget::handlemyclick1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::handlemyclick1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;现在按钮1关联的槽1&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;slot1 works&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::handlemyclick2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;现在按钮1关联的槽2&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;slot2 works&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_pushButton_2_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">disconnect</span>(ui-&gt;pushButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;Widget::handlemyclick1);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;Widget::handlemyclick2);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><blockquote><p><code>on_pushButton_2_clicked()</code>为<code>pushButton2</code>的<code>clicked</code>信号（简称信号2）转到槽，作用是断开<code>pushButton1</code>的<code>clicked</code>信号（简称信号1）与<code>handlemyclick1</code>槽（简称槽1）的连接，将<code>pushButton1</code>的<code>clicked</code>信号（简称信号2）与<code>handlemyclick2</code>槽（简称槽2）连接。这样的话，下次点击<code>pushButton1</code>，就是槽2响应，而不是槽1响应了。</p><p>最开始，信号1与槽1关联，点击按钮1，槽1响应；信号2与其转到槽关联，点击按钮2，转到槽响应，断开了信号1与槽1，关联了信号1与槽2；因此第二次点击按钮1时，信号1发出，槽2响应。</p><blockquote><p>如果不断开信号1与槽1，则信号1发出时，槽1与槽2都会响应，会很混乱，特别是涉及到同一种行为的，窗口标题不知道到底是按照槽1显示，还是按照槽2显示</p></blockquote><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/test1.gif" alt="test1"></p><p>点击button1，显示”关联槽1”，点击button2之后，断开了button1与槽1的连接，将button1与槽2连接，此时点击button1，显示”关联槽2“，并且槽2会断开button1与自己的连接，将button1与槽1连接；再点击button1，显示“关联槽1”</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;信号与槽&quot;&gt;&lt;a href=&quot;#信号与槽&quot; class=&quot;headerlink&quot; title=&quot;信号与槽&quot;&gt;&lt;/a&gt;信号与槽&lt;/h2&gt;&lt;p&gt;&lt;code&gt;信号源&lt;/code&gt;发出(某种类型的)&lt;code&gt;信号&lt;/code&gt;，由&lt;code&gt;槽&lt;/code&gt;接收信号，并</summary>
      
    
    
    
    <category term="Qt" scheme="https://chunyujin.top/categories/Qt/"/>
    
    
    <category term="Qt" scheme="https://chunyujin.top/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt-解决MSVC下编码警告&amp;中文输入乱码</title>
    <link href="https://chunyujin.top/chunyujin/f7d3dfd8.html"/>
    <id>https://chunyujin.top/chunyujin/f7d3dfd8.html</id>
    <published>2024-08-19T05:07:00.000Z</published>
    <updated>2024-10-22T07:34:35.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>如果MSVC编译时，</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240813162138097.png" alt="image-20240813162138097" style="zoom:80%;" /><p>或者</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240819130658443.png" alt="image-20240819130658443"></p><p>在pro文件最下面加入：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">msvc</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">QMAKE_CFLAGS</span> <span class="string">+= /utf-8</span></span><br><span class="line">    <span class="attr">QMAKE_CXXFLAGS</span> <span class="string">+= /utf-8</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240813162216747.png" alt="image-20240813162216747" style="zoom:80%;" /><p>然后“重新构建”（一定要进行这步）即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;如果MSVC编译时，&lt;/p&gt;
&lt;img src=&quot;https://map--depot.oss-cn-hangzhou.aliyuncs.com/image</summary>
      
    
    
    
    <category term="Qt" scheme="https://chunyujin.top/categories/Qt/"/>
    
    
    <category term="Qt" scheme="https://chunyujin.top/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Windows将大写锁定键设置为中英文切换</title>
    <link href="https://chunyujin.top/chunyujin/679ac598.html"/>
    <id>https://chunyujin.top/chunyujin/679ac598.html</id>
    <published>2024-08-12T12:56:00.000Z</published>
    <updated>2024-10-22T07:34:35.298Z</updated>
    
    <content type="html"><![CDATA[<img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-12%20210205.png" alt="屏幕截图 2024-08-12 210205" style="zoom:80%;" /><ol><li>在“设置-时间和语言-语言”选择中文语言的选项</li></ol><p>​<img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812202640052.png" alt="image-20240812202640052" style="zoom:80%;" /></p><p>进入后点击微软输入法的选项</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812202720965.png" alt="image-20240812202720965" style="zoom:80%;" /><p>进入后在“按键”中确保选择了“ctrl+空格”进行大小写切换</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812202921875.png" alt="image-20240812202921875" style="zoom:80%;" /><ol start="2"><li><p>下载脚本工具<a href="https://www.autohotkey.com/">AutoHotkey</a>，本次教程的核心就是使用这个脚本，使CapsLock键映射为ctrl+空格，并判定长按的时间，超过一定时间就判定为按下大写锁定键，从而实现mac上一样的效果；将写好的脚本放在开机目录，开机自启动。</p><blockquote><p>顾名思义，autohotkey是一款热键管理管理脚本工具</p></blockquote></li><li><p>下载好之后进行安装，安装好之后就如下图，不用管，关闭就好</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812203552535.png" alt="image-20240812203552535" style="zoom:80%;" /></li><li><p>方法一：</p><p>新建一个记事本，命名一个比较贴近的名称</p><p>里面内容设置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">NoEnv</span></span><br><span class="line"></span><br><span class="line">SetCapsLockState, Alwaysoff</span><br><span class="line">SetStoreCapsLockMode, Off</span><br><span class="line"></span><br><span class="line">CapsLock::</span><br><span class="line">KeyWait, CapsLock, T0.3</span><br><span class="line">If ErrorLevel &#123;</span><br><span class="line">  Send, &#123;CapsLock&#125;</span><br><span class="line">  KeyWait, CapsLock</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  Send, &#123;Ctrl down&#125;&#123;Space down&#125;&#123;Space up&#125;&#123;Ctrl up&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>分析一下：如果大写锁定键按下时间小于0.3s，则映射为ctrl+空格，否则为大写锁定</p></blockquote><p>然后选择文件-另存为，选择类型为所有文件，然后更改文件后缀为.ahk（autohotkey的后缀）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812204406303.png" alt="image-20240812204406303" style="zoom:80%;" /></li></ol><p>​方法二：</p><p>​安装好autohotkey之后，在鼠标右键的新建里，已经可以看到可以新建autohotkey文件.ahk了，直接创建，然后填入上述代码即可</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812204526727.png" alt="image-20240812204526727" style="zoom:80%;" /><ol start="5"><li><p>点击运行这个文件，发现没有什么反应，并且按键也没有替换掉。</p><p>稍等片刻，弹出如下安装提醒AutoHotKey v1，这个软件就是自动化运行的关键</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812204749668.png" alt="image-20240812204749668" style="zoom:80%;" /></li></ol><p>​点击“是”之后，等待片刻，安装成功</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812204901843.png" alt="image-20240812204901843" style="zoom:80%;" /><ol start="6"><li><p>再次点击刚才创建的.ahk文件，运行成功，右下角菜单状态栏多了一个autohotkey v1正在运行的标志</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812205035150.png" alt="image-20240812205035150" style="zoom:80%;" /></li><li><p>现在将这个文件添加到开机自动文件夹中：<br>win+r打开“运行”，输入<strong>shell:startup</strong>，打开了启动文件夹（一般为C:\Users&lt;UserName&gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup）</p></li></ol><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812205301748.png" alt="image-20240812205301748" style="zoom:80%;" /><p>​将.ahk文件复制或者移动到这个目录下，开机的时候就会自动启动了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812205425257.png" alt="image-20240812205425257" style="zoom:80%;" /><blockquote><p>ps：如果这个目录下有你不想要开机自启动的东西，那就直接删掉他！</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-12%20210205.png&quot; alt=&quot;屏幕截图 20</summary>
      
    
    
    
    <category term="Skill" scheme="https://chunyujin.top/categories/Skill/"/>
    
    <category term="Windows" scheme="https://chunyujin.top/categories/Skill/Windows/"/>
    
    
    <category term="Windows" scheme="https://chunyujin.top/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Windows Terminal好处多多</title>
    <link href="https://chunyujin.top/chunyujin/5f48e093.html"/>
    <id>https://chunyujin.top/chunyujin/5f48e093.html</id>
    <published>2024-08-12T12:55:00.000Z</published>
    <updated>2024-10-22T07:34:35.297Z</updated>
    
    <content type="html"><![CDATA[<p>1. </p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812203736635.png" alt="image-20240812203736635" style="zoom: 80%;" /><p>Windows的新终端Windows terminal比原来的命令行工具好用很多，直接就是上位替代</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1. &lt;/p&gt;
&lt;img src=&quot;https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240812203736635.png&quot; alt=&quot;image-20240812203736635&quot; style=</summary>
      
    
    
    
    <category term="Skill" scheme="https://chunyujin.top/categories/Skill/"/>
    
    <category term="Windows" scheme="https://chunyujin.top/categories/Skill/Windows/"/>
    
    
    <category term="Windows" scheme="https://chunyujin.top/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>C++_NULL和nullptr的区别</title>
    <link href="https://chunyujin.top/chunyujin/f7a38933.html"/>
    <id>https://chunyujin.top/chunyujin/f7a38933.html</id>
    <published>2024-08-07T15:04:00.000Z</published>
    <updated>2024-10-22T07:34:35.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NULL和nullptr的区别"><a href="#NULL和nullptr的区别" class="headerlink" title="NULL和nullptr的区别"></a>NULL和nullptr的区别</h1><p>简单来说，C++中引入了&#96;&#96;nullptr<code>来专门用于指针的置空，解决了C语言中</code>NULL&#96;的二义性问题。</p><p>也就是说，以后要给指针赋予空，用<code>nullptr</code>就对了</p><p>详细参考链接：<a href="https://blog.csdn.net/qq_18108083/article/details/84346655">C++中NULL和nullptr的区别</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NULL和nullptr的区别&quot;&gt;&lt;a href=&quot;#NULL和nullptr的区别&quot; class=&quot;headerlink&quot; title=&quot;NULL和nullptr的区别&quot;&gt;&lt;/a&gt;NULL和nullptr的区别&lt;/h1&gt;&lt;p&gt;简单来说，C++中引入了&amp;#96;&amp;</summary>
      
    
    
    
    <category term="编程日志" scheme="https://chunyujin.top/categories/%E7%BC%96%E7%A8%8B%E6%97%A5%E5%BF%97/"/>
    
    <category term="C&amp;C++" scheme="https://chunyujin.top/categories/%E7%BC%96%E7%A8%8B%E6%97%A5%E5%BF%97/C-C/"/>
    
    
    <category term="C++" scheme="https://chunyujin.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C-指针进阶知识</title>
    <link href="https://chunyujin.top/chunyujin/f389ecbc.html"/>
    <id>https://chunyujin.top/chunyujin/f389ecbc.html</id>
    <published>2024-08-07T14:57:00.000Z</published>
    <updated>2024-10-22T07:34:35.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-指针进阶知识"><a href="#C-指针进阶知识" class="headerlink" title="C-指针进阶知识"></a>C-指针进阶知识</h2><h4 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p1;</span><br><span class="line"><span class="type">int</span> p2[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>* p3[<span class="number">5</span>];<span class="comment">//</span></span><br><span class="line"><span class="built_in">int</span> (*p4)[<span class="number">5</span>] = p3;<span class="comment">//数组指针</span></span><br></pre></td></tr></table></figure><blockquote><ol><li><p>*与变量名p结合的优先程度是最弱的， * 会优先与前面的类型参数进行结合，而变量又会先与后面的方括号、括号结合，所以如果想说明变量是指针，且变量后又有其他符号跟随，就必须用括号将 *和变量括起来，变成 ( *p )的形式。</p></li><li><p>p1是int类型的变量</p></li><li><p>p2的变量类型是<code>int [5]</code>，是一个数组，保存int类型的元素</p></li><li><p>p3的变量类型是<code>int* [5]</code>，是一个数组，保存int*类型的元素</p></li><li><p>p4先与* 结合，p4的变量类型是<code>int (*)[5]</code>，是一个指针。指向的是<code>int [5]</code>类型，即包含五个int类型元素的数组；即p4存储的是包含5个int类型元素的数组的地址。p4是数组指针</p><p>数组指针p4的值虽然和数组名p3一样，都是数组的起始地址，不过前者是”数组p3这个对象“的起始地址，后者是数组p3内首元素“的起始地址，它们的值完全相同，但是表示的范围跨度就不一样了，从现象上来看，数组指针是以一整个数组的空间为跨度，而数组首地址则是一个元素的空间为跨度</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807170034054.png" alt="image-20240807170034054" style="zoom:80%;" /></li></ol><p>*的本意：解引用</p></blockquote><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">void</span> (*add2)(<span class="type">int</span>);</span><br></pre></td></tr></table></figure><blockquote><ol><li>add1的变量类型是<code>void (int)</code>，是一个函数，特征为参数类型是int，返回值类型为void</li><li>add2的变量类型是<code>void (*)(int)</code>，是一个指针，指向特征为：参数类型是int，返回值类型为void 的函数</li></ol><p>函数指针使用时，一般写作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*add2)(<span class="type">int</span>) = add1;</span><br><span class="line"><span class="comment">//add2是一个函数指针，解引用后就是一个函数，所以解引用后用来承接一个函数</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="built_in">void</span> (*add2)(<span class="type">int</span>);</span><br><span class="line">add2 = &amp;add1;</span><br><span class="line"><span class="comment">//add2是一个函数指针，所以add2用来承接一个函数的地址（函数取地址了）</span></span><br></pre></td></tr></table></figure></blockquote><p>void (* test)()的test 不等于 void* test()的test<br>前者test是一个指向返回值为空、无参数的函数的指针；后者test是一个返回值为void*、无参数的函数</p><h6 id="add1与-amp-add1"><a href="#add1与-amp-add1" class="headerlink" title="add1与&amp;add1"></a>add1与&amp;add1</h6><blockquote><p><mark><code>add1</code>和<code>add2</code>（也就是<code>&amp;add1</code>）的值一样，都是函数的起始地址，但是类型不一样，含义也不太相同。</mark><br><mark><code>add1</code>的值是函数的首地址，它的类型是<code>void  (int)</code></mark><br><mark><code>add2</code>（也就是<code>&amp;add1</code>）表示的是一个指向函数<code>add1</code>这个对象的指针，它的类型是<code>void (*)(int)</code></mark><br><mark><code>add1</code>和<code>add2</code>（即<code>&amp;add1</code>）所代表的地址值是一样的，但是类型不一样</mark></p><p>为什么要强调这一点？</p><p>因为在一些语言或者框架下，对于类型有比较严格的要求（比如Qt的connect函数），函数指针就必须是函数名取地址(&amp;add1这种)，确保是诸如void (*)(int)这种类型，否则会报错。</p><p>C语言中要求没有这么严格，add和&amp;add可以混用，比如add就可以作为下面函数指针数组的元素使用。</p></blockquote><h4 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*p[<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure><blockquote><p>p的变量类型是<code>void (*[5])(int, int)</code>，是一个数组，保存的元素的类型为<code>void (*)(int, int)</code>，是指向<code>void (int, int)</code>类型的指针，即指向返回值为空、两个参数为int的函数。</p><p>函数指针数组的使用：转移表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如用转移表来写一个计算器</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> input = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> (*p[<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>) = &#123;<span class="number">0</span>, add, sub, mul, div&#125;;<span class="comment">//转移表</span></span><br><span class="line">    <span class="comment">//注意这里使用了add(int (int,int)类型)，而不是&amp;add即int(*)(int,int)类型</span></span><br><span class="line">    <span class="comment">//因为C语言对于这个不是很严格</span></span><br><span class="line">    <span class="keyword">while</span> (input)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>( <span class="string">&quot;*************************\n&quot;</span> );</span><br><span class="line">         <span class="built_in">printf</span>( <span class="string">&quot;  1:add           2:sub  \n&quot;</span> );</span><br><span class="line">         <span class="built_in">printf</span>( <span class="string">&quot;  3:mul           4:div  \n&quot;</span> );</span><br><span class="line">         <span class="built_in">printf</span>( <span class="string">&quot;*************************\n&quot;</span> );</span><br><span class="line">         <span class="built_in">printf</span>( <span class="string">&quot;请选择：&quot;</span> );</span><br><span class="line">         <span class="built_in">scanf</span>( <span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">         <span class="keyword">if</span> ((input &lt;= <span class="number">4</span> &amp;&amp; input &gt;= <span class="number">1</span>))</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">printf</span>( <span class="string">&quot;输入操作数：&quot;</span> );</span><br><span class="line">             <span class="built_in">scanf</span>( <span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">             ret = (*p[input])(x, y);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         <span class="built_in">printf</span>( <span class="string">&quot;输入有误\n&quot;</span> );</span><br><span class="line">         <span class="built_in">printf</span>( <span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">      &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="指向函数指针数组的指针"><a href="#指向函数指针数组的指针" class="headerlink" title="指向函数指针数组的指针"></a>指向函数指针数组的指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*(*p)[<span class="number">5</span>]) (<span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>p是一个指针，指向类型为<code>int (*[5]) (int)</code>的对象，该对象是一个数组，存储的元素类型为<code>int (*)(int)</code>，即函数指针。所以p是指向函数指针数组的指针</p><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>如果一个函数B，其指针作为另一个函数A的参数，并再A中被调用了，那么B就称为回调函数。</p><blockquote><p>回调函数不是直接就使用的，而是由其他函数作为参数传入后，在某个时期（比如放在顺序执行的某个位置或者满足某个特定的事件、条件）被这个函数调用的。也就是说，调用方先执行自己的语句，回过头来再调用这个函数，所以这个函数叫做“回调函数”</p></blockquote><p>基本结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Callback)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//回调函数类型名称重命名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">claculateSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b,Callback cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> sum = a + b;</span><br><span class="line">  <span class="built_in">cb</span>(sum);</span><br><span class="line">  <span class="comment">//调用回调函数，将结果传递给回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">printSum</span><span class="params">(<span class="type">int</span> sum)</span><span class="comment">//定义回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;计算结果为：%d\n&quot;</span>,sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;回调函数已调用\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> *ret = <span class="built_in">caluculateSum</span>(<span class="number">6</span>, <span class="number">2</span>, printSum);</span><br><span class="line">  <span class="comment">//调用calculateSum函数，并将printSum函数作为回调函数传递</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">预期结果：</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">回调函数已调用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="typedef的用法"><a href="#typedef的用法" class="headerlink" title="typedef的用法"></a>typedef的用法</h5><p>typedef用来为某个类型起别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> CHAR;</span><br><span class="line"><span class="comment">//为char类型起别名CHAR，这样就可以用CHAR来声明变量了</span></span><br><span class="line">CHAR c = <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>typedef一次可以为一个类型起多个别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> antelope, bagel, mushroom;</span><br><span class="line"><span class="comment">//typedef为int取了三个别名</span></span><br><span class="line">bagel i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>typedef可以为数组起别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> array[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//typedef为int [5]类型的数组取别名</span></span><br><span class="line">array nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>由此可以看到，使用typedef取别名的时候，别名的位置就在变量名的位置上</strong></p><p>typedef为函数指针取别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*func)</span> <span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//为void (*)(int,int)类型取别名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printAdd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func = &amp;printAdd;</span><br></pre></td></tr></table></figure><blockquote><p>typedef的主要好处</p><ol><li><p>更好的代码可读性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* STRING;</span><br><span class="line"></span><br><span class="line">STRING name = <span class="string">&quot;chenyujin&quot;</span>;</span><br></pre></td></tr></table></figure><p>用<code>STRING</code>声明变量的时候，就可以轻易辨别该变量是字符串</p></li><li><p>为struct、union、enum等命令定义复杂的数据结构创建别名，从而便于引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">treenode</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">treenode</span>* TreeNode;</span><br></pre></td></tr></table></figure><p><code>TreeNode</code>为<code>struct treenode*</code>的别名</p><p>也可以在struct定义数据写在一起</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">treenode</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; *TreeNode;</span><br></pre></td></tr></table></figure><p><code>TreeNode</code>为<code>struct treenode*</code>的别名</p></li><li><p>方便以后为变量更改类型</p></li><li><p>可移植性</p><p>某一个值在不同计算机上的类型，可能是不一样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i = 100000;</span><br></pre></td></tr></table></figure><p>上面代码在32位整数的计算机没有问题，但是在16位整数的计算机就会出错。</p><p>C 语言的解决办法，就是提供了类型别名，在不同计算机上会解释成不同类型，比如<code>int32_t</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int32_t i = 100000;</span><br></pre></td></tr></table></figure><p>上面示例将变量<code>i</code>声明成<code>int32_t</code>类型，保证它在不同计算机上都是32位宽度，移植代码时就不会出错。</p><p>这一类的类型别名都是用 typedef 定义的。下面是类似的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef long int ptrdiff_t;typedef unsigned long int size_t;typedef int wchar_t;</span><br></pre></td></tr></table></figure><p>这些整数类型别名都放在头文件<code>stdint.h</code>，不同架构的计算机只需修改这个头文件即可，而无需修改代码。</p><p>因此，<code>typedef</code>有助于提高代码的可移植性，使其能适配不同架构的计算机。</p></li><li><p>简化类型声明</p><p>C 语言有些类型声明相当复杂，比如下面这个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char (*(*x(void))[5])(void);</span><br></pre></td></tr></table></figure><p>typedef 可以简化复杂的类型声明，使其更容易理解。首先，最外面一层起一个类型别名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef char (*Func)(void);Func (*x(void))[5];</span><br></pre></td></tr></table></figure><p>这个看起来还是有点复杂，就为里面一层也定义一个别名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef char (*Func)(void);typedef Func Arr[5];Arr* x(void);</span><br></pre></td></tr></table></figure><p>上面代码就比较容易解读了。</p><ul><li><code>x</code>是一个函数，返回一个指向 Arr 类型的指针。</li><li><code>Arr</code>是一个数组，有5个成员，每个成员是<code>Func</code>类型。</li><li><code>Func</code>是一个函数指针，指向一个无参数、返回字符值的函数。</li></ul></li></ol><p>该部分参考自<a href="https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-typedef.md">typedef 命令 - 《阮一峰《C 语言教程》》 - 书栈网 · BookStack</a></p></blockquote><h5 id="void-的用法"><a href="#void-的用法" class="headerlink" title="void*的用法"></a>void*的用法</h5><ol><li><p><code>void*</code>表示”任意类型的指针“，它可以接收任意类型的指针，而不必进行强制类型转换，经常用于作为回调函数中的参数类型，因为这样可以接受任何类型的指针了，包括各种类型的函数指针</p></li><li><p>当然，<code>void*</code> 不只可以用于回调函数，不知用于承接各种函数指针，void* 可以承接各种类型的指针，用于任何你想用的地方</p></li><li><p><code>void*</code>可以直接和其他类型的指针比较存放的地址值是否相同</p></li><li><p>当要使用<code>void*</code>的时候，必须要进行强制类型转换，否则不知道这个指针究竟是什么类型的</p><blockquote><p>这里要补充的是，<code>承接</code>和<code>使用</code>不同，一个是被赋值，一个是用与进行操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d_num = <span class="number">3.145</span>;</span><br><span class="line"><span class="type">void</span> * d_point = &amp;d_num;<span class="comment">//承接</span></span><br><span class="line">cout &lt;&lt; *(<span class="type">double</span>*)d_point &lt;&lt; endl;<span class="comment">//使用，此处是打印d_point指向的对象的值</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><code>void*</code>和其他所有指针一样，可以通过NULL或nullptr来初始化，表示一个空指针</p><blockquote><p>NULL和nullptr的区别，请见“编程日志”的C++目录下的“NULL和nullptr的区别”<a href="https://chunyujin.top/chunyujin/f7a38933">C++_NULL和nullptr的区别</a></p></blockquote></li><li><p>当<code>void*</code>作为函数的输入和输出时，表示可以接受和输出任意类型的指针</p><p>如果函数的参数或返回值可以是任意类型的指针，那么应声明其类型为<code>void*</code></p><blockquote><p>这里是不是和模版有点类似，模版是泛型编程，模版参数也是可以表示任意类型，只不过在使用的时候需要显式表明</p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-指针进阶知识&quot;&gt;&lt;a href=&quot;#C-指针进阶知识&quot; class=&quot;headerlink&quot; title=&quot;C-指针进阶知识&quot;&gt;&lt;/a&gt;C-指针进阶知识&lt;/h2&gt;&lt;h4 id=&quot;数组指针&quot;&gt;&lt;a href=&quot;#数组指针&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Cpp" scheme="https://chunyujin.top/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://chunyujin.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Qt代码格式化-使用astyle插件</title>
    <link href="https://chunyujin.top/chunyujin/3a989153.html"/>
    <id>https://chunyujin.top/chunyujin/3a989153.html</id>
    <published>2024-08-07T13:37:00.000Z</published>
    <updated>2024-10-22T07:34:35.294Z</updated>
    
    <content type="html"><![CDATA[<p>具体配置请见下面文章<a href="https://www.cnblogs.com/hhddd-1024/p/17812399.html">天上人间 (cnblogs.com)</a></p><blockquote><p>其他参考文章：<br><a href="https://www.jianshu.com/p/e91ed18d4cfd">QT 代码格式化 | 配置Beautifier - 简书 (jianshu.com)</a><br><a href="https://blog.csdn.net/okpfsje123/article/details/107933946">qt creator 代码格式化工具Astyle的配置_qt creater 配置astyle-CSDN博客</a></p><p><a href="https://blog.csdn.net/zzs0829/article/details/83933747">Qt Creator 代码格式化的高级配置_qt creator代码格式化-CSDN博客</a></p></blockquote><h2 id="以下是补充说明："><a href="#以下是补充说明：" class="headerlink" title="以下是补充说明："></a>以下是补充说明：</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807094452154.png" alt="image-20240807094452154" style="zoom:80%;" /><blockquote><p>红色部分是astyle可执行程序的路径</p><p>蓝色部分是用户自定义的模块：<br>点击“Add”为添加新设置，“Edit”对于当前模块进行更改</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807094707645.png" alt="image-20240807094707645" style="zoom:80%;" /><blockquote><p>模块的设置基本框架为：<br>Name可以自定义<br>Value部分：</p><p>​必须先使用<code>--style=</code>添加一个astyle的固定风格，该风格是astyle插件中预先设置好的诸多风格之一，可以在[astyle官方文档](<a href="https://astyle.sourceforge.net/astyle.html">Artistic Style (sourceforge.net)</a>)进行查看，也可以在astyle安装目录子文件夹file下查看有哪些预定风格：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807095017257.png" alt="image-20240807095017257" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807095005956.png" alt="image-20240807095005956" style="zoom:80%;" /><p>需要注意的是，在自定义Value部分时，必须要先设定好这样一个风格，否则会报错如：<br>Failed to format: The command “D:\software\astyle-3.5.2-x64\astyle.exe” terminated with exit code 1..<br>Error in Beautifier: Cannot open documentation file “C:&#x2F;Users&#x2F;30297&#x2F;AppData&#x2F;Roaming&#x2F;QtProject&#x2F;qtcreator&#x2F;beautifier&#x2F;documentation&#x2F;artisticstyle.xml”.<br>等</p><p>另外就是自定义部分，下面是一个基于allman格式的自定义模板：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--style=allman</span><br><span class="line">indent=spaces=4# 缩进采用4个空格</span><br><span class="line">indent-switches# -S  设置 switch 整体缩进</span><br><span class="line">indent-cases# -K  设置 cases 整体缩进</span><br><span class="line">indent-namespaces# -N  设置 namespace 整体缩进</span><br><span class="line">indent-preproc-block# -xW 设置预处理模块缩进</span><br><span class="line">indent-preproc-define   # -w  设置宏定义模块缩进</span><br><span class="line">pad-oper                # -p  操作符前后填充空格</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">delete-empty-lines      <span class="comment"># -xe 删除多余空行</span></span></span><br><span class="line">add-braces              # -j  单行语句加上大括号</span><br><span class="line">align-pointer=name      # *、&amp;这类字符靠近变量名字</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">align-pointer=<span class="built_in">type</span></span></span><br></pre></td></tr></table></figure><p>如果自定义配置格式书写有问题，也会出现上述报错。即上述报错一般都源自于自定义配置模块编写出错，仔细检查对照一下即可。</p></blockquote></blockquote><h3 id="设置保存文件时自动格式化"><a href="#设置保存文件时自动格式化" class="headerlink" title="设置保存文件时自动格式化"></a>设置保存文件时自动格式化</h3><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240807095404788.png" alt="image-20240807095404788" style="zoom: 67%;" /><p>“Enable auto format on file save”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;具体配置请见下面文章&lt;a href=&quot;https://www.cnblogs.com/hhddd-1024/p/17812399.html&quot;&gt;天上人间 (cnblogs.com)&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其他参考文章：&lt;br&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="Qt" scheme="https://chunyujin.top/categories/Qt/"/>
    
    
    <category term="Qt" scheme="https://chunyujin.top/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt如何使用第三方库</title>
    <link href="https://chunyujin.top/chunyujin/5a0ef924.html"/>
    <id>https://chunyujin.top/chunyujin/5a0ef924.html</id>
    <published>2024-08-04T03:43:00.000Z</published>
    <updated>2024-10-22T07:34:35.281Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202408041147279.png" alt="截屏2024-08-04 11.46.25"></p><h2 id="1-获取库的-dll和-lib-或-a"><a href="#1-获取库的-dll和-lib-或-a" class="headerlink" title="1.获取库的.dll和.lib(或.a)"></a>1.获取库的.dll和.lib(或.a)</h2><h3 id="在资源管理器中找到对应库的-dll和-lib-或-a"><a href="#在资源管理器中找到对应库的-dll和-lib-或-a" class="headerlink" title="在资源管理器中找到对应库的.dll和.lib(或.a)"></a>在资源管理器中找到对应库的.dll和.lib(或.a)</h3><h4 id="如果第三方库不是Qt生成的："><a href="#如果第三方库不是Qt生成的：" class="headerlink" title="如果第三方库不是Qt生成的："></a>如果第三方库不是Qt生成的：</h4><p>通常比较规范的第三方库，有<code>lib</code>和<code>include</code>两个文件夹。<code>lib</code>文件夹就是包含的库文件。<code>include</code>则包含头文件。</p><h4 id="如果第三方库是Qt生成的："><a href="#如果第三方库是Qt生成的：" class="headerlink" title="如果第三方库是Qt生成的："></a>如果第三方库是Qt生成的：</h4><p>（通过Qt创建库的方法请见另一篇文章）</p><p>第三方库的构建时可以选择构建套件(Kit)：</p><blockquote><p>使用的<code>MSVC</code>编译：编译后会生成<code>.dll</code>和<code>.lib</code>两个文件。<code>.dll</code>在运行应用程序时调用，<code>.lib</code>在应用程序隐式调用动态链接库时使用<br>使用<code>MinGW</code>编译：编译后会生成<code>.dll</code>和<code>.a</code>两个文件，<code>.dll</code>在运行应用程序时调用，<code>.a</code>在应用程序隐式调用动态链接库时使用</p><p><mark>注意，如果一个项目中使用了第三方库，构建项目时使用的套件，必须与使用的第三方库构建使用的套件一致，否则会报错”link1104“错误</mark></p><blockquote><p>即如果第三方库用的MinGW编译，项目中添加的库文件是.a，那么项目构建的时候，也是用MinGW编译才可以通过</p></blockquote></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803102506454.png" alt="image-20240803102506454" style="zoom: 80%;" /><p>构建时可以选择套件、构建的位置，如果选择了Debug，则应该到中间文件目录的Debug文件夹下去找构建后的库：<br>中间文件目录会生成到项目文件的同级目录下：</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803103351534.png" alt="image-20240803103351534"></p><h2 id="2-获取库的头文件"><a href="#2-获取库的头文件" class="headerlink" title="2.获取库的头文件"></a>2.获取库的头文件</h2><h3 id="在资源管理器中找到对应库的头文件"><a href="#在资源管理器中找到对应库的头文件" class="headerlink" title="在资源管理器中找到对应库的头文件"></a>在资源管理器中找到对应库的头文件</h3><h4 id="如果第三方库不是Qt生成的：-1"><a href="#如果第三方库不是Qt生成的：-1" class="headerlink" title="如果第三方库不是Qt生成的："></a>如果第三方库不是Qt生成的：</h4><p>一般就存在于第三方库的<code>include</code>文件夹下</p><h4 id="如果第三方库是Qt生成的：-1"><a href="#如果第三方库是Qt生成的：-1" class="headerlink" title="如果第三方库是Qt生成的："></a>如果第三方库是Qt生成的：</h4><p>头文件存在于项目目录下</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240804110803753.png" alt="image-20240804110803753" style="zoom:80%;" /><h2 id="3-在项目中添加该库文件-及-相关头文件"><a href="#3-在项目中添加该库文件-及-相关头文件" class="headerlink" title="3.在项目中添加该库文件 及 相关头文件"></a>3.在项目中添加该库文件 及 相关头文件</h2><h4 id="方法一：不拷贝（推荐）"><a href="#方法一：不拷贝（推荐）" class="headerlink" title="方法一：不拷贝（推荐）"></a>方法一：不拷贝（推荐）</h4><h5 id="添加库"><a href="#添加库" class="headerlink" title="添加库"></a>添加库</h5><p>右击项目，选择“添加库”</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803163413609.png" alt="image-20240803163413609" style="zoom:80%;" /><p>或者打开.pro文件，在空白处右击鼠标，选择添加库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803163448944.png" alt="image-20240803163448944" style="zoom: 80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803164247193.png" alt="image-20240803164247193" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803164401963.png" alt="image-20240803164401963" style="zoom:80%;" /><p>点击库文件的“浏览”，库的.a文件。如果库是Qt生成的，则找到对应的中间文件目录的debug目录或者release目录，找到对应的.a文件。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803164505781.png" alt="image-20240803164505781" style="zoom: 80%;" /><h5 id="添加库的头文件路径"><a href="#添加库的头文件路径" class="headerlink" title="添加库的头文件路径"></a>添加库的头文件路径</h5><p>点击“包含路径”后面的“浏览”</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240804111413939.png" alt="image-20240804111413939" style="zoom:80%;" /><p>找到库的项目目录（如果库是Qt构建的），选中，然后点击右下角选择文件夹</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240804111523486.png" alt="image-20240804111523486" style="zoom:80%;" /><blockquote><p>因为Qt的头文件在项目目录下</p></blockquote><p>完成之后，确定剩余的勾选项，然后一直下一步，直到结束</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240804111646721.png" alt="image-20240804111646721" style="zoom:80%;" /><blockquote><p>关于勾选项：<br><code>平台</code>：如果不是Linux和mac平台，可以只选Windows<br><code>链接</code>：根据需求选择，可以直接选动态<br><code>Windows</code>下的选项：<br>            因为当前使用的库并不是存在于中间文件目录的debug或release子目录下，而是复制到了工程目录下，所以不勾选<br>            “为debug版本添加’d’作为后缀”建议不勾选（勾选了之后在.pro文件中会在库名后加一个d，构建时容易报错“找不到库文件”，如果勾选上，在.pro将d删除即可</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803112021251.png" alt="image-20240803112021251" style="zoom:80%;" /><p>​“移除release版本中的’d’后缀”不勾选</p></blockquote><p>此处可以查看一下项目的<code>.pro</code>文件，里面有和库有关的配置信息：<br>在添加完库之后，<code>.pro</code>文件中会新生成几行：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240804112017650.png" alt="image-20240804112017650" style="zoom:80%;" /><blockquote><p>其中<code>LIBS</code>是确定库的所在位置（-L），以及库名（-l）</p><p><code>INCLUDEPATH</code>是指定头文件的搜索路径</p><p><code>DEPENDPATH</code>用于指定项目中的源文件所依赖的头文件的搜索路径</p><p>（二者区别见<a href="https://blog.csdn.net/weixin_45650767/article/details/129740691">Qt构建中DEPENDPATH和INCLUDEPATH区别</a>）</p></blockquote><h5 id="使用库"><a href="#使用库" class="headerlink" title="使用库"></a>使用库</h5><p>现在就可以使用库了，本例中使用的<code>des.h</code>即为库中的头文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240804112409882.png" alt="image-20240804112409882" style="zoom:80%;" /><h4 id="方法二：拷贝"><a href="#方法二：拷贝" class="headerlink" title="方法二：拷贝"></a>方法二：拷贝</h4><h5 id="将库文件拷贝到当前项目下，新建目录"><a href="#将库文件拷贝到当前项目下，新建目录" class="headerlink" title="将库文件拷贝到当前项目下，新建目录"></a>将库文件拷贝到当前项目下，新建目录</h5><p>在工程目录下创建一个新的文件夹(此处取名<code>lib</code>，随意)，将库的<code>.dll</code>和<code>.a</code>复制进去(此处以.a为例)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803105505302.png" style="zoom:80%;" /><h5 id="将库的头文件拷贝到当前项目下，新建目录"><a href="#将库的头文件拷贝到当前项目下，新建目录" class="headerlink" title="将库的头文件拷贝到当前项目下，新建目录"></a>将库的头文件拷贝到当前项目下，新建目录</h5><p>在项目目录下新建文件夹（此处取名<code>include</code>，随意），将库头文件拷贝进来（如果多个头文件，建议全部拷贝，因为可能互相包含）。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803170601334.png" alt="image-20240803170601334" style="zoom:80%;" /><p>在Qt Creator中，右击项目中的Header文件夹，点击“Add Existing Directory”（也可以选择“添加现有文件”但是是单文件添加，效率低）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803170832859.png" alt="image-20240803170832859" style="zoom:80%;" /><p>选择当前项目目录下的<code>include</code>文件夹</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803171320095.png" alt="image-20240803171320095" style="zoom:80%;" /><p>稍等片刻，项目中就添加完成了，同时<code>.pro</code>文件中也更新了配置</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803171509008.png" alt="image-20240803171509008" style="zoom:80%;" /><h5 id="添加库和头文件路径"><a href="#添加库和头文件路径" class="headerlink" title="添加库和头文件路径"></a>添加库和头文件路径</h5><p>在Qt Creator中右击项目名，点击添加库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803110136850.png" alt="image-20240803110136850" style="zoom:80%;" /><p>或者，打开项目的<code>.pro</code>文件，右击空白处，点击添加库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803110224689.png" alt="image-20240803110224689" style="zoom:80%;" /><p>选择“外部库”</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803110249815.png" alt="image-20240803110249815" style="zoom:80%;" /><p>点击“库文件”右侧“浏览”</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803110445314.png" alt="image-20240803110445314" style="zoom:80%;" /><p>找到刚在工程目录下创建的lib文件夹下的<code>.a</code>文件，选中打开即可</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803110701026.png" alt="image-20240803110701026" style="zoom:67%;" /><p>完成后会发现“包含路径”一栏已经自动填充，而且是自动选择了项目目录下的include目录，即刚才拷贝过来的库头文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240804113021433.png" alt="image-20240804113021433" style="zoom:80%;" /><p>关于勾选框，左下如果没有特别情况，只勾选Windows即可。右侧Windows中，“debug或release子目录下的库”，如果是Qt生成的库，可以选上。“为debug版本添加’d‘作为后缀”不勾选。（详细看方法一此处介绍）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240804113716498.png" alt="image-20240804113716498" style="zoom:80%;" /><p>之后一路点击“下一步”即可。</p><h5 id="使用库-1"><a href="#使用库-1" class="headerlink" title="使用库"></a>使用库</h5><p>此时就可以使用库了，在引入头文件的时候，可以写相对路径，也可以不写</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803172511304.png" alt="image-20240803172511304" style="zoom:80%;" /><p>构建一下，通过，可以正常使用</p><h4 id="方法三：其他方式（不太推荐）"><a href="#方法三：其他方式（不太推荐）" class="headerlink" title="方法三：其他方式（不太推荐）"></a>方法三：其他方式（不太推荐）</h4><p>比如不在添加库时指定头文件目录，而是添加库后，在项目中添加现有文件夹（Add Existing Directory），在调用使用头文件时，使用绝对路径的方式</p><p>在Qt Creator中，右击项目中的<code>Headers</code>文件夹，选择“Add Existing Directory”（也可以选择“添加现有文件”但是是单文件添加，效率低）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803173247613.png" alt="image-20240803173247613" style="zoom:80%;" /><p>点击“浏览”，找到库（如果是Qt库，则找到该项目文件夹），选择（而不是进入），点击“选择文件夹</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803173420793.png" alt="image-20240803173420793" style="zoom:80%;" /><p>然后点击”Start Parsing“，更新目录范围，点击三角图标，展开目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803173614776.png" alt="image-20240803173614776" style="zoom:80%;" /><p>然后在下面栏中使用通配符*进行筛选，点击Apply Filters，即可选中所有.h文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803175409005.png" alt="image-20240803175409005" style="zoom:80%;" /><p>按下OK，即可添加完毕<br>项目的.pro文件中也更新了配置</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803175507117.png" alt="image-20240803175507117" style="zoom:80%;" /><p>在使用时，不能直接引用头文件原名，否则查找不到：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803175641151.png" alt="image-20240803175641151" style="zoom:80%;" /><p>需要写上绝对路径或者相对路径，相对路径写法可以参考.pro文件中的：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20240803175859426.png" alt="image-20240803175859426" style="zoom:80%;" /><p>构建一下，通过，可以正常使用</p><h2 id="4-写在后面："><a href="#4-写在后面：" class="headerlink" title="4.写在后面："></a>4.写在后面：</h2><p>还是老生常谈的问题：</p><p><mark>如果一个项目中使用了第三方库，构建项目时使用的套件，必须与使用的第三方库构建使用的套件一致，否则会报错”link1104“错误</mark></p><blockquote><p>即如果第三方库用的<code>MinGW</code>编译，生成的库文件包含的是<code>.a</code>，项目中添加的库文件是<code>.a</code>，那么项目构建的时候，也是用<code>MinGW</code>编译才可以通过</p><p>如果第三方库用的<code>MSVC</code>编译，生成的库文件包含的是<code>.lib</code>，项目中添加的库文件是<code>.lib</code>，那么项目构建的时候，也是用<code>MSVC</code>编译才可以通过</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202408041147279.png&quot; alt=&quot;截屏2024-08-04 11.46.25&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-获取库的-dll和</summary>
      
    
    
    
    <category term="Qt" scheme="https://chunyujin.top/categories/Qt/"/>
    
    
    <category term="Qt" scheme="https://chunyujin.top/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>C++_范围for</title>
    <link href="https://chunyujin.top/chunyujin/d5cdc759.html"/>
    <id>https://chunyujin.top/chunyujin/d5cdc759.html</id>
    <published>2024-07-19T08:31:00.000Z</published>
    <updated>2024-10-22T07:34:35.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-范围for"><a href="#C-范围for" class="headerlink" title="C++_范围for"></a>C++_范围for</h1><p>通常遍历STL的方式有三种：</p><ol><li>通过下标+循环 （只适用于顺序存储结构）</li><li>迭代器iterator（STL容器都自带）</li><li>范围for</li></ol><p>下面讲解一下范围for：<br>范围for的实现逻辑实际上就是调用了迭代器iterator，通过查看汇编就可以看出来</p><p>范围for是遍历STL中的每一个元素</p><blockquote><p>这里不要和迭代器搞混，迭代器是访问的元素的地址，然后再解引用迭代器，访问到的元素</p><p>范围for使用时变量直接就是获取到的元素（也就是包含了用迭代器获取地址+迭代器解引用）</p></blockquote><p>下面是一个使用案例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//范围for</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">char</span> ch : s)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器iterator</span></span><br><span class="line">string::iterator it = s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it!= s.<span class="built_in">end</span>())<span class="comment">//注意要使用不等号而不是小于号，因为某些数据结构地址空间不一定是连续的</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it;</span><br><span class="line">    it++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当然，使用auto更为简便</span></span><br><span class="line"><span class="comment">//范围for</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> ch : s)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="keyword">auto</span> it = s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it != s.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it;</span><br><span class="line">    it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-范围for&quot;&gt;&lt;a href=&quot;#C-范围for&quot; class=&quot;headerlink&quot; title=&quot;C++_范围for&quot;&gt;&lt;/a&gt;C++_范围for&lt;/h1&gt;&lt;p&gt;通常遍历STL的方式有三种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过下标+循环 （只适用于顺序存储结</summary>
      
    
    
    
    <category term="Cpp" scheme="https://chunyujin.top/categories/Cpp/"/>
    
    
    <category term="Cpp" scheme="https://chunyujin.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>MySQL_数据库备份与还原</title>
    <link href="https://chunyujin.top/chunyujin/642648e5.html"/>
    <id>https://chunyujin.top/chunyujin/642648e5.html</id>
    <published>2024-07-19T07:55:00.000Z</published>
    <updated>2024-10-22T07:34:35.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h1><h2 id="备份命令在shell命令行进行"><a href="#备份命令在shell命令行进行" class="headerlink" title="备份命令在shell命令行进行"></a>备份命令在shell命令行进行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mysqldump [-P端口号] -u用户名 -p密码 [-B] 数据库名 &gt; 备份后的名称.bak.sql</span></span><br></pre></td></tr></table></figure><blockquote><p>[ ]内的是可以省略的</p><p>-u和用户名、-p和密码之间可以加空格，可以不加</p><p>-B和数据库名之间必须有空格（如果-B没有省略的话）</p><p>端口号可能是3306，取决于数据库有没有指定端口</p><p>备份后的文件要具体到路径，否则认为当前工作路径（同其他shell命令一样）</p></blockquote><p>eg1：<code>mysqldump -uroot -p0295 test2 &gt; ../test2.bak.sql</code>备份到了父目录</p><p>eg2：<code>mysqldump -P3306 -uroot -p0295 test2 &gt; test2.bak.sql</code>备份到了当前目录</p><p><strong>可以多个数据库同时备份</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mysqldump [-P端口号] -u用户名 -p密码 [-B] 数据库1 数据库2 &gt; 备份后的名称.bak.sql</span></span><br></pre></td></tr></table></figure><p>eg：<code>mysqldump -uroot -p0295 -B test2 test_mysql &gt; test.back.sql</code>两个数据库备份到了一个备份文件上</p><p><strong>也可以只进行数据库中表的备份</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mysqldump [-P端口号] -u用户名 -p密码 数据库名 表1 表2 &gt; 备份后的名称.bak.sql</span></span><br></pre></td></tr></table></figure><blockquote><p>备份表的时候不能加-B，因为-B是专用于数据库的，否则会把表名当成数据库名</p></blockquote><p>eg：<code>mysqldump -uroot -p0295 test2 test2_table1 &gt; test_table1.back.sql</code></p><blockquote><p>》 本文为<a href="https://blog.musnow.top/posts/2109090510/%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%8E%E8%A1%A5%E5%85%85%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%81%E7%BD%AE%E9%A1%B6%E9%93%BE%E6%8E%A5">https://blog.musnow.top/posts/2109090510/的总结与补充其他知识点详见置顶链接</a></p></blockquote><h2 id="还原命令在mysql中执行"><a href="#还原命令在mysql中执行" class="headerlink" title="还原命令在mysql中执行"></a>还原命令在mysql中执行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; source 备份文件路径</span><br></pre></td></tr></table></figure><p>eg：<code>source /yj/test2.bak.sql</code></p><p>数据库中的内容和原来数据库中的内容是相同的</p><p>mysql备份的时候，会将里面的语句智能化简</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库备份&quot;&gt;&lt;a href=&quot;#数据库备份&quot; class=&quot;headerlink&quot; title=&quot;数据库备份&quot;&gt;&lt;/a&gt;数据库备份&lt;/h1&gt;&lt;h2 id=&quot;备份命令在shell命令行进行&quot;&gt;&lt;a href=&quot;#备份命令在shell命令行进行&quot; class=&quot;he</summary>
      
    
    
    
    <category term="MySQL" scheme="https://chunyujin.top/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://chunyujin.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL_库和表的使用（部分未完</title>
    <link href="https://chunyujin.top/chunyujin/8db1a874.html"/>
    <id>https://chunyujin.top/chunyujin/8db1a874.html</id>
    <published>2024-07-19T07:54:00.000Z</published>
    <updated>2024-10-22T07:34:35.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="库和表的使用操作小记"><a href="#库和表的使用操作小记" class="headerlink" title="库和表的使用操作小记"></a>库和表的使用操作小记</h1><blockquote><p>记录的是基础用法，有很多细节省略了，详细请看课件或者完整笔记</p></blockquote><p>MySQL的SQL语句分为以下三类</p><blockquote><ol><li><p>DDL 【数据定义语句】</p><p>用来维护存储数据的整体结构，比如库和表的创建、修改、删除、备份与还原、查看</p><p>代表命令<code>create</code>,<code>alter</code>,<code>drop</code>,<code>source</code>,<code>show</code></p></li><li><p>DML【数据操纵语句】</p><p>用来操作表中的具体数据，比如插入数据、查询数据、删除数据</p><p>代表命令<code>insert</code>,<code>select</code>,<code>delete</code>,<code>update</code></p></li><li><p>DLC【数据控制语句】</p><p>负责权限管理和事务</p><p>代表命令<code>grant</code>,<code>revoke</code>,<code>commit</code></p></li></ol></blockquote><h2 id="登录mysql"><a href="#登录mysql" class="headerlink" title="登录mysql"></a>登录mysql</h2><p>有两种方式：</p><p>指明端口</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415225508111.png" alt="image-20230415225508111" style="zoom:80%;" /><p>不指明端口，使用默认的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415225657207.png" alt="image-20230415225657207" style="zoom:80%;" /><blockquote><p>-p的作用是不显式地输入密码，我并没有设置root账户的密码，直接按回车即可</p><p>-u和root之间可以有空格可以没有</p></blockquote><h1 id="DDL【数据定义语句】"><a href="#DDL【数据定义语句】" class="headerlink" title="DDL【数据定义语句】"></a>DDL【数据定义语句】</h1><h2 id="查看mysql所有库"><a href="#查看mysql所有库" class="headerlink" title="查看mysql所有库"></a>查看mysql所有库</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415225821594.png" alt="image-20230415225821594" style="zoom:80%;" /><blockquote><p> 注意mysql语句要用分号结尾</p></blockquote><h2 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415230014631.png" alt="image-20230415230014631" style="zoom:80%;" /><p>或者“如果这个库不存在的话，就创建”（创建表的时候也一样）：</p><blockquote><p>注意，关于库、表的名称，最好使用反引号&#96;&#96; &#96;括起来，这个符号是电脑esc键下面的键，半角状态打出</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415230515065.png" alt="image-20230415230515065"></p><p>也可以不括起来，但是如果名称和mysql内部一些名称冲突的话，会报错</p></blockquote><h2 id="查看创建库的记录-查看库结构"><a href="#查看创建库的记录-查看库结构" class="headerlink" title="查看创建库的记录(查看库结构)"></a>查看创建库的记录(查看库结构)</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407140912098.png" alt="截屏2024-07-14 09.11.54" style="zoom:50%;" /><blockquote><ol><li>只能查看已创建的库</li><li>本质上是查看创建库的所有语句，这些语句保存在了一个文件中，这个文件可以用于库的备份（见另一篇文章）</li></ol></blockquote><h2 id="删除库"><a href="#删除库" class="headerlink" title="删除库"></a>删除库</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415230810279.png" alt="image-20230415230810279" style="zoom:80%;" /><h2 id="进入-x2F-使用库"><a href="#进入-x2F-使用库" class="headerlink" title="进入&#x2F;使用库"></a>进入&#x2F;使用库</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415231043861.png" alt="image-20230415231043861" style="zoom:80%;" /><h2 id="查看当前所在库"><a href="#查看当前所在库" class="headerlink" title="查看当前所在库"></a>查看当前所在库</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415231150871.png" alt="image-20230415231150871" style="zoom:80%;" /><h2 id="退出库"><a href="#退出库" class="headerlink" title="退出库"></a>退出库</h2><p>严格来说也不是退出，而是返回到最初的库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141519106.png" alt="截屏2024-07-14 15.19.42" style="zoom: 50%;" /><p>当然，是没有必要退出的，因为在其他数据库的时候，还是可以使用<code>show databases;</code>命令查看所有数据库，并使用<code>use 数据库名;</code>直接进入其他数据库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141520652.png" alt="截屏2024-07-14 15.20.56" style="zoom:50%;" /><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table 表名 (</span><br><span class="line">    field1 datatype,</span><br><span class="line">    field2 datatype,</span><br><span class="line">    field3 datatype</span><br><span class="line">) character set 字符集 collate 校验规则 engine 存储引擎;</span><br></pre></td></tr></table></figure><blockquote><p>最下面一行后面的内容可以省略</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415232123861.png" alt="image-20230415232123861" style="zoom:80%;" /><blockquote><ol><li><p>可以换行可以不换</p><blockquote><p>换行更美观，但是换行之后之前输入的内容无法修改，所以写代码要准确</p></blockquote></li><li><p>Sno、Sname、Sage之类的就是列属性，就是列名</p></li><li><p>Sno它们后面跟的是这一列数据的数据类型</p></li><li><p>comment是给这个列加备注，可以加可以不加</p></li><li><p>if not exists 可加可不加，意思是如果Student这个表之前不存在的话，就创建，存在的话就不创建，在前面的库的创建和删除中，以及在后面的表的删除中，也是可加可不加</p></li></ol></blockquote><h2 id="查看表的属性"><a href="#查看表的属性" class="headerlink" title="查看表的属性"></a>查看表的属性</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415232523386.png" alt="image-20230415232523386" style="zoom:80%;" /><h2 id="查看库中的所有表"><a href="#查看库中的所有表" class="headerlink" title="查看库中的所有表"></a>查看库中的所有表</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230415232555462.png" alt="image-20230415232555462" style="zoom: 80%;" /><h2 id="查看创建表的记录-查看表结构"><a href="#查看创建表的记录-查看表结构" class="headerlink" title="查看创建表的记录(查看表结构)"></a>查看创建表的记录(查看表结构)</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416084512253.png" alt="image-20230416084512253" style="zoom:80%;" /><blockquote><ol><li>只能查看已存在的表</li><li>本质上是打印出来创建表的时候执行的所有语句</li></ol></blockquote><p>省略长横线：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416085136345.png" alt="image-20230416085136345" style="zoom:80%;" /><h2 id="新增列（新增字段）"><a href="#新增列（新增字段）" class="headerlink" title="新增列（新增字段）"></a>新增列（新增字段）</h2><p>在SC表中的Cno列后面新增一列Grade</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416091642802.png" alt="image-20230416091642802" style="zoom:80%;" /><blockquote><ol><li>如果不加after，默认加在最后一列</li><li>新增一列之后，此列的数据默认为NULL</li></ol></blockquote><p>查看一下表结构，发现列信息被加入进去了：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416092018226.png" alt="image-20230416092018226" style="zoom:80%;" /><h2 id="新增列-字段-时设置默认数据填充"><a href="#新增列-字段-时设置默认数据填充" class="headerlink" title="新增列(字段)时设置默认数据填充"></a>新增列(字段)时设置默认数据填充</h2><p>由于一般新增列的时候，默认该列的数据都为空NULL，但是有些场景需要指定默认数据</p><p>创建新列时设置默认填充数据：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141551171.png" alt="截屏2024-07-14 15.51.15" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141551670.png" alt="截屏2024-07-14 15.51.23" style="zoom:50%;" /><h2 id="设置主键"><a href="#设置主键" class="headerlink" title="设置主键"></a>设置主键</h2><p>主键用于标定一张表中一条数据的唯一性的的列。主键不为空、数据值不能重复，因此可以标定一条数据的唯一性。</p><p>一张表中只能有一个主键，但是主键可以是由一列构成，也可以由多列复合而成（复合主键），只要复合主键中并不是每一列的数据都是相同的，那么这个数据就是唯一的。</p><p>一般选择int类型字段作为主键（比如ID之类）</p><h3 id="新建表时创建主键"><a href="#新建表时创建主键" class="headerlink" title="新建表时创建主键"></a>新建表时创建主键</h3><p>方法一：在设置字段的时候设置上主键</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141608651.png" alt="截屏2024-07-14 16.05.39" style="zoom:50%;" /><p>方法二：在最后设置主键</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141608331.png" alt="截屏2024-07-14 16.07.42" style="zoom:50%;" /><blockquote><ol><li>两种方式都会用到</li><li>主键本身就不能为空，因此可以省略<code>not null</code></li></ol></blockquote><h3 id="取消主键"><a href="#取消主键" class="headerlink" title="取消主键"></a>取消主键</h3><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141616380.png" alt="截屏2024-07-14 16.15.01" style="zoom:50%;" /><h3 id="设置现有列-字段-为主键"><a href="#设置现有列-字段-为主键" class="headerlink" title="设置现有列(字段)为主键"></a>设置现有列(字段)为主键</h3><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141616311.png" alt="截屏2024-07-14 16.15.20" style="zoom:50%;" /><h3 id="在添加新字段时设置为主键"><a href="#在添加新字段时设置为主键" class="headerlink" title="在添加新字段时设置为主键"></a>在添加新字段时设置为主键</h3><blockquote><p>前提是表中没有主键</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141618994.png" alt="截屏2024-07-14 16.18.24" style="zoom:50%;" /><h3 id="设置复合主键"><a href="#设置复合主键" class="headerlink" title="设置复合主键"></a>设置复合主键</h3><h4 id="创建新表时设置"><a href="#创建新表时设置" class="headerlink" title="创建新表时设置"></a>创建新表时设置</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141622536.png" alt="截屏2024-07-14 16.20.57" style="zoom:50%;" /><blockquote><p>不能用第一种方式创建</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141623459.png" alt="截屏2024-07-14 16.22.59" style="zoom:50%;" /><p>会报错“定义了重复主键”</p></blockquote><h4 id="设置现有字段为复合主键"><a href="#设置现有字段为复合主键" class="headerlink" title="设置现有字段为复合主键"></a>设置现有字段为复合主键</h4><blockquote><p>此前表中没有主键</p></blockquote><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141625503.png" alt="截屏2024-07-14 16.24.41"></p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>关于主键、默认值(default)、唯一键、外键等SQL字段约束相关知识，在<a href="https://blog.musnow.top/posts/4138950838/">慕雪的寒舍-SQL字段约束</a></p><h2 id="修改列的数据类型"><a href="#修改列的数据类型" class="headerlink" title="修改列的数据类型"></a>修改列的数据类型</h2><p>将SC表中的Sno的数据类型由int(11)改为int(20)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416092343137.png" alt="image-20230416092343137" style="zoom:80%;" /><p>查看一下表结构：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416092422560.png" alt="image-20230416092422560" style="zoom:80%;" /><blockquote><p>说明修改表的某一列是用新的列覆盖掉旧的列</p><ol><li><p>将同类型缩小，要确保原数据不会溢出</p></li><li><p>不同类型之间转换的时候，要确保这两种数据之间是能双向转化的</p></li></ol></blockquote><h2 id="修改列名"><a href="#修改列名" class="headerlink" title="修改列名"></a>修改列名</h2><p>将表SC的Grade列改名为NianJi</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416093816455.png" alt="image-20230416093816455" style="zoom:80%;" /><blockquote><p>注意，在改列名的时候，必须还要重新指定该列的数据类型，可以保留原来的，也可以修改，但必须都要写出。</p><p>这里我顺便修改成新的数据类型，还可以加注释。</p><p>所以说修改列名是包含了修改修改数据类型的</p><p>修改列名使用change而不是rename</p><ol><li>rename留给了修改表名使用</li><li>修改列名的时候不只是修改了列名，还有加上该列的数据类型（无论是否更改），因此用change更合理</li></ol></blockquote><p>查看一下表结构：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416094024996.png" alt="image-20230416094024996" style="zoom:80%;" /><h2 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416093110524.png" alt="image-20230416093110524" style="zoom:80%;" /><blockquote><p>凡是涉及到删除的操作，都要慎重</p><p>如果表中只剩下一列，不能删除列了，只能删除整张表</p></blockquote><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407141509358.png" alt="截屏2024-07-14 15.09.43" style="zoom:50%;" /><h2 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h2><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416094152571.png" alt="image-20230416094152571" style="zoom:80%;" /><h2 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h2><p><a href="https://blog.musnow.top/posts/2109090510/">https://blog.musnow.top/posts/2109090510/</a></p><h3 id="备份命令在shell命令行进行"><a href="#备份命令在shell命令行进行" class="headerlink" title="备份命令在shell命令行进行"></a>备份命令在shell命令行进行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mysqldump [-P端口号] -u用户名 -p密码 [-B] 数据库名 &gt; 备份后的名称.bak.sql</span></span><br></pre></td></tr></table></figure><blockquote><p>[ ]内的是可以省略的</p><p>-u和用户名、-p和密码之间可以加空格，可以不加</p><p>-B和数据库名之间必须有空格（如果-B没有省略的话）</p><p>端口号可能是3306，取决于数据库有没有指定端口</p><p>备份后的文件要具体到路径，否则认为当前工作路径（同其他shell命令一样）</p></blockquote><p>eg1：<code>mysqldump -uroot -p0295 test2 &gt; ../test2.bak.sql</code>备份到了父目录</p><p>eg2：<code>mysqldump -P3306 -uroot -p0295 test2 &gt; test2.bak.sql</code>备份到了当前目录</p><p><strong>可以多个数据库同时备份</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mysqldump [-P端口号] -u用户名 -p密码 [-B] 数据库1 数据库2 &gt; 备份后的名称.bak.sql</span></span><br></pre></td></tr></table></figure><p>eg：<code>mysqldump -uroot -p0295 -B test2 test_mysql &gt; test.back.sql</code>两个数据库备份到了一个备份文件上</p><p><strong>也可以只进行数据库中表的备份</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mysqldump [-P端口号] -u用户名 -p密码 数据库名 表1 表2 &gt; 备份后的名称.bak.sql</span></span><br></pre></td></tr></table></figure><blockquote><p>备份表的时候不能加-B，因为-B是专用于数据库的，否则会把表名当成数据库名</p></blockquote><p>eg：<code>mysqldump -uroot -p0295 test2 test2_table1 &gt; test_table1.back.sql</code></p><blockquote><p>其他知识点详见置顶链接</p></blockquote><h3 id="还原命令在mysql中执行"><a href="#还原命令在mysql中执行" class="headerlink" title="还原命令在mysql中执行"></a>还原命令在mysql中执行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; source 备份文件路径</span><br></pre></td></tr></table></figure><p>eg：<code>source /yj/test2.bak.sql</code></p><p>数据库中的内容和原来数据库中的内容是相同的</p><p>mysql备份的时候，会将里面的语句智能化简</p><h2 id="MySQL通过system执行shell命令"><a href="#MySQL通过system执行shell命令" class="headerlink" title="MySQL通过system执行shell命令"></a>MySQL通过system执行shell命令</h2><p>eg：<code>mysql&gt; system clear</code>执行清理屏幕功能</p><h2 id="DDL命令操作表时要加table固定写法"><a href="#DDL命令操作表时要加table固定写法" class="headerlink" title="DDL命令操作表时要加table固定写法"></a>DDL命令操作表时要加<code>table</code>固定写法</h2><p>比如<code>alter</code>, <code>drop</code>等等，后面都需要加<code>table</code>, 然后才能跟表名</p><p>而下面的DML在指定表名的时候不需要写<code>table</code>, 直接用表名就可以</p><p>这是因为DDL是操作表的</p><p>而DML是操作数据的</p><h1 id="DML【数据修改语句】"><a href="#DML【数据修改语句】" class="headerlink" title="DML【数据修改语句】"></a>DML【数据修改语句】</h1><h2 id="向表中插入数据（insert）"><a href="#向表中插入数据（insert）" class="headerlink" title="向表中插入数据（insert）"></a>向表中插入数据（insert）</h2><h3 id="单行插入"><a href="#单行插入" class="headerlink" title="单行插入"></a>单行插入</h3><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416085917365.png" alt="image-20230416085917365" style="zoom:80%;" /><blockquote><p>Sno、Sname等字段可以不写，如果不写的话就默认为数据为空(前提是该字段允许为空，或已设置defalut值)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416090914765.png" alt="image-20230416090914765" style="zoom:80%;" /><p>如果字段名全部省略，就默认为所有的数据都要填上，所有数据都要填充，且要按照表中字段顺序填入</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416090326238.png" alt="image-20230416090326238" style="zoom:80%;" /></blockquote><h3 id="多行指定列插入"><a href="#多行指定列插入" class="headerlink" title="多行指定列插入"></a>多行指定列插入</h3><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407161507059.png" alt="截屏2024-07-16 15.06.41" style="zoom:50%;" /><blockquote><p>同单行插入一样，字段名可以省略（但是数据插入要按字段顺序）；</p><p>部分字段名可以不写，默认为空（前提是该字段允许为空，或者有default值）</p></blockquote><h3 id="插入否则更新（on-duplicate-update）"><a href="#插入否则更新（on-duplicate-update）" class="headerlink" title="插入否则更新（on duplicate update）"></a>插入否则更新（on duplicate update）</h3><p>如果要插入的数据，其主键或唯一键，与表中现存数据重合，则插入数据失败。此时我们可以选择更新现有数据。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407161510864.png" alt="截屏2024-07-16 15.02.38" style="zoom:50%;" /><blockquote><p>在test表中插入数据Sno、Sage（Sno必填，因为是主键），如果填入的内容与主键发生重复冲突，则更新<code>update</code>语句后面指定字段中的内容</p><blockquote><p>示例中是，如果发生主键&#x2F;唯一键冲突，则将该主键&#x2F;唯一键对应的数据中Sno字段数据改为21</p></blockquote></blockquote><h3 id="插入否则替换（replace）"><a href="#插入否则替换（replace）" class="headerlink" title="插入否则替换（replace）"></a>插入否则替换（replace）</h3><p>与更新update不同，更新是只更新数据中原有的部分字段，替换replace则是先删除原数据（所有字段），然后根据要填入的value再插入。</p><p>要插入的数据的主键&#x2F;唯一键与现有数据冲突时，replace将现有数据所有字段删除，将要插入的数据重新插入。即replace在遇到冲突时，是先删除，后插入。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407161544052.png" alt="截屏2024-07-16 15.42.16" style="zoom:50%;" /><blockquote><ol><li>replace在无冲突时，相当于普通的insert</li><li>replace在冲突时，将原有数据删除后，原有数据不保留，只会插入replace语句中表明要插入的values</li><li>与insert一样，允许省略全部字段名，或者省略部分允许为空或已设定好default值的字段名</li></ol><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407161544449.png" alt="截屏2024-07-16 15.44.09" style="zoom:50%;" /><blockquote><p>从这里可以看出，数据是先删除后插入</p></blockquote></blockquote><h2 id="查看表中的数据"><a href="#查看表中的数据" class="headerlink" title="查看表中的数据"></a>查看表中的数据</h2><p>基本写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    [DISTINCT] &#123;* | &#123;column [, column] ...&#125;</span><br><span class="line">    [FROM table_name]</span><br><span class="line">    [WHERE ...]</span><br><span class="line">    [ORDER BY column [ASC | DESC], ...]</span><br><span class="line">    LIMIT ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="全列查询"><a href="#全列查询" class="headerlink" title="全列查询"></a>全列查询</h3><p><code>*</code>为通配符</p><p>查看Student所有数据：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416090348697.png" alt="image-20230416090348697" style="zoom:80%;" /><p>查看Course所有数据：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20230416094630308.png" alt="image-20230416094630308" style="zoom:80%;" /><blockquote><ol><li>NULL表示没有数据，和’’不同，’’是有数据，数据是空字符串。</li><li>一般情况下不建议使用全列查询<ol><li>查询到的数据越多，数据传输量越大</li><li>可能会影响索引的使用</li></ol></li></ol></blockquote><h3 id="按列查询"><a href="#按列查询" class="headerlink" title="按列查询"></a>按列查询</h3><p>查询指定字段的数据，并汇聚成一张表呈现出来</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407161602312.png" alt="截屏2024-07-16 16.00.58" style="zoom:50%;" /><h3 id="表达式查询"><a href="#表达式查询" class="headerlink" title="表达式查询"></a>表达式查询</h3><p>所以可以看出来，select到from之间的这部分，实际上就是规定了查询结果的字段。而MySQL支持将查询结果通过表达式进行展示</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407161636807.png" alt="截屏2024-07-16 16.36.19" style="zoom:50%;" /><h4 id="为表达式查询结果设置别名"><a href="#为表达式查询结果设置别名" class="headerlink" title="为表达式查询结果设置别名"></a>为表达式查询结果设置别名</h4><p>这样可以增强查询结果的可读性</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407161638672.png" alt="截屏2024-07-16 16.38.00" style="zoom:50%;" /><h3 id="查询结果去重（select-distinct）"><a href="#查询结果去重（select-distinct）" class="headerlink" title="查询结果去重（select distinct）"></a>查询结果去重（select distinct）</h3><p>有些使用场景下可能需要用到去重，比如上面，只是想知道总体上都是有哪几种总分，因此可以对结果进行去重。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407161641448.png" alt="截屏2024-07-16 16.41.27" style="zoom:50%;" /><blockquote><p>注意去重只是去掉所有字段都重复的数据，所以结果中，就算有一个字段存在重复的数据，但是其他字段不重复，该数据也不会被去掉</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407161643905.png" alt="截屏2024-07-16 16.43.05" style="zoom:50%;" /></blockquote><h3 id="条件查询（where）【重要】"><a href="#条件查询（where）【重要】" class="headerlink" title="条件查询（where）【重要】"></a>条件查询（where）【重要】</h3><p>基本用法就是在表名后加<code>where</code>，后面是查询条件</p><p>where语句支持比较运算符和逻辑运算符</p><table><thead><tr><th>比较运算符</th><th>说明</th></tr></thead><tbody><tr><td><code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code></td><td></td></tr><tr><td><code>=</code></td><td>等于，<code>NULL</code> 不安全，<code>NULL=NULL</code> 的结果是 <code>NULL</code></td></tr><tr><td><code>&lt;=&gt;</code></td><td>等于，<code>NULL</code> 安全，<code>NULL&lt;=&gt;NULL</code> 的结果是 <code>TRUE(1)</code></td></tr><tr><td><code>!=</code>, <code>&lt;&gt;</code></td><td>不等于</td></tr><tr><td><code> BETWEEN a AND b</code></td><td>范围匹配，闭区间，如果 <code>a &lt;= value &lt;= b</code> 返回 <code>TRUE(1)</code></td></tr><tr><td><code>IN (option, ..., ...)</code></td><td>如果是 <code>option</code> 中的任意一个，则返回 <code>TRUE(1)</code></td></tr><tr><td><code>IS NULL</code></td><td>是 <code>NULL</code></td></tr><tr><td><code>IS NOT NULL</code></td><td>不是 <code>NULL</code></td></tr><tr><td><code>LIKE</code></td><td>模糊匹配，<code>%</code> 表示任意多个（包括 0 个）字符；<code>_</code>表示任意一个字符；</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>说明</th></tr></thead><tbody><tr><td>AND</td><td>与，相当于 cpp 中的 <code>&amp;&amp;</code>，全真为 1，有假为 0</td></tr><tr><td>OR</td><td>或，相当于 cpp 中的 &#96;</td></tr><tr><td>NOT</td><td>逻辑取反，条件为 <code>TRUE(1)</code> 的时候结果为 <code>FALSE(0)</code></td></tr></tbody></table><h4 id="使用比较和逻辑运算符："><a href="#使用比较和逻辑运算符：" class="headerlink" title="使用比较和逻辑运算符："></a>使用比较和逻辑运算符：</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407170930132.png" alt="截屏2024-07-17 09.29.54" style="zoom:50%;" /><h4 id="使用BETWEEN…AND…进行区间筛选："><a href="#使用BETWEEN…AND…进行区间筛选：" class="headerlink" title="使用BETWEEN…AND…进行区间筛选："></a>使用BETWEEN…AND…进行区间筛选：</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407170934772.png" alt="截屏2024-07-17 09.34.30" style="zoom:50%;" /><h4 id="配合逻辑运算符，使用相等筛选："><a href="#配合逻辑运算符，使用相等筛选：" class="headerlink" title="配合逻辑运算符，使用相等筛选："></a>配合逻辑运算符，使用相等筛选：</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407170944005.png" alt="截屏2024-07-17 09.44.01" style="zoom:50%;" /><h4 id="使用IN也可以实现相同效果："><a href="#使用IN也可以实现相同效果：" class="headerlink" title="使用IN也可以实现相同效果："></a>使用IN也可以实现相同效果：</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407170949565.png" alt="截屏2024-07-17 09.49.34" style="zoom:50%;" /><h4 id="使用LIKE进行字符匹配："><a href="#使用LIKE进行字符匹配：" class="headerlink" title="使用LIKE进行字符匹配："></a>使用LIKE进行字符匹配：</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407170952036.png" alt="截屏2024-07-17 09.51.53" style="zoom:50%;" /><h4 id="计算后筛选-amp-设置别名："><a href="#计算后筛选-amp-设置别名：" class="headerlink" title="计算后筛选&amp;设置别名："></a>计算后筛选&amp;设置别名：</h4><p>需要注意的是，where只是进行条件筛选，起别名的工作并不是通过where语句完成的，而是select本身</p><p>并且起别名本质是在表示结果的时候更换一下结果表的字段名，并不影响查询过程，所以where是不认识别名的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407171012192.png" alt="截屏2024-07-17 10.12.10" style="zoom:50%;" /><h4 id="使用IS-NULL-或者-IS-NOT-NULL查询："><a href="#使用IS-NULL-或者-IS-NOT-NULL查询：" class="headerlink" title="使用IS NULL 或者 IS NOT NULL查询："></a>使用IS NULL 或者 IS NOT NULL查询：</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407171025330.png" alt="截屏2024-07-17 10.25.04" style="zoom:50%;" /><h4 id="where查询条件不一定必须存在于select要查询的字段中："><a href="#where查询条件不一定必须存在于select要查询的字段中：" class="headerlink" title="where查询条件不一定必须存在于select要查询的字段中："></a>where查询条件不一定必须存在于select要查询的字段中：</h4><p>使用<code>where</code>时设置条件的字段，可以与select查询要获取的结果集字段无关，而是可以根据原有表中任意字段进行筛选</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407171026255.png" alt="截屏2024-07-17 10.26.41" style="zoom:50%;" /><h3 id="结果排序（order-by）"><a href="#结果排序（order-by）" class="headerlink" title="结果排序（order by）"></a>结果排序（order by）</h3><h4 id="按单字段升序【默认】-x2F-降序【后加DESC】-显示"><a href="#按单字段升序【默认】-x2F-降序【后加DESC】-显示" class="headerlink" title="按单字段升序【默认】&#x2F; 降序【后加DESC】 显示"></a>按单字段升序【默认】&#x2F; 降序【后加<code>DESC</code>】 显示</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407171030912.png" alt="截屏2024-07-17 10.29.21" style="zoom:50%;" /><p>降序在字段后加<code>EDSC</code></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407171031288.png" alt="截屏2024-07-17 10.30.52" style="zoom:50%;" /><h4 id="按多字段排序"><a href="#按多字段排序" class="headerlink" title="按多字段排序"></a>按多字段排序</h4><p>按照书写先后确定排序优先级</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407171052900.png" alt="截屏2024-07-17 10.51.57" style="zoom:50%;" /><blockquote><p>先按照数学将序排序，相等时，就再参考语文的升序，如果还是相等，参考英语的升序</p></blockquote><h4 id="按求和结果排序"><a href="#按求和结果排序" class="headerlink" title="按求和结果排序"></a>按求和结果排序</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407171056363.png" alt="截屏2024-07-17 10.55.36" style="zoom:50%;" /><blockquote><p>排序的时候可以使用别名，说明排序只是对于查询后的结果表进行排序，而不同于where（在查询时按条件筛选）</p></blockquote><h4 id="where-order-by"><a href="#where-order-by" class="headerlink" title="where + order by"></a><code>where</code> + <code>order by</code></h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202407171058835.png" alt="截屏2024-07-17 10.58.41" style="zoom:50%;" /><blockquote><p>查询语文成绩大于70分的学生的id、姓名、数学成绩</p><p>并将查询结果按照语文成绩，降序排列</p><ol><li>where查询条件不一定必须存在于select要查询的字段中，而是可以根据原有表中任意字段进行筛选</li><li>排序也不一定按照select查询结果的字段进行排序，而是可以按照原有表中任意字段排序</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;库和表的使用操作小记&quot;&gt;&lt;a href=&quot;#库和表的使用操作小记&quot; class=&quot;headerlink&quot; title=&quot;库和表的使用操作小记&quot;&gt;&lt;/a&gt;库和表的使用操作小记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;记录的是基础用法，有很多细节省略了，详细请看课件或</summary>
      
    
    
    
    <category term="MySQL" scheme="https://chunyujin.top/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://chunyujin.top/tags/MySQL/"/>
    
  </entry>
  
</feed>
