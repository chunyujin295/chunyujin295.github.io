<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><script>(function(){var n=[],t=50,e=!1;return setInterval((function(){var o=new Date;new Date-o>t?(e||n.forEach((function(n){n.call(null)})),e=!0,window.stop(),alert("你真坏，请关闭控制台！"),document.body.innerHTML=""):e=!1}),1),{addListener:function(t){n.push(t)},cancleListenr:function(t){n=n.filter((function(n){return n!==t}))}}})().addListener((function(){window.location.reload()}))</script><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>数据结构_二叉树（C++ | 浴巾的贼船</title><meta name="author" content="浴巾,3029795434@qq.com"><meta name="copyright" content="浴巾"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="数据结构_二叉树（C++实现 1前言：此类笔记仅用于个人复习，内容主要在于记录和体现个人理解，详细还请结合bite课件、录播、板书和代码。  [toc] 前言  本篇中的是一般二叉树(包括线索树、表达式树)是通过链式结构实现的，关于顺序结构的实现请见C语言版(顺便有堆的相关内容) 本篇中哈夫曼树的结点存储是用的是顺序结构 模版不支持分离编译，因此跟以往自定义变量和函数时，声明在头文件、实现在源文件"><meta property="og:type" content="article"><meta property="og:title" content="数据结构_二叉树（C++"><meta property="og:url" content="https://chunyujin.top/chunyujin/147dc864.html"><meta property="og:site_name" content="浴巾的贼船"><meta property="og:description" content="数据结构_二叉树（C++实现 1前言：此类笔记仅用于个人复习，内容主要在于记录和体现个人理解，详细还请结合bite课件、录播、板书和代码。  [toc] 前言  本篇中的是一般二叉树(包括线索树、表达式树)是通过链式结构实现的，关于顺序结构的实现请见C语言版(顺便有堆的相关内容) 本篇中哈夫曼树的结点存储是用的是顺序结构 模版不支持分离编译，因此跟以往自定义变量和函数时，声明在头文件、实现在源文件"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303071113259.gif"><meta property="article:published_time" content="2023-02-21T00:47:00.000Z"><meta property="article:modified_time" content="2024-10-22T07:34:35.303Z"><meta property="article:author" content="浴巾"><meta property="article:tag" content="Cpp"><meta property="article:tag" content="数据结构"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303071113259.gif"><link rel="shortcut icon" href="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202311081041412.png"><link rel="canonical" href="https://chunyujin.top/chunyujin/147dc864"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: 浴巾",link:"链接: ",source:"来源: 浴巾的贼船",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"数据结构_二叉树（C++",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-10-22 15:34:35"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,c={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(c))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=window.matchMedia("(prefers-color-scheme: dark)").matches,a=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!o&&!a&&!c;if(void 0===t){if(a)activateLightMode();else if(o)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const i=saveToLocal.get("aside-status");void 0!==i&&("hide"===i?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/mouse.css"><link rel="stypesheet" href="/css/loading.css?1"><link rel="stylesheet" href="/css/readPercent.css"><link rel="stylesheet" href="/css/custom.css"><span id="fps"></span><svg aria-hidden="true" style="position:absolute;overflow:hidden;width:0;height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248 626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script></symbol></svg><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="浴巾的贼船" type="application/atom+xml"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",(()=>{preloader.endLoading()})),document.addEventListener("pjax:send",(()=>{preloader.initLoading()})),document.addEventListener("pjax:complete",(()=>{preloader.endLoading()}))</script><link rel="stylesheet" href="/css/progress_bar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303071113259.gif" onerror='onerror=null,src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202302121138445.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">135</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">35</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-clock"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa-solid fa-pen-nib"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-mug-hot"></i> <span>喝杯茶</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fa-brands fa-bilibili"></i> <span>追番</span></a></li><li><a class="site-page child" href="/movie/"><i class="fa-fw fa-solid fa-clapperboard"></i> <span>影片</span></a></li><li><a class="site-page child" href="/book/"><i class="fa-fw fa-solid fa-book-skull"></i> <span>读书</span></a></li><li><a class="site-page child" href="/game/"><i class="fa-fw fa-solid fa-gamepad"></i> <span>游戏墙</span></a></li><li><a class="site-page child" href="/air-conditioner/"><i class="fa-fw fa-solid fa-snowflake"></i> <span>乘凉</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-desktop"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fa-solid fa-hand-holding-heart"></i> <span>友链</span></a></li><li><a class="site-page child" href="/website/"><i class="fa-fw fa-solid fa-globe"></i> <span>网站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-jet-fighter"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010017530.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">浴巾的贼船</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-clock"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa-solid fa-pen-nib"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-mug-hot"></i> <span>喝杯茶</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fa-brands fa-bilibili"></i> <span>追番</span></a></li><li><a class="site-page child" href="/movie/"><i class="fa-fw fa-solid fa-clapperboard"></i> <span>影片</span></a></li><li><a class="site-page child" href="/book/"><i class="fa-fw fa-solid fa-book-skull"></i> <span>读书</span></a></li><li><a class="site-page child" href="/game/"><i class="fa-fw fa-solid fa-gamepad"></i> <span>游戏墙</span></a></li><li><a class="site-page child" href="/air-conditioner/"><i class="fa-fw fa-solid fa-snowflake"></i> <span>乘凉</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-desktop"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fa-solid fa-hand-holding-heart"></i> <span>友链</span></a></li><li><a class="site-page child" href="/website/"><i class="fa-fw fa-solid fa-globe"></i> <span>网站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-jet-fighter"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构_二叉树（C++</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-21T00:47:00.000Z" title="发表于 2023-02-21 08:47:00">2023-02-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-22T07:34:35.303Z" title="更新于 2024-10-22 15:34:35">2024-10-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Cpp/">Cpp</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="数据结构_二叉树（C++"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据结构-二叉树（C-实现"><a href="#数据结构-二叉树（C-实现" class="headerlink" title="数据结构_二叉树（C++实现"></a>数据结构_二叉树（C++实现</h1><blockquote><p>1前言：此类笔记仅用于个人复习，内容主要在于记录和体现个人理解，详细还请结合bite课件、录播、板书和代码。</p></blockquote><p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><ol><li><strong>本篇中的是一般二叉树(包括线索树、表达式树)是通过<u>链式结构</u>实现的</strong>，关于顺序结构的实现请见C语言版(顺便有堆的相关内容)</li><li><strong>本篇中哈夫曼树的结点存储是用的是<u>顺序结构</u></strong></li><li>模版不支持分离编译，因此跟以往自定义变量和函数时，声明在头文件、实现在源文件不同，定义(声明+实现)都是在头文件中【详见code日记】</li></ol></blockquote><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>采用<strong>链式存储</strong></p><h3 id="二叉树类的声明："><a href="#二叉树类的声明：" class="headerlink" title="二叉树类的声明："></a>二叉树类的声明：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模版不支持分离编译！！！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的链式存储</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span><span class="comment">//在buildExpressionTree中用到，用来进行string转等价int</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">nullPoint</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//binaryTree类的向前说明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binaryTree</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span><span class="comment">//二叉树结点类</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">binaryTree</span>&lt;elemType&gt;;<span class="comment">//结点类将二叉树类视为友元函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	elemType data;</span><br><span class="line">	Node&lt;elemType&gt; *left;<span class="comment">//指针域</span></span><br><span class="line">	Node&lt;elemType&gt; *right;</span><br><span class="line">	<span class="type">int</span> leftFlag; <span class="comment">//用于标识孩子指针是否为线索，0则说明left指向该结点的左孩子，1则说明left指向该结点的直接前驱</span></span><br><span class="line">	<span class="type">int</span> rightFlag; <span class="comment">//用于标识孩子指针是否为线索，0则说明right指向该结点的右孩子，1则说明right指向该结点的直接后继</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Node</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		left = <span class="literal">NULL</span>;</span><br><span class="line">		right = <span class="literal">NULL</span>;</span><br><span class="line">		leftFlag = <span class="number">0</span>;</span><br><span class="line">		rightFlag = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">const</span> elemType&amp; data, Node&lt;elemType&gt; *left = <span class="literal">NULL</span>, Node&lt;elemType&gt; *right = <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;data = data;</span><br><span class="line">		<span class="keyword">this</span>-&gt;left = left;</span><br><span class="line">		<span class="keyword">this</span>-&gt;right = right;</span><br><span class="line">		leftFlag = <span class="number">0</span>;</span><br><span class="line">		rightFlag = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binaryTree</span><span class="comment">//二叉树类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Node&lt;elemType&gt; *root;<span class="comment">//链式二叉树的根结点指针</span></span><br><span class="line">	elemType stopFlag;<span class="comment">//结束标志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">binaryTree</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		root = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">creatTree</span><span class="params">(<span class="type">const</span> elemType&amp; flag)</span></span>;<span class="comment">//创建一棵二叉树</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> root == <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Node&lt;elemType&gt; *<span class="title">getRoot</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Size</span><span class="params">(Node&lt;elemType&gt; *t)</span></span>;<span class="comment">//递归求二叉树的结点的个数</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Size</span><span class="params">()</span></span>;<span class="comment">//求二叉树的结点个数</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Height</span><span class="params">(Node&lt;elemType&gt; *t)</span></span>;<span class="comment">//递归求二叉树的高度/深度</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Height</span><span class="params">()</span></span>;<span class="comment">//求二叉树的高度</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">delTree</span><span class="params">(Node&lt;elemType&gt; *t)</span></span>;<span class="comment">//递归删除二叉树</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">delTree</span><span class="params">()</span></span>;<span class="comment">//删除二叉树</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(Node&lt;elemType&gt; *t)</span></span>;<span class="comment">//按前序遍历输出以t为根的二叉树的结点的数据值</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;<span class="comment">//前序遍历</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(Node&lt;elemType&gt; *t)</span></span>;<span class="comment">//按中序遍历输出以t为根的二叉树的结点的数据值</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;<span class="comment">//中序遍历</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(Node&lt;elemType&gt; *t)</span></span>;<span class="comment">//按后序遍历输出以t为根的二叉树的结点的数据值</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">()</span></span>;<span class="comment">//后序遍历</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>;<span class="comment">//层序遍历</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Node&lt;elemType&gt; *<span class="title">threadMin</span><span class="params">()</span></span>;<span class="comment">//建立中序遍历线索树</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">threadMidInOrder</span><span class="params">(Node&lt;elemType&gt; *first)</span></span>;<span class="comment">//借助 在原二叉树基础上 建立的中序遍历线索树，对于原二叉树实现非递归的中序遍历</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">threadMidPreOrder</span><span class="params">()</span></span>;<span class="comment">//借助 在原二叉树基础上 建立的中序遍历线索树，对于原二叉树实现非递归的前序遍历</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Node&lt;elemType&gt; *<span class="title">buildTree</span><span class="params">(elemType pre[], <span class="type">int</span> pl, <span class="type">int</span> pr,</span></span></span><br><span class="line"><span class="params"><span class="function">		elemType mid[], <span class="type">int</span> ml, <span class="type">int</span> mr)</span></span>;<span class="comment">//已知一颗二叉树的前序遍历和中序遍历结果 建立这颗二叉树</span></span><br><span class="line">	<span class="comment">//数组pre、mid分别是前序遍历、中序遍历的结果;pl、pr、ml、mr分别是前序、中序遍历结果数组的边界</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;string&gt; <span class="title">init</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>;<span class="comment">//先将string类型的表达式，将元素由char变成string并存在vector中</span></span><br><span class="line">	<span class="comment">// 这样才可以计算多位数</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">judge</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>;<span class="comment">//判断操作符优先度</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">stringToInt</span><span class="params">(string s)</span></span>;<span class="comment">//;string转成等价的int</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">buildExpressionTree</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>;<span class="comment">//将当前树建立为表达式树</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">calculateExpressionTree</span><span class="params">()</span></span>;<span class="comment">//计算当前这颗表达式树</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="二叉树类的成员变量介绍"><a href="#二叉树类的成员变量介绍" class="headerlink" title="二叉树类的成员变量介绍"></a>二叉树类的成员变量介绍</h4><p>二叉树结点类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//binaryTree类的向前说明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binaryTree</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span><span class="comment">//二叉树结点类</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">binaryTree</span>&lt;elemType&gt;;<span class="comment">//结点类将二叉树类视为友元函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	elemType data;</span><br><span class="line">	Node&lt;elemType&gt; *left;<span class="comment">//指针域</span></span><br><span class="line">	Node&lt;elemType&gt; *right;</span><br><span class="line">	<span class="type">int</span> leftFlag; <span class="comment">//用于标识孩子指针是否为线索，0则说明left指向该结点的左孩子，1则说明left指向该结点的直接前驱</span></span><br><span class="line">	<span class="type">int</span> rightFlag; <span class="comment">//用于标识孩子指针是否为线索，0则说明right指向该结点的右孩子，1则说明right指向该结点的直接后继</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Node</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		left = <span class="literal">NULL</span>;</span><br><span class="line">		right = <span class="literal">NULL</span>;</span><br><span class="line">		leftFlag = <span class="number">0</span>;</span><br><span class="line">		rightFlag = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">const</span> elemType&amp; data, Node&lt;elemType&gt; *left = <span class="literal">NULL</span>, Node&lt;elemType&gt; *right = <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;data = data;</span><br><span class="line">		<span class="keyword">this</span>-&gt;left = left;</span><br><span class="line">		<span class="keyword">this</span>-&gt;right = right;</span><br><span class="line">		leftFlag = <span class="number">0</span>;</span><br><span class="line">		rightFlag = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>data为结点的数据域</p><p>left和right是指针域</p><p>leftFlag&#x2F;rightFlag用于标识 孩子指针是否为线索，0则说明孩子指针保存的是指向该结点的孩子的地址，1则说明孩子指针保存的是该结点的直接前驱&#x2F;后继的地址</p><blockquote><p>详见<a href="#%E4%BA%8C%E5%8F%89%E7%BA%BF%E7%B4%A2%E6%A0%91">二叉线索树</a></p></blockquote></blockquote><p>二叉树类的成员变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binaryTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Node&lt;elemType&gt; *root;<span class="comment">//链式二叉树的根结点指针</span></span><br><span class="line">	elemType stopFlag;<span class="comment">//结束标志</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>stopFlag：在创建二叉树的时候，需要不断获取二叉树的结点，这个变量是用来 终止获取结点 的结束标志</p></blockquote><h3 id="二叉树类的实现："><a href="#二叉树类的实现：" class="headerlink" title="二叉树类的实现："></a>二叉树类的实现：</h3><h4 id="二叉树的构建"><a href="#二叉树的构建" class="headerlink" title="二叉树的构建"></a>二叉树的构建</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模版不支持分离编译！！！</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">creatTree</span>(<span class="type">const</span> elemType&amp; flag)<span class="comment">//创建一棵二叉树</span></span><br><span class="line"><span class="comment">//借助队列来创建一颗二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">	queue&lt;Node&lt;elemType&gt; *&gt; que;</span><br><span class="line">	elemType e, el, er;<span class="comment">//根结点、左孩子、右孩子的data</span></span><br><span class="line">	Node&lt;elemType&gt; *p, *pl, *pr;<span class="comment">//根结点、左孩子、后孩子的地址</span></span><br><span class="line"></span><br><span class="line">	stopFlag = flag;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Please input the root:&quot;</span>;<span class="comment">//输入根结点的值</span></span><br><span class="line">	cin &gt;&gt; e;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (e == flag)<span class="comment">//判断是否为结束标志</span></span><br><span class="line">	&#123;</span><br><span class="line">		root = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;elemType&gt;(e);<span class="comment">//new一个Node结点，作为根结点</span></span><br><span class="line">	root = p;</span><br><span class="line"></span><br><span class="line">	que.<span class="built_in">push</span>(p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		p = que.<span class="built_in">front</span>();</span><br><span class="line">		que.<span class="built_in">pop</span>();<span class="comment">//获得队首元素并出队</span></span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Please input the left_child and the right_child of &quot;</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; using &quot;</span> &lt;&lt; stopFlag</span><br><span class="line">			 &lt;&lt; <span class="string">&quot; as no child&quot;</span>;</span><br><span class="line">		cin &gt;&gt; el &gt;&gt; er;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (el != stopFlag)<span class="comment">//如果根结点有左孩子</span></span><br><span class="line">		&#123;</span><br><span class="line">			pl = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;elemType&gt;(el);</span><br><span class="line">			p-&gt;left = pl;</span><br><span class="line">			que.<span class="built_in">push</span>(pl);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (er != stopFlag)<span class="comment">//如果根结点有右孩子</span></span><br><span class="line">		&#123;</span><br><span class="line">			pr = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;elemType&gt;(er);</span><br><span class="line">			p-&gt;right = pr;</span><br><span class="line">			que.<span class="built_in">push</span>(pr);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>借助队列构建二叉树</p><p>首先创建树的根结点入队列</p><p>只要队列不为空，循环</p><p>每次获取队首元素p并出队</p><p>若p有孩子，则创建p的左&#x2F;右孩子结点，让p的指针域指向它们，并将左右孩子入队列。</p><p>否则不执行操作，进入下一次循环</p><p>队空，结束 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211171311731.png" alt="截屏2022-11-17 13.11.05" style="zoom:50%"></p></blockquote><h4 id="递归求以二叉树的结点的个数"><a href="#递归求以二叉树的结点的个数" class="headerlink" title="递归求以二叉树的结点的个数"></a>递归求以二叉树的结点的个数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> binaryTree&lt;elemType&gt;::<span class="built_in">Size</span>(Node&lt;elemType&gt; *t)<span class="comment">//递归求二叉树的结点的个数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> t == <span class="literal">NULL</span> ? <span class="number">0</span> : <span class="number">1</span> + <span class="built_in">Size</span>(t-&gt;left) + <span class="built_in">Size</span>(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> binaryTree&lt;elemType&gt;::<span class="built_in">Size</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Size</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以结合图思考</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221014105348435.png" alt="image-20221014105348435" style="zoom:80%"></blockquote><h4 id="递归求二叉树的高度-x2F-深度"><a href="#递归求二叉树的高度-x2F-深度" class="headerlink" title="递归求二叉树的高度&#x2F;深度"></a>递归求二叉树的高度&#x2F;深度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> binaryTree&lt;elemType&gt;::<span class="built_in">Height</span>(Node&lt;elemType&gt; *t)<span class="comment">//递归求二叉树的高度</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!t)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Height</span>(t-&gt;left) &gt; <span class="built_in">Height</span>(t-&gt;right) ? <span class="built_in">Height</span>(t-&gt;left) + <span class="number">1</span> : <span class="built_in">Height</span>(t-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> binaryTree&lt;elemType&gt;::<span class="built_in">Height</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Height</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>节点的层次：从根开始定义，根为第一层，根的子结点所在的为第二层，以此类推</p><blockquote><p>如下图，A的层次是1，C的是2，H的是4</p></blockquote><p>树的高度&#x2F;深度：根中结点的最大层次，下图中树的高度就是4</p><p>思路：递归</p><p>结点为空则返回高度为0，否则返回当前结点为根结点的树的高度：</p><p>左右子树比较高度，更高的高度+1，就是当前结点为根结点的树的高度</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E5%9B%BE%E7%89%8720221117235938.jpg" alt="QQ图片20221117235938" style="zoom:23%"></blockquote><h4 id="递归删除二叉树"><a href="#递归删除二叉树" class="headerlink" title="递归删除二叉树"></a>递归删除二叉树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">delTree</span>(Node&lt;elemType&gt; *t)<span class="comment">//递归删除二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!t)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">delTree</span>(t-&gt;left);</span><br><span class="line">	<span class="built_in">delTree</span>(t-&gt;right);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> t;</span><br><span class="line">	<span class="comment">/*这里t不用指向NULL，1是因为它是形参，指向也没用，2是下面的root需要指向形参是因为root是类的成员函数，后续还会调用它</span></span><br><span class="line"><span class="comment">	避免root指向被释放的空间，造成非法访问，成为野指针*/</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">delTree</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">delTree</span>(root);</span><br><span class="line">	root = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的遍历："><a href="#二叉树的遍历：" class="headerlink" title="二叉树的遍历："></a>二叉树的遍历：</h4><h5 id="二叉树的递归遍历："><a href="#二叉树的递归遍历：" class="headerlink" title="二叉树的递归遍历："></a>二叉树的递归遍历：</h5><h6 id="前序遍历-递归"><a href="#前序遍历-递归" class="headerlink" title="前序遍历(递归)"></a>前序遍历(递归)</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">preOrder</span>(Node&lt;elemType&gt; *t)<span class="comment">//递归，按前序遍历输出以t为根的二叉树的结点的数据值</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!t)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;NUll &quot;;//如果想要更清楚观察前序遍历的原理，可以在空结点时输出&quot;NULL &quot;</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; t-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//根，左，右</span></span><br><span class="line">	<span class="built_in">preOrder</span>(t-&gt;left);</span><br><span class="line">	<span class="built_in">preOrder</span>(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//template&lt;class elemType&gt;</span></span><br><span class="line"><span class="comment">//void binaryTree&lt;elemType&gt;::preOrder()//递归，前序遍历整棵树</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	preOrder(root);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h6 id="中序遍历-递归"><a href="#中序遍历-递归" class="headerlink" title="中序遍历(递归)"></a>中序遍历(递归)</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">inOrder</span>(Node&lt;elemType&gt; *t)<span class="comment">//递归，按中序遍历输出以t为根的二叉树的结点的数据值</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!t)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;NUll &quot;;//如果想要更清楚观察前序遍历的原理，可以在空结点时输出&quot;NULL &quot;</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">inOrder</span>(t-&gt;left);<span class="comment">//左，根，右</span></span><br><span class="line">	cout &lt;&lt; t-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="built_in">inOrder</span>(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//template&lt;class elemType&gt;</span></span><br><span class="line"><span class="comment">//void binaryTree&lt;elemType&gt;::inOrder()//递归，中序遍历整棵树</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	inOrder(root);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h6 id="后序遍历-递归"><a href="#后序遍历-递归" class="headerlink" title="后序遍历(递归)"></a>后序遍历(递归)</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">postOrder</span>(Node&lt;elemType&gt; *t)<span class="comment">//递归，按后序遍历输出以t为根的二叉树的结点的数据值</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!t)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;NUll &quot;;//如果想要更清楚观察前序遍历的原理，可以在空结点时输出&quot;NULL &quot;</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">postOrder</span>(t-&gt;left);</span><br><span class="line">	<span class="built_in">postOrder</span>(t-&gt;right);</span><br><span class="line">	cout &lt;&lt; t-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//template&lt;class elemType&gt;</span></span><br><span class="line"><span class="comment">//void binaryTree&lt;elemType&gt;::postOrder()//递归，后序遍历整棵树</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	postOrder(root);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h5 id="二叉树的非递归遍历："><a href="#二叉树的非递归遍历：" class="headerlink" title="二叉树的非递归遍历："></a>二叉树的非递归遍历：</h5><blockquote><p>二叉树的非递归遍历，需要用 栈 来进行辅助</p></blockquote><h6 id="前序遍历-非递归"><a href="#前序遍历-非递归" class="headerlink" title="前序遍历(非递归)"></a>前序遍历(非递归)</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">preOrder</span>()<span class="comment">//非递归，前序遍历整棵树</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root)</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">	Node&lt;elemType&gt; *p;<span class="comment">//当前访问的结点</span></span><br><span class="line">	stack&lt;Node&lt;elemType&gt; *&gt; s;<span class="comment">//辅助栈，存放即将访问的结点</span></span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		p = s.<span class="built_in">top</span>();</span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;right)</span><br><span class="line">			s.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;left)</span><br><span class="line">			s.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>前序遍历的访问是“根、左、右”</p><p>用一个栈s存储 需要遍历的结点 ，先将root入栈</p><p>只要栈不为空，就循环</p><p>获取栈顶元素p并出栈</p><p>访问p结点，输出p的data</p><p>看p有无左&#x2F;右孩子，有则入栈</p><p>注意应让右孩子先入栈，再让左孩子入栈</p><blockquote><p>因为栈的特性，后进先出，前序遍历要求访问完根结点之后先访问它的左孩子</p><p>所以应先让右孩子入栈，再让左孩子入栈，这样才能保证栈顶元素是左孩子</p></blockquote><blockquote><p>还是因为栈的特性，访问结点的时候让它的孩子入栈，这样就保证了访问完结点之后访问的就是它的孩子</p></blockquote><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20221118113318.png" alt="QQ截图20221118113318" style="zoom:40%"></blockquote><h6 id="中序遍历-非递归"><a href="#中序遍历-非递归" class="headerlink" title="中序遍历(非递归)"></a>中序遍历(非递归)</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">inOrder</span>()<span class="comment">//非递归，中序遍历整棵树</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root)</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">	Node&lt;elemType&gt; *p;<span class="comment">//当前结点</span></span><br><span class="line">	stack&lt;Node&lt;elemType&gt; *&gt; s1;<span class="comment">//辅助栈，保存即将访问的结点</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> flag;<span class="comment">//用来记录结点的访问情况：是否访问过左孩子。没访问过则左孩子入栈；访问过左孩子才能访问当前结点的data，然后将右孩子入栈</span></span><br><span class="line">	<span class="comment">//未访问过左孩子，值为0，访问过左孩子，值为1</span></span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; s2;<span class="comment">//保存s1中每个结点的访问情况</span></span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">push</span>(root);</span><br><span class="line">	s2.<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//root的初始访问情况是0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!s1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		p = s1.<span class="built_in">top</span>();<span class="comment">//获取栈顶元素，为当前结点</span></span><br><span class="line">		flag = s2.<span class="built_in">top</span>();<span class="comment">//获取栈顶元素，为当前结点的访问情况</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">1</span>)<span class="comment">//如果访问过当前结点的左孩子，则访问当前结点的data，输出data、右孩子入栈</span></span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//访问输出当前结点的data</span></span><br><span class="line">  		<span class="comment">//访问完了当前结点的data，当前结点应当出栈</span></span><br><span class="line">      s1.<span class="built_in">pop</span>();</span><br><span class="line">			s2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;right)<span class="comment">//有右孩子则压栈</span></span><br><span class="line">			&#123;</span><br><span class="line">				s1.<span class="built_in">push</span>(p-&gt;right);<span class="comment">//右孩子压栈</span></span><br><span class="line">				s2.<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//右孩子的初始访问情况是0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//没访问过左孩子</span></span><br><span class="line">		&#123;</span><br><span class="line">			s2.<span class="built_in">pop</span>();</span><br><span class="line">			s2.<span class="built_in">push</span>(<span class="number">1</span>);<span class="comment">//更新当前结点的访问情况</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;left)<span class="comment">//左孩子入栈</span></span><br><span class="line">			&#123;</span><br><span class="line">				s1.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">				s2.<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//左孩子初始访问情况是0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>中序遍历的访问顺序是“左、根、右”</p><p>在访问结点的时候，需要考虑该结点是否访问过左孩子，若没有访问左孩子，则应先访问左孩子，之后再访问当前结点data，然后再访问右孩子</p><p>用flag记录结点的访问情况，未访问过左孩子则值为0，访问过则值为1，根据flag来判断对当前结点如何操作</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20221118113318.png" alt="QQ截图20221118113318" style="zoom:33%"></blockquote><h6 id="后序遍历-非递归"><a href="#后序遍历-非递归" class="headerlink" title="后序遍历(非递归)"></a>后序遍历(非递归)</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">postOrder</span>()<span class="comment">//非递归，后序遍历整棵树</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root)</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">	Node&lt;elemType&gt; *p;<span class="comment">//当前结点</span></span><br><span class="line">	stack&lt;Node&lt;elemType&gt; *&gt; s1;<span class="comment">//辅助栈，保存即将访问的结点</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> flag;<span class="comment">//用来记录当前结点的访问情况。没访问过左孩子则左孩子入栈；访问过左孩子但没有访问过右孩子则右孩子入栈；访问过右孩子才能访问当前结点的data</span></span><br><span class="line">	<span class="comment">//未访问过左孩子，值为0；访问过左孩子未访问过右孩子，值为1；访问过右孩子，值为2</span></span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; s2;<span class="comment">//保存s1中每个结点的访问情况</span></span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">push</span>(root);</span><br><span class="line">	s2.<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//root的初始访问情况是0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!s1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		p = s1.<span class="built_in">top</span>();<span class="comment">//获取栈顶元素，为当前结点</span></span><br><span class="line">		flag = s2.<span class="built_in">top</span>();<span class="comment">//获取栈顶元素，为当前结点的访问情况</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">2</span>)<span class="comment">//访问过当前结点的右孩子，则访问当前结点的data</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//访问输出当前结点的data</span></span><br><span class="line">  		<span class="comment">//访问完了当前结点的data，当前结点应当出栈</span></span><br><span class="line">      s1.<span class="built_in">pop</span>();</span><br><span class="line">			s2.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">1</span>)<span class="comment">//访问过当前结点的左孩子但未访问右孩子</span></span><br><span class="line">		&#123;</span><br><span class="line">			s2.<span class="built_in">pop</span>();</span><br><span class="line">			s2.<span class="built_in">push</span>(<span class="number">2</span>);<span class="comment">//更新当前结点的访问情况</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;right)<span class="comment">//有右孩子则压栈</span></span><br><span class="line">			&#123;</span><br><span class="line">				s1.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">				s2.<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//右孩子的初始访问情况是0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">0</span>)<span class="comment">//未访问过当前结点的左孩子</span></span><br><span class="line">		&#123;</span><br><span class="line">			s2.<span class="built_in">pop</span>();</span><br><span class="line">			s2.<span class="built_in">push</span>(<span class="number">1</span>);<span class="comment">//更新当前结点的访问情况</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;left)<span class="comment">//左孩子入栈</span></span><br><span class="line">			&#123;</span><br><span class="line">				s1.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">				s2.<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//左孩子初始访问情况是0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>思路跟中序遍历类似，访问结点的时候按照“左、右、根”的顺序</p><p>访问结点的时候要判断是否访问过左孩子，没有访问过左孩子要先访问左孩子，如果访问过左孩子要判断是否访问过右孩子，访问过右孩子才能访问当前结点，输出当前结点的值</p><p>flag为 0 说明 未访问过当前结点的左孩子；1则说明访问过左孩子但是没访问右孩子；2则说明访问过右孩子，可以输出当前结点的data</p></blockquote><h6 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">levelOrder</span>()<span class="comment">//层序遍历</span></span><br><span class="line">&#123;</span><br><span class="line">	queue&lt;Node&lt;elemType&gt; *&gt; que;<span class="comment">//辅助队列保存即将访问的结点</span></span><br><span class="line">	Node&lt;elemType&gt; *p;<span class="comment">//当前访问的结点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!root)</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">	que.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		p = que.<span class="built_in">front</span>();</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">		cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;left)</span><br><span class="line">			que.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;right)</span><br><span class="line">			que.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉线索树："><a href="#二叉线索树：" class="headerlink" title="二叉线索树："></a>二叉线索树：</h4><blockquote><p>对于n个结点的二叉树，在二叉链存储结构总中有n+1个空链域</p><blockquote><p>有些结点没有左&#x2F;右孩子，指针域保存的地址是空的，这个指针域是空链域</p></blockquote><p>利用这些空链域存放在 某种遍历次序下的结果中 该结点的 直接前驱结点 和 直接后继结点 的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树。</p><blockquote><p>直接前驱、直接后继：通过某种遍历方式，获得二叉树的遍历结果，在遍历结果中，某个结点的前一个结点就是 在当前遍历方式下 自己的直接前驱，后一个结点就是 在当前遍历方式下 自己的直接后继</p><p>如果指针域的指针存的是直接前驱&#x2F;后继的地址，则就能找到当前结点的直接前驱或者直接后继，这就为遍历提供了线索，故称这种指针为线索</p></blockquote><p>根据线索性质的不同，二叉树可分为前序遍历线索二叉树、中序遍历线索二叉树和后序遍历线索二叉树三种。</p></blockquote><h5 id="中序遍历线索二叉树的构建"><a href="#中序遍历线索二叉树的构建" class="headerlink" title="中序遍历线索二叉树的构建"></a>中序遍历线索二叉树的构建</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">Node&lt;elemType&gt; *binaryTree&lt;elemType&gt;::<span class="built_in">threadMin</span>()<span class="comment">//建立中序遍历线索树</span></span><br><span class="line"><span class="comment">//实质就是在中序遍历的时候将结点的空链域存上线索</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root)</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">	Node&lt;elemType&gt; *first = <span class="literal">NULL</span>;<span class="comment">//记录中序遍历结果中的第一个结点</span></span><br><span class="line">	Node&lt;elemType&gt; *pre = <span class="literal">NULL</span>;<span class="comment">//在中序遍历中当前结点的直接前驱</span></span><br><span class="line"></span><br><span class="line">	Node&lt;elemType&gt; *p;<span class="comment">//当前结点</span></span><br><span class="line">	stack&lt;Node&lt;elemType&gt; *&gt; s1;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">  stack&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">push</span>(root);</span><br><span class="line">	s2.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//实质就是在中序遍历的时候将结点的空链域存上线索</span></span><br><span class="line">	<span class="keyword">while</span> (!s1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">    p = s1.<span class="built_in">top</span>();</span><br><span class="line">		flag = s2.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;-----&quot;</span> &lt;&lt; endl;</span><br><span class="line">      s1.<span class="built_in">pop</span>();</span><br><span class="line">      s2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!first)<span class="comment">//p结点data在此已经访问完了，如果first为空说明p就是中序遍历结果中的第一个结点</span></span><br><span class="line">				first = p;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;right &amp;&amp; p-&gt;rightFlag == <span class="number">0</span>)<span class="comment">//如果当前结点有右孩子，右孩子入栈</span></span><br><span class="line">        <span class="comment">//rightFlag == 0说明右指针存的是右孩子，== 1说明右指针存的是直接后继</span></span><br><span class="line">			&#123;</span><br><span class="line">				s1.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">				s2.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!p-&gt;left)<span class="comment">//如果左指针为空，用来存直接前驱</span></span><br><span class="line">			&#123;</span><br><span class="line">				p-&gt;leftFlag = <span class="number">1</span>;</span><br><span class="line">				p-&gt;left = pre;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//////////////辅助调试，输出一下当前结点直接前驱的data///////////////////////</span></span><br><span class="line">				cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;&#x27;s pre: &quot;</span>;</span><br><span class="line">				<span class="keyword">if</span> (p-&gt;left)</span><br><span class="line">					cout &lt;&lt; p-&gt;left-&gt;data &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">else</span><span class="comment">//中序遍历结果中的第一个结点没有直接前驱，是线索二叉树中唯一一个左指针为空的</span></span><br><span class="line">					cout &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!p-&gt;right)<span class="comment">//如果右指针为空，用来存直接后继</span></span><br><span class="line">			&#123;</span><br><span class="line">				p-&gt;rightFlag = <span class="number">1</span>;</span><br><span class="line">				p-&gt;right = !s1.<span class="built_in">empty</span>() ? s1.<span class="built_in">top</span>() : <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//s1栈顶就是当前结点的直接后继，如果栈为空，说明当前结点是中序遍历结果中的最后一个结点，是线索二叉树中唯一一个右指针为空的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////辅助调试，输出一下当前结点直接前驱的data///////////////////////</span></span><br><span class="line">				cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;&#x27;s next: &quot;</span>;</span><br><span class="line">				<span class="keyword">if</span> (p-&gt;right)</span><br><span class="line">					cout &lt;&lt; p-&gt;right-&gt;data &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">else</span><span class="comment">//中序遍历结果中的最后一个结点没有直接后继，是线索二叉树中唯一一个右指针为空的</span></span><br><span class="line">					cout &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pre = p;<span class="comment">//已访问完当前结点，当前结点成为了下一个要访问的结点的直接前驱</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span><span class="comment">//如果flag == 0</span></span><br><span class="line">		&#123;</span><br><span class="line">      s2.<span class="built_in">pop</span>();</span><br><span class="line">			s2.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;leftFlag == <span class="number">0</span> &amp;&amp; p-&gt;left)<span class="comment">//左结点为左孩子的话，将左孩子入结点栈</span></span><br><span class="line">			&#123;</span><br><span class="line">				s1.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">				s2.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在进行中序遍历的时候顺便对当前访问的结点添加上线索</p><p>访问的上一个结点是当前结点的直接前驱，即将访问的下一个结点(栈顶元素)是当前结点的直接后继</p></blockquote><h5 id="借助中序遍历线索树实现-中序非递归遍历"><a href="#借助中序遍历线索树实现-中序非递归遍历" class="headerlink" title="借助中序遍历线索树实现 中序非递归遍历"></a>借助中序遍历线索树实现 中序非递归遍历</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">threadMidInOrder</span>(Node&lt;elemType&gt; *first)<span class="comment">//借助中序线索树，非递归 中序遍历原来的二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!first || !root)</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">	Node&lt;elemType&gt; *p = first;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;rightFlag == <span class="number">0</span>)<span class="comment">//如果p有右孩子，访问p的右孩子</span></span><br><span class="line">		&#123;</span><br><span class="line">			p = p-&gt;right;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (p-&gt;leftFlag == <span class="number">0</span> &amp;&amp; p-&gt;left)<span class="comment">//当前结点有左子树，应访问左子树的最左结点</span></span><br><span class="line">				p = p-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">		<span class="keyword">else</span><span class="comment">//如果p无右孩子，则直接用线索找它的直接后继</span></span><br><span class="line">			p = p-&gt;right;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从first开始遍历</p><p>遍历结点时</p><p>有右孩子去往右孩子，访问右孩子时，右孩子有左子树，则去往左子树的最左结点</p><p>无右孩子则去往直接后继</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211201041959.png" alt="iShot_2022-11-20_10.41.22" style="zoom:20%"></blockquote><h5 id="借助中序遍历线索树实现-前序非递归遍历"><a href="#借助中序遍历线索树实现-前序非递归遍历" class="headerlink" title="借助中序遍历线索树实现 前序非递归遍历"></a>借助中序遍历线索树实现 前序非递归遍历</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">threadMidPreOrder</span>()<span class="comment">//借助中序线索树，非递归 前序遍历 原来的二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root)</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">	Node&lt;elemType&gt; *p = root;<span class="comment">//从root开始访问</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;leftFlag == <span class="number">0</span>)<span class="comment">//如果有左孩子，则直接访问左孩子</span></span><br><span class="line">			p = p-&gt;left;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span><span class="comment">//没有左孩子则访问右孩子</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (p-&gt;rightFlag == <span class="number">1</span> &amp;&amp; p-&gt;right)<span class="comment">//如果没有右孩子，则去往直接后继，直到有右孩子或者右结点为空(中序遍历结果中的最后一个结点</span></span><br><span class="line">			&#123;</span><br><span class="line">				p = p-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			p = p-&gt;right;<span class="comment">//去往右孩子</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从root开始遍历</p><p>有左孩子访问左孩子</p><p>没有左孩子访问右孩子，没有右孩子则去往直接后继，直到有右孩子，访问右孩子</p></blockquote><h4 id="已知前中序遍历结果，求二叉树"><a href="#已知前中序遍历结果，求二叉树" class="headerlink" title="已知前中序遍历结果，求二叉树"></a>已知前中序遍历结果，求二叉树</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">Node&lt;elemType&gt; *binaryTree&lt;elemType&gt;::<span class="built_in">buildTree</span>(elemType pre[], <span class="type">int</span> pl, <span class="type">int</span> pr,</span><br><span class="line">	elemType mid[], <span class="type">int</span> ml, <span class="type">int</span> mr)<span class="comment">//已知一颗二叉树的前序遍历和中序遍历结果 建立这颗二叉树</span></span><br><span class="line"><span class="comment">//数组pre、mid分别是前序遍历、中序遍历的结果;pl、pr、ml、mr分别是前序、中序遍历结果数组的边界</span></span><br><span class="line">&#123;</span><br><span class="line">	Node&lt;elemType&gt; *p;<span class="comment">//创建当前树的根结点</span></span><br><span class="line">	Node&lt;elemType&gt; *leftRoot, *rightRoot;<span class="comment">//创建当前树的左子树、右子树的根结点</span></span><br><span class="line">	<span class="type">int</span> i, pos, num;<span class="comment">//pos：当前树的根在中序遍历中的位置，num：记录左子树结点个数</span></span><br><span class="line">	<span class="comment">//(根在前序遍历中的位置不用记录，前序遍历结果的第一个就是)</span></span><br><span class="line">	<span class="type">int</span> lpl, lpr, lml, lmr;<span class="comment">//记录前序遍历、中序遍历中左子树的范围</span></span><br><span class="line">	<span class="type">int</span> rpl, rpr, rml, rmr;<span class="comment">//记录前序遍历、中序遍历中右子树的范围</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pl &gt; pr)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	p = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;elemType&gt;(pre[pl]);<span class="comment">//创建当前树的根结点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!root)</span><br><span class="line">		root = p;<span class="comment">//如果当前的二叉树是空树，那就直接让当前的树等于创建的二叉树</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = ml; i &lt;= mr; i++)<span class="comment">//开始寻找前序遍历中的根在中序遍历中的位置</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (mid[i] == pre[pl])</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pos = i;<span class="comment">//----找到了中序遍历结果中的根结点----</span></span><br><span class="line">	num = pos - ml;<span class="comment">//记录左子树的结点个数</span></span><br><span class="line"></span><br><span class="line">	lpl = pl + <span class="number">1</span>;<span class="comment">//前序遍历结果中 左子树的范围</span></span><br><span class="line">	lpr = pl + num;</span><br><span class="line">	lml = ml;<span class="comment">//中序遍历结果中 左子树的范围</span></span><br><span class="line">	lmr = pos - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	leftRoot = <span class="built_in">buildTree</span>(pre, lpl, lpr, mid, lml, lmr);<span class="comment">//递归，找遍历结果中 左子树中 的根结点</span></span><br><span class="line"></span><br><span class="line">	rpl = lpl + <span class="number">1</span>;<span class="comment">//前序遍历结果中 右子树的范围</span></span><br><span class="line">	rpr = pr;</span><br><span class="line">	rml = pos + <span class="number">1</span>;<span class="comment">//中序遍历结果中 右子树的范围</span></span><br><span class="line">	rmr = mr;</span><br><span class="line"></span><br><span class="line">	rightRoot = <span class="built_in">buildTree</span>(pre, rpl, rpr, mid, rml, rmr);<span class="comment">//递归，找遍历结果中 右子树中 的根结点</span></span><br><span class="line"></span><br><span class="line">	p-&gt;left = leftRoot;</span><br><span class="line">	p-&gt;right = rightRoot;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>根据前序遍历“根、左、右”和中序遍历“左、根、右”</p><p>前序遍历结果中的第一个结点就是根，在中序遍历中找到这个根，中序遍历结果中这个根的左面的所有结点就是这个根的左子树的遍历结果，右面的所有结点就是右子树的遍历结果</p><p>这样可以用前序遍历结果找根，中序遍历结果找子树的遍历结果，构建完整二叉树</p><blockquote><p>树是递归的结构，树可以分为根和子树，子树又分为根和子树</p><p>所以要递归找根结点，直到不能再分</p></blockquote><blockquote><p>例如：已知一棵树的前序遍历和中序遍历结果</p><blockquote><p>前序序列：B、L、S、C、F、D、G、I、H</p><p>中序序列：L、S、B、F、C、I、G、H、D</p></blockquote><p>理论思路过程：</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20221120152841.png" alt="image" style="zoom:33%"><p>算法实现：</p><p>pre、mid：前序遍历、中序遍历的结果结果数组</p><p>pl、pr、ml、mr：前序、中序遍历结果数组的左右边界</p><p>p：创建当前树的根结点</p><p>leftRoot、rightRoot：创建当前树的左子树、右子树的根结点<br>pos：记录当前树的根在中序遍历中的位置</p><p>(根在前序遍历中的位置不用记录，前序遍历结果的第一个就是)</p><p>num：记录左子树结点的个数</p><p>lpl、 lpr、 lml、 lmr：记录前序遍历、中序遍历中左子树的范围</p><p>rpl,、rpr,、rml、rmr：记录前序遍历、中序遍历中右子树的范围</p><p>​ <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211201635521.png" alt="iShot_2022-11-20_16.33.37" style="zoom:33%"></p></blockquote></blockquote><h4 id="表达式树的构建："><a href="#表达式树的构建：" class="headerlink" title="表达式树的构建："></a>表达式树的构建：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">vector&lt;string&gt; binaryTree&lt;elemType&gt;::<span class="built_in">init</span>(<span class="type">const</span> string&amp; s)<span class="comment">//表达式的初始化处理</span></span><br><span class="line"><span class="comment">//原始表达式是string类型的，元素为char类型，因此值大于9的整数(也就是两位以上的整数)会被分成两个元素，无法正常表示和计算</span></span><br><span class="line"><span class="comment">//应先将表达式进行初始化：用元素类型为string的vector保存表达式的操作数和操作字符</span></span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;string&gt; v;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt; s.<span class="built_in">length</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		j = i;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (j &lt; s.<span class="built_in">length</span>() &amp;&amp; s[j] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; s[j] &gt;= <span class="string">&#x27;0&#x27;</span>)<span class="comment">//如果遇到了数字，就往后看是否为多位数</span></span><br><span class="line">		&#123;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i == j)<span class="comment">//说明没有遇到数字</span></span><br><span class="line">			v.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(i++, <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			v.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(i, j - i));</span><br><span class="line">			i = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> binaryTree&lt;elemType&gt;::<span class="built_in">judge</span>(<span class="type">const</span> string&amp; s)<span class="comment">//判断操作符优先度</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (s == <span class="string">&quot;+&quot;</span> || s == <span class="string">&quot;-&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;*&quot;</span> || s == <span class="string">&quot;/&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;(&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;)&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> binaryTree&lt;elemType&gt;::<span class="built_in">stringToInt</span>(string s)<span class="comment">//表达式中的操作数string类转int</span></span><br><span class="line">&#123;</span><br><span class="line">	stringstream ss;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	ss &lt;&lt; s;</span><br><span class="line">	ss &gt;&gt; i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">buildExpressionTree</span>(<span class="type">const</span> string&amp; s)<span class="comment">//将当前树建立为表达式树</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (root)<span class="comment">//表达式树应该用空树来建</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;This binaryTree is not a null tree , please define another binaryTree to make it as a ExpressionTree&quot;</span></span><br><span class="line">			 &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	stack&lt;string&gt; s1;<span class="comment">//操作符栈</span></span><br><span class="line">	stack&lt;Node&lt;string&gt; *&gt; s2;<span class="comment">//子树栈，用来存放根结点的地址</span></span><br><span class="line">	Node&lt;string&gt; *p, *left, *right;</span><br><span class="line"></span><br><span class="line">	vector&lt;string&gt; v = <span class="built_in">init</span>(s);<span class="comment">//先将string类型的表达式初始化，将元素由char变成string并存在vector中</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">judge</span>(v[i]) == <span class="number">0</span>)<span class="comment">//如果是操作数，直接创建作为根结点进子树栈</span></span><br><span class="line">		&#123;</span><br><span class="line">			p = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;string&gt;(v[i]);</span><br><span class="line">			s2.<span class="built_in">push</span>(p);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">judge</span>(v[i]) == <span class="number">3</span>)<span class="comment">//如果当前操作符是左括号，直接进栈</span></span><br><span class="line">			s1.<span class="built_in">push</span>(v[i]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">judge</span>(v[i]) == <span class="number">1</span> || <span class="built_in">judge</span>(v[i]) == <span class="number">2</span>)<span class="comment">//如果是 加减乘除 操作符</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (s1.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">				s1.<span class="built_in">push</span>(v[i]);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">while</span> (!s1.<span class="built_in">empty</span>() &amp;&amp; s1.<span class="built_in">top</span>() != <span class="string">&quot;(&quot;</span> &amp;&amp; <span class="built_in">judge</span>(v[i]) &lt; <span class="built_in">judge</span>(s1.<span class="built_in">top</span>()))</span><br><span class="line">					<span class="comment">//如果栈不为空且栈顶元素不是&quot;(&quot;，并且当前操作符优先度 小于栈顶，就让栈顶出栈</span></span><br><span class="line">					<span class="comment">//每次出栈，出栈的栈顶元素要与子树栈的两个栈顶元素构建成子树，并压入子树栈</span></span><br><span class="line">				&#123;</span><br><span class="line"></span><br><span class="line">					right = s2.<span class="built_in">top</span>();</span><br><span class="line">					s2.<span class="built_in">pop</span>();</span><br><span class="line">					left = s2.<span class="built_in">top</span>();</span><br><span class="line">					s2.<span class="built_in">pop</span>();<span class="comment">//子树栈两个栈顶元素出栈</span></span><br><span class="line"></span><br><span class="line">					p = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;string&gt;(s1.<span class="built_in">top</span>());</span><br><span class="line">					s1.<span class="built_in">pop</span>();<span class="comment">//操作符栈顶元素出栈，与刚出子树栈的两个栈顶元素构建成子树，压入子树栈</span></span><br><span class="line">					p-&gt;left = left;</span><br><span class="line">					p-&gt;right = right;</span><br><span class="line">					<span class="comment">//在表达式树中，数字作为左结点是操作数，右结点是被操作数（表达式中左边的数是操作数，右边的数是被操作数</span></span><br><span class="line">					<span class="comment">//而表达式中的数字从左到右正序入栈，因此栈顶是被操作数，作为树结点的时候要记得反过来</span></span><br><span class="line">					s2.<span class="built_in">push</span>(p);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//当前操作符优先度不低于栈顶 or 栈为空</span></span><br><span class="line">				s1.<span class="built_in">push</span>(v[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">judge</span>(v[i]) == <span class="number">-1</span>)<span class="comment">//当前操作符是右括号的话</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="built_in">judge</span>(s1.<span class="built_in">top</span>()) != <span class="number">3</span>)<span class="comment">//在遇到左括号之前，一直将操作符栈顶弹栈</span></span><br><span class="line">				<span class="comment">//每次出栈，出栈的栈顶元素要与子树栈的两个栈顶元素构建成子树，并压入子树栈</span></span><br><span class="line">			&#123;</span><br><span class="line">				right = s2.<span class="built_in">top</span>();</span><br><span class="line">				s2.<span class="built_in">pop</span>();</span><br><span class="line">				left = s2.<span class="built_in">top</span>();</span><br><span class="line">				s2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">				p = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;string&gt;(s1.<span class="built_in">top</span>());</span><br><span class="line">				s1.<span class="built_in">pop</span>();</span><br><span class="line">				p-&gt;left = left;</span><br><span class="line">				p-&gt;right = right;</span><br><span class="line"></span><br><span class="line">				s2.<span class="built_in">push</span>(p);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			s1.<span class="built_in">pop</span>();<span class="comment">//遇到左括号，左括号出栈</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!s1.<span class="built_in">empty</span>())<span class="comment">//处理操作符栈，将栈顶元素出栈直到栈空</span></span><br><span class="line">		<span class="comment">//每次出栈，出栈的栈顶元素要与子树栈的两个栈顶元素构建成子树，并压入子树栈</span></span><br><span class="line">	&#123;</span><br><span class="line">		right = s2.<span class="built_in">top</span>();</span><br><span class="line">		s2.<span class="built_in">pop</span>();</span><br><span class="line">		left = s2.<span class="built_in">top</span>();</span><br><span class="line">		s2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		p = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;string&gt;(s1.<span class="built_in">top</span>());</span><br><span class="line">		s1.<span class="built_in">pop</span>();</span><br><span class="line">		p-&gt;left = left;</span><br><span class="line">		p-&gt;right = right;</span><br><span class="line"></span><br><span class="line">		s2.<span class="built_in">push</span>(p);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//子树栈中只会剩下一个根结点，这个根结点就是表达式树的根结点</span></span><br><span class="line">	root = s2.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总体思路：</p><ol><li><p>表达式其实是一种递归，表达式是由 左操作数 操作符 右操作数 组成</p><p>而 操作数 是 表达式的值</p><p>所以表达式 是由 左表达式的值 操作符 右表达式的值 组成</p></li><li><p>在计算表达式的时候，要先知道 左操作数 和 右操作数 才能进行计算，也就是要先计算左表达式和右表达式</p></li><li><p>在计算表达式的时候，优先度越高的表达式越先计算，其结果作为优先度低一级的部分的操作数</p><p>因此表达式，是由优先度比自己高的表达式(的结果)组成的</p></li><li><p>所以表达式本质就是二叉树，左子树是左表达式，根结点是操作符，右子树是右表达式</p><p>树的叶子结点是表达式里的操作数</p></li></ol><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211201957372.jpeg" alt="IMG_0788" style="zoom:50%"></blockquote><blockquote><p>构建表达式树，就是优先度越高的部分组成的子树层次越深，越靠近叶子</p><p>从左到右顺序读取表达式的元素，将表达式的操作数都建成结点，这个是表达式树的叶子结点</p><p>优先级最高的表达式最先构建成树，并且成为优先级低于自己的表达式的子树</p></blockquote><blockquote><p>s1为操作符栈，用来比较操作符的优先度和存储操作符</p><p>s2为子树栈，存放已经建成的表达式子树</p><p>遍历表达式vector</p><p>如果是操作数，直接进s2栈</p><p>如果是操作符</p><ol><li><p>如果s1栈为空，直接进s1</p></li><li><p>如果s1栈不为空</p><ol><li><p>如果当前操作符为 左括号，直接进栈</p></li><li><p>如果当前操作符是 加减乘除，就与栈顶比较，如果栈顶不为空且不为 左括号，比栈顶优先级低，就让栈顶出栈，</p><blockquote><p>每次出栈，出栈的栈顶元素要与子树栈的两个栈顶元素构建成子树，并压入子树栈</p></blockquote></li><li><p>如果当前操作符为 右括号，在遇到左括号之前，一直将操作符栈顶弹栈(操作符弹栈，按照👆的规矩)，直到遇到左括号，将左括号出栈</p><blockquote><p>每次出栈，出栈的栈顶元素要与子树栈的两个栈顶元素构建成子树，并压入子树栈</p></blockquote></li></ol></li></ol><p>遍历完表达式之后，处理子树栈，将各个子树组成一个表达式树</p><blockquote><p>将操作符栈栈顶出栈直到栈空，每次出栈，出栈的栈顶元素要与子树栈的两个栈顶元素构建成子树，并压入子树栈</p></blockquote><p>子树栈中只会剩下一个根结点，这个根结点就是表达式树的根结点</p></blockquote><h4 id="表达式树的计算："><a href="#表达式树的计算：" class="headerlink" title="表达式树的计算："></a>表达式树的计算：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> binaryTree&lt;elemType&gt;::<span class="built_in">calculateExpressionTree</span>()<span class="comment">//计算表达式树</span></span><br><span class="line"><span class="comment">//表达式数字都是叶子结点，操作符都是分支结点。用后序遍历访问整棵树，遇到数字就进操作数栈，遇到操作符就用操作数栈里的数字计算，结果入栈</span></span><br><span class="line"><span class="comment">//在后序非递归遍历的基础上进行修改即可</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root)</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">	stack&lt;Node&lt;elemType&gt; *&gt; s1;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line">	Node&lt;elemType&gt; *p;</span><br><span class="line">	<span class="type">int</span> flag;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; num;<span class="comment">//操作数栈</span></span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">push</span>(root);</span><br><span class="line">	s2.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!s1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		flag = s2.<span class="built_in">top</span>();</span><br><span class="line">		s2.<span class="built_in">pop</span>();</span><br><span class="line">		p = s1.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			s1.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;data == <span class="string">&quot;+&quot;</span> || p-&gt;data == <span class="string">&quot;-&quot;</span> || p-&gt;data == <span class="string">&quot;*&quot;</span> || p-&gt;data == <span class="string">&quot;/&quot;</span>)<span class="comment">//如果是操作符，执行计算</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> n2 = num.<span class="built_in">top</span>();</span><br><span class="line">				num.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="type">int</span> n1 = num.<span class="built_in">top</span>();</span><br><span class="line">				num.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (p-&gt;data == <span class="string">&quot;+&quot;</span>)</span><br><span class="line">					num.<span class="built_in">push</span>(n1 + n2);</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;data == <span class="string">&quot;-&quot;</span>)</span><br><span class="line">					num.<span class="built_in">push</span>(n1 - n2);</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;data == <span class="string">&quot;/&quot;</span>)</span><br><span class="line">					num.<span class="built_in">push</span>(n1 / n2);</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;data == <span class="string">&quot;*&quot;</span>)</span><br><span class="line">					num.<span class="built_in">push</span>(n1 * n2);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				num.<span class="built_in">push</span>(<span class="built_in">stringToInt</span>(p-&gt;data));<span class="comment">//如果是操作数，转化为int之后存入操作数栈</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			s2.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;right)</span><br><span class="line">			&#123;</span><br><span class="line">				s1.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">				s2.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			s2.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;left)</span><br><span class="line">			&#123;</span><br><span class="line">				s1.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">				s2.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> num.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>计算的时候就采用后序遍历</p><blockquote><p>访问当前结点之前先访问左右孩子，因此树中最先访问的是叶子结点也就是操作数，凡是操作数都入栈保存下来，在访问到操作符的时候就用栈中的操作数进行计算，计算结果作为操作数入栈</p></blockquote></blockquote><h2 id="哈夫曼树-x2F-最优二叉树"><a href="#哈夫曼树-x2F-最优二叉树" class="headerlink" title="哈夫曼树&#x2F;最优二叉树"></a>哈夫曼树&#x2F;最优二叉树</h2><p>路径：一个结点到另一个结点之间的通路就是路径。比如B到H就是一条路径，B到G也是一条路径</p><p>路径的长度：路径上经过的边(“树枝”)的数目。从根结点到第i层结点的路径的长度就是 i-1</p><p>结点的权：给一个结点赋予一个权值。比如给E一个权值20</p><p>结点的带权路径长度：根结点到一个带权结点的路径长度乘这个结点的权值。H的带权路径长度是2*19&#x3D;38</p><p>树的带权路径长度(WPL)：所有叶子结点的带权路径长度之和。这棵树的WPL是2 * 44 + 3 * 19 + 2 * 46 + 2 * 11 &#x3D; 259</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211211629914.png" alt="截屏2022-11-21 16.23.38" style="zoom:50%"><p>哈夫曼树&#x2F;最优二叉树：当有n的带权结点，都作为叶子结点构建成一棵二叉树时，如果构建成的二叉树的WPL最小，就称为“最优二叉树”，也称“哈夫曼树”</p><p>哈夫曼编码：在一棵哈夫曼树中，从根结点开始向下走，经过左孩子记为0，经过右孩子记为1，直到某个叶子结点，从根到这个叶子结点得到的0、1序列就是这个叶子结点的哈夫曼编码。比如，假设上面的树是哈夫曼树，H的哈夫曼编码求法：从A开始到H，A-&gt;B:0, B-&gt;E:1, E-&gt;H:1，叶子结点E的哈夫曼编码就是011.</p><h3 id="哈夫曼树类的声明："><a href="#哈夫曼树类的声明：" class="headerlink" title="哈夫曼树类的声明："></a>哈夫曼树类的声明：</h3><p>采用<strong>顺序存储</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模版不支持分离编译！！！</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HFNode</span><span class="comment">//构建哈夫曼树的结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	elemType data;</span><br><span class="line">	<span class="type">double</span> weight;</span><br><span class="line">	<span class="type">int</span> parents, left, right;<span class="comment">//保存当前结点的父亲和孩子的位置下标</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">HFNode</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		weight = <span class="number">0</span>;</span><br><span class="line">		parents = <span class="number">0</span>;</span><br><span class="line">		left = <span class="number">0</span>;</span><br><span class="line">		right = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">huffmanTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	HFNode&lt;elemType&gt; *HFTree;<span class="comment">//哈夫曼树顺序表，其实这里用vector更方便一点</span></span><br><span class="line">	<span class="type">int</span> leafSize;<span class="comment">//保存哈夫曼树叶子结点的个数</span></span><br><span class="line">	vector&lt;string&gt; HFCode;<span class="comment">//哈夫曼树编码表，保存每个叶子结点的哈夫曼编码</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">huffmanTree</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		HFTree = <span class="literal">NULL</span>;</span><br><span class="line">		leafSize = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;HFNode&lt;elemType&gt;&gt; <span class="built_in">getNode</span>();<span class="comment">//获取叶子结点集合</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">buildBestBinaryTree</span><span class="params">(vector&lt;HFNode&lt;elemType&gt;&gt; allNode)</span></span>;<span class="comment">//创建最优二叉树/哈夫曼树</span></span><br><span class="line"></span><br><span class="line">	<span class="function">HFNode&lt;elemType&gt; *<span class="title">getRoot</span><span class="params">()</span><span class="comment">//返回构建好的哈夫曼树表的地址</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> HFTree;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">makeHuffmanCode</span><span class="params">()</span></span>;<span class="comment">//创建每个叶子结点的哈夫曼编码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="哈夫曼树类的成员变量介绍"><a href="#哈夫曼树类的成员变量介绍" class="headerlink" title="哈夫曼树类的成员变量介绍"></a>哈夫曼树类的成员变量介绍</h4><p>哈夫曼树结点类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HFNode</span><span class="comment">//构建哈夫曼树的结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	elemType data;</span><br><span class="line">	<span class="type">double</span> weight;</span><br><span class="line">	<span class="type">int</span> parents, left, right;<span class="comment">//保存当前结点的父亲和孩子的位置下标</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">HFNode</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		weight = <span class="number">0</span>;</span><br><span class="line">		parents = <span class="number">0</span>;</span><br><span class="line">		left = <span class="number">0</span>;</span><br><span class="line">		right = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>相比普通二叉树的结点，由于用顺序表存储，孩子结点指针域换成了位置下标，并加了父结点位置下标</p><p>增加了结点的权值weight</p></blockquote><p>哈夫曼树类的成员变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">huffmanTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	HFNode&lt;elemType&gt; *HFTree;<span class="comment">//哈夫曼树顺序表，其实这里用vector更方便一点</span></span><br><span class="line">	<span class="type">int</span> leafSize;<span class="comment">//保存哈夫曼树叶子结点的个数</span></span><br><span class="line">	vector&lt;string&gt; HFCode;<span class="comment">//哈夫曼树编码表，保存每个叶子结点的哈夫曼编码</span></span><br></pre></td></tr></table></figure><h3 id="哈夫曼树类的实现："><a href="#哈夫曼树类的实现：" class="headerlink" title="哈夫曼树类的实现："></a>哈夫曼树类的实现：</h3><h4 id="哈夫曼树的构建"><a href="#哈夫曼树的构建" class="headerlink" title="哈夫曼树的构建"></a>哈夫曼树的构建</h4><p>要想构建二叉树首先得有叶子结点，要先获取叶子结点集合</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模版不支持分离编译！！！</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">vector&lt;HFNode&lt;elemType&gt;&gt; huffmanTree&lt;elemType&gt;::<span class="built_in">getNode</span>()<span class="comment">//获取叶子结点集合</span></span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;HFNode&lt;elemType&gt;&gt; allNode;<span class="comment">//创建一个容器，存储叶子结点</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Input the data and weight of the HFNode to add it &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Before you input , input Y to continue ,or others to exit &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="type">char</span> x;</span><br><span class="line">	cin &gt;&gt; x;</span><br><span class="line">	<span class="keyword">while</span> (x == <span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		elemType data;</span><br><span class="line">		<span class="type">double</span> weight;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;input the data of the HFNode&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; data;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;input the weight of the HFNode&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; weight;</span><br><span class="line"></span><br><span class="line">		HFNode&lt;elemType&gt; n;</span><br><span class="line">		n.weight = weight;</span><br><span class="line">		n.data = data;</span><br><span class="line"></span><br><span class="line">		allNode.<span class="built_in">push_back</span>(n);</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Input the data and weight of the HFNode to add it &quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Before you input , input Y to continue ,or others to exit &quot;</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">	&#125;</span><br><span class="line">	leafSize = allNode.<span class="built_in">size</span>();<span class="comment">//当前存储的结点就是是之后建成的哈夫曼树的叶子结点</span></span><br><span class="line">	<span class="keyword">return</span> allNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用叶子结点集合构建哈夫曼树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> huffmanTree&lt;elemType&gt;::<span class="built_in">buildBestBinaryTree</span>(vector&lt;HFNode&lt;elemType&gt;&gt; allNode)<span class="comment">//建立最优二叉树/哈夫曼树</span></span><br><span class="line">&#123;</span><br><span class="line">	HFTree = <span class="keyword">new</span> HFNode&lt;elemType&gt;[<span class="number">2</span> * allNode.<span class="built_in">size</span>()];<span class="comment">//构建哈夫曼树顺序表</span></span><br><span class="line">	<span class="comment">//按照最优二叉树的要求，初始带权值的结点都是叶子结点，也就是allNode里存储的都是叶子节点</span></span><br><span class="line">	<span class="comment">//并且根据最优二叉树的特点，会发现分支结点全部都是度为2的结点</span></span><br><span class="line">	<span class="comment">//根据二叉树的性质，叶子结点个数为n个，则度为2的结点个数为n-1</span></span><br><span class="line">	<span class="comment">//根据最优二叉树的构造方法，分支结点都是度为2的，因此最优二叉树中结点个数总是为2*n-1</span></span><br><span class="line">	<span class="comment">//我们开辟2*n个空间，空出第一个位置，如果表中的结点无父亲或孩子，那么就让对应的位置下标为0</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; allNode.<span class="built_in">size</span>(); i++)<span class="comment">//叶子结点转移到哈夫曼树顺序表，并空出哈夫曼树表的第一个位置</span></span><br><span class="line">	&#123;</span><br><span class="line">		HFTree[i + <span class="number">1</span>] = allNode[i];</span><br><span class="line">		HFTree[i + <span class="number">1</span>].parents = <span class="number">0</span>;</span><br><span class="line">		HFTree[i + <span class="number">1</span>].left = <span class="number">0</span>;</span><br><span class="line">		HFTree[i + <span class="number">1</span>].right = <span class="number">0</span>;<span class="comment">//一开始所有的结点都没有父亲和孩子</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i = allNode.<span class="built_in">size</span>();<span class="comment">//用i来表示当前没有父结点的结点的个数</span></span><br><span class="line">	<span class="type">int</span> n = allNode.<span class="built_in">size</span>();<span class="comment">//用n来表示当前哈夫曼树表中结点的个数，同时也算是最后面的元素的权重</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i != <span class="number">1</span>)<span class="comment">//一开始所有结点都没有父结点，当哈夫曼树建立完成之后，只有根结点是没有父亲的，由此来判定哈夫曼树是否建成</span></span><br><span class="line">		<span class="comment">//由于每次循环创建一个新结点，原来权重最小的两个结点有了父结点，i-2，但是新结点是没有父结点的，所以每次循环总体上为i-1</span></span><br><span class="line">		<span class="comment">//(当然，也可以用n来判定循环，n&lt;2*allNode.size()，画图理解即可）</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> first_min, second_min;<span class="comment">//定义没有父结点的结点中权重最小的两个结点的下标</span></span><br><span class="line">		<span class="type">double</span> first_min_weight = <span class="number">9999</span>;<span class="comment">//将两个权重初始化为一个大到不可能的权重</span></span><br><span class="line">		<span class="type">double</span> second_min_weight = <span class="number">9999</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++)<span class="comment">//寻找权重第一小的无父结点的结点</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (HFTree[x].parents == <span class="number">0</span> &amp;&amp; HFTree[x].weight &lt; first_min_weight)</span><br><span class="line">			&#123;</span><br><span class="line">				first_min = x;</span><br><span class="line">				first_min_weight = HFTree[x].weight;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++)<span class="comment">//寻找权重第二小的无父结点的结点</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (x != first_min &amp;&amp; HFTree[x].parents == <span class="number">0</span> &amp;&amp; HFTree[x].weight &lt; second_min_weight)</span><br><span class="line">			&#123;</span><br><span class="line">				second_min = x;</span><br><span class="line">				second_min_weight = HFTree[x].weight;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">double</span> weight_added = first_min_weight + second_min_weight;</span><br><span class="line"></span><br><span class="line">		n++;</span><br><span class="line"></span><br><span class="line">		HFTree[first_min].parents = n;<span class="comment">//原来的权重最小结点变成了新结点的孩子</span></span><br><span class="line">		HFTree[second_min].parents = n;</span><br><span class="line"></span><br><span class="line">		HFTree[n].left = first_min;</span><br><span class="line">		HFTree[n].right = second_min;</span><br><span class="line">		HFTree[n].weight = weight_added;</span><br><span class="line">		i--;<span class="comment">//由于创建了一个新结点，原来权重最小的两个结点有了父结点，i-2，但是新结点是没有父结点的，所以总体上为i-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//以下辅助调试代码，便于判断是否正确建立了一棵哈夫曼树</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;---------&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;index: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;data: &quot;</span> &lt;&lt; HFTree[x].data &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;weight: &quot;</span> &lt;&lt; HFTree[x].weight &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;parents: &quot;</span> &lt;&lt; HFTree[x].parents &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;left: &quot;</span> &lt;&lt; HFTree[x].left &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;right: &quot;</span> &lt;&lt; HFTree[x].right &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;---------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>哈夫曼算法：</p><p>每次找哈夫曼顺序表里权重最小的两个结点，创建一个新结点，新结点是权重是两个最小结点的和，最小结点是新结点的左孩子，次小结点是新结点的右孩子，新结点存入哈夫曼顺序表。这样构建出来的树就是哈夫曼树。</p><blockquote><p>创建一个哈夫曼树顺序表用来存储哈夫曼树。</p><p>之前获得的叶子结点集合作为哈夫曼树的叶子结点。根据二叉树的性质，如果叶子结点的数目是n，则度为2的结点数目是n-1，而通过哈夫曼算法建立的哈夫曼树，所有的分支结点的度都是2，故哈夫曼树的结点总数是2n-1。</p><p>我们创建一个大小为2n的哈夫曼树顺序表，空出第一个位置，如果表中的结点无父亲或孩子，那么就让对应的下标为0</p><p>先将所有叶子结点添加到哈夫曼树表</p><blockquote><p>刚开始所有的叶子结点都没有父亲、孩子，故父亲、孩子下标都为0</p></blockquote><p>一开始所有结点都没有父结点，当哈夫曼树建立完成之后，只有根结点是没有父亲的，由此来判定哈夫曼树是否建成</p><blockquote><p>由于每次循环创建一个新结点，原来权重最小的两个结点有了父结点，没有父结点的结点总数-2，但是新结点是没有父结点的，所以每次循环总体上为无父结点的结点总数-1</p></blockquote><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/B35974B77F32A658ED5B854157436CA7.png" alt="img" style="zoom:25%"></blockquote></blockquote><h4 id="创建哈夫曼编码"><a href="#创建哈夫曼编码" class="headerlink" title="创建哈夫曼编码"></a>创建哈夫曼编码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> huffmanTree&lt;elemType&gt;::<span class="built_in">makeHuffmanCode</span>()<span class="comment">//创建每个叶子结点的哈夫曼编码</span></span><br><span class="line"><span class="comment">//因为哈夫曼树顺序表里面前面的都是叶子结点(前半部分结点都是叶子结点，即(哈夫曼树顺序表结点个数+1)/2个）</span></span><br><span class="line"><span class="comment">//但是并没有写求哈夫曼树顺序表结点个数的函数，不过有记录叶子结点个数的变量leafSize</span></span><br><span class="line">&#123;</span><br><span class="line">	stack&lt;<span class="type">char</span>&gt; s;<span class="comment">//每次用来存储单个叶子结点的编码</span></span><br><span class="line"></span><br><span class="line">	HFCode.<span class="built_in">push_back</span>(<span class="string">&quot; &quot;</span>);<span class="comment">//因为哈夫曼树表第一个元素没有存结点，这里保持和哈夫曼树表同步</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= leafSize; i++)<span class="comment">//因为一共leafSize个结点，且是从权重1开始遍历，所以要遍历到第leafSize个，应该取到leafSize</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = i;</span><br><span class="line">		<span class="keyword">while</span> (HFTree[j].parents != <span class="number">0</span>)<span class="comment">//不断向上寻找当前结点的父亲，并且判断当前结点是其父亲的左孩子还是右孩子，左为&#x27;0&#x27;，右为&#x27;1&#x27;</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (HFTree[HFTree[j].parents].left == j)</span><br><span class="line">				s.<span class="built_in">push</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				s.<span class="built_in">push</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">			j = HFTree[j].parents;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			HFCode[i].<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">			s.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//进行辅助调试</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= leafSize; i++)<span class="comment">////因为一共leafSize个结点，且是从权重1开始遍历，所以要遍历到第leafSize个，应该取到leafSize</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;data is: &quot;</span> &lt;&lt; HFTree[i].data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;code is: &quot;</span> &lt;&lt; HFCode[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于每一个叶子结点进行哈夫曼编码的时候，用字符栈保存自己的哈夫曼编码</p><p>不断向上寻找当前结点的父亲，并且判断当前结点是其父亲的左孩子还是右孩子，左为’0’，右为’1’</p><p>所有叶子结点的哈夫曼编码保存到HFCode中</p></blockquote><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>That’s all, thanks for reading!💐</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://chunyujin.top">浴巾</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://chunyujin.top/chunyujin/147dc864.html">https://chunyujin.top/chunyujin/147dc864.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://chunyujin.top" target="_blank">浴巾的贼船</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303071113259.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/reward_wechat.JPG" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/reward_wechat.JPG" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/chunyujin/8e17ffd9.html"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010017530.jpg" onerror='onerror=null,src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300157190.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">网址不支持某些字符</div></div></a></div><div class="next-post pull-right"><a href="/chunyujin/c4fcfcf8.html"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010017530.jpg" onerror='onerror=null,src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300157190.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构_KMP算法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/chunyujin/c4fcfcf8.html" title="数据结构_KMP算法"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010017530.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-21</div><div class="title">数据结构_KMP算法</div></div></a></div><div><a href="/chunyujin/9536edd6.html" title="数据结构_队列（C++"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010017530.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-21</div><div class="title">数据结构_队列（C++</div></div></a></div><div><a href="/chunyujin/c000c11f.html" title="数据结构_顺序栈（C++"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010017530.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-21</div><div class="title">数据结构_顺序栈（C++</div></div></a></div><div><a href="/chunyujin/4255e88b.html" title="数据结构_单链表（C++"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010017530.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-21</div><div class="title">数据结构_单链表（C++</div></div></a></div><div><a href="/chunyujin/db3b0256.html" title="数据结构_栈应用_中缀式转后缀式并计算"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010017530.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-21</div><div class="title">数据结构_栈应用_中缀式转后缀式并计算</div></div></a></div><div><a href="/chunyujin/4618b828.html" title="数据结构_线性表应用_多项式的计算"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010017530.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-21</div><div class="title">数据结构_线性表应用_多项式的计算</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author_top is-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202303071113259.gif" onerror='this.onerror=null,this.src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202302121138445.gif"' alt="avatar"></div><div class="author-info__name">浴巾</div><div class="author-info__description">水可载舟，亦可赛艇🚤</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">135</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">35</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/chunyujin295"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chunyujin295" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:3029795434@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://space.bilibili.com/433907522" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili"></i></a><a class="social-icon" href="/qq_add/" target="_blank" title="QQ"><i class="fa-brands fa-qq"></i></a><a class="social-icon" href="/wechat_add/" target="_blank" title="WeChat"><i class="fa-brands fa-weixin"></i></a><a class="social-icon" href="/reward/" target="_blank" title="Reward"><i class="fa-solid fa-sack-dollar"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">🥦点击上方图标可添加好友🥦<br>🌝主题深浅模式跟随系统🌝<br>🌚系统无深浅则默认为深色模式🌚<br>🪐深色模式下可以看到星空背景🪐<br>🪂右下角可手动更改深浅模式🪂<br>🎊鼠标放在上方头像周围有惊喜🎊<br>--------------------------<br></div><div id="welcome-info"></div></div><div class="xpand" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople1.js"></script><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/zdog.dist.js"></script><script id="rendered-js" src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople.js"></script><style>.card-widget.card-announcement{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88C-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text">数据结构_二叉树（C++实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">二叉树类的声明：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">二叉树类的成员变量介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">1.2.2.</span> <span class="toc-text">二叉树类的实现：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">二叉树的构建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%B1%82%E4%BB%A5%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">递归求以二叉树的结点的个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6-x2F-%E6%B7%B1%E5%BA%A6"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">递归求二叉树的高度&#x2F;深度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">递归删除二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">二叉树的遍历：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="toc-number">1.2.2.5.1.</span> <span class="toc-text">二叉树的递归遍历：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-%E9%80%92%E5%BD%92"><span class="toc-number">1.2.2.5.1.1.</span> <span class="toc-text">前序遍历(递归)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E9%80%92%E5%BD%92"><span class="toc-number">1.2.2.5.1.2.</span> <span class="toc-text">中序遍历(递归)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-%E9%80%92%E5%BD%92"><span class="toc-number">1.2.2.5.1.3.</span> <span class="toc-text">后序遍历(递归)</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="toc-number">1.2.2.5.2.</span> <span class="toc-text">二叉树的非递归遍历：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-%E9%9D%9E%E9%80%92%E5%BD%92"><span class="toc-number">1.2.2.5.2.1.</span> <span class="toc-text">前序遍历(非递归)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E9%9D%9E%E9%80%92%E5%BD%92"><span class="toc-number">1.2.2.5.2.2.</span> <span class="toc-text">中序遍历(非递归)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-%E9%9D%9E%E9%80%92%E5%BD%92"><span class="toc-number">1.2.2.5.2.3.</span> <span class="toc-text">后序遍历(非递归)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.2.2.5.2.4.</span> <span class="toc-text">层序遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E7%BA%BF%E7%B4%A2%E6%A0%91%EF%BC%9A"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">二叉线索树：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">1.2.2.6.1.</span> <span class="toc-text">中序遍历线索二叉树的构建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%80%9F%E5%8A%A9%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BA%BF%E7%B4%A2%E6%A0%91%E5%AE%9E%E7%8E%B0-%E4%B8%AD%E5%BA%8F%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">1.2.2.6.2.</span> <span class="toc-text">借助中序遍历线索树实现 中序非递归遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%80%9F%E5%8A%A9%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BA%BF%E7%B4%A2%E6%A0%91%E5%AE%9E%E7%8E%B0-%E5%89%8D%E5%BA%8F%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">1.2.2.6.3.</span> <span class="toc-text">借助中序遍历线索树实现 前序非递归遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%B2%E7%9F%A5%E5%89%8D%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%EF%BC%8C%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.2.7.</span> <span class="toc-text">已知前中序遍历结果，求二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%EF%BC%9A"><span class="toc-number">1.2.2.8.</span> <span class="toc-text">表达式树的构建：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E7%9A%84%E8%AE%A1%E7%AE%97%EF%BC%9A"><span class="toc-number">1.2.2.9.</span> <span class="toc-text">表达式树的计算：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91-x2F-%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.3.</span> <span class="toc-text">哈夫曼树&#x2F;最优二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E%EF%BC%9A"><span class="toc-number">1.3.1.</span> <span class="toc-text">哈夫曼树类的声明：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">哈夫曼树类的成员变量介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">1.3.2.</span> <span class="toc-text">哈夫曼树类的实现：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">哈夫曼树的构建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">创建哈夫曼编码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F"><span class="toc-number">1.4.</span> <span class="toc-text">结束</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/chunyujin/15763eb7.html" title="C++11-智能指针">C++11-智能指针</a><time datetime="2024-10-22T07:03:00.000Z" title="发表于 2024-10-22 15:03:00">2024-10-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/chunyujin/874d4093.html" title="C++_迭代器&amp;范围for的本质">C++_迭代器&amp;范围for的本质</a><time datetime="2024-10-14T05:27:00.000Z" title="发表于 2024-10-14 13:27:00">2024-10-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/chunyujin/5583cd64.html" title="static放置的位置">static放置的位置</a><time datetime="2024-10-11T07:53:00.000Z" title="发表于 2024-10-11 15:53:00">2024-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/chunyujin/3167b709.html" title="QString与QByteArray的区别与用途"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202408041153746.png" onerror='this.onerror=null,this.src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300157190.jpg"' alt="QString与QByteArray的区别与用途"></a><div class="content"><a class="title" href="/chunyujin/3167b709.html" title="QString与QByteArray的区别与用途">QString与QByteArray的区别与用途</a><time datetime="2024-10-11T07:26:00.000Z" title="发表于 2024-10-11 15:26:00">2024-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/chunyujin/e9887bd.html" title="Typora+PicGo图床+阿里云OSS配置"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/PixPin_2024-10-10_21-01-52.png" onerror='this.onerror=null,this.src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300157190.jpg"' alt="Typora+PicGo图床+阿里云OSS配置"></a><div class="content"><a class="title" href="/chunyujin/e9887bd.html" title="Typora+PicGo图床+阿里云OSS配置">Typora+PicGo图床+阿里云OSS配置</a><time datetime="2024-10-10T13:01:00.000Z" title="发表于 2024-10-10 21:01:00">2024-10-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202305251742881.jpeg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024<i id="heartbeat" class="fa fas fa-heartbeat"></i> 浴巾</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">感谢莅临</div><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://www.beian.gov.cn/img/new/gongan.png"> <a href="https://beian.miit.gov.cn/" style="color:#f72b07" target="_blank">鲁ICP备2023001670号</a></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button> <a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i> <span id="percent">0 <span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight,500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.chunyujin.top/",region:"",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const t=document.getElementById("twikoo-count");t&&twikoo.getCommentsCount({envId:"https://twikoo.chunyujin.top/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.innerText=o[0].count})).catch((function(t){console.error(t)}))})()},o=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(t):setTimeout(t,0)};btf.loadComment(document.getElementById("twikoo-wrap"),o)})()</script></div><script src="/js/sun_moon.js" async></script><script defer data-pjax src="/js/readPercent.js"></script><script async src="/js/title.js"></script><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="/js/txmap.js"></script><script async src="/js/fps.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!0,document.body.addEventListener("input",POWERMODE)</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax>function butterfly_clock_anzhiyu_injector_config(){var a=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载butterfly_clock_anzhiyu"),a&&a.insertAdjacentHTML("afterbegin",'<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",qweather_key="5ab96380a1af43cc9cc08bce197ae671",gaud_map_key="e700312c741348cdfba1c9b1277b8179",baidu_ak_key="undefined",flag=0,clock_rectangle="112.982279,28.19409",clock_default_rectangle_enable="false",i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_clock_anzhiyu_injector_config()</script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script></body></html>