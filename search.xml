<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客图集(阿里云图床)</title>
      <link href="/chunyujin/c2a9db75.html"/>
      <url>/chunyujin/c2a9db75.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300142246.jpg" alt="67243791_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300145467.jpg" alt="睡莲"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300149266.png" alt="79640557_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300150858.png" alt="99940581_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300152503.jpg" alt="ss"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300157190.jpg" alt="51562163_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300159454.png" alt="101965789_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300202846.jpg" alt="78830672_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300203045.jpg" alt="74724305_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300205537.jpg" alt="100938340_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301114389.jpg" alt="100938340_p0的副本2"></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300207368.gif" alt="original"  /><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301145729.png" alt="head"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300211286.png" alt="76834683_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300216305.png" alt="A0E1D3CE-D536-443C-9583-9FC6C0BFBC5C"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300228844.png" alt="016269CA-735E-498F-8C68-29AAAB6DAFBB"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301100230.jpg" alt="74364959_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301103690.jpg" alt="98288115_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301116378.jpg" alt="98473741_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301103283.jpg" alt="99287912_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301105836.jpg" alt="99287912_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301922412.png" alt="截屏2022-12-30 19.21.59"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301929027.png" alt="截屏2022-12-30 19.29.38"></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301938709.jpg" alt="97451569_p0"  /><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212302043621.jpg"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212302044439.jpg"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212302109225.jpg" alt="101204641_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010017530.jpg" alt="78440564_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010140253.png" alt="截屏2023-01-01 01.38.06"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010141063.jpg" alt="100613443_p3"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010143595.jpg" alt="100307349_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301011054071.jpg" alt="82492410_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301011057668.jpg" alt="65231299_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301072223869.png" alt="未命名的设计"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301072231029.png" alt="未命名的设计"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301072233799.png" alt="未命名的设计"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301072235859.png" alt="未命名的设计"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301091952484.png" alt="未命名的设计"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301092004378.png" alt="before"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301092004359.png" alt="after"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301092002793.png" alt="未命名计"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301092003112.png" alt="未命名设计"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301092008026.png" alt="line"></p>]]></content>
      
      
      <categories>
          
          <category> 图集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20230107</title>
      <link href="/chunyujin/17e3ae31.html"/>
      <url>/chunyujin/17e3ae31.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Experts-decry-Dell’s-move-away-from-Chinese-chips"><a href="#Experts-decry-Dell’s-move-away-from-Chinese-chips" class="headerlink" title="Experts decry Dell’s move away from Chinese chips"></a><u>Experts</u> <u>decry</u> Dell’s move away from Chinese <u>chips</u></h1><p>By CHENG YU and MA SI | CHINA DAILY | Updated: 2023-01-07 08:50</p><div>  <center>    <img src="https://img2.chinadaily.com.cn/images/202301/07/63b8c1e5a31057c4b4b2db1c.jpeg" alt="img"  />    <br>    Shoppers browse Dell computers at a store in Shenyang, Liaoning province. [PHOTO/CHINA DAILY]   </center> </div>> expert：cn.专家，人才>> > 1. Copy the experts: 模仿专家；采集者退散；模仿母语；模仿> > 2. panel of experts: 专家小组；专家组>> decry：v.谴责>> chip：cn.碎片；炸土豆条；缺口；集成电路(芯片等)  v.打碎，使破碎>> move away form 远离<p>The reported <u>decision</u> of Dell Technologies, a US-based personal computer maker, to replace all <u>semiconductors</u> made in China from its products by 2024, will only weaken the solid ecosystem the company had assiduously built in China over the last several decades and also erode Dell’s global competitiveness, given China’s irreplaceable role in the global consumer electronics chain, experts said.</p><blockquote><p>decision：cn.决定，决心；决议，结果</p><blockquote><p>indecision：n.优柔寡断，犹豫不决</p><p>decisive：adj.决定性的；果断地；坚定的</p><blockquote><p>indecisive：adj.犹豫不决的</p></blockquote><p>decide：v.决定；下决心</p><blockquote><p>decidable：adj.可决定的</p><p>decidability：n.可决定性</p></blockquote></blockquote><p>semiconductor：n.半导体装置</p></blockquote><p>The comments were made after Nikkei Asia reported that Dell has told suppliers to reduce the amount of chips and other made-in-China components in its products. Personal computer maker HP Inc, one of Dell’s rivals, has also started surveying its suppliers to gauge the feasibility of moving production and assembly away from the country, the report said.</p><p>“Dell’s current production largely relies on China’s supply chain. It would be very difficult for the company to find an alternative in the short term,” said Xiang Ligang, director-general of the Information Consumption Alliance, a telecom industry association.</p><p>Xiang said that the PC is not a product with a large profit margin, thus production costs matter, especially when chips made in China are generally cheaper. “Forcing itself to find an alternative is very likely to injure Dell’s production. If supply becomes insufficient, it will be unfavorable to the company’s development and lead to damage to its competitiveness,” he added.</p><p>While emphasizing China’s importance as a major market, Dell said in a statement that it was committed to pursuing global supply chain diversification to best meet customers’ and partners’ needs and expectations.</p><p>Wu Dongmei, global senior vice-president of Dell, said in an interview with China Daily in November that “Dell doesn’t just have a sales office in China” and the company’s development in the country is based on “long-term consideration”.</p><p>“Dell has a full value chain here from design, research and development, production, manufacturing, supply chain management, sales and services that support the development of the company’s business in China and globally,” Wu said.</p><p>“We became very focused in China once Dell decided to operate in the country,” Wu told China Daily. “In fact, we have done assessments and many conditions in the Chinese market are basically better than other places.”</p><p>According to a report by market consultancy Canalys, Dell was the second-largest PC vendor in China in the third quarter last year with a market share of 11.7 percent, following Lenovo Group with 38.2 percent.</p><p>“As China’s economy continues to stabilize this year, the surging domestic demand will continue to drive it to be a market that no tech giant wants to lose. Dell’s reported decision will also lead to the loss of its business in the country including cloud computing,” said Wang Peng, a researcher at the Beijing Academy of Social Sciences.</p><p>“China also has great advantages in the global consumer electronics chain for its efficient cooperation of multiple manufacturing steps, including raw material supply and mold design to final assembly,” Wang said.</p><p>Yao Jun, deputy head of the planning department at the Ministry of Industry and Information Technology, said though some foreign-funded enterprises are diversifying their business layouts, the overall pace of foreign investment in China has not slowed and manufacturing remains a key sector for foreign investment in the country.</p><blockquote><p>来源：<a href="https://global.chinadaily.com.cn/a/202301/07/WS63b8c1e5a31057c47eba838b.html">https://global.chinadaily.com.cn/a/202301/07/WS63b8c1e5a31057c47eba838b.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决butterfly在黑色模式下主页和顶部封面过暗</title>
      <link href="/chunyujin/dffbd9e1.html"/>
      <url>/chunyujin/dffbd9e1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>解决黑色模式下主页和顶部封面过暗:</p><p>在<code>/themes/butterfly/source/css/_mode/darkmode.styl </code></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061849015.png" alt="截屏2023-01-06 18.47.52"></p><p>调整第48行括号里的小数点后的数值，默认是.9，数值越大越暗</p><h5 id="before"><a href="#before" class="headerlink" title="before:"></a>before:</h5><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061850337.png"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061848023.png" alt="截屏2023-01-06 18.48.21"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061848940.png" alt="截屏2023-01-06 18.48.32"></p><h5 id="after："><a href="#after：" class="headerlink" title="after："></a>after：</h5><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061850100.png" alt="截屏2023-01-06 18.50.37"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061851886.png" alt="截屏2023-01-06 18.51.00"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061851284.png" alt="截屏2023-01-06 18.51.22"></p><p><a href="http://chunyujin.top/chunyujin/5b04b880.html">相关问题链接：解决黑色模式下文章预览封面及内部图片过暗</a></p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Hero </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决黑色模式下文章预览封面及内部图片过暗</title>
      <link href="/chunyujin/5b04b880.html"/>
      <url>/chunyujin/5b04b880.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>解决黑色模式下文章预览封面及内部图片过暗</p><p>在<code>/themes/butterfly/source/css/_mode/darkmode.styl </code></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061854032.png" alt="截屏2023-01-06 18.54.56"></p><p>106、108行brightness括号里的值，brightness范围0~1，值越小，图片越暗</p><h5 id="before："><a href="#before：" class="headerlink" title="before："></a>before：</h5><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061858116.png" alt="截屏2023-01-06 18.57.57"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061858319.png" alt="截屏2023-01-06 18.56.21"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061858195.png" alt="截屏2023-01-06 18.56.29"></p><h5 id="after："><a href="#after：" class="headerlink" title="after："></a>after：</h5><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061858048.png" alt="截屏2023-01-06 18.56.47"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061858987.png" alt="截屏2023-01-06 18.57.03"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301061858832.png" alt="截屏2023-01-06 18.57.10"></p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Hero </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用指令&amp;权限管理</title>
      <link href="/chunyujin/1c776eb1.html"/>
      <url>/chunyujin/1c776eb1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><h4 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h4><h5 id="文件的分类"><a href="#文件的分类" class="headerlink" title="文件的分类"></a>文件的分类</h5><blockquote><p><strong>普通文件</strong>，文件属性为[-]</p><p><strong>目录文件</strong>，属性为[d]，文件夹(目录)也是一种文件，是内容为文件的文件，是能用 # cd指令进入的</p><p><strong>块设备文件</strong>，属性为[b]，表示为装置文件里面的可供储存的接口设备(可随机存取装置)，比如硬盘、光驱等。例如一号硬盘的代码是 &#x2F;dev&#x2F;hda1等文件</p><p><strong>字符设备文件</strong>，属性为[c]，表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)、屏幕等</p><p><strong>套接字文件</strong>，属性为[s]，这类文件通常用在网络数据连接，可以启动一个程序来监听客户端的要求，客户端就可以通过套接字来进行数据通信。最常在 &#x2F;var&#x2F;run目录中看到这种文件类型</p><p><strong>管道文件</strong>，属性为[p]，FIFO也是一种特殊的文件类型，它主要的目的是，解决多个程序同时存取一个文件所造成的错误。FIFO是first-in-first-out(先进先出)的缩写</p><p><strong>链接文件</strong>，属性为[l]，类似于Windows里的快捷方式和macOS的替身</p></blockquote><h5 id="文件-x3D-文件属性-文件内容"><a href="#文件-x3D-文件属性-文件内容" class="headerlink" title="文件 &#x3D; 文件属性 + 文件内容"></a>文件 &#x3D; 文件属性 + 文件内容</h5><blockquote><p>当我们在电脑上创建了一个空白文档的时候，查看一下文件的详细信息，会发现这个空白文档并不是占用了0内存，它是占用了内存的。因为要存储这个文档的属性，包括创建时间、修改日期、种类、拥有者等等</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212291208514.png" alt="截屏2022-12-29 12.08.43" style="zoom:50%;" /></blockquote><h5 id="常用的单词："><a href="#常用的单词：" class="headerlink" title="常用的单词："></a>常用的单词：</h5><blockquote><p>command 命令</p><p>option 选项</p><p>dirname 目录名</p></blockquote><h4 id="建议有不懂的指令就去man查找！"><a href="#建议有不懂的指令就去man查找！" class="headerlink" title="建议有不懂的指令就去man查找！"></a>建议有不懂的指令就去man查找！</h4><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><p>一个指令由基本指令、选项、目标、其他内容组成的，除基本指令外的内容都并不是必须的，内容对应相应功能</p><p>一条指令可以添加多个选项，意味着一条指令实现多种功能的结合</p><p>&#x3D;&#x3D;<strong>凡是放方括号里的内容都代表不是必须的，可以不存在</strong>&#x3D;&#x3D;，括号外的内容都是必须的</p><p><strong>指令中，选项的位置正常来讲是可以移动的，并不是固定的必须要按照某种顺序出现在某个位置</strong></p><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><p><code>ls [选项] [指定文件]</code></p><h5 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h5><p>对于目录，该命令列出该目录下的所有文件；对于一般文件，将列出该文件。(默认是按照名称排序的)</p><p>&#x3D;&#x3D;（如果不跟指定目录或文件，则默认是当前目录）&#x3D;&#x3D;</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181010049.png" alt="截屏2022-12-18 10.10.52" style="zoom:50%;" /><h5 id="常用选项："><a href="#常用选项：" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-l # 列出各文件的详细信息。ls -l 可以简写成 ll</span><br><span class="line">-a # 列出所有文件， 包括以.开头的隐藏文件</span><br><span class="line">-d # 只显示指定目录，不显示目录内容</span><br><span class="line">-s(小写) # 显示文件的块数</span><br><span class="line">-S(大写) # 按大小降序排列</span><br><span class="line">-r # 反向排序</span><br><span class="line">-t # 按修改时间先后排序</span><br><span class="line">-h # 按用户易读的方式显示文件大小</span><br><span class="line">-k # 以k字节的形式输出大小(一般输出的时候就是以这种方式输出的，用处不是很大)</span><br><span class="line">-R # 列出所有子目录的文件(递归)</span><br><span class="line">-1 # 一行只输出一个文件</span><br><span class="line">-n # 用数字的UID、GID代替owner、group名称</span><br><span class="line">-i # 显示文件的inode(索引节点)</span><br><span class="line">-F # 在每个文件名后附上一个字符以说明该文件的类型，*表示可执行程序，/表示目录，@表示符号连接，|表示FIFOs，=表示套接字(sockets)。（目录类型识别）</span><br></pre></td></tr></table></figure><blockquote><p><strong>&#x3D;&#x3D;-l&#x3D;&#x3D; ：列出各文件的详细信息。<u>ls -l 可以简写成 ll</u></strong></p><div><center><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181050726.png" alt="image-20221218105015699" style="zoom:30%;" /><br>Linux文件默认是按照名称排序的</center></div><p><strong>&#x3D;&#x3D;-a&#x3D;&#x3D; ：列出所有文件， 包括以.开头的隐藏文件。例如：ls -a [指定目标]</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181011049.png" alt="截屏2022-12-18 10.11.38" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181015520.png" alt="截屏2022-12-18 10.15.19" style="zoom:50%;" /><blockquote><p>可以看出当前目录.和上级目录..是作为隐藏文件保存的</p><p><strong>注意：当前目录.和上级目录..算是当前目录的子目录！</strong></p><p>所以会显示当前目录.的子目录个数是7，分别是：当前目录.，上级目录..，code，date，dir1，dir1-bak，test1</p><p>显示code目录中的子目录个数是3，但是实际上一看code中只有一个子目录hellobite，这就是因为code的当前目录和上级目录也算作了code的子目录，而当前目录和上级目录是隐藏文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181038966.png" alt="截屏2022-12-18 10.38.42" style="zoom:50%;" /><p>同样，显示code的子目录hellobite含有的子目录的个数是2，但是实际上查看发现hellobite中没有子目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181039261.png" alt="截屏2022-12-18 10.39.46" style="zoom:50%;" /></blockquote><p><strong>&#x3D;&#x3D;-d&#x3D;&#x3D; ：只显示指定目录，不显示目录内容</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181016521.png" alt="截屏2022-12-18 10.16.52" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181013186.png" alt="截屏2022-12-18 10.13.50" style="zoom:50%;" /><p><strong>&#x3D;&#x3D;-s&#x3D;&#x3D;（小写 ：显示文件的块数</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181216093.png" alt="截屏2022-12-18 12.16.51" style="zoom:50%;" /><p><strong>&#x3D;&#x3D;-S&#x3D;&#x3D;（大写：按大小降序排列</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181232314.png" alt="截屏2022-12-18 12.32.31" style="zoom:50%;" /><p><strong>&#x3D;&#x3D;-r&#x3D;&#x3D; ：反向排序</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181530665.png" alt="截屏2022-12-18 15.30.32" style="zoom:50%;" /><p><strong>&#x3D;&#x3D;-t&#x3D;&#x3D; ： 按修改时间先后排序</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181706732.png" alt="image-20221218170624706" style="zoom:50%;" /><p><strong>&#x3D;&#x3D;-h&#x3D;&#x3D; ：按用户易读的方式显示文件大小</strong></p><p>就是换算了一下单位</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181640118.png" alt="截屏2022-12-18 16.40.15" style="zoom:50%;" /><p><strong>&#x3D;&#x3D;-R&#x3D;&#x3D; ： 列出所有子目录的文件(递归)</strong></p><center class = "half">        <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181722837.png" alt="截屏2022-12-18 17.22.03" style="zoom:40%;" />                <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181723755.png" alt="iShot_2022-12-18_17.21.42" style="zoom:35%;" /></center><p><strong>&#x3D;&#x3D;-1&#x3D;&#x3D; ： 一行只输出一个文件</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181736886.png" alt="截屏2022-12-18 17.36.33" style="zoom:50%;" /><p>&#x3D;&#x3D;-n&#x3D;&#x3D;：用数字的UID、GID代替owner、group名称</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181741224.png" alt="截屏2022-12-18 17.41.47" style="zoom:50%;" /><p>&#x3D;&#x3D;-i&#x3D;&#x3D;：显示文件的inode(索引节点)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181929066.png" alt="截屏2022-12-18 19.29.50" style="zoom:50%;" /><p>&#x3D;&#x3D;-F&#x3D;&#x3D;：在每个文件名后附上一个字符以说明该文件的类型，*表示可执行程序，&#x2F;表示目录，@表示符号连接，|表示FIFOs，&#x3D;表示套接字(sockets)。（目录类型识别）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212190918116.png" alt="截屏2022-12-19 09.17.01" style="zoom:50%;" /></blockquote><h4 id="文件块-简介"><a href="#文件块-简介" class="headerlink" title="文件块(简介)"></a>文件块(简介)</h4><p>(后续会详细学习)</p><p>Linux系统的心脏部分就是其文件系统，文件系统提供了层次结构的目录和文件。</p><p>一般情况下，文件系统将磁盘空间划分为<font color = red>每1024个字节一组，也称为一块</font>（有的Linux将512字节划为一块），编号从0到整个内存的最大块数。</p><p>文件访问系统访问磁盘的时候基本单位是4kb，也就是说是4个块为一个基本单位</p><p>所以在查看文件的总块数的时候会发现都是4的倍数</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181216093.png" alt="截屏2022-12-18 12.16.51" style="zoom:50%;" /><h4 id="inode索引节点-简介"><a href="#inode索引节点-简介" class="headerlink" title="inode索引节点(简介)"></a>inode索引节点(简介)</h4><p>(后续会详细学习)</p><p>用来存放档案和目录的基本信息，包含时间、档名、使用者及群组等</p><h4 id="UID和GID-简介"><a href="#UID和GID-简介" class="headerlink" title="UID和GID(简介)"></a>UID和GID(简介)</h4><p>(后续会详细学习)</p><p>登陆 Linux 系统时，虽然输入的是自己的用户名和密码，但其实 Linux 并不认识你的用户名称，它只认识用户名对应的 ID 号（也就是一串数字）。Linux 系统将所有用户的名称与 ID 的对应关系都存储在 &#x2F;etc&#x2F;passwd 文件中</p><blockquote><p>说白了，用户名并无实际作用，仅是为了方便用户的记忆而已。</p></blockquote><p>Linux 系统中，每个用户的 ID 细分为 2 种，分别是用户 ID（User ID，简称 UID）和组 ID（Group ID，简称 GID），这与文件有拥有者和拥有群组两种属性相对应</p><p>每个文件都有自己的拥有者 ID 和群组 ID，当显示文件属性时，系统会根据 &#x2F;etc&#x2F;passwd 和 &#x2F;etc&#x2F;group 文件中的内容，分别找到 UID 和 GID 对应的用户名和群组名，然后显示出来</p><center><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181915000.gif" /></center><blockquote><p>&#x2F;etc&#x2F;passwd 文件和 &#x2F;etc&#x2F;group 文件，后续文章会做详细讲解，这里只需要知道，在 &#x2F;etc&#x2F;passwd 文件中，利用 UID 可以找到对应的用户名；在 &#x2F;etc&#x2F;group 文件中，利用 GID 可以找到对应的群组名</p></blockquote><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><p><code>pwd</code></p><h5 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h5><p>显示用户当前所在目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212190925534.png" alt="image-20221219092508502" style="zoom:50%;" /><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><h5 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h5><p><code>cd [指定目录]</code></p><h5 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a>功能：</h5><p>进入到指定目录下</p><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd .. # 返回上级目录(相对路径)</span><br><span class="line">cd /home/litao/linux/ # 绝对路径 </span><br><span class="line">cd ../day02/ # 相对路径</span><br><span class="line">cd ~ # 进入用户家目录</span><br><span class="line">cd - # 返回最近访问的目录</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212190929706.png" alt="截屏2022-12-19 09.29.01" style="zoom:50%;" /><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><h5 id="语法：-3"><a href="#语法：-3" class="headerlink" title="语法："></a>语法：</h5><p><code>date [option]......[+format]</code></p><p>option用来设置时间</p><p>format用来显示时间</p><h5 id="功能：-3"><a href="#功能：-3" class="headerlink" title="功能："></a>功能：</h5><p>显示与设定系统的日期与时间</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221219111457827.png" alt="image-20221219111457827" style="zoom:80%;" /><h5 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h5><ol><li>显示时间：</li></ol><p>使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中常用的标记列表如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+%Y # 显示完整年份(0000~9999)</span><br><span class="line">+%m # 显示月份(1~12)</span><br><span class="line">+%d # 显示天(01~31)</span><br><span class="line">+%F # 显示年月日，相当于指令 +%Y-%m-%d</span><br><span class="line">+%H # 显示小时(00~23)</span><br><span class="line">+%M # 显示分钟(00~59)</span><br><span class="line">+%S # 显示秒(00~61)</span><br><span class="line">+%X # 显示时分秒，相当于指令 +%H:%M:%S</span><br></pre></td></tr></table></figure><center>  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191246406.png" alt="截屏2022-12-19 12.46.55" style="zoom:50%;" />  <br>  Mac的终端默认是中文所以输出的最后一行是中文的</center><ol start="2"><li>设定时间</li></ol><p>只有root才有权限设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">date -s # 设置当前时间，只有root权限才能设置，其他只能查看。</span><br><span class="line">date -s 20080523 # 设置成20080523，这样会把具体时间设置成空00:00:00 </span><br><span class="line">date -s 01:01:01 # 设置具体时间，不会对日期做更改</span><br><span class="line">date -s &quot;01:01:01 2008-05-23&quot; # 这样可以设置全部时间</span><br><span class="line">date -s &quot;01:01:01 20080523&quot; # 这样可以设置全部时间</span><br><span class="line">date -s &quot;2008-05-23 01:01:01&quot; # 这样可以设置全部时间</span><br><span class="line">date -s &quot;20080523 01:01:01&quot; # 这样可以设置全部时间</span><br></pre></td></tr></table></figure><p>3.时间戳转换</p><p>Unix时间戳(英文为Unix epoch, Unix time, POSIX time 或 Unix timestamp)是从1970年1月1日(UTC&#x2F;GMT的 午夜)开始所经过的秒数，不考虑闰秒</p><p>时间-&gt;时间戳：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date +%s </span><br></pre></td></tr></table></figure><p>时间戳-&gt;时间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -d@时间戳时间</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191256969.png" alt="截屏2022-12-19 12.56.52" style="zoom:50%;" /><h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><h5 id="语法：-4"><a href="#语法：-4" class="headerlink" title="语法："></a>语法：</h5><p><code>cal [option] [月份] [年份]</code></p><h5 id="功能：-4"><a href="#功能：-4" class="headerlink" title="功能："></a>功能：</h5><p>查看并输出指定年份的指定月份的日历</p><p>省略月份则输出指定年份整年的日历(如果只有一个参数，只能表示年份)</p><p>都省略则输出系统时间所在月的日历</p><h5 id="常用选项：-1"><a href="#常用选项：-1" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-3 # 显示指定日期所在的前一个月份、当前月份、后一个月份的日历</span><br><span class="line">-j # 显示指定日期在当前年中的第几天(从1月1号开始算)</span><br><span class="line">-y # 显示一整年12个月的日历</span><br></pre></td></tr></table></figure><figure class="half">  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222248298.png" alt="截屏2022-12-22 22.42.54" style="zoom:40%;" />  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222248633.png" alt="截屏2022-12-22 22.47.35" style="zoom: 40%;" /></figure><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><h5 id="语法：-5"><a href="#语法：-5" class="headerlink" title="语法："></a>语法：</h5><p><code>touch [选项]……[文件]……</code></p><h5 id="功能：-5"><a href="#功能：-5" class="headerlink" title="功能："></a>功能：</h5><ol><li>如果文件已存在，更改文件(包括目录文件)的时间记录，包括存取时间和修改时间</li><li>如果文件不存在，创建这个文件(不能新建目录)</li></ol><center class = "half">  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191000119.png" alt="截屏2022-12-19 09.59.53" style="zoom:45%;" />  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191000049.png" alt="截屏2022-12-19 10.00.01" style="zoom:45%;" />  </center><h5 id="常用选项：-2"><a href="#常用选项：-2" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-a，--time=atime，--time=access，--time=use # 只更改存取时间</span><br><span class="line">-m，--time=mtime，--time=modify # 只更改修改时间</span><br><span class="line">-c，--no-creat # 不创建文件</span><br><span class="line">-d [时间] # 将时间记录改为给定的时间，时间可以使用各种不同的格式</span><br><span class="line">-t [时间] # 将时间记录改为给定的时间，时间必须使用[[YY]YY]MMDDhhmm[.SS]，不再放括号里的是必须有的，方括号里的是可以省略的</span><br><span class="line">-r [参考文件] # 将时间记录改为跟参考文件一样的时间</span><br><span class="line">-f # 会被忽略处理，是为了与其他 unix 系统的相容性而保留</span><br></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;-a&#x3D;&#x3D;</p><p>无法直观展示</p><p>&#x3D;&#x3D;-m&#x3D;&#x3D;</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191004398.png" alt="image-20221219100439373" style="zoom:50%;" /><p>&#x3D;&#x3D;-c&#x3D;&#x3D;</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191005165.png" alt="image-20221219100520143" style="zoom:50%;" /><p>&#x3D;&#x3D;-d [时间]&#x3D;&#x3D;</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191008543.png" alt="截屏2022-12-19 10.07.57" style="zoom:50%;" /><p>&#x3D;&#x3D;-t&#x3D;&#x3D; [时间]</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191713110.png" alt="截屏2022-12-19 17.13.54" style="zoom:50%;" /></blockquote><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><h5 id="语法：-6"><a href="#语法：-6" class="headerlink" title="语法："></a>语法：</h5><p><code>mkdir [-p] DIRNAME</code></p><h5 id="功能：-6"><a href="#功能：-6" class="headerlink" title="功能："></a>功能：</h5><p>在当前目录下创建一个名为DIRNAME的目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191720623.png" alt="截屏2022-12-19 17.20.02" style="zoom:50%;" /><h5 id="常用选项：-3"><a href="#常用选项：-3" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p # 后跟一个路径。如果路径中有不存在的目录，则会创建出这些不存在的路径。也就是可以一次性创建一个路径，多个目录。（或--parents）</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191725268.png" alt="截屏2022-12-19 17.25.07" style="zoom:50%;" /><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><h5 id="语法：-7"><a href="#语法：-7" class="headerlink" title="语法："></a>语法：</h5><p><code>rmdir [-p] 目录</code></p><h5 id="适用对象："><a href="#适用对象：" class="headerlink" title="适用对象："></a>适用对象：</h5><p>具有指定目录的权限的所有使用者</p><h5 id="功能：-7"><a href="#功能：-7" class="headerlink" title="功能："></a>功能：</h5><p>删除指定目录，目录必须是空的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191733118.png" alt="截屏2022-12-19 17.33.29" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191736474.png" alt="截屏2022-12-19 17.36.12" style="zoom:50%;" /><h5 id="常用选项：-4"><a href="#常用选项：-4" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-p # 当指定目录被删除后它的父目录变成空的话，连同父目录一起删除</span><br><span class="line">* # 借助通配符*，满足匹配条件的文件都会被复制。</span><br><span class="line">? # 同上</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191739720.png" alt="截屏2022-12-19 17.39.04" style="zoom:50%;" /><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><h5 id="语法：-8"><a href="#语法：-8" class="headerlink" title="语法："></a>语法：</h5><p><code>rm [option] 文件</code></p><h5 id="适用对象：-1"><a href="#适用对象：-1" class="headerlink" title="适用对象："></a>适用对象：</h5><p>所有使用者</p><h5 id="功能：-8"><a href="#功能：-8" class="headerlink" title="功能："></a>功能：</h5><p>删除文件，搭配选项可以删除目录</p><p>注意，文件一旦删除无法恢复！</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212200955025.png" alt="截屏2022-12-20 09.55.42" style="zoom:50%;" /><h5 id="常用选项：-5"><a href="#常用选项：-5" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-r # 删除目录及其下所有文件</span><br><span class="line">* # 借助通配符*，满足匹配条件的文件都会被复制。</span><br><span class="line">? # 同上</span><br><span class="line">-f # 即使文件属性为只读(即写保护)，亦直接删除，无需逐一确认</span><br><span class="line">-i # 删除前逐一询问确认</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201000703.png" alt="截屏2022-12-20 10.00.09" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201003511.png" alt="截屏2022-12-20 10.03.31" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201000976.png" alt="截屏2022-12-20 10.00.26" style="zoom:50%;" /><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><h5 id="语法：-9"><a href="#语法：-9" class="headerlink" title="语法："></a>语法：</h5><p><code>man [option] command</code></p><h5 id="功能：-9"><a href="#功能：-9" class="headerlink" title="功能："></a>功能：</h5><p>查找指定命令的用法</p><h5 id="补充说明："><a href="#补充说明：" class="headerlink" title="补充说明："></a>补充说明：</h5><ol><li><p>Linux手册是联机手册，进行联机查找</p></li><li><p>执行<code>man man</code>指令可以查询man的详细信息，包括用法、每章节的内容分类等</p></li><li><p>帮助文档分为8章：</p><blockquote><p>1 是普通的命令 </p><p>2 是系统调用,如open,write之类的(通过这个，至少可以很方便的查到调用这个函数，需要加什么头文 件) </p><p>3 是库函数,如printf,fread</p><p>4 是特殊文件,也就是&#x2F;dev下的各种设备文件 </p><p>5 是指文件的格式,比如passwd, 就会说明这个文件中各个字段的含义 </p><p>6 是给游戏留的,由各个游戏自己定义</p><p>7 是附件还有一些变量,比如向environ这种全局变量在这里就有说明 </p><p>8 是系统管理用的命令,这些命令只能由root使用,如ifconfig </p></blockquote></li><li><p>man 命令中常用按键以及用途</p><table><thead><tr><th>按键</th><th>用途</th></tr></thead><tbody><tr><td>空格键</td><td>向下翻一页</td></tr><tr><td>PaGe down</td><td>向下翻一页</td></tr><tr><td>PaGe up</td><td>向上翻一页</td></tr><tr><td>home</td><td>直接前往首页</td></tr><tr><td>end</td><td>直接前往尾页</td></tr><tr><td>&#x2F;</td><td>从上至下搜索某个关键词，如“&#x2F;linux”</td></tr><tr><td>？</td><td>从下至上搜索某个关键词，如“?linux”</td></tr><tr><td>n</td><td>定位到下一个搜索到的关键词</td></tr><tr><td>N</td><td>定位到上一个搜索到的关键词</td></tr><tr><td>q</td><td>退出帮助文档</td></tr><tr><td>鼠标滚轮</td><td>上下翻页</td></tr></tbody></table></li></ol><h5 id="常用选项：-6"><a href="#常用选项：-6" class="headerlink" title="常用选项："></a><a href="https://cloud.tencent.com/developer/article/1725969">常用选项：</a></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num # 只在第num章节中进行查找</span><br><span class="line">-k # 后面的command可以是缺省的，进行模糊查找</span><br><span class="line">-a，--all # 寻找所有匹配的手册页</span><br><span class="line">-f，--whatis # 相当于whatis</span><br><span class="line">-i，--ignore-case # 查找手册页时不区分大小写(默认)</span><br><span class="line">-I，--match-case # 区分大小写</span><br></pre></td></tr></table></figure><h4 id="whatis"><a href="#whatis" class="headerlink" title="whatis"></a>whatis</h4><p>Linux 中的 <code>whatis</code> 命令可以从它的字面意思可以看出来，就是“这是什么”，通过它可以知道某命令是用来干什么的，而且是用很简短的方式来描述。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201055267.png" alt="截屏2022-12-20 10.55.10" style="zoom:50%;" /><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><h5 id="语法：-10"><a href="#语法：-10" class="headerlink" title="语法："></a>语法：</h5><p><code>cp [option] 源文件 指定目录下的目标文件</code></p><h5 id="功能：-10"><a href="#功能：-10" class="headerlink" title="功能："></a>功能：</h5><p>将 源文件 在指定目录下 复制出指定文件</p><blockquote><p>如果省略指定目录，则默认是当前目录</p><p>如果省略目标文件，则会在指定目录下复制出跟源文件同名的文件</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201625241.png" alt="截屏2022-12-20 16.25.29" style="zoom:50%;" /><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><ol><li><p>本质过程是根据源文件复制创建出一个新的文件，所以如果目标文件跟已存在的文件重名，会覆盖已存在的文件(且默认不会询问)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201628004.png" alt="截屏2022-12-20 16.28.04" style="zoom:50%;" /></li><li><p>如果要复制目录，则必须加上<code>-r</code>选项，</p></li><li><p>指定文件的类型必须跟源文件类型一样，普通文件只能复制出普通文件，源文件只能复制出源文件</p></li><li><p>可以一次性复制多个源文件，各个源文件之间用空格间隔，最后跟一个指定目录，各个源文件会复制到指定目录中去</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201630006.png" alt="截屏2022-12-20 16.30.35" style="zoom:50%;" /></li></ol><h5 id="常用选项：-7"><a href="#常用选项：-7" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-r # 复制目录(并递归复制该源目录下所有的子目录和文件)</span><br><span class="line">-f，--force # 强制复制，且覆盖已经存在的文件之前不询问用户。如果文件不能打开，可以用它强行复制</span><br><span class="line">-i，--interactive # 在覆盖已存在的文件之前选询问用户(与-f相反)</span><br><span class="line">-u # 当源文件比目标文件新时才会复制，否则不复制成目标文件</span><br><span class="line">* # 借助通配符*，满足匹配条件的文件都会被复制。</span><br><span class="line">? # 同上</span><br></pre></td></tr></table></figure><h4 id="通配符-简介"><a href="#通配符-简介" class="headerlink" title="通配符(简介)"></a>通配符(简介)</h4><p>(后续会详细学习)</p><p>linux常用通配符有* ，？，[ ]，[^]，[:space:]，[:punct:]，[:lower:]，[:upper:]，[:digit:]，[:alnum:]等等</p><p>它是由shell解析，并且一般用于匹配文件名，实际上就是shell解释器去解析的特殊符号</p><blockquote><blockquote><ol><li><p>&#x3D;&#x3D;<strong>通配符不仅会匹配当前目录下的满足条件的文件，还会<u>递归匹配</u>子目录下的满足条件的文件</strong>&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;<strong>开始字符和结束字符都可以省略</strong>&#x3D;&#x3D;</p><blockquote><p>在匹配文件的时候，被匹配的文件名会被分成三部分：开始字符、中间字符、结束字符</p><p>分别对应文件名的开头、中间、结尾</p><blockquote><p>如果开始字符被省略，那么被匹配的字符就变成了：中间字符、结束字符</p><p>则文件名的开头、中间都被视为中间字符，结尾被视为结束字符</p><p>匹配时寻找 文件名结尾 跟 结束字符 相同，且 文件名开头和中间 满足中间字符要求 的文件</p><p>(比如有的通配符要求中间只能有一个字符，那么只有文件名结尾跟结束字符相同，且除了文件名结尾之外的部分(也就是开头和中间)只有一个字符的才能满足匹配要求)</p></blockquote><blockquote><p>如果结束字符被省略，那么被匹配的字符就变成了：开始字符、结束字符</p><p>那么文件名的开头被视为开始字符，中间和结尾被视为结束字符</p><p>匹配时寻找 文件名开头 跟 开始字符 相同，且 文件名中间和结尾 满足中间字符要求 的文件</p></blockquote><blockquote><p>如果开始字符和结束字符都被省略，被匹配的字符只有中间字符</p><p>整个文件名都被视为中间字符，所有 满足中间字符要求 的文件名都会被匹配上</p></blockquote></blockquote></li></ol></blockquote><p>**&#x3D;&#x3D;<em>：匹配任意多个字符&#x3D;&#x3D;</em>*</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开始字符*结束字符 # 会匹配满足 文件名开头 和 文件名结尾 分别与开始字符和结束字符相同的、中间有任意多个字符的文件</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201812569.png" alt="截屏2022-12-20 18.12.08" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201940130.jpeg" alt="IMG_0865" style="zoom:40%;" /><p><strong>&#x3D;&#x3D;?：匹配任意一个字符&#x3D;&#x3D;</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开始字符?结束字符 # 会匹配满足 文件名开头 和 文件名结尾 分别与开始字符和结束字符相同的、中间只有一个字符的文件。</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202250451.png" alt="截屏2022-12-20 22.50.14" style="zoom:50%;" /><p>&#x3D;&#x3D;<strong>[…]：匹配中括号内出现的任意一个字符</strong>&#x3D;&#x3D;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开始字符[…]结束字符 # 会匹配满足 文件名开头 和 文件名结尾 分别与开始字符和结束字符相同的、中间存在于[]内且只有一个字符的文件</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202311425.png" alt="截屏2022-12-20 23.11.52" style="zoom:50%;" /><p>&#x3D;&#x3D;<strong>[!…]：不匹配中括号内出现的任意一个字符</strong>&#x3D;&#x3D;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开始字符[!…]结束字符 # 会匹配满足 文件名开头 和 文件名结尾 分别与开始字符和结束字符相同的、中间不存在于[]内且只有一个字符的文件</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202317821.png" alt="截屏2022-12-20 23.17.01" style="zoom:50%;" /></blockquote><p><strong>&#x3D;&#x3D;通配符可以作为一个选项，在非常多的命令中都可以用到，用来匹配文件名&#x3D;&#x3D;</strong></p><p>一般出现在要shell命令或脚本中，匹配特定的文件名</p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><h5 id="语法：-11"><a href="#语法：-11" class="headerlink" title="语法："></a>语法：</h5><p><code>mv [option] 源文件 指定目录</code></p><p><code>mv [option] 源文件 文件名</code>(文件名也可以是指定目录下的某个文件的文件名，但是这样不是多此一举了吗)</p><h5 id="功能：-11"><a href="#功能：-11" class="headerlink" title="功能："></a>功能：</h5><p>将 源文件 <strong>移动</strong> 到指定目录下。如果指定目录下存在与源文件重名的文件，则默认会被刚移动进来的源文件覆盖掉</p><p>将 源文件 <strong>改名</strong>为 给定的文件名。如果当前目录下已经存在与给定文件名重名的文件，则默认会被新改过名的源文件覆盖掉</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202331000.png" alt="截屏2022-12-20 23.31.16" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202343117.png" alt="截屏2022-12-20 23.43.13" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202333934.png" alt="截屏2022-12-20 23.33.52" style="zoom:50%;" /><h5 id="常用选项：-8"><a href="#常用选项：-8" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-f # force强制，在移动或改名时，如果出现了重名情况，不会询问而是直接复覆盖</span><br><span class="line">-i # 在移动或改名时，如果出现了重名情况，会询问是否覆盖</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202348339.png" alt="截屏2022-12-20 23.48.30" style="zoom:50%;" /><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><h5 id="语法：-12"><a href="#语法：-12" class="headerlink" title="语法："></a>语法：</h5><p><code>cat [选项] [目标文件]</code></p><h5 id="功能：-12"><a href="#功能：-12" class="headerlink" title="功能："></a>功能：</h5><p>输出内容到指定输出设备(默认指定输出设备是显示器)：</p><p>如果目标文件没被省略，<strong>打印&#x2F;输出</strong>目标文件的内容</p><p>如果目标文件被省略，则是<strong>打印&#x2F;输出</strong>刚刚从键盘上输入的内容(Linux下一切皆文件，默认将键盘视为了文件)，ctrl + c结束</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202353491.png" alt="image-20221220235315449" style="zoom:50%;" /><h5 id="常用选项：-9"><a href="#常用选项：-9" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-b # 对非空输出行编号 </span><br><span class="line">-n # 对输出的所有行编号</span><br><span class="line">-s # 不输出多行空行 </span><br></pre></td></tr></table></figure><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><h5 id="语法：-13"><a href="#语法：-13" class="headerlink" title="语法："></a>语法：</h5><p><code>more [选项] 文件</code></p><h5 id="功能：-13"><a href="#功能：-13" class="headerlink" title="功能："></a>功能：</h5><p>类似于cat，但是逐页后翻逐页<strong>打印&#x2F;输出</strong>，并可以查看前面已<strong>打印&#x2F;输出</strong>的内容，支持跳转</p><h5 id="按键用途："><a href="#按键用途：" class="headerlink" title="按键用途："></a>按键用途：</h5><blockquote><table><thead><tr><th>按键</th><th>用途</th></tr></thead><tbody><tr><td>空格space，f，ctrl+f</td><td>向下滚动一屏(后翻，下一页)</td></tr><tr><td>b(意味着back)，ctrl+b</td><td>向上滚动一屏(前翻，上一页)</td></tr><tr><td>q</td><td>退出查看</td></tr><tr><td>enter</td><td>向下n行，需要定义。默认为1行</td></tr><tr><td>&#x3D;</td><td>输出当前的行号</td></tr><tr><td>!命令</td><td>调用shell，并执行命令</td></tr><tr><td>v</td><td>调用vi编辑器</td></tr></tbody></table></blockquote><blockquote><p>向后翻页</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212211159652.gif" alt="Dec-21-2022 11-58-30" style="zoom: 80%;" /><p>向前翻页，按q退出</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212211200255.gif" alt="Dec-21-2022 11-59-56" style="zoom:80%;" /><p>文件内容是被打印出来的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212211204121.gif" alt="Dec-21-2022 12-03-52" style="zoom:80%;" /></blockquote><h5 id="常用选项：-10"><a href="#常用选项：-10" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+NUM # 从文件的第NUM行开始打印</span><br><span class="line">-NUM # 每页只输出NUM行</span><br><span class="line">+/STRING # 在目标文件中寻找含有字符串STRING的一行，并从它的前两行开始打印</span><br><span class="line">-p # 不滚屏，清屏并打印文本</span><br><span class="line">-c # 不滚屏，打印文本并清理行尾</span><br><span class="line">-u # 不打印文件中的下划线</span><br><span class="line">-s # 压缩多个连续空行为一个空行</span><br><span class="line">-d # 显示帮助，提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能</span><br><span class="line">-f # 统计逻辑行数而不是屏幕行数</span><br><span class="line">-l # 忽略ctrl+l(换页)字符，抑制换页(form feed)后的暂停</span><br></pre></td></tr></table></figure><h5 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h5><p>cat和more指令的本质是将文件内容&#x3D;&#x3D;<strong>打印</strong>&#x3D;&#x3D;出来。</p><p>因此实际上只能不断打印输出文件后面的内容，对于文件前面的内容，只能通过翻页的方式查看已经打印出来的。</p><p>当用 more +NUM，从第NUM行开始查看的时候，NUM行之前的内容由于没有被打印出来，所以无法查看到。</p><p>&#x3D;&#x3D;所以cat和more指令更像是文件内容打印指令，而不是正统的文件内容查看指令。&#x3D;&#x3D;</p><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><h5 id="说明：-2"><a href="#说明：-2" class="headerlink" title="说明："></a>说明：</h5><p>&#x3D;&#x3D;Linux正统的文件内容查看工具&#x3D;&#x3D;</p><p>less是进入文件内部加载，进行浏览查看，而不是将文件内容打印出来再进行查看</p><p>less在查看之前不会加载整个文件，只加载浏览位置的内容</p><p>less可以随意浏览文件内容，可以用上下、翻页(pagedown\pageup)、空格、回车、b、f等按键 随意前后移动查看，功能强大，用法具有弹性</p><blockquote><p>前后移动查看</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212211220727.gif" alt="Dec-21-2022 12-20-22" style="zoom:80%;" /><p>退出，发现less并不是将文件内容打印出来，而是进入文件加载，进行浏览查看</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212211223871.gif" alt="Dec-21-2022 12-22-53" style="zoom:80%;" /></blockquote><h5 id="语法：-14"><a href="#语法：-14" class="headerlink" title="语法："></a>语法：</h5><p><code>less [option] 文件</code></p><h5 id="按键用途：-1"><a href="#按键用途：-1" class="headerlink" title="按键用途："></a>按键用途：</h5><table><thead><tr><th>按键</th><th>用途</th></tr></thead><tbody><tr><td>按键</td><td>用途</td></tr><tr><td>空格space，f，ctrl+f，pageup</td><td>向下滚动一屏(后翻，下一页)</td></tr><tr><td>b(意味着back)，ctrl+b，pagedown</td><td>向上滚动一屏(前翻，上一页)</td></tr><tr><td>d，ctrl + d</td><td>向下滚动半屏</td></tr><tr><td>u，ctrl + u</td><td>向上移动半屏</td></tr><tr><td>↓，j</td><td>向下滚动一行</td></tr><tr><td>↑，k</td><td>向上滚动一行</td></tr><tr><td>g</td><td>移动到第一行</td></tr><tr><td>NUMg</td><td>移动到文件的第NUM行</td></tr><tr><td>G</td><td>移动到最后一行</td></tr><tr><td>enter</td><td>向下n行，需要定义。默认为1行</td></tr><tr><td>q，ZZ</td><td>退出查看</td></tr><tr><td>&#x2F;STRING</td><td>向下搜索“STRING”</td></tr><tr><td>?STRING</td><td>向上搜索“STRING”</td></tr><tr><td>n</td><td>重复前一个搜索（与 &#x2F; 或 ? 有关）</td></tr><tr><td>N</td><td>反向重复前一个搜索（与 &#x2F; 或 ? 有关）</td></tr><tr><td>ma</td><td>使用a标记文本的当前位置</td></tr><tr><td>a</td><td>跳转到a标记处</td></tr><tr><td>h</td><td>显示less的帮助文档</td></tr><tr><td>!命令</td><td>调用shell，并执行命令</td></tr><tr><td>v</td><td>调用vi编辑器</td></tr></tbody></table><h5 id="常用选项-可以在浏览文件时使用"><a href="#常用选项-可以在浏览文件时使用" class="headerlink" title="常用选项(可以在浏览文件时使用):"></a>常用选项(可以在浏览文件时使用):</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-i # 忽略搜索时的大小写</span><br><span class="line">-N # 显示每行的行号，再用一次会取消显示每行的行号</span><br></pre></td></tr></table></figure><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><h5 id="语法：-15"><a href="#语法：-15" class="headerlink" title="语法："></a>语法：</h5><p><code>head [option] 文件</code></p><h5 id="功能：-14"><a href="#功能：-14" class="headerlink" title="功能："></a>功能：</h5><p>从指定文件的开头开始输出到标准输出，到文件的某位置结束。默认打印前10行</p><h5 id="常用选项：-11"><a href="#常用选项：-11" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-n +NUM # 打印前NUM行，可以简写成 -n NUM 或 -nNUM 或者 -NUM</span><br><span class="line">-n -NUM # 从第一行开始打印，到倒数第NUM行停止。</span><br><span class="line">-c +SIZE # 从头开始打印，到SIZE个字节停止。可以简写成 -c SIZE 或 -cSIZE</span><br><span class="line">-c -SIZE # 从头开始打印，到倒数第SIZE个字节停止。</span><br><span class="line">-q # 不显示详细处理信息，比如文件名 (默认就是隐藏的)</span><br><span class="line">-v # 显示详细处理信息</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222148587.png" alt="image-20221222214831555" style="zoom:50%;" /><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><h5 id="语法：-16"><a href="#语法：-16" class="headerlink" title="语法："></a>语法：</h5><p><code>tail [option] [文件]</code></p><h5 id="功能：-15"><a href="#功能：-15" class="headerlink" title="功能："></a>功能：</h5><p>有指定文件时，用于从文件某位置开始输出到标准输出，到文件末尾结束。默认打印文件的最后10行。</p><p>无指定文件时，作为输入信息进行处理。</p><p>常用来查看日志文件。</p><h5 id="常用选项：-12"><a href="#常用选项：-12" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-n -NUM # 从倒数第NUM行开始输出，到结尾结束。可以简写成 -n NUM 或 -nNUM 或 -NUM。</span><br><span class="line">-n +NUM # 从正数第NUM行开始输出，到结尾结束。</span><br><span class="line">-c -SIZE # 从倒数第SIZE个字节开始输出，到结尾结束。可以简写成 -c SIZE 或 -cSIZE</span><br><span class="line">-c +SIZE # 从正数第SIZE个字节开始输出，到结尾结束。</span><br><span class="line">-f # 循环读取</span><br><span class="line">-p # 不显示详细处理信息，比如文件名(默认就是不显示的)</span><br><span class="line">-v # 显示详细的处理信息</span><br><span class="line">-s S # 与-f合用，表示在每反复的间隔休息S秒</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222152371.png" alt="截屏2022-12-22 21.52.01" style="zoom:50%;" /><blockquote><p>现在创建了一个一共100行的文件，请取出第50行</p><center>  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222153309.png" alt="截屏2022-12-22 21.53.18" style="zoom:50%;" /><br>生成1到100的序列并输出重定向到文件atest</center><p>方法一：</p><blockquote><p>将atest的前50行输出重定向到新文件tmp中</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222157524.png" alt="截屏2022-12-22 21.57.55" style="zoom:50%;" /><p>输出tmp的最后一行</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222158536.png" alt="截屏2022-12-22 21.58.37" style="zoom:50%;" /></blockquote><p>方法二：</p><blockquote><p>利用管道，输出atest的前五十行的最后一行s</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222159422.png" alt="截屏2022-12-22 21.59.30" style="zoom:50%;" /></blockquote></blockquote><h4 id="管道-简介"><a href="#管道-简介" class="headerlink" title="管道(简介)"></a>管道(简介)</h4><p>将两个或者多个命令（程序或者进程）连接到一起，把一个命令的输出作为下一个命令的输入，以这种方式连接的两个或者多个命令就形成了<strong>管道（pipe）</strong></p><p>管道可以级联多个命令，将上一个命令的输出作为下一个命令的输入，实现流水线式的操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command1 | command2</span><br><span class="line">command1 | command2 |......| commandN </span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212220959035.png" alt="截屏2022-12-22 09.59.25" style="zoom:50%;" /><p>当在两个命令之间设置管道时，管道符<code>|</code>左边命令的输出就变成了右边命令的输入。只要第一个命令向标准输出写入，而第二个命令是从标准输入读取，那么这两个命令就可以形成一个管道。大部分的 Linux 命令都可以用来形成管道。</p><blockquote><p>这里需要注意，command1 必须有正确输出，而 command2 必须可以处理 command2 的输出结果；而且 command2 只能处理 command1 的正确输出结果，不能处理 command1 的错误信息。</p></blockquote><p>多个被级联起来的命令就像是组成了几条管道联通起来，数据资源在里面进行了传输，非常形象</p><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><h5 id="语法：-17"><a href="#语法：-17" class="headerlink" title="语法："></a>语法：</h5><p><code>echo [option] 输出内容 [输出重定向]</code></p><h5 id="功能：-16"><a href="#功能：-16" class="headerlink" title="功能："></a>功能：</h5><p>将内容输出到到标准输出(默认输出设备是显示器，可以通过输出重定向进行更改输出设备)</p><h5 id="常用选项：-13"><a href="#常用选项：-13" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-e # 支持反斜杠控制的字符转换(具体参见下表)</span><br><span class="line">-n # 取消输出后行末的换行符号(内容输出后换行)</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222100949.png" alt="截屏2022-12-22 21.00.02" style="zoom:50%;" /><center>控制字符表⬇️</center><table><thead><tr><th>控制字符</th><th>作 用</th></tr></thead><tbody><tr><td>\</td><td>输出\本身</td></tr><tr><td>\a</td><td>输出警告音</td></tr><tr><td>\b</td><td>退格键，也就是向左删除键</td></tr><tr><td>\c</td><td>取消输出行末的换行符。和“-n”选项一致</td></tr><tr><td>\e</td><td>Esc键</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\r</td><td>回车键</td></tr><tr><td>\t</td><td>制表符，也就是Tab键</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\Onnn</td><td>按照八进制 ASCII 码表输出字符。其中 0 为数字 0，nnn 是三位八进制数</td></tr><tr><td>\xhh</td><td>按照十六进制 ASCH 码表输出字符。其中 hh 是两位十六进制数</td></tr></tbody></table><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222106931.png" alt="截屏2022-12-22 21.06.54" style="zoom:50%;" /><p>echo经常搭配输出重定向使用，将输入输出到指定文件中，而且如果指定文件不存在，还会创建出来(输出重定向的作用)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222108421.png" alt="截屏2022-12-22 21.08.08" style="zoom:50%;" /><p><a href="http://c.biancheng.net/linux/echo.html">更高级的玩法还看这里</a></p><h4 id="重定向-简介"><a href="#重定向-简介" class="headerlink" title="重定向(简介)"></a>重定向(简介)</h4><p>Linux 中标准的<strong>输入设备&#x2F;标准输入 默认是 键盘</strong>，标准的<strong>输出设备&#x2F;标准输入 默认是 显示器</strong></p><ul><li>输入重定向：指的是重新指定设备来代替键盘作为新的输入设备；</li><li>输出重定向：指的是重新指定设备来代替显示器作为新的输出设备。</li></ul><blockquote><p>新的输入设备：通常是指文件或者命令的执行结果</p><p>新的输出设备：通常是指文件</p></blockquote><p><strong>输入重定向：</strong></p><blockquote><table><thead><tr><th>命令符号格式</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将指定文件作为命令的输入设备</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>表示从标准输入设备（键盘）中读入，直到遇到分界符才停止（读入的数据不包括分界符），这里的分界符其实就是自定义的字符串</td></tr><tr><td>命令 &lt; 文件 1 &gt; 文件 2</td><td>将文件 1 作为命令的输入设备，该命令的执行结果输出到文件 2 中。</td></tr></tbody></table><p>命令 &lt; 文件：用文件代替默认输入设备(键盘)的输入</p><blockquote><p>当使用cat命令时，如果不加目标文件，会从默认输入设备上获取输入并输出到默认输出设备</p><p>更改默认输入设备为指定文件(这就跟cat命令后面加目标文件一个效果了)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212221723418.png" alt="截屏2022-12-22 17.23.54" style="zoom:50%;" /></blockquote><p>命令 &lt;&lt; 分界符：</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212221724262.png" alt="截屏2022-12-22 17.24.45" style="zoom:50%;" /></blockquote><p>命令 &lt; 文件 1 &gt; 文件 2：是输入重定向和输出重定向的结合使用</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212221727249.png" alt="截屏2022-12-22 17.27.12" style="zoom:50%;" /></blockquote></blockquote><p><strong>输出重定向：</strong></p><p>使用频率更高，将命令的结果重定向输出到指定的新输出设备(即文件)中</p><p><strong>&#x3D;&#x3D;注意&#x3D;&#x3D;如果指定的文件是不存在的，输出重定向的时候会创建出这个文件</strong></p><p>输出重定向按<u>性质</u> 分为 标准输出重定向和 错误输出重定向 两种</p><blockquote><p>当命令正确执行时，会产生正确的输出结果，此时将正确的输出结果作为输出设备时是标准输出重定向</p><p>当命令执行失败时，会产生错误输出信息，此时将错误输出信息作为输出设备时时错误输出重定向</p><p>两种在写法上没有区别，只是按照命令的执行成功与否进行了分类</p></blockquote><p>输出重定向按<u>用法</u> 分为 清空写入重定向(&gt;) 和 追加写入重定向(&gt;&gt;)</p><blockquote><p>清空写入重定向(&gt;)：将命令的结果重定向输出到指定的文件中，如果该文件原来已经包含数据，会清空原有数据，再写入新数据</p><p>追加写入重定向(&gt;&gt;)：将命令的结果重定向输出到指定的文件中，如果该文件原来已经包含数据，新数据会写入原有数据的后面</p></blockquote><blockquote><table><thead><tr><th>命令符号格式</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，会清空原有数据，再写入新数据。</td></tr><tr><td>命令 2&gt; 文件</td><td>将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，会清空原有数据，再写入新数据。<br />注意，”2&gt;”是固定格式</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，新数据将写入到原有内容的后面。</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，新数据将写入到原有内容的后面。<br />注意，”2&gt;”是固定格式</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或者 命令 &amp;&gt;&gt; 文件</td><td>将标准输出或者错误输出写入到指定文件，如果该文件中已包含数据，新数据将写入到原有内容的后面。<br />注意，第一种写法中，最后的 “2&gt;&amp;1” 是一体的，可以认为是固定写法。</td></tr></tbody></table><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222048427.png" alt="截屏2022-12-22 20.47.56" style="zoom:50%;" /></blockquote><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><h5 id="语法：-18"><a href="#语法：-18" class="headerlink" title="语法："></a>语法：</h5><p><code>find [pathname] [option]</code></p><h5 id="功能：-17"><a href="#功能：-17" class="headerlink" title="功能："></a>功能：</h5><p>在指定目录下查找文件</p><p>任何位于选项参数之前的字符串都被视为指定目录</p><p>如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p><h5 id="常用选项：-14"><a href="#常用选项：-14" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-name &quot;NAME&quot; # 在指定目录和子目录下查找文件名为NAME的文件，双引号可以省略。可以结合通配符使用，这个时候加上双引号搜索到的才是是全面的</span><br><span class="line">-type TYPE # 文件类型是TYPE的文件。f是普通文件，d是目录</span><br></pre></td></tr></table></figure><blockquote><p>查看更多用法<a href="https://www.runoob.com/linux/linux-comm-find.html">点这里</a></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212241118537.png" alt="截屏2022-12-24 11.18.40" style="zoom:50%;" /><blockquote><p>Linux下find命令提供了相当多的查找条件，功能很强大。由于find具有强大的功能，所以它的选项也很 多，其中大部分选项都值得我们花时间来了解一下。</p><p>即使系统中含有网络文件系统( NFS)，find命令在该文件系统中同样有效，只你具有相应的权限。</p><p>在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系 统可能会花费很长的时间(这里是指30G字节以上的文件系统)。 </p></blockquote></blockquote><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>行文本过滤工具</p><h5 id="语法：-19"><a href="#语法：-19" class="headerlink" title="语法："></a>语法：</h5><p><code>grep [option] &quot;STRING&quot; 指定文件</code></p><h5 id="功能：-18"><a href="#功能：-18" class="headerlink" title="功能："></a>功能：</h5><p>用于查找指定文件里包含STRING的行，将其打印出来</p><p>双引号可以省略</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212241130543.png" alt="截屏2022-12-24 11.30.14" style="zoom:50%;" /><h5 id="常用选项：-15"><a href="#常用选项：-15" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-i # 查找时忽略大小写</span><br><span class="line">-n # 顺便输出在文件中的行号</span><br><span class="line">-v # 反向选择，即打印出不包含被查找的字符串的行</span><br></pre></td></tr></table></figure><figure style=half>  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212241150576.png" alt="截屏2022-12-24 11.49.36" style="zoom:50%;" />  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212241150581.png" alt="截屏2022-12-24 11.49.46" style="zoom:50%;" /></figure><h3 id="打包-和-压缩："><a href="#打包-和-压缩：" class="headerlink" title="打包 和 压缩："></a>打包 和 压缩：</h3><p>&#x3D;&#x3D;打包&#x3D;&#x3D;：也称归档、备份，指的是一个文件或者目录的集合，而这个集合被存储在一个文件中。打包文件没有经过压缩，因此占用的空间就是打包文件中所有文件的总空间。</p><blockquote><p>将多个文件打包形成一个包</p></blockquote><p>&#x3D;&#x3D;压缩&#x3D;&#x3D;：利用算法将文件进行处理，以达到保留最大文件信息而让文件体积变小的目的。</p><blockquote><p>只能将一个文件压缩成一个压缩包</p></blockquote><p>打包就像是将行李放进行李箱。压缩就像是为了减少行李的大小，用收纳法将行李的体积折叠的尽可能小，这样就能在箱子里放入更多的行李，也可以将打包好的行李进行收纳，这样行李占用的体积就更小，可以用更小的行李箱。</p><p>压缩是将文件的大小减小，起到减少资源占用的作用。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212261737354.jpeg" alt="IMG_0891" style="zoom:50%;" /><p>如果想一次性压缩许多零零散散的文件或目录，就得要先把它们打成一个包，然后把这个包压缩。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212261747026.jpeg" alt="IMG_0892" style="zoom:50%;" /><p>压缩软件打包压缩格式界面：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212261740678.jpeg" alt="截屏2022-12-26 17.36.56" style="zoom:50%;" /><h3 id="关于普通文件类型的说明："><a href="#关于普通文件类型的说明：" class="headerlink" title="关于普通文件类型的说明："></a>关于普通文件类型的说明：</h3><p>文件的分类就分为<a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB">上面介绍的几类</a></p><p>在Linux中，并不以文件的后缀来区分文件类型，无论是<code>.c</code> <code>.cpp</code> <code> .zip</code> <code> .tar</code> <code>.txt</code>等，都是普通文件类型，文件后缀只是在处理文件的时候进行区分，比如只有<code>.zip</code>等才能解压，<code>.c</code> <code> .cpp</code>等才能编译等。它们都是普通文件。</p><h3 id="zip-x2F-unzip压缩"><a href="#zip-x2F-unzip压缩" class="headerlink" title="zip&#x2F;unzip压缩"></a>zip&#x2F;unzip压缩</h3><p>压缩包拓展名&#x2F;后缀 是<code>.zip</code></p><h5 id="语法-x2F-功能："><a href="#语法-x2F-功能：" class="headerlink" title="语法&#x2F;功能："></a>语法&#x2F;功能：</h5><p><code>zip [option] ZIPNAME 目标文件 </code>：将目标文件压缩为名称为ZIPNAME的压缩包。压缩包的<code>.zip</code>后缀可带可不带，会自动补上</p><p><code>unzip [option] 指定压缩包  </code>：将压缩包解压到当前目录下。若当前目录下有文件与解压后文件重名，会进行询问是否覆盖。注意，解压后文件的名称是压缩前文件的名称，并不是压缩包的名称。</p><h5 id="常用选项：-16"><a href="#常用选项：-16" class="headerlink" title="常用选项："></a>常用选项：</h5><p>zip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-r # 递归处理，将指定目录下的所有文件和子目录一并处理，分别形成单独的压缩包</span><br><span class="line">-m # 将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中</span><br><span class="line">-v # 显示详细的压缩过程信息(默认)</span><br><span class="line">-q # 在压缩的时候不显示命令的执行过程</span><br><span class="line">-数字 # 压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好</span><br><span class="line">-u # 更新压缩文件，即往压缩文件中添加新文件</span><br></pre></td></tr></table></figure><p>unzip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-d 指定目录 # 将压缩包解压到指定目录</span><br><span class="line">-n # 解压时不覆盖已经存在的文件</span><br><span class="line">-o # 解压时覆盖已经存在的文件，且不向用户询问</span><br><span class="line">-v # 不解压，只是查看压缩包的详细信息，包括压缩包中包含的文件大小、文件名、压缩比等</span><br><span class="line">-t # 不解压，测试压缩包有损坏</span><br><span class="line">-x 文件列表 # 解压，但不包含文件列表中的指定文件</span><br></pre></td></tr></table></figure><h4 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h4><p>只能压缩普通文件。</p><p>就算指定了目录，也是将目录下的所有普通文件一一单独压缩出来。压缩文件的拓展名&#x2F;后缀是<code>.gz</code></p><blockquote><p>gzip压缩完之后源文件会被删除</p></blockquote><h5 id="语法-x2F-功能：-1"><a href="#语法-x2F-功能：-1" class="headerlink" title="语法&#x2F;功能："></a>语法&#x2F;功能：</h5><p><code>gzip [option] 指定文件</code></p><blockquote><p>gzip命令十分简单，不需要指定压缩后的文件的名称，压缩后文件的名称是 <code>源文件名.gz</code></p></blockquote><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令:"></a>常用命令:</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-c # 将压缩数据输出到标准输出中，并保留源文件。可以将数据重定向到压缩包中，这样在不删除源文件的同时还不会将数据打印到屏幕上</span><br><span class="line">-d # 对压缩包解压</span><br><span class="line">-f # 强行压缩或解压文件，不理会文件名或者硬连接是否存在以及该文件是否为符号连接。</span><br><span class="line">-r # 递归压缩指定目录下及其子目录下的所有普通文件</span><br><span class="line">-v # 压缩和解压时，显示压缩包的文件名和压缩比等详细信息</span><br><span class="line">-l # 显示每个压缩文件的大小、压缩比，未压缩文件的大小、未压缩文件的名称等详细信息</span><br><span class="line">-数字 # 压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好</span><br><span class="line">-h # 显示帮助</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212251324128.png" alt="截屏2022-12-25 13.23.46" style="zoom:50%;" /><h4 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h4><p>只能压缩普通文件。</p><p>就算指定了目录，也是将目录下的所有普通文件一一单独压缩出来。压缩文件的拓展名&#x2F;后缀是<code>.bz2</code></p><p>从理论上来讲，bzip2的算法比gzip更先进、压缩比更好；而gzip的压缩速度相对来讲更快</p><blockquote><p>bzip2压缩完之后源文件会被删除</p></blockquote><h5 id="语法：-20"><a href="#语法：-20" class="headerlink" title="语法："></a>语法：</h5><p><code>bzip2 [option] 指定文件</code></p><blockquote><p>gzip命令十分简单，不需要指定压缩后的文件的名称，压缩后文件的名称是 <code>源文件名.bz2</code></p></blockquote><h5 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-c # 将压缩和解压的结果送到标准输出</span><br><span class="line">-d # 解压</span><br><span class="line">-f # 压缩或解压时，若出现输出文件与现有文件重名，会直接覆盖。(默认是不会覆盖的)</span><br><span class="line">-h # 显示帮助</span><br><span class="line">-k # 在压缩或解压后不会删除源文件</span><br><span class="line">-s # 强制进行压缩</span><br><span class="line">-V # 显示版本信息</span><br></pre></td></tr></table></figure><h3 id="tar打包-x2F-解包"><a href="#tar打包-x2F-解包" class="headerlink" title="tar打包&#x2F;解包"></a>tar打包&#x2F;解包</h3><h5 id="语法：-21"><a href="#语法：-21" class="headerlink" title="语法："></a>语法：</h5><p><code>tar [option] 指定文件</code></p><h4 id="打包："><a href="#打包：" class="headerlink" title="打包："></a>打包：</h4><p>也称归档、备份</p><p>打包并不是压缩，只是将文件打包到一个集合中，但是如果想要将一堆文件进行压缩的话，首先就得先把这堆零零散散的文件打一个包，这样才方便压缩。所以打包是很重要的。打包后的文件后缀为<code>.tar</code></p><h5 id="常用选项：-17"><a href="#常用选项：-17" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-c # 进行打包的指令</span><br><span class="line">-f TARNAME # 指定包的文件名为TARNAME。注意要加上.tar后缀</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本质上是将打包好的内容输出到名为TARNAME的tar包中</span></span><br><span class="line">-v # 显示详细过程信息</span><br><span class="line">-A # 追加tar文件到打包文件中</span><br><span class="line">-z TARGZIPNAME # 询问是否在打包后同时进行gzip压缩，并将压缩包命名为TARGZIPNAME。注意要加上后缀.tar.gz</span><br><span class="line">-j TARBZIP2NAME # 询问是否在打包后同时进行bzip2压缩，并将压缩包命名为TAEBZIP2NAME。要加后缀.tar.bz2</span><br><span class="line">-p # 打包的时候保留源文件的属性（权限等）</span><br><span class="line">-N &quot;YYYY/MM/DD&quot; # 打包比某日期新的文件</span><br><span class="line">--exclude 文件 # 打包时不打包该文件</span><br><span class="line">-u # 更新原压缩包的文件</span><br></pre></td></tr></table></figure><h5 id="说明：-3"><a href="#说明：-3" class="headerlink" title="说明："></a>说明：</h5><blockquote><ol><li>-cfv 常视作打包的习惯用法</li><li>tar命令的选项中 <code>-</code> 是可加可不加的，比如 <code>-cfv</code> 和 <code>cfv</code> 是一样的</li><li>tar可以将多个文件进行打包，文件之间用空格间隔开就可以。</li><li>tar也可以将目录下的所有文件都打包，例如将date目录下的所有文件都打包：<code>tar -cvf date.tar ./date/</code></li><li>通常都是在打包时同时进行gzip或者bzip2压缩</li><li><u>要注意，一般情况Linux命令的选项是可以不管顺序的，但是在这里</u>，-f后面紧跟包的名称，所以压缩的时候要把-f放在选项最后，否则会报错</li></ol></blockquote><h5 id="应用举例："><a href="#应用举例：" class="headerlink" title="应用举例："></a>应用举例：</h5><blockquote><ol><li><p>将 .&#x2F;test 目录下的文件全部打包为<code>test.tar</code></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271109047.png" alt="截屏2022-12-27 11.09.06" style="zoom:50%;" /></li><li><p>将test目录下的文件全部打包并压缩为<code>tt.tar.gz</code></p><blockquote><p>注意选项的顺序，-f要放在选项的最后面，否则会报错</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271116816.png" alt="image-20221227111606770" style="zoom:50%;" /></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271116841.png" alt="截屏2022-12-27 11.16.26" style="zoom:50%;" /></li><li><p>打包 .&#x2F;test 和 .&#x2F;date并压缩为<code>myfile.tar.gz</code>，但是不打包.&#x2F;test中的date</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271124056.png" alt="截屏2022-12-27 11.24.12" style="zoom:50%;" /></li><li><p>将用户目录下的所有文件备份并压缩，且保留其权限</p><p>(使用的相对路径，也可以使用绝对路径)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271217612.png" alt="截屏2022-12-27 12.17.13" style="zoom:50%;" /><blockquote><p>在最后一行会提示：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271217195.png" alt="截屏2022-12-27 12.17.34" style="zoom:50%;" /><p>这是因为我们将用户目录中的所有文件都备份并压缩了，在执行完命令之后，会在当前目录下生成压缩包</p><p>而当前目录就是用户目录，所以压缩包声明在了用户目录下</p><p>原来的目标文件，也是用户目录，所以原来的目标文件内容发生了变化，就会给出这个提示</p><p>如果再执行一次这个命令(使用的绝对路径，也可以使用相对路径)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271223698.png" alt="截屏2022-12-27 12.23.07" style="zoom:50%;" /><p>会在压缩的时候显示</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271224909.png" alt="截屏2022-12-27 12.23.57" style="zoom:50%;" /><p>因为在压缩之前已经有了yujin.tar.gz这个文件，在压缩用户目录的时候会将它压缩，然后在压缩完用户目录之后又会生成yujin.tar.gz这个压缩包，相当于时间先后、新旧文件的更改，所以会给出这种说明</p></blockquote></li><li><p>在test目录下，比2022&#x2F;12&#x2F;26新的文件才会被打包</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271232344.png" alt="截屏2022-12-27 12.32.14" style="zoom:50%;" /><blockquote><p>命令的最后面可以是<code>./test</code>也可以是<code>./test/</code>或者<code>test</code>、 <code>test/</code></p></blockquote></li></ol></blockquote><h4 id="解包："><a href="#解包：" class="headerlink" title="解包："></a>解包：</h4><h5 id="常用选项：-18"><a href="#常用选项：-18" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-t # 不解包，直接查看tar包里的内容</span><br><span class="line">-x # 解包</span><br><span class="line">-v # 显示详细过程信息</span><br><span class="line">-f # 查看或解包.tar时带上这个选项</span><br><span class="line">-z # 如果压缩包是.tar.gz，那么查看或者解包的时候要加上这个选项</span><br><span class="line">-j # 如果压缩包是.tar.bz2，那么查看或者解包的时候要加上这个选项</span><br><span class="line">-C 指定目录 # 解压到指定目录。如果不带此选项，默认是解包到当前目录</span><br></pre></td></tr></table></figure><h5 id="应用举例：-1"><a href="#应用举例：-1" class="headerlink" title="应用举例："></a>应用举例：</h5><blockquote><ol><li><p>查看上面压缩的<code>mylife.tar.gz</code>中的文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271147961.png" alt="截屏2022-12-27 11.47.24" style="zoom:50%;" /></li><li><p>将<code>test.tar</code>解包到date目录下</p><p>可以先进入到指定目录，再解压到当前目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271152042.png" alt="截屏2022-12-27 11.52.25" style="zoom:50%;" /><p>也可以用选项-C直接解压到指定目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271240994.png" alt="image-20221227124038949" style="zoom:50%;" /></li><li><p>只想将<code>test.tar.gz</code>中的dir1解开到当前目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271813984.png" alt="截屏2022-12-27 18.13.21" style="zoom:50%;" /><blockquote><p>可以看到，解压出的文件是按照原来的层级形成的，解压出test目录下的dir1目录下的mytest.c</p></blockquote></li><li><p>将a目录进行打包，并立即在dir1目录下解开它(这就相当于将a目录移动到dir1目录下，跟cp类似)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271749705.png" alt="截屏2022-12-27 17.49.53" style="zoom:50%;" /><blockquote><p>运用了管道，将前一个命令的输出作为后一个命令的输入</p><p>这里的单独的<code>-</code>意思是标准输入输出(standard input , standard output)</p><p>在前面的命令中，是将a目录进行打包，然后输出到-f 后面的文件中，-f后面跟的是-，也就是标准输出，所以就是将打包好的a目录输出到了标准输出</p><p>在后面的命令中，-xvf 后面跟的是 - ，也就是要解压的包是标准输出上的，并解压到dir1</p><p>这样就用管道命令和标准输入输出实现了</p></blockquote></li></ol></blockquote><h3 id="bc"><a href="#bc" class="headerlink" title="bc"></a>bc</h3><p>可以很方便进行浮点运算，用的时候man一下查找用法即可，此处不再赘述</p><h3 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h3><h5 id="语法：-22"><a href="#语法：-22" class="headerlink" title="语法："></a>语法：</h5><p><code>uname [option]</code></p><h5 id="功能：-19"><a href="#功能：-19" class="headerlink" title="功能："></a>功能：</h5><p>显示电脑的操作系统等信息</p><h5 id="常用选项：-19"><a href="#常用选项：-19" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a # 输出所有详细信息，依次为内核名称、主机名、内核版本号、内核版本、硬件名、处理器类型、硬件平台信息、操作系统名称</span><br></pre></td></tr></table></figure><h3 id="几个重要的热键"><a href="#几个重要的热键" class="headerlink" title="几个重要的热键"></a>几个重要的热键</h3><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>Tab</td><td>命令补全、档案补齐</td></tr><tr><td>ctrl + c</td><td>终止当前进程</td></tr><tr><td>ctrl + d</td><td>代表“键盘输入结束(End of file,EOF,End of input)“的意思；<br />另外，也可以取代exit命令来登出Linux账户</td></tr></tbody></table><p><u>更多快捷键请见linuxJournal中的快捷键整理</u></p><h2 id="Linux权限的概念"><a href="#Linux权限的概念" class="headerlink" title="Linux权限的概念"></a>Linux权限的概念</h2><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>Linux中有两种用户：超级用户(root)、普通用户</p><blockquote><p>超级用户：可以在Linux系统内做任何事情，不受限制。命令提示符是：#</p><p>普通用户：在Linux下做有限的事情。命令提示符是：$</p></blockquote><h4 id="用户切换指令：su"><a href="#用户切换指令：su" class="headerlink" title="用户切换指令：su"></a>用户切换指令：su</h4><h5 id="语法：-23"><a href="#语法：-23" class="headerlink" title="语法："></a>语法：</h5><p><code>su [USERNAME]</code></p><h5 id="功能：-20"><a href="#功能：-20" class="headerlink" title="功能："></a>功能：</h5><p>切换用户</p><h5 id="说明：-4"><a href="#说明：-4" class="headerlink" title="说明："></a>说明：</h5><p>当只使用su命令的时候，是切换到root用户，输入root用户的密码</p><p>当使用 su USERNAME 的时候，是切换到名称为USERNAME的普通用户，并要输入那个用户的密码；如果是从root切换到别的普通用户，不需要输入密码</p><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><h5 id="语法：-24"><a href="#语法：-24" class="headerlink" title="语法："></a>语法：</h5><p><code>sudo [option] 指令</code></p><h5 id="功能：-21"><a href="#功能：-21" class="headerlink" title="功能："></a>功能：</h5><p>以root身份执行当前指令</p><h5 id="说明：-5"><a href="#说明：-5" class="headerlink" title="说明："></a>说明：</h5><p>不会切换身份，只是用root身份执行指令，当前用户(使用sudo命令的用户)不变，相当于在执行指令的时候暂时提高了权限</p><h5 id="常用选项：-20"><a href="#常用选项：-20" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-u USERNAME # 以USERNAME身份执行当前命令</span><br><span class="line">-l # 显示当前用户(使用sudo命令的用户)的权限</span><br></pre></td></tr></table></figure><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><h4 id="文件访问者的分类："><a href="#文件访问者的分类：" class="headerlink" title="文件访问者的分类："></a>文件访问者的分类：</h4><p>访问文件的人有三种</p><blockquote><p>文件的所有者：u——User</p><p>文件所有者所在组的用户：g——Group</p><p>其他用户：o——Others</p></blockquote><p>其中，文件的创建者不一定就是文件的所有者，文件的所有权是可以转让的</p><p>Group，在工作中，一般是以团队进行的，文件的所有者是属于某一个团队的，这个团队的人有时就需要访问这个文件，文件所有者可以创建一个Group，指定在Group里的所有人对于这个文件的访问权限。文件所有者本人本身就是一个团队，他可以往团队里加人。</p><p>Others就是不属于前两者的人。</p><h4 id="文件类型和访问权限-文件属性-："><a href="#文件类型和访问权限-文件属性-：" class="headerlink" title="文件类型和访问权限(文件属性)："></a>文件类型和访问权限(文件属性)：</h4><p>在使用<code>ll</code>命令的时候会展示出文件的详细信息</p><div><center><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181050726.png" alt="image-20221218105015699" style="zoom:30%;" /><br>Linux文件默认是按照名称排序的</center></div><p>文件属性包括文件类型和文件权限，文件类型就是文件的种类，包括普通文件、目录文件等，详细在一开始有讲过<a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB">在这里可以查看一下</a></p><p>文件权限就是，文件访问者对于文件的访问权限是如何的</p><blockquote><ul><li><p>读(r):Read 对文件而言，具有读取文件内容的权限；对目录来说，具有ls浏览该目录信息的权限</p></li><li><p>写(w):Write 对文件而言，具有修改文件内容的权限；对目录来说具有创建删除移动目录内文件的权限 </p></li><li><p>执行(x):execute 对文件而言，具有执行文件的权限；对目录来说，具有cd进入目录的权限</p></li><li><p>“-“表示不具有该项权限</p></li></ul><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212281710542.png" alt="截屏2022-12-28 17.10.03" style="zoom: 33%;" /></blockquote><h4 id="文件权限的表示方法："><a href="#文件权限的表示方法：" class="headerlink" title="文件权限的表示方法："></a>文件权限的表示方法：</h4><ol><li><p>字符表示方法</p><table><thead><tr><th align="center">Linux字符表示</th><th align="center">权限说明</th><th align="center">Linux字符表示</th><th align="center">权限说明</th></tr></thead><tbody><tr><td align="center">r–</td><td align="center">只读</td><td align="center">-w-</td><td align="center">仅可写</td></tr><tr><td align="center">–x</td><td align="center">仅可执行</td><td align="center">rw-</td><td align="center">可读可写</td></tr><tr><td align="center">-wx</td><td align="center">可写可执行</td><td align="center">r-x</td><td align="center">可读可执行</td></tr><tr><td align="center">rwx</td><td align="center">全部权限</td><td align="center">—</td><td align="center">无任何权限</td></tr></tbody></table></li><li><p>8进制数值表示方法</p><p>对于权限的顺序，可以排列为r、w、x</p><p>对于权限的有无，可以用二进制表示，0表示没有这个权限，1表示有这个权限</p><p>故r、w、x这三个权限可以用三个二进制数表示，而三个二进制数又能被一个八进制数表示</p><table><thead><tr><th>权限符号</th><th>二进制</th><th>八进制</th></tr></thead><tbody><tr><td>—</td><td>000</td><td>0</td></tr><tr><td>r–</td><td>100</td><td>4</td></tr><tr><td>-w-</td><td>010</td><td>2</td></tr><tr><td>–r</td><td>001</td><td>1</td></tr><tr><td>rw-</td><td>110</td><td>6</td></tr><tr><td>r-x</td><td>101</td><td>5</td></tr><tr><td>-wx</td><td>011</td><td>3</td></tr><tr><td>rwx</td><td>111</td><td>7</td></tr></tbody></table></li></ol><h4 id="文件访问权限的设置方法："><a href="#文件访问权限的设置方法：" class="headerlink" title="文件访问权限的设置方法："></a>文件访问权限的设置方法：</h4><h5 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h5><h6 id="功能：-22"><a href="#功能：-22" class="headerlink" title="功能："></a>功能：</h6><p>设置文件的访问权限</p><h6 id="语法：-25"><a href="#语法：-25" class="headerlink" title="语法："></a>语法：</h6><p><code>chmod [option] 权限 文件</code></p><h6 id="说明：-6"><a href="#说明：-6" class="headerlink" title="说明："></a>说明：</h6><p>只有文件所有者和root用户才能修改文件访问权限的权限</p><h6 id="常用选项：-21"><a href="#常用选项：-21" class="headerlink" title="常用选项："></a>常用选项：</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R # 递归修改目录文件的权限</span><br></pre></td></tr></table></figure><h6 id="权限格式一："><a href="#权限格式一：" class="headerlink" title="权限格式一："></a>权限格式一：</h6><p>用户表示符 +或-或&#x3D; 文件权限字符</p><blockquote><p>用户表示符：</p><ul><li>u拥有者</li><li>g同组者</li><li>o其他用户</li><li>a所有用户</li></ul><p>+：向用户增加(追加)权限</p><p>-：向用户取消(减少)权限</p><p>&#x3D;：向用户赋予权限，也就是用户只有被赋予的权限</p></blockquote><blockquote><p>向hello.txt的拥有者追加执行权限</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282037692.png" alt="截屏2022-12-28 20.36.43" style="zoom:50%;" /><p>向hello.txt的同组者减少可写权限</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282040631.png" alt="截屏2022-12-28 20.40.03" style="zoom:50%;" /><p>向hello.txt的其他人只赋予可写权限</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282041865.png" alt="截屏2022-12-28 20.41.15" style="zoom:50%;" /><blockquote><p>可以看到others原来是有rw权限，但是被赋予w权限之后，就只有w权限了</p></blockquote></blockquote><h6 id="权限格式二："><a href="#权限格式二：" class="headerlink" title="权限格式二："></a>权限格式二：</h6><p>三个8进制数表示权限   （方便常用）</p><blockquote><p>第一个八进制数表示user的权限</p><p>第二个表示group的权限</p><p>第三个表示other的权限</p><p>跟文件的权限对应</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212281710542.png" alt="截屏2022-12-28 17.10.03" style="zoom: 25%;" /></blockquote><blockquote><p>将hello.txt的文件权限设置为rwx rwx rwx</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282045567.png" alt="截屏2022-12-28 20.45.01" style="zoom:50%;" /><blockquote><p>rwx对应的二进制就是111，对应的八进制数就是7</p></blockquote><p>将hello.txt的文件权限设置为555</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282049750.png" alt="截屏2022-12-28 20.49.33" style="zoom:50%;" /><blockquote><p>5对应的权限就是101即r-x</p></blockquote><p>将hello.txt的文件权限设置为754</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282050739.png" alt="截屏2022-12-28 20.50.54" style="zoom:50%;" /></blockquote><h5 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h5><h6 id="功能：-23"><a href="#功能：-23" class="headerlink" title="功能："></a>功能：</h6><p>修改文件的拥有者</p><h6 id="语法：-26"><a href="#语法：-26" class="headerlink" title="语法："></a>语法：</h6><p><code>chown [option] 用户名 文件名</code></p><h6 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h6><p>只有root用户才有权限使用这个命令</p><h6 id="常用选项：-22"><a href="#常用选项：-22" class="headerlink" title="常用选项："></a>常用选项：</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-v # 显示详细过程信息</span><br><span class="line">-R # 递归更改目录的拥有者</span><br><span class="line">-help # 查看用法帮助</span><br><span class="line">-f # 忽略错误信息</span><br></pre></td></tr></table></figure><h6 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h6><blockquote><p>把hello.txt的所属权从yujin转给chenyujin</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282101595.png" alt="截屏2022-12-28 21.01.19" style="zoom:50%;" /></blockquote><h5 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h5><h6 id="功能：-24"><a href="#功能：-24" class="headerlink" title="功能："></a>功能：</h6><p>修改文件所属组 </p><h6 id="语法：-27"><a href="#语法：-27" class="headerlink" title="语法："></a>语法：</h6><p><code>chgrp [option] 用户组名 文件名</code></p><h6 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h6><p>与chown不同，只要是文件原组里的用户，就可以修改文件的所属组</p><h6 id="常用选项：-23"><a href="#常用选项：-23" class="headerlink" title="常用选项："></a>常用选项：</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-v # 显示详细过程信息</span><br><span class="line">-c # 效果类似&quot;-v&quot;参数，但仅显示更改的部分。</span><br><span class="line">-R # 递归更改目录的拥有者</span><br></pre></td></tr></table></figure><h5 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h5><h6 id="功能：-25"><a href="#功能：-25" class="headerlink" title="功能："></a>功能：</h6><p>查看或修改文件权限掩码</p><h6 id="语法：-28"><a href="#语法：-28" class="headerlink" title="语法："></a>语法：</h6><p><code>umask 权限掩码值</code></p><h6 id="说明：-7"><a href="#说明：-7" class="headerlink" title="说明："></a>说明：</h6><p>将现有的默认权限减去权限掩码，即可产生创建文件时的预设权限</p><h5 id="权限掩码-简介"><a href="#权限掩码-简介" class="headerlink" title="权限掩码(简介)"></a>权限掩码(简介)</h5><p>英文名：unmask</p><p>在创建目录文件的时候，默认权限是775</p><p>在创建普通文件的时候，默认权限是664</p><p>（不同系统上可能有差别，此处以centOS7为例</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212171711414.png" alt="202212171709806" style="zoom:50%;" /><p>但是实际上：</p><blockquote><ol><li>普通目录的默认起始预设权限是777，普通文件的默认起始预设权限是666</li><li>权限掩码umask会在用户创建目录或者文件时拿掉一些默认起始权限，得到的才是创建之后的默认权限</li></ol><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask # 查看权限掩码</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212171704218.png" alt="截屏2022-12-17 17.03.59" style="zoom:50%;" /><p>当前系统下的权限掩码是0002（第一位不用看，代表特殊权限，此处暂不讨论。当然，在写权限的时候是可以带上的，比如0777</p><p>系统会拿掉权限掩码对应的权限，002则对应着owner: 0, grouper: 0, other: 2</p><p>意味着other会被拿掉2权限(2是八进制数，对应的二进制数是010，也就是w权限)</p><p>对于目录，ohter的默认起始权限是<strong>7</strong>(也就是111,rwx)，被拿掉<strong>2</strong>(也就是010,w)之后就变成了<strong>5</strong>(也就是101,rx)，所以创建出的目录的默认权限就变成了775</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212171731199.png" alt="截屏2022-12-17 17.31.22" style="zoom:40%;" /><p>对于文件，other的默认起始权限是<strong>6</strong>(110,rw)，被拿掉<strong>2</strong>(010,w)之后就变成了<strong>4</strong>(100,r)，所以创建出的文件默认权限就是664</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212171732621.png" alt="截屏2022-12-17 17.32.26" style="zoom:40%;" /></blockquote><p>注意，权限掩码是“拿掉”权限，而不是进行二进制减法，比如初始权限是111 110 110，权限掩码是000 000 001，得到的默认权限是111 110 110，而不是111 110 101，因为最后一位本来就没有权限，权限掩码只是拿掉权限，本来就没有权限，拿掉了还是没有权限</p></blockquote><h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><h5 id="功能：-26"><a href="#功能：-26" class="headerlink" title="功能："></a>功能：</h5><p>查看文件类型</p><h5 id="语法：-29"><a href="#语法：-29" class="headerlink" title="语法："></a>语法：</h5><p><code>file [option] 文件</code></p><h5 id="常用选项：-24"><a href="#常用选项：-24" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-c # 显示详细执行过程，便于排错或分析程序执行的情形 </span><br><span class="line">-z # 尝试去解读压缩文件的内容</span><br></pre></td></tr></table></figure><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282224254.png" alt="截屏2022-12-28 22.24.01" style="zoom:50%;" /></blockquote><h4 id="粘滞位"><a href="#粘滞位" class="headerlink" title="粘滞位"></a>粘滞位</h4><p>让我们回顾一下目录的权限：</p><blockquote><ul><li><p>读(r):Read 对目录来说，具有ls浏览该目录信息的权限</p></li><li><p>写(w):Write 对目录来说具有创建删除移动目录内文件的权限 </p></li><li><p>执行(x):execute 对目录来说，具有cd进入目录的权限</p></li></ul></blockquote><p>那这样的话，只要用户具有目录的w权限，就能删除目录中的文件。</p><p>那么问题来了，当张三和李四对于一个目录都有w的权限的时候，张三创建了一个文件，结果被李四删除了！我张三创建的文件你李四凭什么给我删除了！？这不科学呀</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282254005.png" alt="截屏2022-12-28 22.53.59" style="zoom:50%;" /><blockquote><p>这里yujin具有work目录的w权限(属于others)，他将work里root创建的root_work删除了</p></blockquote><p>为了解决这个不科学的问题，就出现了粘滞位</p><h5 id="说明-amp-功能-amp-用法："><a href="#说明-amp-功能-amp-用法：" class="headerlink" title="说明&amp;功能&amp;用法："></a>说明&amp;功能&amp;用法：</h5><p>目录的所有者可以对目录添加粘滞位，加上了粘滞位的目录，具有w权限的用户不能删除目录下别人的文件了，只能删除自己的文件</p><p><code>chmod +t 目录</code></p><blockquote><p>只有 root 和 目录所有者 才能给目录加上粘滞位</p></blockquote><blockquote><p>将work目录加上粘滞位之后，yujin就没办法删除root创建的文件root_work2了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282310392.png" alt="image-20221228231028314" style="zoom:50%;" /></blockquote><p><strong>当一个目录被加上粘滞位的时候，该目录下的文件只能由</strong></p><blockquote><ol><li><strong>root删除</strong></li><li><strong>该目录的所有者删除</strong></li><li><strong>该文件的所有者删除</strong></li></ol></blockquote><h4 id="关于权限的总结"><a href="#关于权限的总结" class="headerlink" title="关于权限的总结"></a>关于权限的总结</h4><blockquote><ul><li>目录的可执行权限是表示你可否在目录下执行命令</li><li>如果目录没有-x权限，则无法对目录执行任何命令，甚至无法cd 进入目, 即使目录仍然有-r 读权限(这 个地方很容易犯错，认为有读权限就可以进入目录读取目录下的文件) </li><li>而如果目录具有-x权限，但没有-r权限，则用户可以执行命令，可以cd进入目录。但由于没有目录的读 权限,所以在目录下，即使可以执行ls命令，但仍然没有权限读出目录下的文档。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宏实现#pragma once&amp;#ifndef</title>
      <link href="/chunyujin/5f33e850.html"/>
      <url>/chunyujin/5f33e850.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为了避免同一个头文件被包含(include)多次，C&#x2F;C++中有两种宏实现的方式：一种是#pragma once方式</p><p>一种是#ifndef的方式</p><p>有些编译器只支持其中的一种。</p><p>在能够支持这两种方式的编译器是，两者并没有太大的区别，但是两者仍然有一些细微的区别。</p><p><a href="https://blog.csdn.net/qq_43907537/article/details/107938459?ops_request_misc=&request_id=&biz_id=102&utm_term=?ops_request_misc=&request_id=&biz_id=102&utm_term=&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-107938459.nonecase&spm=1018.2226.3001.4187#pragma%20once&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-107938459.nonecase">#pragma once用法</a></p><p><a href="https://blog.csdn.net/qq_35027690/article/details/125865367">#ifndef, #define, #endif 理解</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/chunyujin/d87f7e0c.html"/>
      <url>/chunyujin/d87f7e0c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="欢迎使用坚果云Markdown"><a href="#欢迎使用坚果云Markdown" class="headerlink" title="欢迎使用坚果云Markdown"></a>欢迎使用坚果云Markdown</h3><h5 id="新增图片上传功能"><a href="#新增图片上传功能" class="headerlink" title="新增图片上传功能"></a>新增图片上传功能</h5><p>现在可以在文章中插入图片，将更丰富的内容分享给朋友了！</p><ul><li>您可以插入外链图片，或上传本地图片到文档中。</li><li>从本地上传的图片不支持外链引用，您可以通过坚果云分享链接来发布图文预览。</li><li>可上传的单张图片最大20M，支持PNG、JPG格式，使用时请留意账号流量或空间是否充足。</li><li>若有其他疑问，欢迎咨询官网在线客服。</li></ul><h3 id="Welcome-to-the-Nutstore-Markdown"><a href="#Welcome-to-the-Nutstore-Markdown" class="headerlink" title="Welcome to the Nutstore Markdown"></a>Welcome to the Nutstore Markdown</h3><h5 id="New-feature-Insert-pictures-in-your-articles-now"><a href="#New-feature-Insert-pictures-in-your-articles-now" class="headerlink" title="New feature! Insert pictures in your articles now!"></a>New feature! Insert pictures in your articles now!</h5><p>You can insert pictures from external links, or upload ones.</p><p>The pictures in the articles can not be used through external links. Please share your articles with the Nutstore share link.</p><p>The maximum size of the picture to upload is 20M. PNG and JPG are better. Be sure that your traffic and space are enough if you want to add a lot of pictures in your article.</p><p>Have any other questions, please contact our official customer service.</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电脑正确坐姿：健康才是是第一生产力</title>
      <link href="/chunyujin/768897a3.html"/>
      <url>/chunyujin/768897a3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>🧑🏻‍💻</p><h3 id="电脑正确坐姿-健康才是是第一生产力！！"><a href="#电脑正确坐姿-健康才是是第一生产力！！" class="headerlink" title="电脑正确坐姿_健康才是是第一生产力！！"></a>电脑正确坐姿_健康才是是第一生产力！！</h3><blockquote><p>以下所有都只是建议，要根据自己情况来就行</p></blockquote><h4 id="挺直腰背。腰背可以靠在靠背上，放松，让靠背承力"><a href="#挺直腰背。腰背可以靠在靠背上，放松，让靠背承力" class="headerlink" title="挺直腰背。腰背可以靠在靠背上，放松，让靠背承力"></a>挺直腰背。腰背可以靠在靠背上，放松，让靠背承力</h4><h4 id="放松肩部肌肉，不要耸肩，颈肩背不要前倾，不要用肩膀承力"><a href="#放松肩部肌肉，不要耸肩，颈肩背不要前倾，不要用肩膀承力" class="headerlink" title="放松肩部肌肉，不要耸肩，颈肩背不要前倾，不要用肩膀承力"></a>放松肩部肌肉，不要耸肩，颈肩背不要前倾，不要用肩膀承力</h4><p>避免含胸驼背！！</p><p>建议购买人体工学椅或升降桌，调整高度到自己舒服的位置</p><h4 id="调整键盘位置：，大臂放松，自然下垂于身体两侧，键盘不要离身体太远，使大臂与小臂呈大约90～120度-键盘太远会导致前倾-；键盘高度最好位于肚脐高度附近，小臂自然舒适放在桌面上，使不会耸肩，不会使肩膀、大臂前倾，还能使视线能自然看到双手和键盘【根据自身舒适情况调整"><a href="#调整键盘位置：，大臂放松，自然下垂于身体两侧，键盘不要离身体太远，使大臂与小臂呈大约90～120度-键盘太远会导致前倾-；键盘高度最好位于肚脐高度附近，小臂自然舒适放在桌面上，使不会耸肩，不会使肩膀、大臂前倾，还能使视线能自然看到双手和键盘【根据自身舒适情况调整" class="headerlink" title="调整键盘位置：，大臂放松，自然下垂于身体两侧，键盘不要离身体太远，使大臂与小臂呈大约90～120度(键盘太远会导致前倾)；键盘高度最好位于肚脐高度附近，小臂自然舒适放在桌面上，使不会耸肩，不会使肩膀、大臂前倾，还能使视线能自然看到双手和键盘【根据自身舒适情况调整"></a>调整键盘位置：，大臂放松，自然下垂于身体两侧，键盘不要离身体太远，使大臂与小臂呈大约90～120度(键盘太远会导致前倾)；键盘高度最好位于肚脐高度附近，小臂自然舒适放在桌面上，使不会耸肩，不会使肩膀、大臂前倾，还能使视线能自然看到双手和键盘【根据自身舒适情况调整</h4><h4 id="保证视线平视显示器而不低头；与显示器保持合适距离，一般建议在1-5～2倍显示器高度之间，这样才能使观感舒适（比如27寸显示器高度为35～37cm，建议眼睛距离显示器52-5～70cm之间以达到舒适的观感"><a href="#保证视线平视显示器而不低头；与显示器保持合适距离，一般建议在1-5～2倍显示器高度之间，这样才能使观感舒适（比如27寸显示器高度为35～37cm，建议眼睛距离显示器52-5～70cm之间以达到舒适的观感" class="headerlink" title="保证视线平视显示器而不低头；与显示器保持合适距离，一般建议在1.5～2倍显示器高度之间，这样才能使观感舒适（比如27寸显示器高度为35～37cm，建议眼睛距离显示器52.5～70cm之间以达到舒适的观感"></a>保证视线平视显示器而不低头；与显示器保持合适距离，一般建议在1.5～2倍显示器高度之间，这样才能使观感舒适（比如27寸显示器高度为35～37cm，建议眼睛距离显示器52.5～70cm之间以达到舒适的观感</h4><p>如果显示器高度不够，可以购买增高支架或者桌面置物架来增高</p><h4 id="达到观感、腰背、肩膀、手臂、腰部都能十分舒适的平衡点"><a href="#达到观感、腰背、肩膀、手臂、腰部都能十分舒适的平衡点" class="headerlink" title="达到观感、腰背、肩膀、手臂、腰部都能十分舒适的平衡点"></a>达到观感、腰背、肩膀、手臂、腰部都能十分舒适的平衡点</h4><h3 id="总之，核心就是舒服：肩膀舒服，脖子舒服，腰部舒服，眼睛舒服，使用键鼠方便。"><a href="#总之，核心就是舒服：肩膀舒服，脖子舒服，腰部舒服，眼睛舒服，使用键鼠方便。" class="headerlink" title="总之，核心就是舒服：肩膀舒服，脖子舒服，腰部舒服，眼睛舒服，使用键鼠方便。"></a>总之，核心就是舒服：肩膀舒服，脖子舒服，腰部舒服，眼睛舒服，使用键鼠方便。</h3><h5 id="购买建议："><a href="#购买建议：" class="headerlink" title="购买建议："></a>购买建议：</h5><blockquote><p>人体工学椅</p><p>显示器支架臂</p></blockquote><hr><h4 id="关于为什么要把键盘放在桌面上而不是键盘托盘上："><a href="#关于为什么要把键盘放在桌面上而不是键盘托盘上：" class="headerlink" title="关于为什么要把键盘放在桌面上而不是键盘托盘上："></a>关于为什么要把键盘放在桌面上而不是键盘托盘上：</h4><p>[知乎链接](既然大家都喜欢把键盘放在桌子上，为什么电脑桌还要设计托盘？ - 华而无为的回答 - 知乎 <a href="https://www.zhihu.com/answer/2808056675">https://www.zhihu.com/answer/2808056675</a>)</p><p>最近本人一直在被这个问题纠结。本人在学校的时候宿舍使用了人体工学椅，可以调节高度到健康的位置。但是家里的办公桌是大电脑桌，有一个键盘托盘，桌子高度75cm，电脑托盘高度是60cm，本人身高较高，当键盘放在桌子上的时候，键盘会略微高于手肘，但是将手肘放到桌子上的时候，颈肩肘都是可以得到放松的，这属于比较小的误差吧。当键盘放在托盘上的时候，会感觉不习惯，而且本人用的是很薄的键盘，打字要去够才能够到。</p><ol><li><p>起始电脑托盘的存在属于电脑桌这个外设跟不上电子产品发展，电脑托盘属于落后的产物，电脑桌的传统设计在国内也没有更改过。电脑桌的基本设计理念一直延续着它刚诞生的情况，现在很多新的人体工程电脑桌要不就是升降的，要不就是不带键盘托盘的。</p></li><li><p>另一个方面，看现在的键盘，比较传统的薄膜键盘和机械键盘的厚度基本上是和上世纪的键盘厚度一样， 放到键盘托盘上还是可以比较容易敲击的；现在生产的比较新的薄膜键盘，都是极薄设计的，这种设计就是在桌面上用的比较爽的。 </p></li><li><p>当你将键盘放在托盘上的时候，你的姿势会维持在一个固定的角度，就像是身体被卡在了那里，虽然姿势满足健康坐姿，但是久坐之后对于身体是很不好的。当键盘鼠标放在桌子上的时候，可以很轻松调整自己的坐姿和更改键盘的位置，避免久坐不动的现象。</p></li><li><p>将键盘放到托盘里，人会里显示器很远，看不清显示器</p></li><li><p>将键盘放在托盘里，人很难看到键盘(要低头)，而且手感会下降(玄学，但是尝试一下会发现放在托盘里敲键盘的姿势是缩着手从上而下敲击键盘，感受不到键盘的手感)，视觉上不舒服，心理上不舒服(这一点对强迫症比较重要～～～)</p></li></ol><p>对于正确的电脑桌前坐姿而言，只要能满足健康的坐姿，建议还是将键盘放在桌子上的。如果不满足条件，可以通过调整座位高度或桌子高度实现。</p><p>现在去淘宝搜索人体工学办公桌，也都是舍弃了电脑托盘的设计居多，很少再见到带托盘的了，除非是在家具城买的老式的办公桌子。</p>]]></content>
      
      
      <categories>
          
          <category> 健康 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 健康 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Linux</title>
      <link href="/chunyujin/7ef7519f.html"/>
      <url>/chunyujin/7ef7519f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Linux是一种开源的操作系统"><a href="#Linux是一种开源的操作系统" class="headerlink" title="Linux是一种开源的操作系统"></a>Linux是一种开源的操作系统</h3><h4 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h4><p>计算机本质是许多硬件组成的一个整体</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212180856455.png" alt="image-20221218085649201" style="zoom:50%;" /><blockquote><p>设备驱动直接控制计算机的硬件，用户通过应用软件使用计算机</p><p>应用程序会调用多种设备驱动，驱动程序提供给应用程序接口，供应用程序调用接口来使用硬件</p><p>一个计算机上会有很多硬件，所以会有很多设备驱动，每个硬件对应的设备驱动也不一样；每个应用程序都会与很多设备驱动对接，还会经常有多个应用占用同一个硬件的情况，如何进行资源管理和分配是对于设计者来说是一件很麻烦的事情。</p><p>于是就有了操作系统，操作系统是用来管理软件和硬件的对接，并将硬件驱动程序的接口抽象化，行成一套简单的接口给上层的应用程序使用。</p><p>另外，设备驱动是嵌入到操作系统里的，上面讲的只是为了体现这几者的关系。</p></blockquote><p>世界三大操作系统：Windows，macOS，Linux</p><p>Windows是世界上市场份额占比最大的终端操作系统；macOS是基于Unix内核的操作系统；Linux是开源的操作系统，被广泛用于服务器、嵌入式，并且智能手机上的android操作系统正是基于Linux开发的子系统。</p><h4 id="为什么是开源"><a href="#为什么是开源" class="headerlink" title="为什么是开源"></a>为什么是开源</h4><p>开源是Linus大神的非常强烈的信念，当时在接触MINIX的时候，被MINIX只允许用在教育上的使用很不满，于是他便开始编写自己的开源操作系统，并一直坚持开源理念。</p><p>开源，即<u>开放源代码</u></p><p>这意味着任何人都可以使用，但请记得注明来源。</p><blockquote><p><strong>开放源代码</strong>（英语：Open Source）是一种在电脑程序出品前和开发中提供其内部代码的做法。</p><p>开放源代码在互联网上获得广泛使用，参加者需要大量更新电脑源代码。开放源代码使得生产模块、通信管道、交互社群获得改善。随后，一个新著作权、软件授权条款、域名和消费者提供创建的，一个新词开源软件诞生。</p><p>开源模型概念包括同时间不同时程和方法来生产，相对而言，更加集中式的软体设计模型，例如典型的商业软体公司。一个开源软体开发的主要原则和惯例是易货贸易和合作的同侪生产，经由免费公开的最终产品、原始信息、蓝图和文件。这逐渐应用在其它领域，例如生物技术。———<em>来源<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81">维基百科</a></em></p></blockquote><p>代码开源，意味着更安全、更高效、更稳定</p><p>因为全部的使用者都在使用且知悉源代码，一旦出现问题会被用户群体立即指出，甚至用户群体可以立即给出各种解决方案！</p><p>代码闭源则只能由商业公司内部维护</p><h3 id="Linux的应用场景"><a href="#Linux的应用场景" class="headerlink" title="Linux的应用场景"></a>Linux的应用场景</h3><p>服务器后台</p><p>嵌入式、树莓派</p><p>智能家电</p><p>车载系统</p><p>物联网</p><p>手机、平板电脑</p><p>……</p><p>一切都是基于Linux的开源特性</p><p>还有就是Linux确实很好用</p><p>这为无数人提供了便利！</p><h3 id="生动的补充"><a href="#生动的补充" class="headerlink" title="生动的补充"></a>生动的补充</h3><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212180928015.png" alt="image-20221218092828996"></p><h3 id="Linux下一切皆文件！！！"><a href="#Linux下一切皆文件！！！" class="headerlink" title="Linux下一切皆文件！！！"></a>Linux下一切皆文件！！！</h3>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/chunyujin/0.html"/>
      <url>/chunyujin/0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="安装MinGW"><a href="#安装MinGW" class="headerlink" title="安装MinGW"></a>安装MinGW</h4><p>相比在 Linux 平台上安装 GCC 编译环境，在 Windows 平台上安装 MinGW 是比较简单的，只需经历以下几个过程。</p><ol><li><p>打开 <a href="https://osdn.net/projects/mingw/">MinGW 官网</a>（点击即可进入官网），下载 MinGW 安装包。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215731250.png" alt="image-20221215215731250" style="zoom:67%;" /></li><li><p>下载完成后，会得到一个名为 mingw-get-setup.exe 的安装包，双击打开它，可以看到如下的对话框：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215752602.png" alt="image-20221215215752602" style="zoom:67%;" /></li><li><p>直接点击“Install”，进入下面的对话框，自定义安装位置，然后选择continue</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215808186.png" alt="image-20221215215808186" style="zoom:67%;" /></li><li><p>进入安装 MinGW 配置器的界面。安装完成之后，得到一个名为 “MinGW Installer Manager” 的软件，借助它，可以随时根据需要修改 GCC 编译器的配置。点击“continue”,会自动弹出配置界面，如下所示：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215823311.png" alt="image-20221215215823311" style="zoom:67%;" /></li><li><p>为使 GCC 同时支持编译 C 语言和 C++，需勾选图中标注的 2 项。我们知道，GCC 还支持其它编程语言，读者可借助此配置器，随时实际需要安装自己需要的编译环境。勾选完成后，在菜单栏中选择<code>Installation -&gt; Apply Changes</code>，弹出如下对话框：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215851706.png" alt="image-20221215215851706" style="zoom:67%;" /></li></ol><p>选择“Apply”。然后耐心等待，直至安装成功，即可关闭此界面。注意，整个安装过程中可能会提示某些组件下载失败，但没关系，后续需要时，可以通过 MinGw Installer（图 4 所示）安装界面中的 “All Packages”选项中，手动选择指定的安装包进行安装。</p><h4 id="添加到环境变量"><a href="#添加到环境变量" class="headerlink" title="添加到环境变量"></a>添加到环境变量</h4><p>打开<code>我的电脑</code>-&gt;<code>属性</code>-&gt;<code>高级系统设置</code>-&gt;<code>“高级”中的环境变量</code></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213001922.png" alt="image-20221215213001922" style="zoom:67%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213141396.png" alt="image-20221215213141396" style="zoom: 67%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213248912.png" alt="image-20221215213248912" style="zoom:67%;" /><p>在上方的“用户变量”的Path变量中添加MinGW的bin的位置</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213407962.png" alt="image-20221215213407962" style="zoom:67%;" /><blockquote><p>也可以在下方的“系统变量”的Path中添加MinGW的bin的位置</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213829809.png" alt="image-20221215213829809" style="zoom:67%;" /><p>环境变量、系统变量、用户变量的关系：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215214853021.png" alt="image-20221215214853021" style="zoom: 50%;" /><p>环境变量只是一个总称，代表了系统变量和用户变量，因此我们说环境变量都是指的系统变量和用户变量。系统变量就是系统级别的变量，用户需要使用系统变量。如果系统变量被修改了，而任何系统用户都在用系统变量，因此每个系统用户都将受到影响。用户变量运行在系统变量之上的，每个用户拥有不同的用户变量，不同用户的用户变量之间是并列的，也是互不干扰的。</p></blockquote><h4 id="检验配置完成"><a href="#检验配置完成" class="headerlink" title="检验配置完成"></a>检验配置完成</h4><p>打开命令行提示符，输入<code>gcc -v</code>或者<code>g++ -v</code></p><p>出现下面则说明成功</p><p><img>(<a href="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-12-15%20220238.png">https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-12-15%20220238.png</a>)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MinGw配置(Windows电脑)</title>
      <link href="/chunyujin/1ee5d0ce.html"/>
      <url>/chunyujin/1ee5d0ce.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="安装MinGW"><a href="#安装MinGW" class="headerlink" title="安装MinGW"></a>安装MinGW</h4><p>相比在 Linux 平台上安装 GCC 编译环境，在 Windows 平台上安装 MinGW 是比较简单的，只需经历以下几个过程。</p><ol><li><p>打开 <a href="https://osdn.net/projects/mingw/">MinGW 官网</a>（点击即可进入官网），下载 MinGW 安装包。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215731250.png" alt="image-20221215215731250" style="zoom:67%;" /></li><li><p>下载完成后，会得到一个名为 mingw-get-setup.exe 的安装包，双击打开它，可以看到如下的对话框：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215752602.png" alt="image-20221215215752602" style="zoom:67%;" /></li><li><p>直接点击“Install”，进入下面的对话框，自定义安装位置，然后选择continue</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215808186.png" alt="image-20221215215808186" style="zoom:67%;" /></li><li><p>进入安装 MinGW 配置器的界面。安装完成之后，得到一个名为 “MinGW Installer Manager” 的软件，借助它，可以随时根据需要修改 GCC 编译器的配置。点击“continue”,会自动弹出配置界面，如下所示：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215823311.png" alt="image-20221215215823311" style="zoom:67%;" /></li><li><p>为使 GCC 同时支持编译 C 语言和 C++，需勾选图中标注的 2 项。我们知道，GCC 还支持其它编程语言，读者可借助此配置器，随时实际需要安装自己需要的编译环境。勾选完成后，在菜单栏中选择<code>Installation -&gt; Apply Changes</code>，弹出如下对话框：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215851706.png" alt="image-20221215215851706" style="zoom:67%;" /></li></ol><p>选择“Apply”。然后耐心等待，直至安装成功，即可关闭此界面。注意，整个安装过程中可能会提示某些组件下载失败，但没关系，后续需要时，可以通过 MinGw Installer（图 4 所示）安装界面中的 “All Packages”选项中，手动选择指定的安装包进行安装。</p><h4 id="添加到环境变量"><a href="#添加到环境变量" class="headerlink" title="添加到环境变量"></a>添加到环境变量</h4><p>打开<code>我的电脑</code>-&gt;<code>属性</code>-&gt;<code>高级系统设置</code>-&gt;<code>“高级”中的环境变量</code></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213001922.png" alt="image-20221215213001922" style="zoom:67%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213141396.png" alt="image-20221215213141396" style="zoom: 67%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213248912.png" alt="image-20221215213248912" style="zoom:67%;" /><p>在上方的“用户变量”的Path变量中添加MinGW的bin的位置</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213407962.png" alt="image-20221215213407962" style="zoom:67%;" /><blockquote><p>也可以在下方的“系统变量”的Path中添加MinGW的bin的位置</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213829809.png" alt="image-20221215213829809" style="zoom:67%;" /><p>环境变量、系统变量、用户变量的关系：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215214853021.png" alt="image-20221215214853021" style="zoom: 50%;" /><p>环境变量只是一个总称，代表了系统变量和用户变量，因此我们说环境变量都是指的系统变量和用户变量。系统变量就是系统级别的变量，用户需要使用系统变量。如果系统变量被修改了，而任何系统用户都在用系统变量，因此每个系统用户都将受到影响。用户变量运行在系统变量之上的，每个用户拥有不同的用户变量，不同用户的用户变量之间是并列的，也是互不干扰的。</p></blockquote><h4 id="检验配置完成"><a href="#检验配置完成" class="headerlink" title="检验配置完成"></a>检验配置完成</h4><p>打开命令行提示符，输入<code>gcc -v</code>或者<code>g++ -v</code></p><p>出现下面则说明成功</p><p><img>(<a href="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-12-15%20220238.png">https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-12-15%20220238.png</a>)</p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> MinGw </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MinGw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NotePad++配置</title>
      <link href="/chunyujin/55caa4ef.html"/>
      <url>/chunyujin/55caa4ef.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>安装MinGW并添加到环境变量：</p><p><a href="http://chunyujin.top/chunyujin/1ee5d0ce.html">点此查看步骤(建议右键选择在新窗口中打开)</a></p><p>创建一个cpp文件并写一段测试代码</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215200029209.png" alt="image-20221215200029209"></p><p>点击顶部菜单栏的“运行”或者直接按F5</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215200205821.png" alt="image-20221215200205821"></p><p>输入一下宏定义命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd /k pushd &quot;$(CURRENT_DIRECTORY)&quot; &amp;&amp; g++ -o &quot;$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp;&amp; &quot;$(NAME_PART)&quot;.exe &amp; PAUSE &amp; EXIT</span><br></pre></td></tr></table></figure><p>点击运行即可</p><p>建议选择“保存”按键，将宏定义保存到快捷键，比如<code>ctrl + alt + n</code>(跟vscode的coderunner插件一样的快捷键)，下次运行直接快捷键即可</p><blockquote><p><code>cmd /k</code>：<strong>打开</strong> cmd 控制台，运行完程序让其停留而不自动关闭。</p><p><code>pushd &quot;$(CURRENT_DIRECTORY)&quot;</code>：<strong>将工作路径更换到源文件所在的路径</strong>，例如’pushd E:\kkk’相当于 cmd 中先<code>e:</code>再<code>cd kkk</code>，这条命令在源代码要调用同目录文件而只写了相对路径时尤为重要。因为 Notepad++ 的默认工作路径是它自己的安装路径。</p><p><code>g++ -o &quot;$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot;</code>：调用环境变量中的编译器 g++.exe 来将源代码<strong>编译</strong>成同名 exe 文件并输出到相同路径。</p><p><code>&quot;$(NAME_PART)&quot;.exe</code>：<strong>运行</strong>源代码编译出的可执行文件。</p><p><code>PAUSE</code>：暂停，提示<strong>“按任意键继续”</strong>，配合下一条命令实现“按任意键关闭”的效果，两者都没有的话程序运行完就会秒关。</p><p><code>EXIT</code>：<strong>关闭</strong> cmd 控制台，没有的话按任意键会退到 cmd 命令台，等待输入下一条命令。</p><ul><li><p>$(CURRENT_DIRECTORY)代表文件所在目录的路径。</p></li><li><p>$(NAME_PART)表示该文件无后缀部分的文件名。</p></li><li><p>$(FULL_CURRENT_PATH)代表当前完整的文件路径。</p></li><li><p>双引号（半角）：用于防止目录或文件名中含空格的情况。</p></li><li><p>“&amp;&amp;”和“&amp;”：前者表示上一条命令正常执行完再执行下一条命令，非正常则不执行下一条；后者无顾虑。例如一分为六后的后两条子命令，表示不管源代码编译、运行是否成功，都会出现“按任意键继续”字样，并且按任意键后关闭 cmd 控制台。</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NotePad++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VsCode_C++环境搭建(Mac m1芯片版本)</title>
      <link href="/chunyujin/1580f89a.html"/>
      <url>/chunyujin/1580f89a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.cnblogs.com/BYGAO/p/15135609.html">文章转载自百叶的自留地(2021年8月)，非商业用途，侵删</a></p><p>文末放了我的三个json文件配置，可以参考。</p><h2 id="1-下载VS-code"><a href="#1-下载VS-code" class="headerlink" title="1.下载VS code"></a>1.下载VS code</h2><p>VS code已针对m1 芯片进行了适配，去官网下载VS code Apple Silicon版并安装。</p><h2 id="2-确保clang已安装"><a href="#2-确保clang已安装" class="headerlink" title="2.确保clang已安装"></a>2.确保clang已安装</h2><p>在终端里输入<code>clang --version</code>查看是否已安装，若未安装，输入<code>xcode-select --install</code>读完条款输入agree安装即可。</p><h2 id="3-下载扩展"><a href="#3-下载扩展" class="headerlink" title="3.下载扩展"></a>3.下载扩展</h2><p>一共有三个扩展需要下载。<br>1.C&#x2F;C++<br>2.C++ Intellisense<br>3.CodeLLDB<br>4.Chinese(中文插件，可选)</p><h2 id="4-新建cpp文件"><a href="#4-新建cpp文件" class="headerlink" title="4.新建cpp文件"></a>4.新建cpp文件</h2><p>这里直接采用<a href="https://code.visualstudio.com/docs/cpp/config-clang-mac">微软官方文档</a>里的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; msg &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;from&quot;</span>, <span class="string">&quot;VS Code&quot;</span>, <span class="string">&quot;and the C++ extension!&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> string&amp; word : msg)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; word &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，在文件第10行输入<code>msg.</code>应该是能看到VS code跳出<code>assign</code>之类的提示的。</p><h2 id="5-配置文件"><a href="#5-配置文件" class="headerlink" title="5.配置文件"></a>5.配置文件</h2><h3 id="1-配置tasks-json文件"><a href="#1-配置tasks-json文件" class="headerlink" title="1.配置tasks.json文件"></a>1.配置tasks.json文件</h3><p>首先点击<code>终端</code>—<code>配置默认生成任务</code>—<code>C/C++ clang++</code>，会生成一个tasks.json文件，这是默认生成的，需要修改其中的<code>args</code>选项,添加一个<code>&quot;-std=c++17&quot;</code>，修改后为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;args&quot;</span>: [</span><br><span class="line"><span class="string">&quot;-g&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;file&#125;</span>&quot;</span>,</span><br><span class="line"><span class="string">&quot;-std=c++17&quot;</span>,</span><br><span class="line"><span class="string">&quot;-o&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;fileDirname&#125;</span>/<span class="variable">$&#123;fileBasenameNoExtension&#125;</span>&quot;</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>配置完后，会发现VS code提示语法错误，不要急，接下来就修正它。</p><h3 id="2-配置c-cpp-properties-json文件"><a href="#2-配置c-cpp-properties-json文件" class="headerlink" title="2.配置c_cpp_properties.json文件"></a>2.配置c_cpp_properties.json文件</h3><p>使用组合键<code>shift+command+p</code>（mac下shift就是<code>fn</code>键上面那个啦），调出<code>C/C++:编辑配置（json）</code>，会自动生成一个<code>c_cpp_properties.json</code>文件。</p><p>将<code>&quot;compilerPath&quot;: &quot;/usr/bin/clang&quot;,</code>修改为<code>&quot;compilerPath&quot;: &quot;/usr/bin/clang++&quot;,</code><br>将<code>&quot;&quot;cppStandard&quot;: &quot;c++98&quot;,</code>修改为<code>&quot;cppStandard&quot;: &quot;c++17&quot;,</code></p><p>其实只是将编译器修改为clang++，cpp标准修改为C++ 17.</p><h3 id="3-编译生成文件"><a href="#3-编译生成文件" class="headerlink" title="3.编译生成文件"></a>3.编译生成文件</h3><p>这么配置完后，其实VS code还是会报两个语法错误，不过这不要紧，这是因为还没更新的缘故。<br>点击<code>终端</code>—<code>运行生成任务</code>，运行完后会生成一个二进制文件，语法报错也没了，表示我们编译成功了。<br>如果想测试的话，新建一个终端，使用<code>./你的二进制文件名</code>，即可看到输出结果。</p><h3 id="4-配置launch-json文件"><a href="#4-配置launch-json文件" class="headerlink" title="4.配置launch.json文件"></a>4.配置launch.json文件</h3><p>点击<code>运行</code>—<code>添加配置</code>—<code>C++(GDB/LLDB)</code>—<code>clang++</code>，会生成一个<code>launch.json</code>文件。<br>将<code>&quot;type&quot;: &quot;cppdbg&quot;,</code>修改为<code>&quot;type&quot;: &quot;lldb&quot;,</code><br>至此，所有文件就配置完了。</p><h3 id="5-调试"><a href="#5-调试" class="headerlink" title="5.调试"></a>5.调试</h3><p>在文件的第10行放一个断点，点击<code>运行</code>—<code>启动调试</code>，就可以看到各种变量了。</p><h2 id="我的文件配置"><a href="#我的文件配置" class="headerlink" title="我的文件配置"></a>我的文件配置</h2><p>以下是我的三个json文件配置代码。<br><code>tasks.json</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line"><span class="string">&quot;tasks&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppbuild&quot;</span>,</span><br><span class="line"><span class="string">&quot;label&quot;</span>: <span class="string">&quot;C/C++: clang++ 生成活动文件&quot;</span>,</span><br><span class="line"><span class="string">&quot;command&quot;</span>: <span class="string">&quot;/usr/bin/clang++&quot;</span>,</span><br><span class="line"><span class="string">&quot;args&quot;</span>: [</span><br><span class="line"><span class="string">&quot;-g&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;file&#125;</span>&quot;</span>,</span><br><span class="line"><span class="string">&quot;-std=c++17&quot;</span>,</span><br><span class="line"><span class="string">&quot;-o&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;fileDirname&#125;</span>/<span class="variable">$&#123;fileBasenameNoExtension&#125;</span>&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;options&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;<span class="variable">$&#123;fileDirname&#125;</span>&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;problemMatcher&quot;</span>: [</span><br><span class="line"><span class="string">&quot;<span class="variable">$gcc</span>&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;group&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line"><span class="string">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;detail&quot;</span>: <span class="string">&quot;编译器: /usr/bin/clang++&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>c_cpp_properties.json</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Mac&quot;</span>,</span><br><span class="line">            <span class="string">&quot;includePath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;<span class="variable">$&#123;workspaceFolder&#125;</span>/**&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;defines&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;macFrameworkPath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;compilerPath&quot;</span>: <span class="string">&quot;/usr/bin/clang++&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cStandard&quot;</span>: <span class="string">&quot;c17&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cppStandard&quot;</span>: <span class="string">&quot;c++17&quot;</span>,</span><br><span class="line">            <span class="string">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;macos-clang-arm64&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>launch.json</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;clang++ - 生成和调试活动文件&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;lldb&quot;</span>,</span><br><span class="line">            <span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="string">&quot;program&quot;</span>: <span class="string">&quot;<span class="subst">$&#123;fileDirname&#125;</span>/<span class="subst">$&#123;fileBasenameNoExtension&#125;</span>&quot;</span>,</span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;<span class="subst">$&#123;fileDirname&#125;</span>&quot;</span>,</span><br><span class="line">            <span class="string">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;MIMode&quot;</span>: <span class="string">&quot;lldb&quot;</span>,</span><br><span class="line">            <span class="string">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;C/C++: clang++ 生成活动文件&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VsCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Calibre实现Kindle带封面传书</title>
      <link href="/chunyujin/35444f4.html"/>
      <url>/chunyujin/35444f4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="Kindle如何带封面传书"><a href="#Kindle如何带封面传书" class="headerlink" title="Kindle如何带封面传书"></a>Kindle如何带封面传书</h4><p>软件：Calibre</p><p>Kinlde传书以往分为两种方式，一种是邮件传输，另一种是数据线连接电脑传输</p><h5 id="邮件传书"><a href="#邮件传书" class="headerlink" title="邮件传书"></a>邮件传书</h5><blockquote><p>每部Kindle都有自己的邮箱，通过附件的方式给Kindle邮箱发送邮件就可以传书</p><p>但是Kinlde在2022年8月份就宣布停止mobi格式书籍的邮箱传输，并只支持epub</p><p>Kindle机器本身只支持azw格式，Kindle可以对mobi进行转换，成为azw格式</p><p>通过邮件传书，无论是mobi还是epub格式都是先通过线上转换，变成azw格式之后发送到kindle去的，而mobi格式通过邮箱传输可以保留原来的封面，epub格式则会失去封面，用邮箱传书的话要带封面只能用mobi格式</p><p>亚马逊以后将停止kindle邮箱传书，只能选择数据线传书</p></blockquote><h5 id="数据线传书"><a href="#数据线传书" class="headerlink" title="数据线传书"></a>数据线传书</h5><blockquote><p>mobi的书籍通过数据线传输之后会丢失封面，epub则因为Kindle硬件无法进行格式转换，无法读取。</p><p>网络上获取的资源一般都是mobi格式以及epub格式的</p></blockquote><p>以下是通过数据线带封面传书的步骤</p><p><strong>如果书籍带有封面，并且不需要更换，跳过2、3步骤，如果书籍没有封面或者封面不官方和美观，执行2、3步骤</strong></p><ol><li>将需要传输的书籍放到calibre里面</li><li><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202208231507207.png" alt="截屏2022-08-23 15.06.53" style="zoom:50%;" /></li><li><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202208231508238.png" alt="截屏2022-08-23 15.08.01" style="zoom:50%;" /></li><li><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202208231509350.png" alt="截屏2022-08-23 15.09.53" style="zoom:50%;" /></li><li>推出Kindle，但是不要关闭calibre</li><li>保持Kindle的wifi打开的状态，等待亚马逊删除封面</li><li>再次连接Kindle到电脑，等到calibre读取到Kindle，此时calibre会恢复刚刚导入到Kindle书籍的封面</li><li>大功告成，可以推出Kindle以及关闭calibre</li></ol><h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h5><blockquote><ol><li>关于“步骤6”中“亚马逊删除封面“，因为Kindle图书的正规获取渠道是亚马逊图书商城，对于图书的封面，亚马逊是从网络上获取的，网络获取分为邮件和亚马逊商城，通过邮件推送来的mobi格式的图书，自带封面信息，因此Kindle可以通过网络（邮件）下载到图书封面，从亚马逊图书商城里获得的图书，自然也会下载到图书封面信息。</li><li>通过数据线传输书籍，书籍信息中的封面信息无法作为元数据保存为图书信息，还会占用掉封片信息，因此需要等亚马逊删除掉封面之后再由calibre恢复（写入）元数据信息（书籍封面）</li><li>calibre的原理：</li></ol><blockquote><p>更改书籍的信息（元数据），从名称作者到封面</p><p>都可以自定义更改</p><p>并且还可以从官方根据书籍名称获取书籍元数据，并下载保存在图书中</p></blockquote></blockquote><h5 id="自己制作封面："><a href="#自己制作封面：" class="headerlink" title="自己制作封面："></a>自己制作封面：</h5><blockquote><blockquote><p>如果无法获取到在线的封面，可以自己制作封面，一般来说书籍中的第一页就是书的封面，我们可以在calibre双击打开书籍，然后截取封面。进入编辑原数据，将截图设定为封面</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212230933831.png" alt="截屏2022-12-23 09.31.25"  /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212230934612.png" alt="截屏2022-12-23 09.31.48"  /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212230934010.png" alt="截屏2022-12-23 09.31.59"  /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212230934909.png" alt="截屏2022-12-23 09.32.58"  /><p>完成之后不要忘了点左下角的确定</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212230934041.png" alt="截屏2022-12-23 09.33.07" style="zoom:50%;" /></blockquote><p>信息来源</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202208231555992.png" alt="截屏2022-08-23 15.33.18" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Kindle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kindle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_历史命令</title>
      <link href="/chunyujin/6694219c.html"/>
      <url>/chunyujin/6694219c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Linux会保存用户的历史指令"><a href="#Linux会保存用户的历史指令" class="headerlink" title="Linux会保存用户的历史指令"></a>Linux会保存用户的历史指令</h3><p>历史指令保存在用户目录下的.bash_history文件(历史记录文件)中，并且每条指令都用时间戳的形式记录了执行时刻</p><p>当用户通过shell进入Linux系统时，Linux系统会先将.bash_history中的保存的之前的历史指令读取到历史记录缓存区中，在用户正常退出shell之前，执行的所有指令也会先记录在缓存区中，当用户正常退出shell(exit或者control+d)时，shell进程会自动将历史记录缓存区中的所有历史记录写入到.bash_history中</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209114140665.png" alt="image-20221209114140665"></p><h4 id="查看历史缓冲区"><a href="#查看历史缓冲区" class="headerlink" title="查看历史缓冲区"></a>查看历史缓冲区</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history #查看历史记录缓存区中保存的历史指令</span><br></pre></td></tr></table></figure><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20221209112431.png" alt="QQ截图20221209112431"  /><p>从最开始到现在为止</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20221209112449.png"></p></blockquote><h5 id="通过键盘上下键快捷查看历史缓冲区"><a href="#通过键盘上下键快捷查看历史缓冲区" class="headerlink" title="通过键盘上下键快捷查看历史缓冲区"></a>通过键盘上下键快捷查看历史缓冲区</h5><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E5%BD%95%E5%B1%8F20221209120917.gif" alt="QQ录屏20221209120917"></p><h5 id="定量查看历史缓冲区的历史指令"><a href="#定量查看历史缓冲区的历史指令" class="headerlink" title="定量查看历史缓冲区的历史指令"></a>定量查看历史缓冲区的历史指令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history &lt;数字&gt; #查看缓冲区中最近的n条历史指令</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209172316597.png" alt="image-20221209172316597"></p><h4 id="手动写入-bash-history"><a href="#手动写入-bash-history" class="headerlink" title="手动写入.bash_history"></a>手动写入.bash_history</h4><p>如果执行了几条指令，比如执行两次<code>ls</code>和<code>ll</code>，查看一下历史缓存区</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209115827151.png" alt="image-20221209115827151"></p><p>再查看.bash_history，发现没有记录在里面，因为历史记录保存在了历史缓存区，当退出shell的时候才会自动从缓存区写入.bash_history</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209115907240.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history -w #手动将历史缓存写入用户目录下的.bash_history</span><br></pre></td></tr></table></figure><p>正常情况下，只有在 Shell 正常退出时，才会将缓冲区内容保存到.bash_history。如果想主动保存缓冲区的历史记录，执行 <code>-w</code> 选项即可</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209120133565.png" alt="image-20221209120133565"></p><h4 id="清除历史缓冲区"><a href="#清除历史缓冲区" class="headerlink" title="清除历史缓冲区"></a>清除历史缓冲区</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history -c #清除历史缓冲区</span><br></pre></td></tr></table></figure><p>历史缓冲区写入.bash_history其实就是用新内容覆盖掉原有内容，所以清除历史缓冲区就是清除本次登录用户时的所有操作的记录，不会删除之前的历史记录</p><h4 id="重复执行缓冲区历史指令"><a href="#重复执行缓冲区历史指令" class="headerlink" title="重复执行缓冲区历史指令"></a>重复执行缓冲区历史指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!&lt;数字&gt; #重复执行缓冲区中的第n条历史指令</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209173229978.png" alt="image-20221209173229978"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!-&lt;数字&gt; #重复执行缓冲区中倒数第n行历史指令</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209174342766.png" alt="image-20221209174342766"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!! #重复执行上一条命令</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209174410518.png" alt="image-20221209174410518"></p><h4 id="搜索历史命令"><a href="#搜索历史命令" class="headerlink" title="搜索历史命令"></a>搜索历史命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + r# 输入残缺指令，搜索对应完整历史指令</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212121356384.gif" alt="Dec-12-2022 13-56-09"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_map&amp;pair类</title>
      <link href="/chunyujin/899a3eaf.html"/>
      <url>/chunyujin/899a3eaf.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h4><blockquote><p>STL中的容器分为序列式容器(vector、list、array、deque、forward_list)和关联式容器(map、multimap、set、multiset)</p><p>序列式容器的特点是保存元素时只保存元素本身，不会对存储的元素进行自动排序，元素排列的顺序取决于存储它们的顺序</p><p>关联式容器在存储元素的时候还会存储另一个跟元素相关的值，称为“键”，元素和它的“键”作为一个整体“键值对”存储在关联式容器中，关联式容器自动根据“键”的大小将元素作升序排序；另外，可以根据元素的“键”找到对应的元素。</p></blockquote><h4 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h4><blockquote><p>pair是C++STL标准库中的一个类模版，定义在头文件 <code>&lt;utility&gt;</code> 中</p><p>是专门用来表示“键值对”的类型</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_auto关键字</title>
      <link href="/chunyujin/b4979a36.html"/>
      <url>/chunyujin/b4979a36.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://c.biancheng.net/view/3718.html">auto关键字(类型推导)</a></p><p>当STL的模板类型实例化的时候，如果实例化的类型是模版类型，那么使用迭代器是会报错的</p><p>比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; i;<span class="comment">//vecter的实例化类型是int</span></span><br><span class="line">vector&lt;T&gt; v;<span class="comment">//vector的实例化类型是模版类型T</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator I = i.<span class="built_in">begin</span>();<span class="comment">//正确</span></span><br><span class="line">  veector&lt;T&gt;::iterator V = v.<span class="built_in">begin</span>();<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为在模板参数T实例化之前，模板类型为int的vector明确了自己的类型就是int，故迭代器可以根据类型执行相应的关于空间的操作。而模版类型为T的vector尚不知道T究竟是什么类型，所以迭代器无法通过类型来执行操作</p></blockquote><p>auto关键字是在程序编译时自动推导出变量的类型，可以很自然地和泛型编程结合而不用去提前考虑变量的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;T&gt; v;<span class="comment">//vector的实例化类型是模版类型T</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> V = v.<span class="built_in">begin</span>();<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>auto会在最后编译的时候，会判断变量的类型。在编译时，一旦调用函数，T类型就已经实例化，并且v是vector，vector.begin()函数返回的就是vector的迭代器，因此编译器会推导出此时V的类型</p><p>&#x3D;&#x3D;因此auto可以将泛型编程(模板)跟STL很好地结合&#x3D;&#x3D;</p></blockquote><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212041341428.png" alt="iShot_2022-12-04_13.40.14"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_所有函数都可直接调用</title>
      <link href="/chunyujin/5656723d.html"/>
      <url>/chunyujin/5656723d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>无论函数是否有返回值，都可以直接调用</p><p>并不是说有返回值的函数在调用的时候必须用一个变量去承接返回值</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_vector常用用法</title>
      <link href="/chunyujin/170bba21.html"/>
      <url>/chunyujin/170bba21.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h6 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a><a href="http://c.biancheng.net/view/6749.html">常用用法</a></h6><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212031057955.png" alt="iShot_2022-12-03_10.57.40"></p><h6 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a><a href="http://c.biancheng.net/view/6846.html">删除元素</a></h6><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212041438569.png" alt="iShot_2022-12-04_14.38.37"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_迭代器&amp;find()函数</title>
      <link href="/chunyujin/874d4093.html"/>
      <url>/chunyujin/874d4093.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器(iterator)"></a><a href="http://c.biancheng.net/view/338.html">迭代器(iterator)</a></h3><h4 id="什么是迭代器"><a href="#什么是迭代器" class="headerlink" title="什么是迭代器"></a>什么是迭代器</h4><p>迭代器与容器的关系，相当于指针与数组的关系</p><p>因为容器是封装起来的，不知道内部是如何实现的，所以通过在内存中的地址的原理访问和遍历容器，一般来说是不实际的</p><p>要访问容器(顺序容器、关联容器)中的元素，就需要通过迭代器进行；就如同访问数组中的元素需要通过指针进行一样</p><p>用迭代器访问元素的操作也和用指针访问数组的操作很像</p><p>迭代器按照定义方式分成以下四种</p><blockquote><ol><li><p>正向迭代器，定义方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容器类名::iterator 迭代器名;</span><br></pre></td></tr></table></figure></li><li><p>常量正向迭代器，定义方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容器类名::const_iterator 迭代器名;</span><br></pre></td></tr></table></figure></li><li><p>反向迭代器，定义方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容器类名::reverse_iterator 迭代器名;</span><br></pre></td></tr></table></figure></li><li><p>常量反向迭代器，定义方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容器类名::const_reverse_iterator 迭代器名;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="迭代器用法示例"><a href="#迭代器用法示例" class="headerlink" title="迭代器用法示例"></a>迭代器用法示例</h4><p>通过迭代器可以读取它指向的元素，<code>*迭代器名</code>就表示迭代器指向的元素。通过非常量迭代器还能修改其指向的元素。</p><p>迭代器都可以进行<code>++</code>操作。反向迭代器和正向迭代器的区别在于：</p><ul><li>对正向迭代器进行<code>++</code>操作时，迭代器会指向容器中的后一个元素；</li><li>而对反向迭代器进行<code>++</code>操作时，迭代器会指向容器中的前一个元素。</li></ul><p>下面的程序演示了如何通过迭代器&#x3D;&#x3D;遍历一个 vector 容器&#x3D;&#x3D;中的所有元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;  <span class="comment">//v是存放int类型变量的可变长数组，开始时没有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n&lt;<span class="number">5</span>; ++n)</span><br><span class="line">        v.<span class="built_in">push_back</span>(n);  <span class="comment">//push_back成员函数在vector容器尾部添加一个元素</span></span><br><span class="line">  </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator i;  <span class="comment">//定义正向迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i) <span class="comment">//用迭代器遍历容器</span></span><br><span class="line">    &#123;  </span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//*i 就是迭代器i指向的元素</span></span><br><span class="line">        *i *= <span class="number">2</span>;  <span class="comment">//每个元素变为原来的2倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//用反向迭代器遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::reverse_iterator j = v.<span class="built_in">rbegin</span>(); j != v.<span class="built_in">rend</span>(); ++j)</span><br><span class="line">        cout &lt;&lt; *j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>程序的输出结果是：<br>0 1 2 3 4<br>8 6 4 2 0</p><p>第 6 行，vector 容器有多个构造函数，如果用无参构造函数初始化，则容器一开始是空的。</p><p>第 10 行，begin 成员函数返回指向容器中第一个元素的迭代器。++i 使得 i 指向容器中的下一个元素。end 成员函数返回的不是指向最后一个元素的迭代器，而是指向最后一个元素后面的位置的迭代器，因此循环的终止条件是<code>i != v.end()</code>。</p><p>第 16 行定义了反向迭代器用以遍历容器。反向迭代器进行<code>++</code>操作后，会指向容器中的上一个元素。rbegin 成员函数返回指向容器中最后一个元素的迭代器，rend 成员函数返回指向容器中第一个元素前面的位置的迭代器，因此本循环实际上是从后往前遍历整个数组。</p><p>如果迭代器指向了容器中最后一个元素的后面或第一个元素的前面，再通过该迭代器访问元素，就有可能导致程序崩溃，这和访问 NULL 或未初始化的指针指向的地方类似。</p><p>第 10 行和第 16 行，写<code>++i</code>、<code>++j</code>相比于写<code>i++</code>、<code>j++</code>，程序的执行速度更快。</p><p>回顾<code>++</code>被重载成前置和后置运算符的例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CDemo CDemo::<span class="keyword">operator</span>++ ()</span><br><span class="line">&#123;  <span class="comment">//前置++</span></span><br><span class="line">    ++n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">CDemo CDemo::<span class="keyword">operator</span> ++(<span class="type">int</span> k)</span><br><span class="line">&#123;  <span class="comment">//后置++</span></span><br><span class="line">    <span class="function">CDemo <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;  <span class="comment">//记录修改前的对象</span></span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span> tmp;  <span class="comment">//返回修改前的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后置<code>++</code>要多生成一个局部对象 tmp，因此执行速度比前置的慢。同理，迭代器是一个对象，<a href="http://c.biancheng.net/stl/">STL</a> 在重载迭代器的<code>++</code>运算符时，后置形式也比前置形式慢。在次数很多的循环中，<code>++i</code>和<code>i++</code>可能就会造成运行时间上可观的差别了。因此，本教程在前面特别提到，对循环控制变量i，要养成写<code>++i</code>、不写<code>i++</code>的习惯。</p></blockquote><p>注意，容器适配器 stack、queue 和 priority_queue 没有迭代器。容器适配器有一些成员函数，可以用来对元素进行访问。</p><h4 id="迭代器的功能分类"><a href="#迭代器的功能分类" class="headerlink" title="迭代器的功能分类"></a>迭代器的功能分类</h4><p>不同容器的迭代器，其功能强弱有所不同。容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。例如，排序算法需要通过随机访问迭代器来访问容器中的元素，因此有的容器就不支持排序算法。</p><p>常用的迭代器按功能强弱分为输入、输出、正向、双向、随机访问五种，这里只介绍常用的三种。</p><blockquote><ol><li><p>正向迭代器。假设 p 是一个正向迭代器，则 p 支持以下操作：++p，p++，*p。此外，两个正向迭代器可以互相赋值，还可以用<code>==</code>和<code>!=</code>运算符进行比较。</p></li><li><p>双向迭代器。双向迭代器具有正向迭代器的全部功能。除此之外，若 p 是一个双向迭代器，则<code>--p</code>和<code>p--</code>都是有定义的。<code>--p</code>使得 p 朝和<code>++p</code>相反的方向移动。</p></li><li><p>随机访问迭代器。随机访问迭代器具有双向迭代器的全部功能。若 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p></li></ol><ul><li>p+&#x3D;i：使得 p 往后移动 i 个元素。</li><li>p-&#x3D;i：使得 p 往前移动 i 个元素。</li><li>p+i：返回 p 后面第 i 个元素的迭代器。</li><li>p-i：返回 p 前面第 i 个元素的迭代器。</li><li>p[i]：返回 p 后面第 i 个元素的引用。</li></ul><p>此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 运算符进行比较。<code>p1&lt;p2</code>的含义是：p1 经过若干次（至少一次）<code>++</code>操作后，就会等于 p2。其他比较方式的含义与此类似。</p><p>&#x3D;&#x3D;对于两个随机访问迭代器 p1、p2，表达式<code>p2-p1</code>也是有定义的，其返回值是 p2 所指向元素和 p1 所指向元素的序号(下标)之差（也可以说是 p2 和 p1 之间的元素个数减一）。&#x3D;&#x3D;</p><blockquote><p>例如在vector中返回某个元素的下标</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span><span class="comment">//std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span><span class="comment">//std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; temp = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = temp.<span class="built_in">begin</span>();</span><br><span class="line">it += <span class="number">2</span>;<span class="comment">//p+=i</span></span><br><span class="line"><span class="comment">//此时it对应的元素下标为</span></span><br><span class="line"><span class="type">int</span> index = it - temp.<span class="built_in">begin</span>();<span class="comment">//p2-p1</span></span><br><span class="line">cout &lt;&lt; index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出2</p></blockquote></blockquote><p>不同容器的迭代器的功能:</p><table><thead><tr><th>容器</th><th>迭代器功能</th></tr></thead><tbody><tr><td>vector</td><td>随机访问</td></tr><tr><td>deque</td><td>随机访问</td></tr><tr><td>list</td><td>双向</td></tr><tr><td>set &#x2F; multiset</td><td>双向</td></tr><tr><td>map &#x2F; multimap</td><td>双向</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr><tr><td>priority_queue</td><td>不支持迭代器</td></tr></tbody></table><blockquote><p>vector 的迭代器是随机迭代器，因此&#x3D;&#x3D;遍历 vector 容器&#x3D;&#x3D;有以下几种做法。下面的程序中，每个循环演示了一种做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//v被初始化成有100个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; v.<span class="built_in">size</span>() ; ++i) <span class="comment">//size返回元素个数</span></span><br><span class="line">        cout &lt;&lt; v[i]; <span class="comment">//像普通数组一样使用vector容器</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator i;</span><br><span class="line">    <span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span> (); ++i) <span class="comment">//用 != 比较两个迭代器</span></span><br><span class="line">        cout &lt;&lt; * i;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span> ();++i) <span class="comment">//用 &lt; 比较两个迭代器</span></span><br><span class="line">        cout &lt;&lt; * i;</span><br><span class="line">  </span><br><span class="line">    i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(i &lt; v.<span class="built_in">end</span>()) &#123; <span class="comment">//间隔一个输出</span></span><br><span class="line">        cout &lt;&lt; * i;</span><br><span class="line">        i += <span class="number">2</span>; <span class="comment">// 随机访问迭代器支持 &quot;+= 整数&quot;  的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>list 容器的迭代器是双向迭代器。</p><p>假设 v 和 i 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure><p>则以下代码是合法的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=v.<span class="built_in">begin</span>(); i!=v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">  cout &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p>以下代码则不合法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=v.<span class="built_in">begin</span>(); i&lt;v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">  cout &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p>因为双向迭代器不支持用 “&lt;” 进行比较。以下代码也不合法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">  cout &lt;&lt; v[i];</span><br></pre></td></tr></table></figure><p>因为 list 不支持随机访问迭代器的容器，也不支持用下标随机访问其元素。</p></blockquote><p><strong>&#x3D;&#x3D;在 <a href="http://c.biancheng.net/cplus/">C++</a> 中，数组也是容器。数组的迭代器就是指针，而且是随机访问迭代器。例如，对于数组 int a[10]，int * 类型的指针就是其迭代器。则 a、a+1、a+2 都是 a 的迭代器。&#x3D;&#x3D;</strong></p><h4 id="迭代器的辅助函数-好用"><a href="#迭代器的辅助函数-好用" class="headerlink" title="迭代器的辅助函数(好用)"></a>迭代器的辅助函数(好用)</h4><p>STL 中有用于操作迭代器的三个函数模板</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">advance</span>(p, n) </span><br></pre></td></tr></table></figure><p>使迭代器 p 向前或向后移动 n 个元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">distance</span>(p, q)</span><br></pre></td></tr></table></figure><p>计算两个迭代器之间的距离，即迭代器 p 经过多少次 + + 操作后和迭代器 q 相等。如果调用时 p 已经指向 q 的后面，则这个函数会陷入死循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">iter_swap</span>(p, q)</span><br></pre></td></tr></table></figure><p>用于交换两个迭代器 p、q 指向的值</p></blockquote><p>要使用上述模板，需要包含头文件 algorithm。下面的程序演示了这三个函数模板的 用法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">//要使用操作迭代器的函数模板，需要包含此文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    list &lt;<span class="type">int</span>&gt; <span class="built_in">lst</span>(a, a+<span class="number">5</span>);</span><br><span class="line">    list &lt;<span class="type">int</span>&gt;::iterator p = lst.<span class="built_in">begin</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">advance</span>(p, <span class="number">2</span>);  <span class="comment">//p向后移动两个元素，指向3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1)&quot;</span> &lt;&lt; *p &lt;&lt; endl;  <span class="comment">//输出 1)3</span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">advance</span>(p, <span class="number">-1</span>);  <span class="comment">//p向前移动一个元素，指向2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2)&quot;</span> &lt;&lt; *p &lt;&lt; endl;  <span class="comment">//输出 2)2</span></span><br><span class="line">  </span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator q = lst.<span class="built_in">end</span>();</span><br><span class="line">  </span><br><span class="line">    q--;  <span class="comment">//q 指向 5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3)&quot;</span> &lt;&lt; <span class="built_in">distance</span>(p, q) &lt;&lt; endl;  <span class="comment">//输出 3)3</span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">iter_swap</span>(p, q); <span class="comment">//交换 2 和 5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;4)&quot;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (p = lst.<span class="built_in">begin</span>(); p != lst.<span class="built_in">end</span>(); ++p)</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是：<br>\1) 3<br>\2) 2<br>\3) 3<br>\4) 1 5 3 4 2</p><h4 id="返回-随机访问迭代器中某个元素的-位置-序号-下标"><a href="#返回-随机访问迭代器中某个元素的-位置-序号-下标" class="headerlink" title="返回 随机访问迭代器中某个元素的 位置(序号)(下标)"></a>返回 随机访问迭代器中某个元素的 位置(序号)(下标)</h4><p>方法1⃣️用循环，从第1个元素开始找，直到找到对应的元素，返回下标</p><p>方法2⃣️利用<a href="http://c.biancheng.net/view/7489.html">find函数</a>，找到对应元素的迭代器，利用<a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%88%86%E7%B1%BB">“两个随机访问迭代器相减，返回值是两个迭代器对应的元素的序号(下标)之差”</a>，用该元素的迭代器减去容器首元素迭代器，返回值就是该元素的下标</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span><span class="comment">//std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span><span class="comment">//std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span><span class="comment">//std::find()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; temp = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>(), <span class="number">5</span>);<span class="comment">//value为要查找的值，该函数返回一个指向对应元素的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时it对应的元素下标为</span></span><br><span class="line"><span class="type">int</span> index = it - temp.<span class="built_in">begin</span>();</span><br><span class="line">cout &lt;&lt; index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>find函数是algorithm的库函数</p><p>find() 函数本质上是一个模板函数，用于在指定范围内查找和目标元素值相等的第一个元素。</p><p>如下为 find() 函数的语法格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InputIterator <span class="title">find</span> <span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，first 和 last 为输入迭代器，[first, last) 用于指定该函数的查找范围；value 为要查找的目标元素。</p><blockquote><p>正因为 first 和 last 的类型为输入迭代器，因此该函数适用于所有的序列式容器。</p></blockquote><p>该函数会<strong>返回</strong>一个<u>输入迭代器</u>，当 find() 函数查找成功时，其指向的是在 [first, last) 区域内查找到的第一个目标元素；如果查找失败，则该迭代器的指向和 last 相同。</p><blockquote><p>例如查找vector的元素时，first是vector.begin()，end是vector.end()</p><blockquote><p> vector.end()是指向容器的最后一个元素之后的&#x2F;0</p></blockquote></blockquote><p>值得一提的是，find() 函数的底层实现，其实就是用<code>==</code>运算符将 val 和 [first, last) 区域内的元素逐个进行比对。这也就意味着，[first, last) 区域内的元素必须支持<code>==</code>运算符。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::find</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//find() 函数作用于普通数组</span></span><br><span class="line"><span class="type">char</span> stl[] = <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line"><span class="comment">//调用 find() 查找第一个字符 &#x27;c&#x27;</span></span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">find</span>(stl, stl + <span class="built_in">strlen</span>(stl), <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="comment">//判断是否查找成功</span></span><br><span class="line"><span class="keyword">if</span> (p != stl + <span class="built_in">strlen</span>(stl))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//find() 函数作用于容器</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">it = <span class="built_in">find</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myvector.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;查找成功：&quot;</span> &lt;&lt; *it;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;查找失败&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.biancheng.net/stl/</span><br><span class="line">查找成功：30</span><br></pre></td></tr></table></figure><p>可以看到，find() 函数除了可以作用于序列式容器，还可以作用于普通数组(因为在C++中普通数组也是容器)</p><blockquote><p>补充：find() 函数的底层实现，C++ 标准库中给出了参数代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (first != last)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*first == val) <span class="keyword">return</span> first;</span><br><span class="line">++first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="迭代器的好处"><a href="#迭代器的好处" class="headerlink" title="迭代器的好处"></a>迭代器的好处</h4><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212031252529.png" alt="截屏2022-12-03 12.51.56"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_模板</title>
      <link href="/chunyujin/a0e18b05.html"/>
      <url>/chunyujin/a0e18b05.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h6 id="x3D-x3D-模板参数分为三类-x3D-x3D"><a href="#x3D-x3D-模板参数分为三类-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;模板参数分为三类&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>模板参数分为三类</strong>&#x3D;&#x3D;</h6><ol><li>类型参数</li></ol><blockquote><p>通过 关键字 typename 或者 class 引入(两者基本上是等价的)</p></blockquote><ol start="2"><li>非类型参数</li></ol><blockquote><p>模板参数不局限于类型，类型的值也可以作为模板参数，通过 关键字 值的类型 引入</p><p>目前C++只支持 <u>整形</u> &#x2F; <u>枚举类型</u> &#x2F; <u>指针类型</u>(可以是原始数据类型的指针、派生数据类型的指针、对象的指针、对象的成员的指针) &#x2F; <u>引用类型</u>(可以是原始数据类型的引用、派生数据类型的引用、对象的引用)</p></blockquote><ol start="3"><li>模板型模板参数</li></ol><h6 id="x3D-x3D-模板参数支持缺省-x3D-x3D"><a href="#x3D-x3D-模板参数支持缺省-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;模板参数支持缺省&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>模板参数支持缺省</strong>&#x3D;&#x3D;</h6><blockquote><p>但是要注意的是，缺省参数的使用不要忘了按照规范形式，比如在类或函数声明时加了缺省值，在实现时就不要加了</p><p>(缺省值在声明时添加，在实现时就不添加了)</p><p>还有，缺省要从右往左缺省</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212031014022.png" alt="截屏2022-12-03 10.14.22"></p></blockquote><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221202104949903.png" alt="image-20221202104949903"></p><p><a href="https://blog.csdn.net/zhizhengguan/article/details/115869685">https://blog.csdn.net/zhizhengguan/article/details/115869685</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_模板不支持分离编译</title>
      <link href="/chunyujin/ad941677.html"/>
      <url>/chunyujin/ad941677.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="C-模板不支持分离编译！！"><a href="#C-模板不支持分离编译！！" class="headerlink" title="C++模板不支持分离编译！！"></a>C++模板不支持分离编译！！</h3><p>一般情况下，自定义变量和函数的时候，在头文件中声明，在源文件中实现，在链接过程中会将分离开的声明和实现进行链接起来</p><p>但是&#x3D;&#x3D;<strong>模板变量和函数是不支持分离编译，也就是说模板的定义(声明+实现)必须在同一个文件里</strong>&#x3D;&#x3D;(一般建议在声明模板的地方定义模板，也就是头文件中)</p><p>模板是不支持声明和定义放到两个文件中的</p><blockquote><p>这就是为什么当模版是分离编译的时候，在main文件中包含模版的头文件的时候，编译时会报错：函数为定义。因为无法将模版的声明和实现进行链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有些语句后面不用加分号</title>
      <link href="/chunyujin/6e7957f9.html"/>
      <url>/chunyujin/6e7957f9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>if(){}</p><p>while(){}</p><p>for(){}</p><p>int xx(){}</p><p>if语句、while循环、for循环、函数定义是，{}是语句的一部分，后面不用跟分号</p><p>函数的只声明不定义的时候需要语句最后要加分号</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212021945977.png" alt="截屏2022-12-02 19.42.03"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>size_t</title>
      <link href="/chunyujin/8883767d.html"/>
      <url>/chunyujin/8883767d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>size_t在各种头文件中都有定义</p><blockquote><p>&lt;stddef.h&gt;, &lt;stdio.h&gt;, &lt;stdlib.h&gt;, &lt;string.h&gt;, &lt;time.h&gt;, &lt;wchar.h&gt;</p></blockquote><p>size_t类型表示C中&#x3D;&#x3D;任何对象能达到的最大长度&#x3D;&#x3D;，它是无符号整数数据类型</p><p>size_t并不是一个具体的大小的数据，而是要看系统，系统的对象长度最大为多少，size_t的大小就是多少。所以size_t类型方便在于系统之间移植使用。</p><p>比如在32位系统上，size_t类型就是 unsgned int 类型的typedf（即别名），也就是32位无符号整数；在64位系统上，size_t类型被定义为unsigned long long的typedef。</p><p>通常在用做下标或者长度变量时建议使用size_t，因为它始终是无符号的数。</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JB全家桶快捷键&amp;操作</title>
      <link href="/chunyujin/1d504d03.html"/>
      <url>/chunyujin/1d504d03.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h4><p>⌃  + R</p><p>ctrl + R</p><h4 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h4><p>⌘ + ⌥  + L</p><p>win + alt + L　</p><h4 id="批量更改变量、函数名称"><a href="#批量更改变量、函数名称" class="headerlink" title="批量更改变量、函数名称"></a>批量更改变量、函数名称</h4><p>光标<strong>移动到</strong>变量、函数名称上</p><p>⇧  + F6</p><p>Shift + F6</p><h4 id="CLion-vscode风格代码高亮插件"><a href="#CLion-vscode风格代码高亮插件" class="headerlink" title="CLion_vscode风格代码高亮插件"></a>CLion_vscode风格代码高亮插件</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210272216897.png" alt="截屏2022-10-27 22.16.17" style="zoom:50%;" /><h4 id="CLion-vscode风格代码样式-用于格式化样式"><a href="#CLion-vscode风格代码样式-用于格式化样式" class="headerlink" title="CLion_vscode风格代码样式(用于格式化样式)"></a>CLion_vscode风格代码样式(用于格式化样式)</h4><p>Microsoft风格（vscode</p><p>舒服😌</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210272214080.png" alt="截屏2022-10-27 22.10.18" style="zoom:50%;" /><p>设置解引用符号*的位置</p><p>第一种舒服😌</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210301112448.png" alt="截屏2022-10-30 11.10.27" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210301112444.png" alt="截屏2022-10-30 11.10.50" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210301112437.png" alt="截屏2022-10-30 11.11.03" style="zoom:50%;" /><h4 id="设置背景"><a href="#设置背景" class="headerlink" title="设置背景"></a>设置背景</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210272217806.png" alt="截屏2022-10-27 22.16.48" style="zoom:50%;" /><h4 id="如果在CLion外部更改了项目中的文件的属性"><a href="#如果在CLion外部更改了项目中的文件的属性" class="headerlink" title="如果在CLion外部更改了项目中的文件的属性"></a>如果在CLion外部更改了项目中的文件的属性</h4><p><strong>比如我在CLion外部将原本的main.c改名成为了GuessingGame.c</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031163458930.png" alt="image-20221031163458930" style="zoom: 80%;" /><p>clion会报错</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031163348563.png" alt="image-20221031163348563" style="zoom: 80%;" /><p>发现CmakeLists.txt文件包含的文件是aaa main.c而不是aaa GuessingGame.c，说明并没有将GuessingGame.c包含在项目里</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031163553021.png" alt="image-20221031163553021" style="zoom:80%;" /><p>将第6行括号里的main.c改成GuesingGame.c即可</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031164432573.png" alt="image-20221031164432573" style="zoom:80%;" /><blockquote><p>注意，如果不是替换掉main.c，而只是添加GuessingGame.c的话，CLion中其实main.c是不存在的，那么就找不到main.c，当然也会报错</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031165612625.png" alt="image-20221031165612535" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031165619957.png" alt="image-20221031165619808" style="zoom:80%;" /></blockquote><p>然后会发现提示CMake项目需要重新加载，重新加载即可</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E5%9B%BE%E7%89%8720221031164540.jpg" alt="QQ图片20221031164540" style="zoom:80%;" /><p><strong>同样，如果在CLion外部，将文件添加到项目中，在CLion中也会报错</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031164230637.png" alt="image-20221031164230449" style="zoom:67%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031164247033.png" alt="image-20221031164247033" style="zoom:67%;" /><p>在CmakeLists.txt文件中添加上这几个文件就可以</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031165652840.png" alt="image-20221031165652840" style="zoom:80%;" /><blockquote><p>&#x3D;&#x3D;<strong>注意在CmakeLists.txt中添加文件的写法格式，上图就是正确的格式</strong>&#x3D;&#x3D;</p></blockquote><p>如果是在CLion内部新建头文件或者源文件，在添加的时候，勾选上添加到目标即可</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211102142435.png" alt="截屏2022-11-10 21.40.22" style="zoom:50%;" /><p>忘记勾选也没事，在CmakeLists.txt文件中添加上就可以</p><h4 id="可以直接将没有配置环境的文件夹直接在CLion中打开"><a href="#可以直接将没有配置环境的文件夹直接在CLion中打开" class="headerlink" title="可以直接将没有配置环境的文件夹直接在CLion中打开"></a>可以直接将没有配置环境的文件夹直接在CLion中打开</h4><p>众所周知，CLion会对每一个项目配置环境，前提是这是CLion的项目</p><p>如果一个文件夹不是CLion的项目，我们在CLion中打开，CLion会提示是否配置环境</p><p>(CLion项目中的环境配置文件↓)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-10-31%20170055.png" alt="屏幕截图 2022-10-31 170055" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E5%9B%BE%E7%89%8720221031170119.jpg" alt="QQ图片20221031170119" style="zoom:80%;" /><p>如果一个不是CLion项目的文件夹（也就是说没有配置环境），在CLion中打开</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031170502825.png" alt="image-20221031170502825" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031170513665.png" alt="image-20221031170513665" style="zoom:80%;" /><p>会提示是否创建CMake项目</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031170644553.png" alt="image-20221031170644553" style="zoom:80%;" /><p>选择“创建”即可</p><p>这样CLion就会在文件夹中生成环境文件了，文件夹就变成了一个CLion项目</p><h4 id="Windows下CLion运行结果中文输出是乱码"><a href="#Windows下CLion运行结果中文输出是乱码" class="headerlink" title="Windows下CLion运行结果中文输出是乱码"></a>Windows下CLion运行结果中文输出是乱码</h4><ol><li>那就不输出中文呗</li><li>或者不选择”运行”，选择”调试”(不打断点)</li></ol><h4 id="彩虹括号-插件"><a href="#彩虹括号-插件" class="headerlink" title="彩虹括号 插件"></a>彩虹括号 插件</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211120940116.png" alt="截屏2022-11-12 09.40.19" style="zoom:50%;" /><p>会让编译器代码高亮变慢，所以已经卸载……</p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JetBrains </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数原则&amp;交互&amp;耦合</title>
      <link href="/chunyujin/8d125c1d.html"/>
      <url>/chunyujin/8d125c1d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212010740120.png" alt="截屏2022-12-01 07.39.50"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>条件编译</title>
      <link href="/chunyujin/68bc2fec.html"/>
      <url>/chunyujin/68bc2fec.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://baike.baidu.com/item/%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/7692959">条件编译-百度百科</a></p><p><a href="http://c.biancheng.net/view/289.html">条件编译- C语言中文网</a></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211301126439.png" alt="iShot_2022-11-30_11.19.02"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>库文件&amp;静态库&amp;动态库</title>
      <link href="/chunyujin/bba9c8e0.html"/>
      <url>/chunyujin/bba9c8e0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://baike.baidu.com/item/%E5%BA%93%E6%96%87%E4%BB%B6/2550595">库文件-百度百科</a></p><p><a href="https://blog.csdn.net/junxuezheng/article/details/100557176">库、动态库和静态库（.dll，.so，.lib，.a）知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/71372182">浅谈静态库和动态库_知乎</a></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211292044221.png" alt="截屏2022-11-29 20.43.42"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211292010960.png" alt="iShot_2022-11-29_20.10.12"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言为何不支持重载</title>
      <link href="/chunyujin/fcea8946.html"/>
      <url>/chunyujin/fcea8946.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://zhuanlan.zhihu.com/p/580630581">C语言为什么不支持函数重载?c++又是如何支持的?</a></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211291556357.png" alt="iShot_2022-11-29_15.55.49"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BinaryTree_C++</title>
      <link href="/chunyujin/d183517b.html"/>
      <url>/chunyujin/d183517b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据结构-二叉树（C-实现"><a href="#数据结构-二叉树（C-实现" class="headerlink" title="数据结构_二叉树（C++实现"></a>数据结构_二叉树（C++实现</h1><blockquote><p>1前言：此类笔记仅用于个人复习，内容主要在于记录和体现个人理解，详细还请结合bite课件、录播、板书和代码。</p></blockquote><p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><ol><li><strong>本篇中的是一般二叉树(包括线索树、表达式树)是通过<u>链式结构</u>实现的</strong>，关于顺序结构的实现请见C语言版(顺便有堆的相关内容)</li><li><strong>本篇中哈夫曼树的结点存储是用的是<u>顺序结构</u></strong></li><li>模版不支持分离编译，因此跟以往自定义变量和函数时，声明在头文件、实现在源文件不同，定义(声明+实现)都是在头文件中【详见code日记】</li></ol></blockquote><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>采用<strong>链式存储</strong></p><h3 id="二叉树类的声明："><a href="#二叉树类的声明：" class="headerlink" title="二叉树类的声明："></a>二叉树类的声明：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模版不支持分离编译！！！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的链式存储</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span><span class="comment">//在buildExpressionTree中用到，用来进行string转等价int</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">nullPoint</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//binaryTree类的向前说明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binaryTree</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span><span class="comment">//二叉树结点类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">binaryTree</span>&lt;elemType&gt;;<span class="comment">//结点类将二叉树类视为友元函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">elemType data;</span><br><span class="line">Node&lt;elemType&gt; *left;<span class="comment">//指针域</span></span><br><span class="line">Node&lt;elemType&gt; *right;</span><br><span class="line"><span class="type">int</span> leftFlag; <span class="comment">//用于标识孩子指针是否为线索，0则说明left指向该结点的左孩子，1则说明left指向该结点的直接前驱</span></span><br><span class="line"><span class="type">int</span> rightFlag; <span class="comment">//用于标识孩子指针是否为线索，0则说明right指向该结点的右孩子，1则说明right指向该结点的直接后继</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Node</span>()</span><br><span class="line">&#123;</span><br><span class="line">left = <span class="literal">NULL</span>;</span><br><span class="line">right = <span class="literal">NULL</span>;</span><br><span class="line">leftFlag = <span class="number">0</span>;</span><br><span class="line">rightFlag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Node</span>(<span class="type">const</span> elemType&amp; data, Node&lt;elemType&gt; *left = <span class="literal">NULL</span>, Node&lt;elemType&gt; *right = <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;data = data;</span><br><span class="line"><span class="keyword">this</span>-&gt;left = left;</span><br><span class="line"><span class="keyword">this</span>-&gt;right = right;</span><br><span class="line">leftFlag = <span class="number">0</span>;</span><br><span class="line">rightFlag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binaryTree</span><span class="comment">//二叉树类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node&lt;elemType&gt; *root;<span class="comment">//链式二叉树的根结点指针</span></span><br><span class="line">elemType stopFlag;<span class="comment">//结束标志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">binaryTree</span>()</span><br><span class="line">&#123;</span><br><span class="line">root = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">creatTree</span><span class="params">(<span class="type">const</span> elemType&amp; flag)</span></span>;<span class="comment">//创建一棵二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> root == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;elemType&gt; *<span class="title">getRoot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Size</span><span class="params">(Node&lt;elemType&gt; *t)</span></span>;<span class="comment">//递归求二叉树的结点的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Size</span><span class="params">()</span></span>;<span class="comment">//求二叉树的结点个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Height</span><span class="params">(Node&lt;elemType&gt; *t)</span></span>;<span class="comment">//递归求二叉树的高度/深度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Height</span><span class="params">()</span></span>;<span class="comment">//求二叉树的高度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delTree</span><span class="params">(Node&lt;elemType&gt; *t)</span></span>;<span class="comment">//递归删除二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delTree</span><span class="params">()</span></span>;<span class="comment">//删除二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(Node&lt;elemType&gt; *t)</span></span>;<span class="comment">//按前序遍历输出以t为根的二叉树的结点的数据值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;<span class="comment">//前序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(Node&lt;elemType&gt; *t)</span></span>;<span class="comment">//按中序遍历输出以t为根的二叉树的结点的数据值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;<span class="comment">//中序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(Node&lt;elemType&gt; *t)</span></span>;<span class="comment">//按后序遍历输出以t为根的二叉树的结点的数据值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">()</span></span>;<span class="comment">//后序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>;<span class="comment">//层序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;elemType&gt; *<span class="title">threadMin</span><span class="params">()</span></span>;<span class="comment">//建立中序遍历线索树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadMidInOrder</span><span class="params">(Node&lt;elemType&gt; *first)</span></span>;<span class="comment">//借助 在原二叉树基础上 建立的中序遍历线索树，对于原二叉树实现非递归的中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadMidPreOrder</span><span class="params">()</span></span>;<span class="comment">//借助 在原二叉树基础上 建立的中序遍历线索树，对于原二叉树实现非递归的前序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;elemType&gt; *<span class="title">buildTree</span><span class="params">(elemType pre[], <span class="type">int</span> pl, <span class="type">int</span> pr,</span></span></span><br><span class="line"><span class="params"><span class="function">elemType mid[], <span class="type">int</span> ml, <span class="type">int</span> mr)</span></span>;<span class="comment">//已知一颗二叉树的前序遍历和中序遍历结果 建立这颗二叉树</span></span><br><span class="line"><span class="comment">//数组pre、mid分别是前序遍历、中序遍历的结果;pl、pr、ml、mr分别是前序、中序遍历结果数组的边界</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">init</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>;<span class="comment">//先将string类型的表达式，将元素由char变成string并存在vector中</span></span><br><span class="line"><span class="comment">// 这样才可以计算多位数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">judge</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>;<span class="comment">//判断操作符优先度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">stringToInt</span><span class="params">(string s)</span></span>;<span class="comment">//;string转成等价的int</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildExpressionTree</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>;<span class="comment">//将当前树建立为表达式树</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculateExpressionTree</span><span class="params">()</span></span>;<span class="comment">//计算当前这颗表达式树</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="二叉树类的成员变量介绍"><a href="#二叉树类的成员变量介绍" class="headerlink" title="二叉树类的成员变量介绍"></a>二叉树类的成员变量介绍</h4><p>二叉树结点类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//binaryTree类的向前说明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binaryTree</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span><span class="comment">//二叉树结点类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">binaryTree</span>&lt;elemType&gt;;<span class="comment">//结点类将二叉树类视为友元函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">elemType data;</span><br><span class="line">Node&lt;elemType&gt; *left;<span class="comment">//指针域</span></span><br><span class="line">Node&lt;elemType&gt; *right;</span><br><span class="line"><span class="type">int</span> leftFlag; <span class="comment">//用于标识孩子指针是否为线索，0则说明left指向该结点的左孩子，1则说明left指向该结点的直接前驱</span></span><br><span class="line"><span class="type">int</span> rightFlag; <span class="comment">//用于标识孩子指针是否为线索，0则说明right指向该结点的右孩子，1则说明right指向该结点的直接后继</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Node</span>()</span><br><span class="line">&#123;</span><br><span class="line">left = <span class="literal">NULL</span>;</span><br><span class="line">right = <span class="literal">NULL</span>;</span><br><span class="line">leftFlag = <span class="number">0</span>;</span><br><span class="line">rightFlag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Node</span>(<span class="type">const</span> elemType&amp; data, Node&lt;elemType&gt; *left = <span class="literal">NULL</span>, Node&lt;elemType&gt; *right = <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;data = data;</span><br><span class="line"><span class="keyword">this</span>-&gt;left = left;</span><br><span class="line"><span class="keyword">this</span>-&gt;right = right;</span><br><span class="line">leftFlag = <span class="number">0</span>;</span><br><span class="line">rightFlag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>data为结点的数据域</p><p>left和right是指针域</p><p>leftFlag&#x2F;rightFlag用于标识 孩子指针是否为线索，0则说明孩子指针保存的是指向该结点的孩子的地址，1则说明孩子指针保存的是该结点的直接前驱&#x2F;后继的地址</p><blockquote><p>详见<a href="#%E4%BA%8C%E5%8F%89%E7%BA%BF%E7%B4%A2%E6%A0%91">二叉线索树</a></p></blockquote></blockquote><p>二叉树类的成员变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binaryTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node&lt;elemType&gt; *root;<span class="comment">//链式二叉树的根结点指针</span></span><br><span class="line">elemType stopFlag;<span class="comment">//结束标志</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>stopFlag：在创建二叉树的时候，需要不断获取二叉树的结点，这个变量是用来 终止获取结点 的结束标志</p></blockquote><h3 id="二叉树类的实现："><a href="#二叉树类的实现：" class="headerlink" title="二叉树类的实现："></a>二叉树类的实现：</h3><h4 id="二叉树的构建"><a href="#二叉树的构建" class="headerlink" title="二叉树的构建"></a>二叉树的构建</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模版不支持分离编译！！！</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">creatTree</span>(<span class="type">const</span> elemType&amp; flag)<span class="comment">//创建一棵二叉树</span></span><br><span class="line"><span class="comment">//借助队列来创建一颗二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">queue&lt;Node&lt;elemType&gt; *&gt; que;</span><br><span class="line">elemType e, el, er;<span class="comment">//根结点、左孩子、右孩子的data</span></span><br><span class="line">Node&lt;elemType&gt; *p, *pl, *pr;<span class="comment">//根结点、左孩子、后孩子的地址</span></span><br><span class="line"></span><br><span class="line">stopFlag = flag;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Please input the root:&quot;</span>;<span class="comment">//输入根结点的值</span></span><br><span class="line">cin &gt;&gt; e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (e == flag)<span class="comment">//判断是否为结束标志</span></span><br><span class="line">&#123;</span><br><span class="line">root = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;elemType&gt;(e);<span class="comment">//new一个Node结点，作为根结点</span></span><br><span class="line">root = p;</span><br><span class="line"></span><br><span class="line">que.<span class="built_in">push</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">p = que.<span class="built_in">front</span>();</span><br><span class="line">que.<span class="built_in">pop</span>();<span class="comment">//获得队首元素并出队</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Please input the left_child and the right_child of &quot;</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; using &quot;</span> &lt;&lt; stopFlag</span><br><span class="line"> &lt;&lt; <span class="string">&quot; as no child&quot;</span>;</span><br><span class="line">cin &gt;&gt; el &gt;&gt; er;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (el != stopFlag)<span class="comment">//如果根结点有左孩子</span></span><br><span class="line">&#123;</span><br><span class="line">pl = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;elemType&gt;(el);</span><br><span class="line">p-&gt;left = pl;</span><br><span class="line">que.<span class="built_in">push</span>(pl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (er != stopFlag)<span class="comment">//如果根结点有右孩子</span></span><br><span class="line">&#123;</span><br><span class="line">pr = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;elemType&gt;(er);</span><br><span class="line">p-&gt;right = pr;</span><br><span class="line">que.<span class="built_in">push</span>(pr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>借助队列构建二叉树</p><p>首先创建树的根结点入队列</p><p>只要队列不为空，循环</p><p>每次获取队首元素p并出队</p><p>若p有孩子，则创建p的左&#x2F;右孩子结点，让p的指针域指向它们，并将左右孩子入队列。</p><p>否则不执行操作，进入下一次循环</p><p>队空，结束 <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211171311731.png" alt="截屏2022-11-17 13.11.05" style="zoom:50%;" /></p></blockquote><h4 id="递归求以二叉树的结点的个数"><a href="#递归求以二叉树的结点的个数" class="headerlink" title="递归求以二叉树的结点的个数"></a>递归求以二叉树的结点的个数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> binaryTree&lt;elemType&gt;::<span class="built_in">Size</span>(Node&lt;elemType&gt; *t)<span class="comment">//递归求二叉树的结点的个数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> t == <span class="literal">NULL</span> ? <span class="number">0</span> : <span class="number">1</span> + <span class="built_in">Size</span>(t-&gt;left) + <span class="built_in">Size</span>(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> binaryTree&lt;elemType&gt;::<span class="built_in">Size</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Size</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以结合图思考</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221014105348435.png" alt="image-20221014105348435" style="zoom: 80%;" /></blockquote><h4 id="递归求二叉树的高度-x2F-深度"><a href="#递归求二叉树的高度-x2F-深度" class="headerlink" title="递归求二叉树的高度&#x2F;深度"></a>递归求二叉树的高度&#x2F;深度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> binaryTree&lt;elemType&gt;::<span class="built_in">Height</span>(Node&lt;elemType&gt; *t)<span class="comment">//递归求二叉树的高度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Height</span>(t-&gt;left) &gt; <span class="built_in">Height</span>(t-&gt;right) ? <span class="built_in">Height</span>(t-&gt;left) + <span class="number">1</span> : <span class="built_in">Height</span>(t-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> binaryTree&lt;elemType&gt;::<span class="built_in">Height</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Height</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>节点的层次：从根开始定义，根为第一层，根的子结点所在的为第二层，以此类推</p><blockquote><p>如下图，A的层次是1，C的是2，H的是4</p></blockquote><p>树的高度&#x2F;深度：根中结点的最大层次，下图中树的高度就是4</p><p>思路：递归</p><p>结点为空则返回高度为0，否则返回当前结点为根结点的树的高度：</p><p>左右子树比较高度，更高的高度+1，就是当前结点为根结点的树的高度</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E5%9B%BE%E7%89%8720221117235938.jpg" alt="QQ图片20221117235938" style="zoom: 23%;" /></blockquote><h4 id="递归删除二叉树"><a href="#递归删除二叉树" class="headerlink" title="递归删除二叉树"></a>递归删除二叉树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">delTree</span>(Node&lt;elemType&gt; *t)<span class="comment">//递归删除二叉树</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">delTree</span>(t-&gt;left);</span><br><span class="line"><span class="built_in">delTree</span>(t-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> t;</span><br><span class="line"><span class="comment">/*这里t不用指向NULL，1是因为它是形参，指向也没用，2是下面的root需要指向形参是因为root是类的成员函数，后续还会调用它</span></span><br><span class="line"><span class="comment">避免root指向被释放的空间，造成非法访问，成为野指针*/</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">delTree</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">delTree</span>(root);</span><br><span class="line">root = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的遍历："><a href="#二叉树的遍历：" class="headerlink" title="二叉树的遍历："></a>二叉树的遍历：</h4><h5 id="二叉树的递归遍历："><a href="#二叉树的递归遍历：" class="headerlink" title="二叉树的递归遍历："></a>二叉树的递归遍历：</h5><h6 id="前序遍历-递归"><a href="#前序遍历-递归" class="headerlink" title="前序遍历(递归)"></a>前序遍历(递归)</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">preOrder</span>(Node&lt;elemType&gt; *t)<span class="comment">//递归，按前序遍历输出以t为根的二叉树的结点的数据值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;NUll &quot;;//如果想要更清楚观察前序遍历的原理，可以在空结点时输出&quot;NULL &quot;</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; t-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//根，左，右</span></span><br><span class="line"><span class="built_in">preOrder</span>(t-&gt;left);</span><br><span class="line"><span class="built_in">preOrder</span>(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//template&lt;class elemType&gt;</span></span><br><span class="line"><span class="comment">//void binaryTree&lt;elemType&gt;::preOrder()//递归，前序遍历整棵树</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//preOrder(root);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h6 id="中序遍历-递归"><a href="#中序遍历-递归" class="headerlink" title="中序遍历(递归)"></a>中序遍历(递归)</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">inOrder</span>(Node&lt;elemType&gt; *t)<span class="comment">//递归，按中序遍历输出以t为根的二叉树的结点的数据值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;NUll &quot;;//如果想要更清楚观察前序遍历的原理，可以在空结点时输出&quot;NULL &quot;</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">inOrder</span>(t-&gt;left);<span class="comment">//左，根，右</span></span><br><span class="line">cout &lt;&lt; t-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">inOrder</span>(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//template&lt;class elemType&gt;</span></span><br><span class="line"><span class="comment">//void binaryTree&lt;elemType&gt;::inOrder()//递归，中序遍历整棵树</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//inOrder(root);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h6 id="后序遍历-递归"><a href="#后序遍历-递归" class="headerlink" title="后序遍历(递归)"></a>后序遍历(递归)</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">postOrder</span>(Node&lt;elemType&gt; *t)<span class="comment">//递归，按后序遍历输出以t为根的二叉树的结点的数据值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;NUll &quot;;//如果想要更清楚观察前序遍历的原理，可以在空结点时输出&quot;NULL &quot;</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">postOrder</span>(t-&gt;left);</span><br><span class="line"><span class="built_in">postOrder</span>(t-&gt;right);</span><br><span class="line">cout &lt;&lt; t-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//template&lt;class elemType&gt;</span></span><br><span class="line"><span class="comment">//void binaryTree&lt;elemType&gt;::postOrder()//递归，后序遍历整棵树</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//postOrder(root);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h5 id="二叉树的非递归遍历："><a href="#二叉树的非递归遍历：" class="headerlink" title="二叉树的非递归遍历："></a>二叉树的非递归遍历：</h5><blockquote><p>二叉树的非递归遍历，需要用 栈 来进行辅助</p></blockquote><h6 id="前序遍历-非递归"><a href="#前序遍历-非递归" class="headerlink" title="前序遍历(非递归)"></a>前序遍历(非递归)</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">preOrder</span>()<span class="comment">//非递归，前序遍历整棵树</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">Node&lt;elemType&gt; *p;<span class="comment">//当前访问的结点</span></span><br><span class="line">stack&lt;Node&lt;elemType&gt; *&gt; s;<span class="comment">//辅助栈，存放即将访问的结点</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">push</span>(root);</span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">p = s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;right)</span><br><span class="line">s.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;left)</span><br><span class="line">s.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>前序遍历的访问是“根、左、右”</p><p>用一个栈s存储 需要遍历的结点 ，先将root入栈</p><p>只要栈不为空，就循环</p><p>获取栈顶元素p并出栈</p><p>访问p结点，输出p的data</p><p>看p有无左&#x2F;右孩子，有则入栈</p><p>注意应让右孩子先入栈，再让左孩子入栈</p><blockquote><p>因为栈的特性，后进先出，前序遍历要求访问完根结点之后先访问它的左孩子</p><p>所以应先让右孩子入栈，再让左孩子入栈，这样才能保证栈顶元素是左孩子</p></blockquote><blockquote><p> 还是因为栈的特性，访问结点的时候让它的孩子入栈，这样就保证了访问完结点之后访问的就是它的孩子</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20221118113318.png" alt="QQ截图20221118113318" style="zoom:40%;" /></blockquote><h6 id="中序遍历-非递归"><a href="#中序遍历-非递归" class="headerlink" title="中序遍历(非递归)"></a>中序遍历(非递归)</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">inOrder</span>()<span class="comment">//非递归，中序遍历整棵树</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">Node&lt;elemType&gt; *p;<span class="comment">//当前结点</span></span><br><span class="line">stack&lt;Node&lt;elemType&gt; *&gt; s1;<span class="comment">//辅助栈，保存即将访问的结点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag;<span class="comment">//用来记录结点的访问情况：是否访问过左孩子。没访问过则左孩子入栈；访问过左孩子才能访问当前结点的data，然后将右孩子入栈</span></span><br><span class="line"><span class="comment">//未访问过左孩子，值为0，访问过左孩子，值为1</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s2;<span class="comment">//保存s1中每个结点的访问情况</span></span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">push</span>(root);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//root的初始访问情况是0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">p = s1.<span class="built_in">top</span>();<span class="comment">//获取栈顶元素，为当前结点</span></span><br><span class="line">flag = s2.<span class="built_in">top</span>();<span class="comment">//获取栈顶元素，为当前结点的访问情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span>)<span class="comment">//如果访问过当前结点的左孩子，则访问当前结点的data，输出data、右孩子入栈</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//访问输出当前结点的data</span></span><br><span class="line">  <span class="comment">//访问完了当前结点的data，当前结点应当出栈</span></span><br><span class="line">      s1.<span class="built_in">pop</span>();</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;right)<span class="comment">//有右孩子则压栈</span></span><br><span class="line">&#123;</span><br><span class="line">s1.<span class="built_in">push</span>(p-&gt;right);<span class="comment">//右孩子压栈</span></span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//右孩子的初始访问情况是0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//没访问过左孩子</span></span><br><span class="line">&#123;</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">1</span>);<span class="comment">//更新当前结点的访问情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;left)<span class="comment">//左孩子入栈</span></span><br><span class="line">&#123;</span><br><span class="line">s1.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//左孩子初始访问情况是0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>中序遍历的访问顺序是“左、根、右”</p><p>在访问结点的时候，需要考虑该结点是否访问过左孩子，若没有访问左孩子，则应先访问左孩子，之后再访问当前结点data，然后再访问右孩子</p><p>用flag记录结点的访问情况，未访问过左孩子则值为0，访问过则值为1，根据flag来判断对当前结点如何操作</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20221118113318.png" alt="QQ截图20221118113318" style="zoom: 33%;" /></blockquote><h6 id="后序遍历-非递归"><a href="#后序遍历-非递归" class="headerlink" title="后序遍历(非递归)"></a>后序遍历(非递归)</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">postOrder</span>()<span class="comment">//非递归，后序遍历整棵树</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">Node&lt;elemType&gt; *p;<span class="comment">//当前结点</span></span><br><span class="line">stack&lt;Node&lt;elemType&gt; *&gt; s1;<span class="comment">//辅助栈，保存即将访问的结点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag;<span class="comment">//用来记录当前结点的访问情况。没访问过左孩子则左孩子入栈；访问过左孩子但没有访问过右孩子则右孩子入栈；访问过右孩子才能访问当前结点的data</span></span><br><span class="line"><span class="comment">//未访问过左孩子，值为0；访问过左孩子未访问过右孩子，值为1；访问过右孩子，值为2</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s2;<span class="comment">//保存s1中每个结点的访问情况</span></span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">push</span>(root);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//root的初始访问情况是0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">p = s1.<span class="built_in">top</span>();<span class="comment">//获取栈顶元素，为当前结点</span></span><br><span class="line">flag = s2.<span class="built_in">top</span>();<span class="comment">//获取栈顶元素，为当前结点的访问情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">2</span>)<span class="comment">//访问过当前结点的右孩子，则访问当前结点的data</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//访问输出当前结点的data</span></span><br><span class="line">  <span class="comment">//访问完了当前结点的data，当前结点应当出栈</span></span><br><span class="line">      s1.<span class="built_in">pop</span>();</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">1</span>)<span class="comment">//访问过当前结点的左孩子但未访问右孩子</span></span><br><span class="line">&#123;</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">2</span>);<span class="comment">//更新当前结点的访问情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;right)<span class="comment">//有右孩子则压栈</span></span><br><span class="line">&#123;</span><br><span class="line">s1.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//右孩子的初始访问情况是0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">0</span>)<span class="comment">//未访问过当前结点的左孩子</span></span><br><span class="line">&#123;</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">1</span>);<span class="comment">//更新当前结点的访问情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;left)<span class="comment">//左孩子入栈</span></span><br><span class="line">&#123;</span><br><span class="line">s1.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//左孩子初始访问情况是0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>思路跟中序遍历类似，访问结点的时候按照“左、右、根”的顺序</p><p>访问结点的时候要判断是否访问过左孩子，没有访问过左孩子要先访问左孩子，如果访问过左孩子要判断是否访问过右孩子，访问过右孩子才能访问当前结点，输出当前结点的值</p><p>flag为 0 说明 未访问过当前结点的左孩子；1则说明访问过左孩子但是没访问右孩子；2则说明访问过右孩子，可以输出当前结点的data</p></blockquote><h6 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">levelOrder</span>()<span class="comment">//层序遍历</span></span><br><span class="line">&#123;</span><br><span class="line">queue&lt;Node&lt;elemType&gt; *&gt; que;<span class="comment">//辅助队列保存即将访问的结点</span></span><br><span class="line">Node&lt;elemType&gt; *p;<span class="comment">//当前访问的结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">que.<span class="built_in">push</span>(root);</span><br><span class="line"><span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">p = que.<span class="built_in">front</span>();</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;left)</span><br><span class="line">que.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;right)</span><br><span class="line">que.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉线索树："><a href="#二叉线索树：" class="headerlink" title="二叉线索树："></a>二叉线索树：</h4><blockquote><p>对于n个结点的二叉树，在二叉链存储结构总中有n+1个空链域</p><blockquote><p>有些结点没有左&#x2F;右孩子，指针域保存的地址是空的，这个指针域是空链域</p></blockquote><p>利用这些空链域存放在 某种遍历次序下的结果中 该结点的 直接前驱结点 和 直接后继结点 的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树。</p><blockquote><p>直接前驱、直接后继：通过某种遍历方式，获得二叉树的遍历结果，在遍历结果中，某个结点的前一个结点就是 在当前遍历方式下 自己的直接前驱，后一个结点就是 在当前遍历方式下 自己的直接后继</p><p>如果指针域的指针存的是直接前驱&#x2F;后继的地址，则就能找到当前结点的直接前驱或者直接后继，这就为遍历提供了线索，故称这种指针为线索</p></blockquote><p>根据线索性质的不同，二叉树可分为前序遍历线索二叉树、中序遍历线索二叉树和后序遍历线索二叉树三种。</p></blockquote><h5 id="中序遍历线索二叉树的构建"><a href="#中序遍历线索二叉树的构建" class="headerlink" title="中序遍历线索二叉树的构建"></a>中序遍历线索二叉树的构建</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">Node&lt;elemType&gt; *binaryTree&lt;elemType&gt;::<span class="built_in">threadMin</span>()<span class="comment">//建立中序遍历线索树</span></span><br><span class="line"><span class="comment">//实质就是在中序遍历的时候将结点的空链域存上线索</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">Node&lt;elemType&gt; *first = <span class="literal">NULL</span>;<span class="comment">//记录中序遍历结果中的第一个结点</span></span><br><span class="line">Node&lt;elemType&gt; *pre = <span class="literal">NULL</span>;<span class="comment">//在中序遍历中当前结点的直接前驱</span></span><br><span class="line"></span><br><span class="line">Node&lt;elemType&gt; *p;<span class="comment">//当前结点</span></span><br><span class="line">stack&lt;Node&lt;elemType&gt; *&gt; s1;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag;</span><br><span class="line">  stack&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">push</span>(root);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//实质就是在中序遍历的时候将结点的空链域存上线索</span></span><br><span class="line"><span class="keyword">while</span> (!s1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    p = s1.<span class="built_in">top</span>();</span><br><span class="line">flag = s2.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;-----&quot;</span> &lt;&lt; endl;</span><br><span class="line">      s1.<span class="built_in">pop</span>();</span><br><span class="line">      s2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!first)<span class="comment">//p结点data在此已经访问完了，如果first为空说明p就是中序遍历结果中的第一个结点</span></span><br><span class="line">first = p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;right &amp;&amp; p-&gt;rightFlag == <span class="number">0</span>)<span class="comment">//如果当前结点有右孩子，右孩子入栈</span></span><br><span class="line">        <span class="comment">//rightFlag == 0说明右指针存的是右孩子，== 1说明右指针存的是直接后继</span></span><br><span class="line">&#123;</span><br><span class="line">s1.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!p-&gt;left)<span class="comment">//如果左指针为空，用来存直接前驱</span></span><br><span class="line">&#123;</span><br><span class="line">p-&gt;leftFlag = <span class="number">1</span>;</span><br><span class="line">p-&gt;left = pre;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//////////////辅助调试，输出一下当前结点直接前驱的data///////////////////////</span></span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;&#x27;s pre: &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;left)</span><br><span class="line">cout &lt;&lt; p-&gt;left-&gt;data &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//中序遍历结果中的第一个结点没有直接前驱，是线索二叉树中唯一一个左指针为空的</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!p-&gt;right)<span class="comment">//如果右指针为空，用来存直接后继</span></span><br><span class="line">&#123;</span><br><span class="line">p-&gt;rightFlag = <span class="number">1</span>;</span><br><span class="line">p-&gt;right = !s1.<span class="built_in">empty</span>() ? s1.<span class="built_in">top</span>() : <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//s1栈顶就是当前结点的直接后继，如果栈为空，说明当前结点是中序遍历结果中的最后一个结点，是线索二叉树中唯一一个右指针为空的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////辅助调试，输出一下当前结点直接前驱的data///////////////////////</span></span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;&#x27;s next: &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;right)</span><br><span class="line">cout &lt;&lt; p-&gt;right-&gt;data &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//中序遍历结果中的最后一个结点没有直接后继，是线索二叉树中唯一一个右指针为空的</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pre = p;<span class="comment">//已访问完当前结点，当前结点成为了下一个要访问的结点的直接前驱</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span><span class="comment">//如果flag == 0</span></span><br><span class="line">&#123;</span><br><span class="line">      s2.<span class="built_in">pop</span>();</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;leftFlag == <span class="number">0</span> &amp;&amp; p-&gt;left)<span class="comment">//左结点为左孩子的话，将左孩子入结点栈</span></span><br><span class="line">&#123;</span><br><span class="line">s1.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在进行中序遍历的时候顺便对当前访问的结点添加上线索</p><p>访问的上一个结点是当前结点的直接前驱，即将访问的下一个结点(栈顶元素)是当前结点的直接后继</p></blockquote><h5 id="借助中序遍历线索树实现-中序非递归遍历"><a href="#借助中序遍历线索树实现-中序非递归遍历" class="headerlink" title="借助中序遍历线索树实现 中序非递归遍历"></a>借助中序遍历线索树实现 中序非递归遍历</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">threadMidInOrder</span>(Node&lt;elemType&gt; *first)<span class="comment">//借助中序线索树，非递归 中序遍历原来的二叉树</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!first || !root)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">Node&lt;elemType&gt; *p = first;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;rightFlag == <span class="number">0</span>)<span class="comment">//如果p有右孩子，访问p的右孩子</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p-&gt;leftFlag == <span class="number">0</span> &amp;&amp; p-&gt;left)<span class="comment">//当前结点有左子树，应访问左子树的最左结点</span></span><br><span class="line">p = p-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">else</span><span class="comment">//如果p无右孩子，则直接用线索找它的直接后继</span></span><br><span class="line">p = p-&gt;right;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从first开始遍历</p><p>遍历结点时</p><p>有右孩子去往右孩子，访问右孩子时，右孩子有左子树，则去往左子树的最左结点</p><p>无右孩子则去往直接后继</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211201041959.png" alt="iShot_2022-11-20_10.41.22" style="zoom: 20%;" /></blockquote><h5 id="借助中序遍历线索树实现-前序非递归遍历"><a href="#借助中序遍历线索树实现-前序非递归遍历" class="headerlink" title="借助中序遍历线索树实现 前序非递归遍历"></a>借助中序遍历线索树实现 前序非递归遍历</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">threadMidPreOrder</span>()<span class="comment">//借助中序线索树，非递归 前序遍历 原来的二叉树</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">Node&lt;elemType&gt; *p = root;<span class="comment">//从root开始访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;leftFlag == <span class="number">0</span>)<span class="comment">//如果有左孩子，则直接访问左孩子</span></span><br><span class="line">p = p-&gt;left;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span><span class="comment">//没有左孩子则访问右孩子</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;rightFlag == <span class="number">1</span> &amp;&amp; p-&gt;right)<span class="comment">//如果没有右孩子，则去往直接后继，直到有右孩子或者右结点为空(中序遍历结果中的最后一个结点</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p = p-&gt;right;<span class="comment">//去往右孩子</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从root开始遍历</p><p>有左孩子访问左孩子</p><p>没有左孩子访问右孩子，没有右孩子则去往直接后继，直到有右孩子，访问右孩子</p></blockquote><h4 id="已知前中序遍历结果，求二叉树"><a href="#已知前中序遍历结果，求二叉树" class="headerlink" title="已知前中序遍历结果，求二叉树"></a>已知前中序遍历结果，求二叉树</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">Node&lt;elemType&gt; *binaryTree&lt;elemType&gt;::<span class="built_in">buildTree</span>(elemType pre[], <span class="type">int</span> pl, <span class="type">int</span> pr,</span><br><span class="line">elemType mid[], <span class="type">int</span> ml, <span class="type">int</span> mr)<span class="comment">//已知一颗二叉树的前序遍历和中序遍历结果 建立这颗二叉树</span></span><br><span class="line"><span class="comment">//数组pre、mid分别是前序遍历、中序遍历的结果;pl、pr、ml、mr分别是前序、中序遍历结果数组的边界</span></span><br><span class="line">&#123;</span><br><span class="line">Node&lt;elemType&gt; *p;<span class="comment">//创建当前树的根结点</span></span><br><span class="line">Node&lt;elemType&gt; *leftRoot, *rightRoot;<span class="comment">//创建当前树的左子树、右子树的根结点</span></span><br><span class="line"><span class="type">int</span> i, pos, num;<span class="comment">//pos：当前树的根在中序遍历中的位置，num：记录左子树结点个数</span></span><br><span class="line"><span class="comment">//(根在前序遍历中的位置不用记录，前序遍历结果的第一个就是)</span></span><br><span class="line"><span class="type">int</span> lpl, lpr, lml, lmr;<span class="comment">//记录前序遍历、中序遍历中左子树的范围</span></span><br><span class="line"><span class="type">int</span> rpl, rpr, rml, rmr;<span class="comment">//记录前序遍历、中序遍历中右子树的范围</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pl &gt; pr)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">p = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;elemType&gt;(pre[pl]);<span class="comment">//创建当前树的根结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line">root = p;<span class="comment">//如果当前的二叉树是空树，那就直接让当前的树等于创建的二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = ml; i &lt;= mr; i++)<span class="comment">//开始寻找前序遍历中的根在中序遍历中的位置</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mid[i] == pre[pl])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pos = i;<span class="comment">//----找到了中序遍历结果中的根结点----</span></span><br><span class="line">num = pos - ml;<span class="comment">//记录左子树的结点个数</span></span><br><span class="line"></span><br><span class="line">lpl = pl + <span class="number">1</span>;<span class="comment">//前序遍历结果中 左子树的范围</span></span><br><span class="line">lpr = pl + num;</span><br><span class="line">lml = ml;<span class="comment">//中序遍历结果中 左子树的范围</span></span><br><span class="line">lmr = pos - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">leftRoot = <span class="built_in">buildTree</span>(pre, lpl, lpr, mid, lml, lmr);<span class="comment">//递归，找遍历结果中 左子树中 的根结点</span></span><br><span class="line"></span><br><span class="line">rpl = lpl + <span class="number">1</span>;<span class="comment">//前序遍历结果中 右子树的范围</span></span><br><span class="line">rpr = pr;</span><br><span class="line">rml = pos + <span class="number">1</span>;<span class="comment">//中序遍历结果中 右子树的范围</span></span><br><span class="line">rmr = mr;</span><br><span class="line"></span><br><span class="line">rightRoot = <span class="built_in">buildTree</span>(pre, rpl, rpr, mid, rml, rmr);<span class="comment">//递归，找遍历结果中 右子树中 的根结点</span></span><br><span class="line"></span><br><span class="line">p-&gt;left = leftRoot;</span><br><span class="line">p-&gt;right = rightRoot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>根据前序遍历“根、左、右”和中序遍历“左、根、右”</p><p>前序遍历结果中的第一个结点就是根，在中序遍历中找到这个根，中序遍历结果中这个根的左面的所有结点就是这个根的左子树的遍历结果，右面的所有结点就是右子树的遍历结果</p><p>这样可以用前序遍历结果找根，中序遍历结果找子树的遍历结果，构建完整二叉树</p><blockquote><p>树是递归的结构，树可以分为根和子树，子树又分为根和子树</p><p>所以要递归找根结点，直到不能再分</p></blockquote><blockquote><p>例如：已知一棵树的前序遍历和中序遍历结果</p><blockquote><p>前序序列：B、L、S、C、F、D、G、I、H</p><p>中序序列：L、S、B、F、C、I、G、H、D</p></blockquote><p>理论思路过程：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20221120152841.png" alt="image" style="zoom: 33%;" /><p>算法实现：</p><p>pre、mid：前序遍历、中序遍历的结果结果数组</p><p>pl、pr、ml、mr：前序、中序遍历结果数组的左右边界</p><p>p：创建当前树的根结点</p><p>leftRoot、rightRoot：创建当前树的左子树、右子树的根结点<br>pos：记录当前树的根在中序遍历中的位置</p><p>(根在前序遍历中的位置不用记录，前序遍历结果的第一个就是)</p><p>num：记录左子树结点的个数</p><p>lpl、 lpr、 lml、 lmr：记录前序遍历、中序遍历中左子树的范围</p><p>rpl,、rpr,、rml、rmr：记录前序遍历、中序遍历中右子树的范围</p><p>​<img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211201635521.png" alt="iShot_2022-11-20_16.33.37" style="zoom: 33%;" /></p></blockquote></blockquote><h4 id="表达式树的构建："><a href="#表达式树的构建：" class="headerlink" title="表达式树的构建："></a>表达式树的构建：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">vector&lt;string&gt; binaryTree&lt;elemType&gt;::<span class="built_in">init</span>(<span class="type">const</span> string&amp; s)<span class="comment">//表达式的初始化处理</span></span><br><span class="line"><span class="comment">//原始表达式是string类型的，元素为char类型，因此值大于9的整数(也就是两位以上的整数)会被分成两个元素，无法正常表示和计算</span></span><br><span class="line"><span class="comment">//应先将表达式进行初始化：用元素类型为string的vector保存表达式的操作数和操作字符</span></span><br><span class="line">&#123;</span><br><span class="line">vector&lt;string&gt; v;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; s.<span class="built_in">length</span>())</span><br><span class="line">&#123;</span><br><span class="line">j = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (j &lt; s.<span class="built_in">length</span>() &amp;&amp; s[j] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; s[j] &gt;= <span class="string">&#x27;0&#x27;</span>)<span class="comment">//如果遇到了数字，就往后看是否为多位数</span></span><br><span class="line">&#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == j)<span class="comment">//说明没有遇到数字</span></span><br><span class="line">v.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(i++, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(i, j - i));</span><br><span class="line">i = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> binaryTree&lt;elemType&gt;::<span class="built_in">judge</span>(<span class="type">const</span> string&amp; s)<span class="comment">//判断操作符优先度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="string">&quot;+&quot;</span> || s == <span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;*&quot;</span> || s == <span class="string">&quot;/&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;(&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;)&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> binaryTree&lt;elemType&gt;::<span class="built_in">stringToInt</span>(string s)<span class="comment">//表达式中的操作数string类转int</span></span><br><span class="line">&#123;</span><br><span class="line">stringstream ss;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">ss &lt;&lt; s;</span><br><span class="line">ss &gt;&gt; i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> binaryTree&lt;elemType&gt;::<span class="built_in">buildExpressionTree</span>(<span class="type">const</span> string&amp; s)<span class="comment">//将当前树建立为表达式树</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root)<span class="comment">//表达式树应该用空树来建</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;This binaryTree is not a null tree , please define another binaryTree to make it as a ExpressionTree&quot;</span></span><br><span class="line"> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stack&lt;string&gt; s1;<span class="comment">//操作符栈</span></span><br><span class="line">stack&lt;Node&lt;string&gt; *&gt; s2;<span class="comment">//子树栈，用来存放根结点的地址</span></span><br><span class="line">Node&lt;string&gt; *p, *left, *right;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; v = <span class="built_in">init</span>(s);<span class="comment">//先将string类型的表达式初始化，将元素由char变成string并存在vector中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">judge</span>(v[i]) == <span class="number">0</span>)<span class="comment">//如果是操作数，直接创建作为根结点进子树栈</span></span><br><span class="line">&#123;</span><br><span class="line">p = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;string&gt;(v[i]);</span><br><span class="line">s2.<span class="built_in">push</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">judge</span>(v[i]) == <span class="number">3</span>)<span class="comment">//如果当前操作符是左括号，直接进栈</span></span><br><span class="line">s1.<span class="built_in">push</span>(v[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">judge</span>(v[i]) == <span class="number">1</span> || <span class="built_in">judge</span>(v[i]) == <span class="number">2</span>)<span class="comment">//如果是 加减乘除 操作符</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s1.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">s1.<span class="built_in">push</span>(v[i]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (!s1.<span class="built_in">empty</span>() &amp;&amp; s1.<span class="built_in">top</span>() != <span class="string">&quot;(&quot;</span> &amp;&amp; <span class="built_in">judge</span>(v[i]) &lt; <span class="built_in">judge</span>(s1.<span class="built_in">top</span>()))</span><br><span class="line"><span class="comment">//如果栈不为空且栈顶元素不是&quot;(&quot;，并且当前操作符优先度 小于栈顶，就让栈顶出栈</span></span><br><span class="line"><span class="comment">//每次出栈，出栈的栈顶元素要与子树栈的两个栈顶元素构建成子树，并压入子树栈</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">right = s2.<span class="built_in">top</span>();</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line">left = s2.<span class="built_in">top</span>();</span><br><span class="line">s2.<span class="built_in">pop</span>();<span class="comment">//子树栈两个栈顶元素出栈</span></span><br><span class="line"></span><br><span class="line">p = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;string&gt;(s1.<span class="built_in">top</span>());</span><br><span class="line">s1.<span class="built_in">pop</span>();<span class="comment">//操作符栈顶元素出栈，与刚出子树栈的两个栈顶元素构建成子树，压入子树栈</span></span><br><span class="line">p-&gt;left = left;</span><br><span class="line">p-&gt;right = right;</span><br><span class="line"><span class="comment">//在表达式树中，数字作为左结点是操作数，右结点是被操作数（表达式中左边的数是操作数，右边的数是被操作数</span></span><br><span class="line"><span class="comment">//而表达式中的数字从左到右正序入栈，因此栈顶是被操作数，作为树结点的时候要记得反过来</span></span><br><span class="line">s2.<span class="built_in">push</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前操作符优先度不低于栈顶 or 栈为空</span></span><br><span class="line">s1.<span class="built_in">push</span>(v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">judge</span>(v[i]) == <span class="number">-1</span>)<span class="comment">//当前操作符是右括号的话</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">judge</span>(s1.<span class="built_in">top</span>()) != <span class="number">3</span>)<span class="comment">//在遇到左括号之前，一直将操作符栈顶弹栈</span></span><br><span class="line"><span class="comment">//每次出栈，出栈的栈顶元素要与子树栈的两个栈顶元素构建成子树，并压入子树栈</span></span><br><span class="line">&#123;</span><br><span class="line">right = s2.<span class="built_in">top</span>();</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line">left = s2.<span class="built_in">top</span>();</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">p = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;string&gt;(s1.<span class="built_in">top</span>());</span><br><span class="line">s1.<span class="built_in">pop</span>();</span><br><span class="line">p-&gt;left = left;</span><br><span class="line">p-&gt;right = right;</span><br><span class="line"></span><br><span class="line">s2.<span class="built_in">push</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">pop</span>();<span class="comment">//遇到左括号，左括号出栈</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s1.<span class="built_in">empty</span>())<span class="comment">//处理操作符栈，将栈顶元素出栈直到栈空</span></span><br><span class="line"><span class="comment">//每次出栈，出栈的栈顶元素要与子树栈的两个栈顶元素构建成子树，并压入子树栈</span></span><br><span class="line">&#123;</span><br><span class="line">right = s2.<span class="built_in">top</span>();</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line">left = s2.<span class="built_in">top</span>();</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">p = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;string&gt;(s1.<span class="built_in">top</span>());</span><br><span class="line">s1.<span class="built_in">pop</span>();</span><br><span class="line">p-&gt;left = left;</span><br><span class="line">p-&gt;right = right;</span><br><span class="line"></span><br><span class="line">s2.<span class="built_in">push</span>(p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子树栈中只会剩下一个根结点，这个根结点就是表达式树的根结点</span></span><br><span class="line">root = s2.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总体思路：</p><ol><li><p>表达式其实是一种递归，表达式是由 左操作数 操作符 右操作数 组成</p><p>而 操作数 是 表达式的值</p><p>所以表达式 是由 左表达式的值 操作符 右表达式的值 组成</p></li><li><p>在计算表达式的时候，要先知道 左操作数 和 右操作数 才能进行计算，也就是要先计算左表达式和右表达式</p></li><li><p>在计算表达式的时候，优先度越高的表达式越先计算，其结果作为优先度低一级的部分的操作数</p><p>因此表达式，是由优先度比自己高的表达式(的结果)组成的</p></li><li><p>所以表达式本质就是二叉树，左子树是左表达式，根结点是操作符，右子树是右表达式</p><p>树的叶子结点是表达式里的操作数</p></li></ol><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211201957372.jpeg" alt="IMG_0788" style="zoom:50%;" /></blockquote><blockquote><p>构建表达式树，就是优先度越高的部分组成的子树层次越深，越靠近叶子</p><p>从左到右顺序读取表达式的元素，将表达式的操作数都建成结点，这个是表达式树的叶子结点</p><p>优先级最高的表达式最先构建成树，并且成为优先级低于自己的表达式的子树</p></blockquote><blockquote><p>s1为操作符栈，用来比较操作符的优先度和存储操作符</p><p>s2为子树栈，存放已经建成的表达式子树</p><p>遍历表达式vector</p><p>如果是操作数，直接进s2栈</p><p>如果是操作符</p><ol><li><p>如果s1栈为空，直接进s1</p></li><li><p>如果s1栈不为空</p><ol><li><p>如果当前操作符为 左括号，直接进栈</p></li><li><p>如果当前操作符是 加减乘除，就与栈顶比较，如果栈顶不为空且不为 左括号，比栈顶优先级低，就让栈顶出栈，</p><blockquote><p>每次出栈，出栈的栈顶元素要与子树栈的两个栈顶元素构建成子树，并压入子树栈</p></blockquote></li><li><p>如果当前操作符为 右括号，在遇到左括号之前，一直将操作符栈顶弹栈(操作符弹栈，按照👆的规矩)，直到遇到左括号，将左括号出栈</p><blockquote><p>每次出栈，出栈的栈顶元素要与子树栈的两个栈顶元素构建成子树，并压入子树栈</p></blockquote></li></ol></li></ol><p>遍历完表达式之后，处理子树栈，将各个子树组成一个表达式树</p><blockquote><p>将操作符栈栈顶出栈直到栈空，每次出栈，出栈的栈顶元素要与子树栈的两个栈顶元素构建成子树，并压入子树栈</p></blockquote><p>子树栈中只会剩下一个根结点，这个根结点就是表达式树的根结点</p></blockquote><h4 id="表达式树的计算："><a href="#表达式树的计算：" class="headerlink" title="表达式树的计算："></a>表达式树的计算：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> binaryTree&lt;elemType&gt;::<span class="built_in">calculateExpressionTree</span>()<span class="comment">//计算表达式树</span></span><br><span class="line"><span class="comment">//表达式数字都是叶子结点，操作符都是分支结点。用后序遍历访问整棵树，遇到数字就进操作数栈，遇到操作符就用操作数栈里的数字计算，结果入栈</span></span><br><span class="line"><span class="comment">//在后序非递归遍历的基础上进行修改即可</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">nullPoint</span>();</span><br><span class="line"></span><br><span class="line">stack&lt;Node&lt;elemType&gt; *&gt; s1;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line">Node&lt;elemType&gt; *p;</span><br><span class="line"><span class="type">int</span> flag;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; num;<span class="comment">//操作数栈</span></span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">push</span>(root);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">flag = s2.<span class="built_in">top</span>();</span><br><span class="line">s2.<span class="built_in">pop</span>();</span><br><span class="line">p = s1.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">s1.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;data == <span class="string">&quot;+&quot;</span> || p-&gt;data == <span class="string">&quot;-&quot;</span> || p-&gt;data == <span class="string">&quot;*&quot;</span> || p-&gt;data == <span class="string">&quot;/&quot;</span>)<span class="comment">//如果是操作符，执行计算</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n2 = num.<span class="built_in">top</span>();</span><br><span class="line">num.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> n1 = num.<span class="built_in">top</span>();</span><br><span class="line">num.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;data == <span class="string">&quot;+&quot;</span>)</span><br><span class="line">num.<span class="built_in">push</span>(n1 + n2);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;data == <span class="string">&quot;-&quot;</span>)</span><br><span class="line">num.<span class="built_in">push</span>(n1 - n2);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;data == <span class="string">&quot;/&quot;</span>)</span><br><span class="line">num.<span class="built_in">push</span>(n1 / n2);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;data == <span class="string">&quot;*&quot;</span>)</span><br><span class="line">num.<span class="built_in">push</span>(n1 * n2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">num.<span class="built_in">push</span>(<span class="built_in">stringToInt</span>(p-&gt;data));<span class="comment">//如果是操作数，转化为int之后存入操作数栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;right)</span><br><span class="line">&#123;</span><br><span class="line">s1.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;left)</span><br><span class="line">&#123;</span><br><span class="line">s1.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">s2.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>计算的时候就采用后序遍历</p><blockquote><p> 访问当前结点之前先访问左右孩子，因此树中最先访问的是叶子结点也就是操作数，凡是操作数都入栈保存下来，在访问到操作符的时候就用栈中的操作数进行计算，计算结果作为操作数入栈</p></blockquote></blockquote><h2 id="哈夫曼树-x2F-最优二叉树"><a href="#哈夫曼树-x2F-最优二叉树" class="headerlink" title="哈夫曼树&#x2F;最优二叉树"></a>哈夫曼树&#x2F;最优二叉树</h2><p>路径：一个结点到另一个结点之间的通路就是路径。比如B到H就是一条路径，B到G也是一条路径</p><p>路径的长度：路径上经过的边(“树枝”)的数目。从根结点到第i层结点的路径的长度就是 i-1</p><p>结点的权：给一个结点赋予一个权值。比如给E一个权值20</p><p>结点的带权路径长度：根结点到一个带权结点的路径长度乘这个结点的权值。H的带权路径长度是2*19&#x3D;38</p><p>树的带权路径长度(WPL)：所有叶子结点的带权路径长度之和。这棵树的WPL是2 * 44 + 3 * 19 + 2 * 46 + 2 * 11 &#x3D;  259</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211211629914.png" alt="截屏2022-11-21 16.23.38" style="zoom:50%;" /><p>哈夫曼树&#x2F;最优二叉树：当有n的带权结点，都作为叶子结点构建成一棵二叉树时，如果构建成的二叉树的WPL最小，就称为“最优二叉树”，也称“哈夫曼树”</p><p>哈夫曼编码：在一棵哈夫曼树中，从根结点开始向下走，经过左孩子记为0，经过右孩子记为1，直到某个叶子结点，从根到这个叶子结点得到的0、1序列就是这个叶子结点的哈夫曼编码。比如，假设上面的树是哈夫曼树，H的哈夫曼编码求法：从A开始到H，A-&gt;B:0, B-&gt;E:1, E-&gt;H:1，叶子结点E的哈夫曼编码就是011. </p><h3 id="哈夫曼树类的声明："><a href="#哈夫曼树类的声明：" class="headerlink" title="哈夫曼树类的声明："></a>哈夫曼树类的声明：</h3><p>采用<strong>顺序存储</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模版不支持分离编译！！！</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HFNode</span><span class="comment">//构建哈夫曼树的结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">elemType data;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line"><span class="type">int</span> parents, left, right;<span class="comment">//保存当前结点的父亲和孩子的位置下标</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">HFNode</span>()</span><br><span class="line">&#123;</span><br><span class="line">weight = <span class="number">0</span>;</span><br><span class="line">parents = <span class="number">0</span>;</span><br><span class="line">left = <span class="number">0</span>;</span><br><span class="line">right = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">huffmanTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HFNode&lt;elemType&gt; *HFTree;<span class="comment">//哈夫曼树顺序表，其实这里用vector更方便一点</span></span><br><span class="line"><span class="type">int</span> leafSize;<span class="comment">//保存哈夫曼树叶子结点的个数</span></span><br><span class="line">vector&lt;string&gt; HFCode;<span class="comment">//哈夫曼树编码表，保存每个叶子结点的哈夫曼编码</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">huffmanTree</span>()</span><br><span class="line">&#123;</span><br><span class="line">HFTree = <span class="literal">NULL</span>;</span><br><span class="line">leafSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;HFNode&lt;elemType&gt;&gt; <span class="built_in">getNode</span>();<span class="comment">//获取叶子结点集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildBestBinaryTree</span><span class="params">(vector&lt;HFNode&lt;elemType&gt;&gt; allNode)</span></span>;<span class="comment">//创建最优二叉树/哈夫曼树</span></span><br><span class="line"></span><br><span class="line"><span class="function">HFNode&lt;elemType&gt; *<span class="title">getRoot</span><span class="params">()</span><span class="comment">//返回构建好的哈夫曼树表的地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> HFTree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeHuffmanCode</span><span class="params">()</span></span>;<span class="comment">//创建每个叶子结点的哈夫曼编码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="哈夫曼树类的成员变量介绍"><a href="#哈夫曼树类的成员变量介绍" class="headerlink" title="哈夫曼树类的成员变量介绍"></a>哈夫曼树类的成员变量介绍</h4><p>哈夫曼树结点类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HFNode</span><span class="comment">//构建哈夫曼树的结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">elemType data;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line"><span class="type">int</span> parents, left, right;<span class="comment">//保存当前结点的父亲和孩子的位置下标</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">HFNode</span>()</span><br><span class="line">&#123;</span><br><span class="line">weight = <span class="number">0</span>;</span><br><span class="line">parents = <span class="number">0</span>;</span><br><span class="line">left = <span class="number">0</span>;</span><br><span class="line">right = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>相比普通二叉树的结点，由于用顺序表存储，孩子结点指针域换成了位置下标，并加了父结点位置下标</p><p>增加了结点的权值weight</p></blockquote><p>哈夫曼树类的成员变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">huffmanTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HFNode&lt;elemType&gt; *HFTree;<span class="comment">//哈夫曼树顺序表，其实这里用vector更方便一点</span></span><br><span class="line"><span class="type">int</span> leafSize;<span class="comment">//保存哈夫曼树叶子结点的个数</span></span><br><span class="line">vector&lt;string&gt; HFCode;<span class="comment">//哈夫曼树编码表，保存每个叶子结点的哈夫曼编码</span></span><br></pre></td></tr></table></figure><h3 id="哈夫曼树类的实现："><a href="#哈夫曼树类的实现：" class="headerlink" title="哈夫曼树类的实现："></a>哈夫曼树类的实现：</h3><h4 id="哈夫曼树的构建"><a href="#哈夫曼树的构建" class="headerlink" title="哈夫曼树的构建"></a>哈夫曼树的构建</h4><p>要想构建二叉树首先得有叶子结点，要先获取叶子结点集合</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模版不支持分离编译！！！</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">vector&lt;HFNode&lt;elemType&gt;&gt; huffmanTree&lt;elemType&gt;::<span class="built_in">getNode</span>()<span class="comment">//获取叶子结点集合</span></span><br><span class="line">&#123;</span><br><span class="line">vector&lt;HFNode&lt;elemType&gt;&gt; allNode;<span class="comment">//创建一个容器，存储叶子结点</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Input the data and weight of the HFNode to add it &quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Before you input , input Y to continue ,or others to exit &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">char</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">while</span> (x == <span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">elemType data;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;input the data of the HFNode&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; data;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;input the weight of the HFNode&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; weight;</span><br><span class="line"></span><br><span class="line">HFNode&lt;elemType&gt; n;</span><br><span class="line">n.weight = weight;</span><br><span class="line">n.data = data;</span><br><span class="line"></span><br><span class="line">allNode.<span class="built_in">push_back</span>(n);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Input the data and weight of the HFNode to add it &quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Before you input , input Y to continue ,or others to exit &quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">&#125;</span><br><span class="line">leafSize = allNode.<span class="built_in">size</span>();<span class="comment">//当前存储的结点就是是之后建成的哈夫曼树的叶子结点</span></span><br><span class="line"><span class="keyword">return</span> allNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用叶子结点集合构建哈夫曼树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> huffmanTree&lt;elemType&gt;::<span class="built_in">buildBestBinaryTree</span>(vector&lt;HFNode&lt;elemType&gt;&gt; allNode)<span class="comment">//建立最优二叉树/哈夫曼树</span></span><br><span class="line">&#123;</span><br><span class="line">HFTree = <span class="keyword">new</span> HFNode&lt;elemType&gt;[<span class="number">2</span> * allNode.<span class="built_in">size</span>()];<span class="comment">//构建哈夫曼树顺序表</span></span><br><span class="line"><span class="comment">//按照最优二叉树的要求，初始带权值的结点都是叶子结点，也就是allNode里存储的都是叶子节点</span></span><br><span class="line"><span class="comment">//并且根据最优二叉树的特点，会发现分支结点全部都是度为2的结点</span></span><br><span class="line"><span class="comment">//根据二叉树的性质，叶子结点个数为n个，则度为2的结点个数为n-1</span></span><br><span class="line"><span class="comment">//根据最优二叉树的构造方法，分支结点都是度为2的，因此最优二叉树中结点个数总是为2*n-1</span></span><br><span class="line"><span class="comment">//我们开辟2*n个空间，空出第一个位置，如果表中的结点无父亲或孩子，那么就让对应的位置下标为0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; allNode.<span class="built_in">size</span>(); i++)<span class="comment">//叶子结点转移到哈夫曼树顺序表，并空出哈夫曼树表的第一个位置</span></span><br><span class="line">&#123;</span><br><span class="line">HFTree[i + <span class="number">1</span>] = allNode[i];</span><br><span class="line">HFTree[i + <span class="number">1</span>].parents = <span class="number">0</span>;</span><br><span class="line">HFTree[i + <span class="number">1</span>].left = <span class="number">0</span>;</span><br><span class="line">HFTree[i + <span class="number">1</span>].right = <span class="number">0</span>;<span class="comment">//一开始所有的结点都没有父亲和孩子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = allNode.<span class="built_in">size</span>();<span class="comment">//用i来表示当前没有父结点的结点的个数</span></span><br><span class="line"><span class="type">int</span> n = allNode.<span class="built_in">size</span>();<span class="comment">//用n来表示当前哈夫曼树表中结点的个数，同时也算是最后面的元素的权重</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i != <span class="number">1</span>)<span class="comment">//一开始所有结点都没有父结点，当哈夫曼树建立完成之后，只有根结点是没有父亲的，由此来判定哈夫曼树是否建成</span></span><br><span class="line"><span class="comment">//由于每次循环创建一个新结点，原来权重最小的两个结点有了父结点，i-2，但是新结点是没有父结点的，所以每次循环总体上为i-1</span></span><br><span class="line"><span class="comment">//(当然，也可以用n来判定循环，n&lt;2*allNode.size()，画图理解即可）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> first_min, second_min;<span class="comment">//定义没有父结点的结点中权重最小的两个结点的下标</span></span><br><span class="line"><span class="type">double</span> first_min_weight = <span class="number">9999</span>;<span class="comment">//将两个权重初始化为一个大到不可能的权重</span></span><br><span class="line"><span class="type">double</span> second_min_weight = <span class="number">9999</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++)<span class="comment">//寻找权重第一小的无父结点的结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (HFTree[x].parents == <span class="number">0</span> &amp;&amp; HFTree[x].weight &lt; first_min_weight)</span><br><span class="line">&#123;</span><br><span class="line">first_min = x;</span><br><span class="line">first_min_weight = HFTree[x].weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++)<span class="comment">//寻找权重第二小的无父结点的结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x != first_min &amp;&amp; HFTree[x].parents == <span class="number">0</span> &amp;&amp; HFTree[x].weight &lt; second_min_weight)</span><br><span class="line">&#123;</span><br><span class="line">second_min = x;</span><br><span class="line">second_min_weight = HFTree[x].weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> weight_added = first_min_weight + second_min_weight;</span><br><span class="line"></span><br><span class="line">n++;</span><br><span class="line"></span><br><span class="line">HFTree[first_min].parents = n;<span class="comment">//原来的权重最小结点变成了新结点的孩子</span></span><br><span class="line">HFTree[second_min].parents = n;</span><br><span class="line"></span><br><span class="line">HFTree[n].left = first_min;</span><br><span class="line">HFTree[n].right = second_min;</span><br><span class="line">HFTree[n].weight = weight_added;</span><br><span class="line">i--;<span class="comment">//由于创建了一个新结点，原来权重最小的两个结点有了父结点，i-2，但是新结点是没有父结点的，所以总体上为i-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下辅助调试代码，便于判断是否正确建立了一棵哈夫曼树</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;index: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;data: &quot;</span> &lt;&lt; HFTree[x].data &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;weight: &quot;</span> &lt;&lt; HFTree[x].weight &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;parents: &quot;</span> &lt;&lt; HFTree[x].parents &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;left: &quot;</span> &lt;&lt; HFTree[x].left &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;right: &quot;</span> &lt;&lt; HFTree[x].right &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---------&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>哈夫曼算法：</p><p>每次找哈夫曼顺序表里权重最小的两个结点，创建一个新结点，新结点是权重是两个最小结点的和，最小结点是新结点的左孩子，次小结点是新结点的右孩子，新结点存入哈夫曼顺序表。这样构建出来的树就是哈夫曼树。</p><blockquote><p>创建一个哈夫曼树顺序表用来存储哈夫曼树。</p><p>之前获得的叶子结点集合作为哈夫曼树的叶子结点。根据二叉树的性质，如果叶子结点的数目是n，则度为2的结点数目是n-1，而通过哈夫曼算法建立的哈夫曼树，所有的分支结点的度都是2，故哈夫曼树的结点总数是2n-1。</p><p>我们创建一个大小为2n的哈夫曼树顺序表，空出第一个位置，如果表中的结点无父亲或孩子，那么就让对应的下标为0</p><p>先将所有叶子结点添加到哈夫曼树表</p><blockquote><p>刚开始所有的叶子结点都没有父亲、孩子，故父亲、孩子下标都为0</p></blockquote><p>一开始所有结点都没有父结点，当哈夫曼树建立完成之后，只有根结点是没有父亲的，由此来判定哈夫曼树是否建成</p><blockquote><p>由于每次循环创建一个新结点，原来权重最小的两个结点有了父结点，没有父结点的结点总数-2，但是新结点是没有父结点的，所以每次循环总体上为无父结点的结点总数-1</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/B35974B77F32A658ED5B854157436CA7.png" alt="img" style="zoom: 25%;" /></blockquote></blockquote><h4 id="创建哈夫曼编码"><a href="#创建哈夫曼编码" class="headerlink" title="创建哈夫曼编码"></a>创建哈夫曼编码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> huffmanTree&lt;elemType&gt;::<span class="built_in">makeHuffmanCode</span>()<span class="comment">//创建每个叶子结点的哈夫曼编码</span></span><br><span class="line"><span class="comment">//因为哈夫曼树顺序表里面前面的都是叶子结点(前半部分结点都是叶子结点，即(哈夫曼树顺序表结点个数+1)/2个）</span></span><br><span class="line"><span class="comment">//但是并没有写求哈夫曼树顺序表结点个数的函数，不过有记录叶子结点个数的变量leafSize</span></span><br><span class="line">&#123;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; s;<span class="comment">//每次用来存储单个叶子结点的编码</span></span><br><span class="line"></span><br><span class="line">HFCode.<span class="built_in">push_back</span>(<span class="string">&quot; &quot;</span>);<span class="comment">//因为哈夫曼树表第一个元素没有存结点，这里保持和哈夫曼树表同步</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= leafSize; i++)<span class="comment">//因为一共leafSize个结点，且是从权重1开始遍历，所以要遍历到第leafSize个，应该取到leafSize</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (HFTree[j].parents != <span class="number">0</span>)<span class="comment">//不断向上寻找当前结点的父亲，并且判断当前结点是其父亲的左孩子还是右孩子，左为&#x27;0&#x27;，右为&#x27;1&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (HFTree[HFTree[j].parents].left == j)</span><br><span class="line">s.<span class="built_in">push</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">s.<span class="built_in">push</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">j = HFTree[j].parents;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">HFCode[i].<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行辅助调试</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= leafSize; i++)<span class="comment">////因为一共leafSize个结点，且是从权重1开始遍历，所以要遍历到第leafSize个，应该取到leafSize</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;data is: &quot;</span> &lt;&lt; HFTree[i].data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;code is: &quot;</span> &lt;&lt; HFCode[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于每一个叶子结点进行哈夫曼编码的时候，用字符栈保存自己的哈夫曼编码</p><p>不断向上寻找当前结点的父亲，并且判断当前结点是其父亲的左孩子还是右孩子，左为’0’，右为’1’</p><p>所有叶子结点的哈夫曼编码保存到HFCode中</p></blockquote><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>That’s all, thanks for reading!💐</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_类型&amp;变量&amp;类和对象</title>
      <link href="/chunyujin/a5010295.html"/>
      <url>/chunyujin/a5010295.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="数据类型-type"><a href="#数据类型-type" class="headerlink" title="数据类型(type)"></a>数据类型(type)</h3><p>简称类型</p><p>是具有相同特征的数据的集合，是一个抽象<strong>概念</strong></p><blockquote><p>C++的数据类型主要分为三种：</p><p><strong>原始数据类型</strong>：内置或预定义的数据类型，用户可以直接使用它们声明变量。例如：int，char，float，bool等</p><blockquote><p>整数、字符、布尔型、浮点、双浮点数、void、宽字符 等</p></blockquote><p><strong>派生数据类型</strong>：从原始或内置数据类型派生的数据类型</p><blockquote><p>函数</p><p>数组</p><p>指针</p><p>引用</p></blockquote><p><strong>用户自定义类型</strong>：这些数据类型由用户自己定义</p><blockquote><p>类</p><p>结构体</p><p>union：在并集中，所有成员共享相同的内存位置</p><p>枚举类型</p><p>typedef：为 复杂的声明 定义 简单的别名</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/20200401135258635.png" alt="20200401135258635" style="zoom:67%;" /></blockquote><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><blockquote><p>变量：数据保存在计算机中，是存储在内存中的某一块空间上，这块用来存储数据的空间就是变量，给这块空间命的名就是变量名</p><blockquote><p>变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。<a href="https://www.runoob.com/cprogramming/c-variables.html">C变量</a></p></blockquote></blockquote><p>变量类型就是存储在变量中的数据的数据类型</p><p>变量的值就是变量这块空间中存储的数据的值</p><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><blockquote><p>变量的定义，告知编译器 在内存申请一块空间 用来存储数据，数据类型是什么，空间名(即变量) 叫什么，数据的值 是什么</p><p>变量的声明，只告知编译器 在内存申请一块空间 用来存储数据，数据类型是什么，空间名(即变量) 叫什么，关于数据的值，则没有说明</p></blockquote><blockquote><p>变量的定义和声明都会在内存中申请出一块空间，区别在于是否赋予变量(中的数据)具体的值</p></blockquote><blockquote><p>无论是声明还是定义，都要指定 变量的类型，因为要按照数据类型在内存中申请对应的具体大小的空间</p></blockquote><h3 id="用户自定义类型的定义"><a href="#用户自定义类型的定义" class="headerlink" title="用户自定义类型的定义"></a>用户自定义类型的定义</h3><h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><blockquote><p>函数的定义，告知编译器 函数的返回值类型、函数名、参数、函数的实现</p><p>函数的声明，只告知编译器 函数的返回值类型、函数名、参数，不进行函数的实现</p></blockquote><p>函数的定义 &#x3D; 函数的声明 + 函数的实现</p><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><blockquote><p>类的定义，告知编译器 类的名称、类的私有成员、类的公有成员、类的成员变量的声明、类的成员函数的定义</p><p>类的声明，告知编译器 类的名称、类的私有成员、类的公有成员、类的成员变量的声明、类的成员函数的声明，不进行类的成员函数的实现</p><p>类的实现，就是类的成员函数的实现</p></blockquote><p>类的定义 &#x3D; 类的声明 + 类的(成员函数)的实现</p><blockquote><p>类和函数，有声明但没有实现，则是未定义，编译器会报错类或函数未定义(undefined)</p><p>没有声明，则编译器会报错未声明(unclear)</p></blockquote><p><strong>一般来说，在定义函数和类时，在头文件中声明，在源文件中实现</strong></p><blockquote><p>不过模版类不支持分离编译(见另一篇日记)，因此要在同一个文件中(一般是头文件)完成定义</p></blockquote><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><blockquote><p> 类是一种用户自定义类型</p><p>STL是一个 标准 模板类 库</p></blockquote><p>类是一个数据类型，是一个抽象的概念</p><p>对象是类的实例化，对象是变量</p><blockquote><p>类是封装对象的属性和行为的载体，而对象的属性以成员变量的形式存在。对象的方法以成员方法的形式存在，在成员方法内定义的变量为局部变量</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>节点和结点</title>
      <link href="/chunyujin/624685c8.html"/>
      <url>/chunyujin/624685c8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="节点和结点"><a href="#节点和结点" class="headerlink" title="节点和结点"></a>节点和结点</h3><blockquote><p>节点和结点的区别有：</p><p>节点是一个实体具有处理的能力；而结点是一个交叉点，是一个标记</p><p>一般算法中的点都称为&#x3D;&#x3D;结点&#x3D;&#x3D;</p><p>节点被认为是一个实体，有处理能力，比如网络上的一台计算机；而结点则只是一个交叉点，像”结绳记事”，打个结，做个标记，仅此而已</p><p>还有就是，要记住：一般算法中点的都是&#x3D;&#x3D;结点&#x3D;&#x3D;。</p><p> 我们在数据结构的图形表示中，对于数据集合中的每一个数据元素用中间标有元素值的方框表示，一般称它为数据结点，简称结点</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_STL用法[持续更新]</title>
      <link href="/chunyujin/de6e9320.html"/>
      <url>/chunyujin/de6e9320.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p><a href="http://c.biancheng.net/view/6749.html">vector容器详解</a></p><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p><a href="http://c.biancheng.net/view/2236.html">string用法详解</a></p><p><a href="https://blog.csdn.net/weixin_44267044/article/details/103578226">c++在string末尾添加字符或字符串</a></p><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><p><a href="http://c.biancheng.net/view/478.html">stack用法详解</a></p><h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><p><a href="http://c.biancheng.net/view/479.html">queue用法详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重点!_头文件&amp;源文件&amp;编译&amp;链接</title>
      <link href="/chunyujin/e0e64692.html"/>
      <url>/chunyujin/e0e64692.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="重点-头文件-amp-源文件-amp-编译-amp-链接"><a href="#重点-头文件-amp-源文件-amp-编译-amp-链接" class="headerlink" title="[重点!]头文件&amp;源文件&amp;编译&amp;链接"></a>[重点!]头文件&amp;源文件&amp;编译&amp;链接</h2><h4 id="C-x2F-C-支持分离式编译：一个程序可以分成多个部分保存在各个文件-头文件、源文件-中，在链接之前，各个文件-无论源文件还是头文件-是相互独立、没有关联的"><a href="#C-x2F-C-支持分离式编译：一个程序可以分成多个部分保存在各个文件-头文件、源文件-中，在链接之前，各个文件-无论源文件还是头文件-是相互独立、没有关联的" class="headerlink" title="C&#x2F;C++支持分离式编译：一个程序可以分成多个部分保存在各个文件(头文件、源文件)中，在链接之前，各个文件(无论源文件还是头文件)是相互独立、没有关联的"></a><strong>C&#x2F;C++支持分离式编译：一个程序可以分成多个部分保存在各个文件(头文件、源文件)中，在链接之前，各个文件(无论源文件还是头文件)是相互独立、没有关联的</strong></h4><blockquote><p>分离式编译是指一个完整的程序或项目由若干个源文件共同实现，每个源文件单独编译生成目标文件，最后将该项目中的所有目标文件连接成一个单一的可执行文件的过程。</p></blockquote><blockquote><p>在这里插一嘴：</p><p>&#x3D;&#x3D;<strong>#include</strong>&#x3D;&#x3D;的作用</p><p>这是一个宏定义，众所周知，宏定义就是替换，比如a.cpp中要包含a.h，写作#include”a.h”</p><p>这一行就是将#include后的”a.h”替换为a.h中的所有代码</p><blockquote><p>头文件里的内容就在这里“展开”了</p></blockquote><p><strong>但这并不能说明a.cpp和a.h是有关联的，只是a.cpp中包含了a.h，包含并不意味着有关联</strong></p><p>因为#incldue是宏定义，是替换，跟其他的宏定义一样，比如#define N 100</p></blockquote><h4 id="众所周知，-x3D-x3D-在定义变量-自定义-或者函数时，头文件保存变量-自定义-和函数的声明，源文件保存变量和函数的实现-x3D-x3D"><a href="#众所周知，-x3D-x3D-在定义变量-自定义-或者函数时，头文件保存变量-自定义-和函数的声明，源文件保存变量和函数的实现-x3D-x3D" class="headerlink" title="众所周知，&#x3D;&#x3D;在定义变量(自定义)或者函数时，头文件保存变量(自定义)和函数的声明，源文件保存变量和函数的实现&#x3D;&#x3D;"></a>众所周知，&#x3D;&#x3D;在定义变量(自定义)或者函数时，头文件保存变量(自定义)和函数的<u>声明</u>，源文件保存变量和函数的<u>实现</u>&#x3D;&#x3D;</h4><blockquote><p>头文件的作用</p><p>C&#x2F;C++编译采用的是分离编译模式。在一个项目中，有多个源文件存在，但是它们总会有一些相同的内容，比如用户自定义类型、全局变量、全局函数的声明等。将这些内容抽取出来放到头文件中，提供给各个源文件包含，就可以避免想相同内容的重复书写，提高编程效率和代码安全性。所以，设立头文件的目的主要是：提供全局变量、全局函数的声明或公用数据类型的定义，从而实现分离编译和代码复用。 </p><p>概括的说，头文件有如下三个作用。  </p><ol><li>加强类型检查，提高类型安全性。  使用头文件，可有效地保证自定义类型的一致性。虽然，在语法上，同一个数据类型（如一个class）在不同的源文件中书写多次是允许的，程序员认为他们是同一个自定义类型，但是，由于数据类型不具有外部连接特性，编译器并不关心该类型的多个版本之间是否一致，这样有可能会导致逻辑错误的发生。</li><li>减少公用代码的重复书写，提高编程效率。  程序开发过程中，对某些数据类型或者接口进行修改是在所难免的，使用头文件，只需要修改头文件中的内容，就可以保证修改在所有源文件中生效，从而避免了繁琐易错的重复修改。</li><li>提供保密和代码重用的手段。  头文件也是C++代码重用机制中不可缺少的一种手段，在很多场合，源代码不便（或不准）向用户公布，只要向用户提供头文件和二进制库即可。<u>用户只需要按照头文件的接口声明来调用库函数，而不必关心接口的具体实现，编译器会从库中连接相应的实现代码。</u>（封装性）</li></ol></blockquote><p>但是其实头文件和源文件并没有关联</p><p>比如在a.h中声明了一个类a，包含成员变量和成员函数的声明，在a.cpp中包含类a成员函数的定义(实现)</p><p>其实在编写的时候，a.h和a.cpp没有关联，编译器并不知道它俩的关系</p><p>a.cpp中对于类a的成员函数进行了定义，但a.cpp中并没有类a的声明</p><p>而a.h和a.cpp并没有关联，也就是说编译器不知道a.cpp中的类a在哪儿声明的，而类a如果没有声明，这就是一个错误</p><p>所以这就是为什么a.cpp一定要包含a.h</p><blockquote><p>如果再有一个b.h和b.cpp以及一个包含main函数的main.cpp</p><p>如果b中想要使用类a，则在b.h中包含类a的声明和定义就可以</p><p>我们知道，main.cpp中想要使用某个现有的变量或者函数，只要包含对应的<u>头文件</u>就可以</p><p>那么是不是只需要在b.h中包含头文件a.h（#include”a.h）就可以的</p><p>这是不可以的，因为a.h和a.cpp是没有关联的：a.h中只有a的声明，没有a的定义</p><blockquote><p>如果此时运行的话，在运行时会报错：缺少a的定义</p><p>但是如果不运行是不会报错的，因为a.h中虽然没有a的定义，但是有声明，并没有语法和逻辑错误</p><p>缺少a的定义是属于编译错误</p></blockquote><p>正确的做法是b.h中包含a.cpp而不是a.h</p><p>因为a.cpp中是对类a的成员函数的实现，而a.cpp中又包含a.h</p><p>话说回来，为什么main.cpp中可以包含头文件，不用包含源文件？因为<strong>链接</strong></p></blockquote><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>编译是对项目中所有的源文件（注意只是源文件，不是头文件）进行编译，将它们“翻译”成为机器能识别的机器语言，每个源文件被编译后会生成一个对应的目标文件，里面是源文件代码被翻译成的机器语言</p><p>头文件是不进行编译的，理由在下面</p><p>众所周知，main函数是程序的入口，要想执行程序，就要执行main函数</p><p>含有main函数的源文件，在这里我叫它main文件吧</p><p>main文件也是源文件，也和其他源文件一样，在编译的时候会进行编译</p><p>main文件中会包含头文件</p><p>可是头文件中只有声明，没有定义，那怎么能用对应的变量和函数呢</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>在编译之后，每个源文件都会生成一个目标文件</p><p>在执行程序时，编译之后，进行链接</p><p>main文件中含有头文件，链接就是通过头文件，找到对应的实现头文件中声明的内容的源文件，再找到这些源文件的目标文件，将这些目标文件跟main文件的目标文件“链接”起来，形成一个结合体打包起来——可执行文件</p><p>所以，因为有链接这一步，main文件中只包含头文件就行，因为链接时可以找到对应的源文件</p><p>而且链接是对于main文件而言的，也就是这一步只能用在main文件上，将main文件的目标文件 与 main文件包含的头文件对应的源文件的目标文件 结合起来</p><p>跟编译不同，一般的源文件不执行链接这个步骤，因为这是没有意义的，只有main文件是程序的接口</p><h4 id="x3D-x3D-总结-x3D-x3D"><a href="#x3D-x3D-总结-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><blockquote><ol><li></li></ol><blockquote><p>&#x3D;&#x3D;<strong>只有main文件才能只包含头文件，不包含源文件</strong>&#x3D;&#x3D;</p><p>&#x3D;&#x3D;<strong>只有库函数或者库里的类被一般源文件调用的时候，一般的源文件可以只包含对应的库头文件</strong>&#x3D;&#x3D;&#x3D;&#x3D;<strong>一般的源文件想要调用别的 自定义的类 或者 自定义的函数 的时候，要在其头文件中包含对应的源文件而不是头文件</strong>&#x3D;&#x3D;</p></blockquote><ol start="2"><li></li></ol><blockquote><p>&#x3D;&#x3D;<strong>在定义变量(自定义)或者函数时，头文件保存变量(自定义)和函数的<u>声明</u>，源文件保存变量和函数的实现</strong>&#x3D;&#x3D;</p></blockquote></blockquote><blockquote><p>源文件如何根据#include来包含头文件：</p><ol><li>系统库自带的头文件(库文件)用尖括号括起来，这样编译器会在系统库文件目录下查找。 </li><li>用户自定义的文件用双引号括起来，编译器首先会在用户目录下查找，然后在到C++安装目录（比如VC中可以指定和修改库文件查找路径，Unix和Linux中可以通过环境变量来设定）中查找，最后在系统文件中查找。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_vector访问元素的几种方式</title>
      <link href="/chunyujin/4e5ebe5e.html"/>
      <url>/chunyujin/4e5ebe5e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="C-STL-vector容器访问元素的几种方式"><a href="#C-STL-vector容器访问元素的几种方式" class="headerlink" title="C++ STL vector容器访问元素的几种方式"></a><a href="http://c.biancheng.net/view/6816.html">C++ STL vector容器访问元素的几种方式</a></h2><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20221116085628.png" alt="QQ截图20221116085628"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_取整函数</title>
      <link href="/chunyujin/d3194531.html"/>
      <url>/chunyujin/d3194531.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="C-取整函数"><a href="#C-取整函数" class="headerlink" title="C++取整函数"></a>C++取整函数</h3><h5 id="都包含在头文件cmath中"><a href="#都包含在头文件cmath中" class="headerlink" title="都包含在头文件cmath中"></a>都包含在头文件cmath中</h5><p>#include<cmath></p><h5 id="向上取整：ceil"><a href="#向上取整：ceil" class="headerlink" title="向上取整：ceil()"></a>向上取整：ceil()</h5><p>画图很好理解</p><p>无论是整数还是负数，向上取整就是向上(x轴正方向)找距离最近的整数</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211061133486.jpeg" alt="IMG_0725" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211061133405.jpeg" alt="IMG_0726" style="zoom:50%;" /><blockquote><p>ceil(1.3)</p><p>结果是2</p><p>ceil(-1.2)</p><p>结果是-1</p></blockquote><h5 id="向下取整：floor"><a href="#向下取整：floor" class="headerlink" title="向下取整：floor()"></a>向下取整：floor()</h5><p>又叫 “地板算法”</p><p>无论是整数还是负数，向上取整就是向下(x轴负方向)找距离最近的整数</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211061136576.jpeg" alt="IMG_0723" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211061136193.jpeg" alt="IMG_0724" style="zoom:50%;" /><blockquote><p>ceil(1.3)</p><p>结果是1</p><p>ceil(-1.2)</p><p>结果是-2</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>震惊!_类内成员函数可以访问本类对象的私有成员</title>
      <link href="/chunyujin/3fe5c396.html"/>
      <url>/chunyujin/3fe5c396.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="震惊-类内成员函数可以访问本类对象的私有成员"><a href="#震惊-类内成员函数可以访问本类对象的私有成员" class="headerlink" title="[震惊!]类内成员函数可以访问本类对象的私有成员"></a>[震惊!]类内成员函数可以访问本类对象的私有成员</h3><p>sList是一个类</p><p>私有成员是head，有一个成员函数的形参是本类对象(的引用，引不引用不影响结论和原因)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210301200183.png" alt="截屏2022-10-30 11.33.24" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210301200702.png" alt="截屏2022-10-30 11.33.38" style="zoom:50%;" /><h6 id="x3D-x3D-为什么呢！head明明是b的私有成员，为什么可以被访问了！！？？-x3D-x3D"><a href="#x3D-x3D-为什么呢！head明明是b的私有成员，为什么可以被访问了！！？？-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;为什么呢！head明明是b的私有成员，为什么可以被访问了！！？？&#x3D;&#x3D;"></a>&#x3D;&#x3D;为什么呢！head明明是b的私有成员，为什么可以被访问了！！？？&#x3D;&#x3D;</h6><p>因为！</p><p><strong>对象b是sList类的，而这个intersection函数是sList的成员函数</strong></p><p><strong>head虽然是sList类的对象的私有成员，但是是在sList类内访问的</strong></p><p>&#x3D;&#x3D;<strong>就是 在类内访问了本类(的实例化对象)的私有成员，这当然是可以的！ 因为这是在类内访问的，又不是在类外</strong>&#x3D;&#x3D;</p><p>这说明了，类的成员的访问权限，是对于&#x3D;&#x3D;类&#x3D;&#x3D;而言的，决定在&#x3D;&#x3D;类&#x3D;&#x3D;外是否可被访问</p><p>而非对于对象来说的（因为对象不同但是都是属于同一种类，类的实例化对象的成员，本来就是类的成员，只是抽象和实例化的问题</p><p>这非常合理地体现了 类 的封装性</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210301200083.png" alt="截屏2022-10-30 11.45.50" style="zoom:50%;" /><p>这个就是不行的，在类外访问了</p><blockquote><p>这一点是非常好用的，可以利用这一点</p><p>&#x3D;&#x3D;用成员函数肆无忌惮地访问对象的私有成员！&#x3D;&#x3D;只要声明函数是类的成员函数，将外部同类对象设为形参(或加个引用)就可以了！！</p><p>不必再为如何访问到同类外部对象的私有成员而苦思了！</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210312112520.PNG" alt="IMG_2368" style="zoom: 33%;" />]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开辟新空间与普通声明定义的一个区别</title>
      <link href="/chunyujin/2e648a29.html"/>
      <url>/chunyujin/2e648a29.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="开辟新空间与普通声明定义的一个区别"><a href="#开辟新空间与普通声明定义的一个区别" class="headerlink" title="开辟新空间与普通声明定义的一个区别"></a>开辟新空间与普通声明定义的一个区别</h4><p>如果在一个循环中，有一个语句是普通声明定义一个变量，在循环中，其实每次都是使用的同一个空间，只是在循环中反复覆盖这个空间的数据</p><p>而开辟新空间(C++的new，C的malloc等)是每次在敦区开辟一个新的空间，而且如果不手动释放，在程序结束之前一直都在占用。（所以有的时候需要手动释放，防止堆上的空间都被占用导致开辟不出新空间）</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210291419187.png" alt="截屏2022-10-29 14.14.50"></p><p>上面的代码是在一个while循环里的，Book是一个链表的结点类，数据域有IBSN、name、price</p><p>本意是想要每次都在链表尾插</p><p>如果划线的写成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Book <span class="title">b</span><span class="params">(ISBN,name,price)</span></span>;</span><br></pre></td></tr></table></figure><p>其实每次循环用的都是同一块空间，是在链表的同一个结点上反复更改数据域的ISBN、name、price而已，因为b并不是产生的新结点，b用的是原来的地址，没有分配新的空间</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表怎么排序</title>
      <link href="/chunyujin/d43e1a90.html"/>
      <url>/chunyujin/d43e1a90.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="链表怎么排序"><a href="#链表怎么排序" class="headerlink" title="链表怎么排序"></a>链表怎么排序</h4><h5 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h5><p>只交换结点的数据域，不更改指针域</p><p>这样就可以采用各种排序方式了，冒泡、选择等，根据链表的特性进行一定的更改就可以</p><h5 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h5><p>将链表放到顺序表，对顺序表排序，将顺序表每个结点的数据域依次赋值给链表的每个结点的数据域</p><p>也是不用更改指针域</p><p>参考来源</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210291314360.png" alt="iShot_2022-10-29_13.14.22" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_与Shell的关系</title>
      <link href="/chunyujin/a64800cc.html"/>
      <url>/chunyujin/a64800cc.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一个完整的计算机，整体结构如下图：</p><p><img src="https://img-blog.csdnimg.cn/67f4c5c0392d42bb949f4d5f71790a46.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZmF0ZmF0bW9tbw==,size_8,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>①我们的计算机由硬件组成，包括CPU、内存、主板、磁盘、各种外设等等。当这台计算机没有安装任何软件，只是一个硬件的集合体时，也叫做 裸机(纯硬件)。</p><p>②操作系统是系统软件，操作系统的内核控制着和管理计算机上的所有硬件和软件，从而进行任务调度、资源分配等。操作系统起到承上启下的作用。</p><p>③我们平时使用的应用软件(或叫应用程序)，如QQ音乐、英雄联盟等，是基于操作系统开发的，可以理解为在操作系统的上层。这些程序的开发往往调用了操作系统提供的接口，离开了操作系统是无法独立运行的。</p><p><strong>Shell是一个特殊的应用程序，介于操作系统内核和用户之间，是一个“命令解释器”，负责接受用户输入的指令并进行解释，将需要执行的操作传递给内核执行，并输出执行结果返回给用户。</strong></p><p><strong>在linux早期是没有图形化界面的，与系统进行交互的唯一方式就是通过shell提供的命令行界面(command-line interface, CLI)。同样在工作中，需要通过本机登录内网开发机，使用命令行界面进行开发，从而保障安全性。</strong></p><p>命令行界面只接受文本输入。我们想使用shell进行开发，则需要深入了解shell的命令，后续文章会对shell命令进行详细的介绍，本专栏主要针对想入门shell的新同学，有问题欢迎评论或私信，共同交流，一般周末公司不加班都会回复~~~</p><p>PS : 在厂里搬砖，基本都是在linux机器上进行开发的。很多同学在校时大多在机子上装个Pycharm之类的IDE就足够完成科研任务了，这也使得刚工作后不太熟悉linux开发的节奏。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_快捷键&amp;热键</title>
      <link href="/chunyujin/bd04c738.html"/>
      <url>/chunyujin/bd04c738.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-光标移动"><a href="#1-光标移动" class="headerlink" title="1. 光标移动"></a>1. 光标移动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ctrl + &lt;      # 移动到前一个单词开头</span><br><span class="line">ctrl + &gt;      # 移动到后一个单词结尾</span><br><span class="line">ctrl + A      # 移动到开头</span><br><span class="line">ctrl + E      # 移动到结尾</span><br><span class="line">alt  + B      # 向左移动一个单词</span><br><span class="line">alt  + F      # 向右移动一个单词</span><br><span class="line">ctrl + B      # 向左移动一个字符</span><br><span class="line">ctrl + F      # 向右移动一个字符</span><br><span class="line">esc  + B      # 向左移动一个单词</span><br><span class="line">esc  + F      # 向右移动一个单词</span><br><span class="line">ctrl + XX     # 在上次光和当前光标所在字符间跳转</span><br><span class="line">esc  + T      # 交换光标位置前的两个单词</span><br></pre></td></tr></table></figure><h2 id="2-拷贝-x2F-剪切-x2F-粘贴-x2F-删除"><a href="#2-拷贝-x2F-剪切-x2F-粘贴-x2F-删除" class="headerlink" title="2. 拷贝&#x2F;剪切&#x2F;粘贴&#x2F;删除"></a>2. 拷贝&#x2F;剪切&#x2F;粘贴&#x2F;删除</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* ctrl/shift + Insert # whindows下复制粘贴文本 </span><br><span class="line">* cmd + c/v # macOS下复制粘贴文本</span><br><span class="line">  ctrl + K      # 剪切光标后所有字符</span><br><span class="line">  ctrl + U      # 剪切光标前所有字符</span><br><span class="line">  ctrl + Y      # 粘贴ctrl+U/K剪切的内容</span><br><span class="line">  ctrl + W      # 删除光标前一个单词</span><br><span class="line">  ctrl + D      # 删除光标所在字符(光标右侧) #不建议使用</span><br><span class="line">  ctrl + H      # 删除光标前字符(光标左侧)</span><br></pre></td></tr></table></figure><h2 id="3-撤销"><a href="#3-撤销" class="headerlink" title="3. 撤销"></a>3. 撤销</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* ctrl + _      # 撤销操作</span><br><span class="line">  ctrl + ?      # 撤消前一次输入</span><br><span class="line">  alt  + R      # 撤消前一次动作</span><br></pre></td></tr></table></figure><h2 id="4-替换"><a href="#4-替换" class="headerlink" title="4. 替换"></a>4. 替换</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* ctrl + T      # 将光标当前字符与前面一个字符替换</span><br></pre></td></tr></table></figure><h2 id="5-历史命令编辑"><a href="#5-历史命令编辑" class="headerlink" title="5. 历史命令编辑"></a>5. 历史命令编辑</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  ctrl + P      # 上条输入的命令(相当于上键)</span><br><span class="line">  ctrl + N      # 上条历史命(相当于下键)</span><br><span class="line">  alt  + &gt;      # 上一次执行命令</span><br><span class="line">* ctrl + R      # 输入残缺指令，搜索对应完整历史指令</span><br></pre></td></tr></table></figure><h2 id="6-控制命令"><a href="#6-控制命令" class="headerlink" title="6. 控制命令"></a>6. 控制命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* ctrl + L      # 清除屏幕，相当于clear</span><br><span class="line">* ctrl + C      # (强制)终止命令&amp;另起一行</span><br><span class="line">* ctrl + D      # 退出(比如用户登出、退出shell、退出终端)</span><br><span class="line">* ctrl + Z      # 暂停并挂起当前任务</span><br><span class="line">  ctrl + I      # 补全功能(类似Tab键)</span><br><span class="line">  ctrl + O      # 重复执行命令</span><br><span class="line">  alt  + &lt;数字&gt;  # 操作的次数</span><br><span class="line">  ctrl + S      # 锁住终端，阻止屏幕输出</span><br><span class="line">  ctrl + Q      # 解锁终端，允许屏幕输出</span><br></pre></td></tr></table></figure><h2 id="7-补全-x2F-补齐"><a href="#7-补全-x2F-补齐" class="headerlink" title="7.补全&#x2F;补齐"></a>7.补全&#x2F;补齐</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tab</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单击tab实现指令补全，仅当通过残缺的指令能确定唯一的完整指令时才可以实现补全</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">双击tab实现档案补全，当通过残缺的指令无法确定唯一完整指令时，显示所有对应指令</span></span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212121406831.gif" alt="Dec-12-2022 14-04-41"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212121406885.gif" alt="Dec-12-2022 14-05-29"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git！从零开始连接远程仓库</title>
      <link href="/chunyujin/b51810cf.html"/>
      <url>/chunyujin/b51810cf.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Git！从零开始用连接远程仓库！！-全平台"><a href="#Git！从零开始用连接远程仓库！！-全平台" class="headerlink" title="Git！从零开始用连接远程仓库！！[全平台]"></a>Git！从零开始用连接远程仓库！！[全平台]</h3><p>[toc]</p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>无论你正在使用的是macOS、Linux还是Windows，总是可以使用Git这个无人争锋的 <u>版本控制系统</u>软件 进行本地仓库的构建以及将本地仓库和远程仓库(GItHub、GItee等)链接</p><p>因为原理都是一样的！</p></blockquote><p>&#x3D;&#x3D;所以实际操作都用高亮（就像是这段文字）标识出来并设为标题，方便快速操作&#x3D;&#x3D;</p><p>&#x3D;&#x3D;没有标明是在macOS、Linux还是Windows系统，说明操作基本是一样的&#x3D;&#x3D;</p><p>因为在下是苦bee大学僧，经常去教室上课，mac又是放在宿舍里的，所以有些非单一场景独占的掩饰有时是mac终端，有时是Windows Git Bash，这两者除了外观不一样，基本操作都是一样的～～</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><blockquote><p>macOS和Linux的用户电脑如今一般都自带Git～</p><p>Windows用户到官网中进行安装Git即可～</p><p>&#x3D;&#x3D;macOS、Linux的终端，与Windows的Git Bash窗口，操作命令完全是一致的！因为macOS的终端包含Git，而Windows的Git就是Git呀~&#x3D;&#x3D;</p></blockquote><p>下面让在下来展示从建立仓库到连接远程仓库的过程～～</p><h4 id="x3D-x3D-🌱步骤一➡️配置你的Git个人用户信息-x3D-x3D"><a href="#x3D-x3D-🌱步骤一➡️配置你的Git个人用户信息-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;🌱步骤一➡️配置你的Git个人用户信息&#x3D;&#x3D;"></a>&#x3D;&#x3D;🌱步骤一➡️配置你的Git个人用户信息&#x3D;&#x3D;</h4><blockquote><p>git作为一个软件，而且是作为一个版本控制的软件，每每都会涉及到文件的更改，我们对于文件的每一次更改都保存在了Git里面，所以，知道 更改文件的人是谁 是肥肠重要滴～</p><p>在git里，你需要先配置好自己的用户名和邮箱，这样你才是一个值得被信任的用户～到时候连接人家的远程仓库，人家才敢跟你连接(如果有的话～)</p></blockquote><p>Git 提供了一个叫做 <strong>git config</strong> 的工具，是专门用来 配置 和 读取 相应的工作环境变量的</p><blockquote><p>git的工作环境就是git正在工作的环境嘛（</p><p>也就是你在什么地方正在使用git，如果你在终端打开了git，那么它的工作环境就是当前整个电脑下，如果是在电脑的某个文件文件夹目录下，那git的工作环境就是在这个文件夹目录下～</p><p>工作环境变量就是工作环境的一些信息，用户信息就属于工作环境变量～</p></blockquote><p><strong>步骤</strong></p><ol><li><strong>配置个人用户名和邮箱的命令：</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email 你的邮箱</span><br></pre></td></tr></table></figure><blockquote><p>–global选项的意思是“全局”，也就是说更改的配置就在你的用户主目录</p><p>为了以后不用每个目录底下都配置一遍用户信息，我们当然选择进行全局配置鸟～</p></blockquote><ol start="2"><li><strong>配置好了之后就可以看自己的用户信息:</strong></li></ol><p>可以选择将所有的信息列出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p>也可以选择查看某个信息，比如只查看用户名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br></pre></td></tr></table></figure><p>如果不知道之前自己有没有配置用户信息，可以用查看信息的命令查看一下～～</p><blockquote><p>除了用户名和邮箱，还可以配置用户密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.password 你的密码</span><br></pre></td></tr></table></figure></blockquote><p>&#x3D;&#x3D;<u><strong>具体操作：</strong></u>&#x3D;&#x3D;</p><h5 id="x3D-x3D-macos和Linux下：-x3D-x3D"><a href="#x3D-x3D-macos和Linux下：-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;macos和Linux下：&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>macos和Linux下：</strong>&#x3D;&#x3D;</h5><blockquote><ul><li>打开一个新的<strong>终端</strong>界面</li></ul><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046666.png" alt="截屏2022-10-19 17.08.30 Redacted" style="zoom: 50%;" /><ul><li><strong>输入配置用户信息的指令</strong></li></ul><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046709.png" alt="截屏2022-10-19 17.14.58 Redacted" style="zoom:50%;" /><ul><li><strong>检查一下是否配置好</strong></li></ul><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046835.png" alt="截屏2022-10-19 17.15.05 Redacted" style="zoom:50%;" /><p>如果灰色标记标出来的三行信息跟自己刚才的配置的一样，说明成功了哦～</p></blockquote><h5 id="x3D-x3D-Windows下：-x3D-x3D"><a href="#x3D-x3D-Windows下：-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Windows下：&#x3D;&#x3D;"></a>&#x3D;&#x3D;Windows下：&#x3D;&#x3D;</h5><blockquote><ul><li><p>打开<strong>Git Bash</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046894.png" alt="image-20221020000813500" style="zoom:80%;" /></li><li><p><strong>输入配置用户信息的指令</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046946.png" alt="image-20221020002543410" style="zoom:80%;" /></li><li><p><strong>检查一下是否配置好</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046091.png" alt="image-20221020002655079" style="zoom:80%;" /></li></ul></blockquote><p>🎉恭喜，到这里，Git需要配置的前期工作已经完成了🎉</p><hr><h6 id="插一嘴-如何修改用户的配置"><a href="#插一嘴-如何修改用户的配置" class="headerlink" title="插一嘴:如何修改用户的配置"></a>插一嘴:<a href="#1.%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE">如何修改用户的配置</a></h6><hr><h4 id="x3D-x3D-🌱步骤二➡️拥有-x2F-建立一个本地仓库，并将本地文件夹文件提交进本地仓库-x3D-x3D"><a href="#x3D-x3D-🌱步骤二➡️拥有-x2F-建立一个本地仓库，并将本地文件夹文件提交进本地仓库-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;🌱步骤二➡️拥有&#x2F;建立一个本地仓库，并将本地文件夹文件提交进本地仓库&#x3D;&#x3D;"></a>&#x3D;&#x3D;🌱步骤二➡️拥有&#x2F;建立一个本地仓库，并将本地文件夹文件提交进本地仓库&#x3D;&#x3D;</h4><blockquote><p>你可以新建空的文件夹作为试验，建立一个Git的仓库，也可以用一个已经保存了文件的文件夹建成一个Git仓库</p><p>因为这都是一样的，都只是一个 <strong>将已有的文件夹</strong> 设定为 <strong>一个Git仓库</strong> 的过程</p></blockquote><p><strong>这里我就用我已经拥有的文件夹来开始</strong></p><p><strong>步骤：</strong></p><ol><li><strong>在你想要建立成仓库的文件夹打开Git</strong></li><li><strong>将这个文件夹初始化为一个Git本地仓库</strong></li></ol><p>命令为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>如果显示了 Initialized empty Git repository in …….</p><p>说明你的仓库已经初始化好了，现在有了一个空的位于当前文件夹的空仓库</p><hr><h6 id="插一嘴-如何查看仓库的状态"><a href="#插一嘴-如何查看仓库的状态" class="headerlink" title="插一嘴:如何查看仓库的状态"></a>插一嘴:<a href="#2.%E6%9F%A5%E7%9C%8B%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81">如何查看仓库的状态</a></h6><hr><ol start="3"><li><p><strong>将文件夹里的 一个文件或者所有文件 提交到Git仓库中</strong></p><ol><li>将文件添加到GIt的缓存区</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .         # 如果你想要将文件夹里所有的文件都提交到Git仓库，可以用 . 来表示当前文件夹（当前文件夹就含有所有文件不是吗</span><br><span class="line">git add 文件名(如果不是文件夹还要包涵文件后缀)       # 如果你想提交单个文件/文件夹</span><br></pre></td></tr></table></figure><blockquote><ol><li>“ .”是相对路径的写法，表示当前目录，当前目录就是现在打开的这个刚创建了一个Git仓库的文件夹呀～</li><li>为什么要先放到GIt缓存区：因为安全，放到了缓存区之后再正式提交到Git本地仓库，有了可以撤回的空间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached 文件       # 撤回刚才放到缓存区的文件</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li>查看一下此时仓库的状态，会发现有Changes to be committed的提示</li></ol><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046145.png" alt="截屏2022-10-19 22.09.22" style="zoom:50%;" /><p>​说明缓存区内有文件未提交到Git仓库</p><ol start="3"><li>将缓存区提交到Git仓库</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;提交时你想要添加的说明&quot;</span><br></pre></td></tr></table></figure><blockquote><p>”说明“是必须添加的内容，因为Git的一个作用就是追踪你对于仓库的操作，记录你何时因为什么原因更新了仓库文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046311.png" alt="截屏2022-10-21 01.00.35" style="zoom:50%;" /></blockquote></li></ol><p>&#x3D;&#x3D;具体操作：&#x3D;&#x3D;</p><h5 id="x3D-x3D-macOS和Linux下：-x3D-x3D"><a href="#x3D-x3D-macOS和Linux下：-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;macOS和Linux下：&#x3D;&#x3D;"></a>&#x3D;&#x3D;macOS和Linux下：&#x3D;&#x3D;</h5><blockquote><ul><li><p><strong>进入到想要建立成仓库的文件夹终端下：</strong></p><p>有两种方法：</p><p>方法一：用鼠标</p><p>鼠标移动到文件夹上，右击鼠标，找到“服务”</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046536.png" alt="截屏2022-10-19 19.31.47" style="zoom:50%;" /><p>“新建位于文件夹位置的终端标签页” 和 “新建位于文件夹位置的终端窗口” 都可以</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046598.png" alt="截屏2022-10-19 19.33.31 Redacted" style="zoom:50%;" /><p>此时发现进入到了文件夹的终端窗口</p><p>  方法二：用终端命令行</p><p>首先我们需要知道文件夹的路径</p><p>如果不知道可以打开一个终端窗口，并将文件夹拖进去，就可以得到这个文件夹的路径了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046704.png" alt="截屏2022-10-19 19.36.55 Redacted" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046766.png" alt="截屏2022-10-19 19.37.17 Redacted" style="zoom:50%;" /><p>我们将这个文件夹的路径复制一下</p><p>在终端中用cd指令就可以打开文件夹下的终端了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd 你刚刚复制的文件夹路径</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046821.png" alt="截屏2022-10-19 19.37.57 Redacted" style="zoom:50%;" />&gt;</p><blockquote><p>cd指令可以直接在终端中进入指定的文件路径</p></blockquote></li><li><p><strong>文件夹初始化为Git仓库</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046884.png" alt="截屏2022-10-19 19.47.11 Redacted" style="zoom:50%;" /></li><li><p>查看一下这个Git仓库状态</p><p>～如果文件夹原来没东西，应该是这样的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046936.png" alt="截屏2022-10-19 19.53.52 Redacted" style="zoom:50%;" /><p>~如果文件夹内有东西（我的CLion文件夹里放入的是hello.c），应该是这样的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046015.png" alt="截屏2022-10-19 19.55.49 Redacted" style="zoom:50%;" /><blockquote><p>关于“Unteacked files:“的信息，在<a href="#2.%E6%9F%A5%E7%9C%8B%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81">补充的内容：2.查看仓库状态</a>中有说明</p></blockquote></li><li><p>如果文件夹中原来没有文件，现在可以放入一个文件，以便测试一下下一步的操作</p><p>我的CLion文件夹里已经放入了一个 hello.c</p></li><li><p><strong>将文件夹中的 所有文件或者单个文件 添加到Git缓冲区</strong></p><p>此处我添加所有的文件（文件夹里其实也就一个hello.c文件）</p><p>并查看一下Git仓库状态</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046046.png" alt="截屏2022-10-19 19.50.17 Redacted" style="zoom:50%;" /><p>说明hello.c这个文件添加到了缓存区</p><blockquote><p>并且Git还细心提示可以用</p></blockquote></li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git rm --cached 文件</span><br></pre></td></tr></table></figure><p>来<strong>撤销刚才添加到缓存区的文件</strong></p></blockquote><ul><li><p><strong>将缓存区的文件提交到Git仓库</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046116.png" alt="截屏2022-10-19 20.01.47 Redacted" style="zoom:50%;" /><p>我添加的说明是”This is a test”，想添加什么都可以，尽量用英文</p><p>查看一下仓库状态</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046189.png" alt="截屏2022-10-19 20.03.10 Redacted" style="zoom:50%;" /><p>”nothing to commit, working tree clean“无事可做，工作树干净</p><p>意思是之前的文件都提交了，现在没有需要提交的文件了，工作树（缓存区）很干净（因为缓存区都提交了</p></li></ul></blockquote><h5 id="x3D-x3D-Windows下：-x3D-x3D-1"><a href="#x3D-x3D-Windows下：-x3D-x3D-1" class="headerlink" title="&#x3D;&#x3D;Windows下：&#x3D;&#x3D;"></a>&#x3D;&#x3D;Windows下：&#x3D;&#x3D;</h5><blockquote><ul><li><p>找到想要设为Git本地仓库的文件夹，右击，点击<strong>Git Bash Here</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046246.png" alt="image-20221020002832274" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046313.png" alt="image-20221020003438024" style="zoom:80%;" /><p>这样就在Git中进入了文件夹</p></li><li><p><strong>文件夹初始化为Git仓库</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046369.png" alt="image-20221020003654246" style="zoom:80%;" /></li><li><p>查看一下这个Git仓库的状态</p><p>如果文件夹中原来没有文件，应该是这样的~</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046445.png" alt="image-20221020003829168" style="zoom:80%;" /><p>如果文件夹中原来有文件（比如我的CLion文件夹原来有一个hello.c文件)，是这样的~</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046499.png" alt="image-20221020005253111" style="zoom:80%;" /><blockquote><p>关于“Unteacked files:“的信息，在<a href="#2.%E6%9F%A5%E7%9C%8B%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81">补充的内容：2.查看仓库状态</a>有说明</p></blockquote></li><li><p>如果文件夹中原来没有文件，现在可以放入一个文件，以便测试一下下一步的操作</p><p>我的CLion文件夹里已经放入了一个 hello.c</p></li><li><p><strong>将文件夹中的 所有文件或者单个文件 添加到Git缓冲区</strong></p><p>此处我添加所有的文件（文件夹里其实也就一个hello.c文件）</p><p>并查看一下Git仓库状态</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046563.png" alt="image-20221020010248818" style="zoom:80%;" /><p>说明hello.c这个文件添加到了缓存区</p><blockquote><p>并且Git还细心提示可以用 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached 文件</span><br></pre></td></tr></table></figure><p>来撤销刚才添加到缓存区的文件</p></blockquote></li><li><p><strong>将缓存区的文件提交到Git仓库</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046613.png" alt="image-20221020010408321" style="zoom:80%;" /><p>我添加的说明是”This is a test”，想添加什么都可以，尽量用英文</p><p>查看一下仓库状态</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046665.png" alt="image-20221020010442512" style="zoom:80%;" /><p>”nothing to commit, working tree clean“无事可做，工作树干净</p><p>意思是之前的文件都提交了，现在没有需要提交的文件了，工作树（缓存区）很干净（因为缓存区都提交了</p></li></ul></blockquote><p>🎉恭喜，到这一步，你已经有了一个Git本地仓库，并学会了如何往仓库中提交文件🎉</p><hr><h6 id="插一嘴-仓库的分支—-在查看仓库的时候，第一行中的”On-branch-XXX”是啥"><a href="#插一嘴-仓库的分支—-在查看仓库的时候，第一行中的”On-branch-XXX”是啥" class="headerlink" title="插一嘴:仓库的分支—-在查看仓库的时候，第一行中的”On branch XXX”是啥"></a>插一嘴:<a href="#3.%5B%E9%87%8D%E7%82%B9%5D%E4%BB%93%E5%BA%93%E7%9A%84%E5%88%86%E6%94%AF">仓库的分支—-在查看仓库的时候，第一行中的”On branch XXX”是啥</a></h6><hr><h4 id="x3D-x3D-🌱步骤三➡️拥有-x2F-建立一个远程仓库，并将你的本地GIt的SSH-key公钥添加到远程仓库-—-Gitee为例-x3D-x3D"><a href="#x3D-x3D-🌱步骤三➡️拥有-x2F-建立一个远程仓库，并将你的本地GIt的SSH-key公钥添加到远程仓库-—-Gitee为例-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;🌱步骤三➡️拥有&#x2F;建立一个远程仓库，并将你的本地GIt的SSH key公钥添加到远程仓库 —-Gitee为例&#x3D;&#x3D;"></a>&#x3D;&#x3D;🌱步骤三➡️拥有&#x2F;建立一个远程仓库，并将你的本地GIt的SSH key公钥添加到远程仓库 —-Gitee为例&#x3D;&#x3D;</h4><blockquote><p>因为macOS和Linux都是默认安装Git的，所以自带Git的SSH key</p><p>Windows安装了Git之后就自带Git的SSH key了</p></blockquote><blockquote><p>SHH key分为公钥和密钥</p><p>如果想要远程仓库能 接收 本地仓库的文件，需要在远程仓库中添加本地Git的公钥，授权成功后，远程仓库根据本地Git的公钥匹配本地Git的密钥，Git才有权将本地仓库的文件上传到远程仓库</p><p>否则就算与远程仓库建立了链接，也只能获取远程仓库的文件而不能上传到远程仓库（本地Git对远程仓库只能读不能写</p></blockquote><h5 id="x3D-x3D-建立一个远程仓库—-Gitee为例-x3D-x3D"><a href="#x3D-x3D-建立一个远程仓库—-Gitee为例-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;建立一个远程仓库—-Gitee为例&#x3D;&#x3D;"></a>&#x3D;&#x3D;建立一个远程仓库—-Gitee为例&#x3D;&#x3D;</h5><blockquote><ul><li><p>进入到Gitee官网，网页右上角会发现</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046713.png" alt="截屏2022-10-19 22.27.47" style="zoom: 40%;" /></li><li><p>填写仓库名称，”初始化仓库“的选项勾不勾都是可以的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046789.png" alt="截屏2022-10-19 22.29.13 Redacted" style="zoom:50%;" /></li><li><p>进入到仓库中会是这样的（如果勾选了“初始化仓库”，仓库中会有下图的文件，没有的话就没有）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046868.png" alt="截屏2022-10-19 22.29.39 Redacted" style="zoom:50%;" /></li><li><p>这样一个远程仓库就建立好了</p></li><li><p>🎉这一步就完成了</p></li></ul></blockquote><h5 id="x3D-x3D-macOS和Linux下获取本地Git的SSH-key公钥：-x3D-x3D"><a href="#x3D-x3D-macOS和Linux下获取本地Git的SSH-key公钥：-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;macOS和Linux下获取本地Git的SSH key公钥：&#x3D;&#x3D;"></a>&#x3D;&#x3D;macOS和Linux下获取本地Git的SSH key公钥：&#x3D;&#x3D;</h5><blockquote><ul><li><p>打开一个终端</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046938.png" alt="image-20221020151601824" style="zoom:80%;" /></li><li><p>以防万一，先测试一下Git是否安装了SSH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh</span><br></pre></td></tr></table></figure><p>如果出现了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046002.png" alt="截屏2022-10-19 21.01.32 Redacted" style="zoom:50%;" /><p>说明带有SSH，否则自行下载安装（在终端中输出<code>sudo apt-get install ssh</code>即可）</p></li><li><p>紧接着，输入以下指令【注意，如果确定本地ssh已经生成了密钥和公钥，请跳过这一步】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>就会在<strong>安装了SSH的路径</strong>上生成<strong>id-rsa (密钥文件</strong>)和<strong>id-rsa.pub (公钥文件)</strong></p></li><li><p>macOS和Linux的SSH路径在~&#x2F;.ssh下</p><blockquote><p>~的意思是个人文件夹</p><p>就是   &#x2F;Users&#x2F;你自己的用户名</p><p>所以~&#x2F;.ssh 就是 &#x2F;User&#x2F;你自己的用户名&#x2F;.ssh</p></blockquote></li><li><p>获得SSH公钥：</p><p>方法一:</p><p>打开一个终端，在终端中输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /User/你自己的用户名/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046064.png" alt="截屏2022-10-19 21.45.49 Redacted Redacted" style="zoom:50%;" /><p><strong><u>中间的这一大段的就是本地Git的SSH 公钥，复制它即可</u></strong></p><p>方法二：</p><p>打开一个终端，直接用cd指令进入到.ssh文件夹下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046169.png" alt="截屏2022-10-20 00.02.44 Redacted" style="zoom:50%;" /><p><strong><u>中间的这一大段就是本地Git的SSH 公钥，复制它即可</u></strong></p></li><li><p>🎉这一步就完成了</p></li></ul></blockquote><h5 id="x3D-x3D-Windows下获取本地Git的SSH-key公钥：-x3D-x3D"><a href="#x3D-x3D-Windows下获取本地Git的SSH-key公钥：-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Windows下获取本地Git的SSH key公钥：&#x3D;&#x3D;"></a>&#x3D;&#x3D;Windows下获取本地Git的SSH key公钥：&#x3D;&#x3D;</h5><blockquote><ul><li><p>打开Git Bash</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046309.png" alt="image-20221020151305597" style="zoom:80%;" /></li><li><p>以防万一，先看一下Git有没有安装SSH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh</span><br></pre></td></tr></table></figure><p>如果出现了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046366.png" alt="image-20221020150100500" style="zoom:80%;" /><p>说明安装了SSH，否则请自行下载安装（在Git Bash中输入<code>sudo apt-get install ssh</code>即可）</p></li><li><p>紧接着，输入以下指令 【注意，如果确定本地ssh已经生成了密钥和公钥，请跳过这一步】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>就会在<strong>安装了SSH的路径</strong>上生成<strong>id-rsa (密钥文件</strong>)和<strong>id-rsa.pub (公钥文件)</strong></p></li><li><p>Windows的SSH路径在~&#x2F;.ssh下</p><blockquote><p>~的意思是个人文件夹</p><p>就是   &#x2F;Users&#x2F;你自己的用户名</p><p>所以~&#x2F;.ssh 就是 &#x2F;User&#x2F;你自己的用户名&#x2F;.ssh</p></blockquote></li><li><p><strong>获得SSH公钥：</strong></p><p>方法一:</p><p>在Git Bash中输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /User/你自己的用户名/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046410.png" style="zoom:80%;" /><p><strong><u>中间的这一大段就是本地Git的SSH 公钥，复制它即可</u></strong></p><p>方法二：</p><p>在Git Bash中，直接用cd指令进入到.ssh文件夹下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046482.png" alt="image-20221020151035414" style="zoom:80%;" /><p><strong><u>中间的这一大段就是本地Git的SSH 公钥，复制它即可</u></strong></p></li><li><p>🎉这一步就完成了</p></li></ul></blockquote><hr><h6 id="插一嘴-如何查看隐藏文件"><a href="#插一嘴-如何查看隐藏文件" class="headerlink" title="插一嘴:如何查看隐藏文件"></a>插一嘴:<a href="#4.%E6%9F%A5%E7%9C%8B%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6">如何查看隐藏文件</a></h6><hr><h5 id="x3D-x3D-将本地Git的SSH-key公钥添加到远程Gitee仓库：-x3D-x3D"><a href="#x3D-x3D-将本地Git的SSH-key公钥添加到远程Gitee仓库：-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;将本地Git的SSH key公钥添加到远程Gitee仓库：&#x3D;&#x3D;"></a>&#x3D;&#x3D;将本地Git的SSH key公钥添加到远程Gitee仓库：&#x3D;&#x3D;</h5><blockquote><ul><li><p>点击GItee的<strong>头像-设置</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046574.png" alt="截屏2022-10-19 22.56.01" style="zoom:50%;" /></li><li><p>点击左侧的<strong>SHH公钥</strong>（因为我已经添加了一个公钥了，所以显示的是公钥数为1，否则是0）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046666.png" alt="截屏2022-10-19 22.56.33 Redacted" style="zoom:50%;" /></li><li><p>将之前获得的SSH 公钥填进第二个框，第一个框就自动填充了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046723.png" alt="截屏2022-10-19 22.42.12" style="zoom:40%;" /></li><li><p>添加好了就是这样的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046838.png" alt="截屏2022-10-19 22.48.15 Redacted" style="zoom:50%;" /></li></ul></blockquote><h5 id="x3D-x3D-本地仓库连接到远程Gitee仓库：-x3D-x3D"><a href="#x3D-x3D-本地仓库连接到远程Gitee仓库：-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;本地仓库连接到远程Gitee仓库：&#x3D;&#x3D;"></a>&#x3D;&#x3D;本地仓库连接到远程Gitee仓库：&#x3D;&#x3D;</h5><blockquote><ul><li><p>获取Gitee仓库的ssh链接，直接复制</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046966.png" alt="截屏2022-10-19 22.59.35 Redacted"></p></li><li><p>在本地Git仓库里输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin 你刚才复制的Gitee仓库的ssh</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046981.png" alt="截屏2022-10-19 23.04.34 Redacted" style="zoom:50%;" /><p>没有报错说明连接上了</p></li><li><p>🎉这一步就完成了</p></li></ul></blockquote><h4 id="x3D-x3D-🌱步骤四➡️pull-和-push-本地仓库与远程仓库的文件提交和获取-x3D-x3D"><a href="#x3D-x3D-🌱步骤四➡️pull-和-push-本地仓库与远程仓库的文件提交和获取-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;🌱步骤四➡️pull 和 push(本地仓库与远程仓库的文件提交和获取)&#x3D;&#x3D;"></a>&#x3D;&#x3D;🌱步骤四➡️pull 和 push(本地仓库与远程仓库的文件提交和获取)&#x3D;&#x3D;</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin 远程仓库分支名</span><br><span class="line">git pull origin 远程仓库分支名</span><br></pre></td></tr></table></figure><blockquote><p><strong>push：“推”，将本地仓库当前分支的文件 上传合并&#x2F;推送合并 到远程仓库某个分支</strong></p><p><strong>pull：“拉”，将远程仓库某个分支的文件 下拉合并&#x2F;获取合并 到本地仓库当前分支</strong></p></blockquote><p>比如我们现在将这个”测试用文件夹”master分支的仓库，push到已经连接的远程仓库test的master分支</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046029.png" alt="截屏2022-10-21 01.45.01" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046093.png" alt="截屏2022-10-21 01.44.30" style="zoom:50%;" /><p>可以看到远程仓库里已经有了本地仓库的所有文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046170.png" alt="截屏2022-10-21 01.47.20" style="zoom:50%;" /><p>然后我们随便在远程仓库添加一个文件，来模拟别的本地仓库push文件到远程仓库test</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046214.png" alt="截屏2022-10-21 01.49.21" style="zoom:50%;" /><p>现在在本地仓库pull远程仓库test的master分支仓库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046274.png" alt="截屏2022-10-21 01.52.04" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046329.png" alt="截屏2022-10-21 01.53.07" style="zoom:50%;" /><p>成功了（好耶</p><blockquote><p>⚠️push、pull总是取双方仓库每个文件的最新状态</p><p>⚠️因为是Git仓库，所以无论是push还是pull，都是对于仓库内的文件进行的下拉、提交，没有提交到仓库里的文件，Git是无权管理的</p><blockquote><p>比如，我在当前分支(master)CLion文件夹里添加了一个hello.c文件，并不把它提交到仓库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046385.png" alt="截屏2022-10-20 22.08.04" style="zoom:50%;" /><p>现在我将远程仓库master分支的所有文件下拉到本地仓库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046454.png" alt="截屏2022-10-20 22.09.05 Redacted" style="zoom:50%;" /><p>远程仓库的master分支里本来是没有hello.c文件的，而本地仓库master分支里也没有(因为没提交到仓库)，所以没有涉及到关于hello.c文件的跟踪，hello.c还是存在于CLion文件夹(但并不在本地仓库master分支里)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046385.png" alt="截屏2022-10-20 22.08.04" style="zoom:50%;" /><p>如果现在查看仓库状态</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046498.png" alt="截屏2022-10-20 22.12.02 Redacted" style="zoom:50%;" /><p>Look，确实是这样的</p><p>如果将hello.c添加到本地仓库master分支，再从远程仓库master分支pull到本地仓库当前分支</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046735.png" alt="截屏2022-10-20 22.14.15 Redacted" style="zoom:50%;" /><p>发现，诶？不对诶，怎么CLion文件夹中还有hello.c文件？</p><p>因为Git跟踪的hello.c状态，远程与本地相比，在本地的状态是最新的，因为远程：没跟踪到hello.c文件(连状态都没有)，本地：于XX日期XX时刻创建了hello.c文件，当然是本地的最新啦</p><p>那么，我们先将本地仓库push到远程仓库，再到远程仓库去删除这个hello.c文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046893.png" alt="截屏2022-10-20 22.19.34 Redacted" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046957.png" alt="截屏2022-10-20 22.19.45 Redacted" style="zoom:50%;" /><p>那这样远程仓库的hello.c状态就比本地仓库新了：于xxx时刻被删除</p><p>再次将远程仓库pull到本地仓库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046131.png" alt="截屏2022-10-20 22.22.35 Redacted" style="zoom:50%;" /><p>(界面往往包含很多信息，比如这个，显示hello.c的最新的状态是在远程仓库被删除了)</p><p>看一下本地CLion文件夹</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046186.png" alt="截屏2022-10-20 22.24.17" style="zoom:50%;" /><p>明白了吧～～</p></blockquote></blockquote><p>因为不止一个本地仓库可以访问远程仓库，所以如果你不知道自己本地仓库的版本比远程仓库是新还是旧</p><p>每次开始工作时建议先将远程仓库pull到本地仓库，因为pull和push总是取文件最新状态嘛～～</p><p><a href="https://blog.csdn.net/wys0127/article/details/123856744">git 为什么要先commit，然后pull，最后再push？而不是commit然后直接push？</a></p><p>🎉恭喜，到这一步，你已经掌握了如何在本地仓库和远程仓库进行文件提交和获取了🎉</p><h4 id="“插一嘴”补充的内容："><a href="#“插一嘴”补充的内容：" class="headerlink" title="“插一嘴”补充的内容："></a>“插一嘴”补充的内容：</h4><h6 id="1-如何修改用户配置"><a href="#1-如何修改用户配置" class="headerlink" title="1.如何修改用户配置"></a>1.如何修改用户配置</h6><blockquote><p>如果单纯想要修改用户配置，只需要用添加用户配置的命令就可以了，因为新的配置会覆盖旧的配置</p></blockquote><blockquote><p>如果想要删除用户配置，比如删除用户名、邮箱、密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset user.name</span><br><span class="line">git config --global --unset user.email</span><br><span class="line">git config --global --unset user.password</span><br></pre></td></tr></table></figure><p>删除了用户名和邮箱，在连接远程仓库的时候可能会被认为本地Git不安全（因为都没有报上名来~~</p><p>删除了密码，则在进行一些操作时会跳过输入密码的环节，方便但是不是很安全，因为往往是在一些“确认要进行操作吗”的操作时需要你输入密码来确认，如果没有密码就直接跳过了~</p></blockquote><p><a href="#%E6%8F%92%E4%B8%80%E5%98%B4:%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E7%9A%84%E9%85%8D%E7%BD%AE">点这里返回上次阅读的位置</a></p><h6 id="2-查看仓库状态"><a href="#2-查看仓库状态" class="headerlink" title="2.查看仓库状态"></a>2.查看仓库状态</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>这是一个使用很频繁的命令，有时候你就是想看看现在仓库处于什么状态，有时候你会忘记自己有没有将文件夹下已经更改的文件提交到Git仓库，等等等等，反正只要你想看一下仓库状态，就会用它～</p><blockquote><p>比如到现在为止，我们只是完成了仓库的初始化，还没有向仓库中提交任何文件</p><ul><li>如果文件夹中本来是没有文件的，我们查看一下仓库的状态</li></ul><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046235.png" alt="截屏2022-10-19 17.53.32 Redacted" style="zoom:50%;" /><p>可以看到 “No commits yet”（还没有任何提交）</p><ul><li>如果文件夹里原来是有文件的（比如一个文件hello.c），我们查看一下仓库的状态</li></ul><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046288.png" alt="截屏2022-10-19 19.19.26 Redacted" style="zoom:50%;" /><p>可以看到Git检测到文件夹里有一个新的文件”未被跟踪”（Untracked files ：）</p><p>在括号里提示了用什么命令来将hello.c文件放入缓存区</p><p>下面的红色的hello.c就是未被添加到缓存区的文件</p><blockquote><p>“跟踪”，因为Git本身是一个版本控制软件，说白了就是记录并保存下来你每次对于文件的更改（这个就叫跟踪，知道你什么时候修改的什么文件）</p><p>&#x3D;&#x3D;<strong>只有将修改了的文件添加到Git的缓存区，文件状态才能被Git跟踪</strong>&#x3D;&#x3D;</p><p>&#x3D;&#x3D;当你完成了所有的工作、已经不需要再对任何文件进行更改，就执行最后一步：将缓存区的文件提交到Git，这样仓库里的文件就会更新了&#x3D;&#x3D;</p><blockquote><p>修改，当然是包括添加新文件、删除旧文件、更改现有文件等~</p></blockquote></blockquote></blockquote><p><a href="#%E6%8F%92%E4%B8%80%E5%98%B4:%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%BB%93%E5%BA%93%E7%9A%84%E7%8A%B6%E6%80%81">点这里返回刚才阅读的位置</a></p><h6 id="3-重点-仓库的分支"><a href="#3-重点-仓库的分支" class="headerlink" title="3.[重点]仓库的分支"></a>3.[重点]仓库的分支</h6><p>branch 即为“分支”</p><p>如果用户a和用户b同时对于项目进行修改，仓库为了防止两人的修改相互影响，会形成两条分支来分别保存a、b的修改，这样a、b对于项目的修改都在自己的那条分支上，等到ab的工作完成了，就可以选择统一将分支合并起来</p><blockquote><p>在仓库初始化(执行了git init)之后，会默认生成一个主分支master，也就是在Windows的Git Hash窗口中显示的这个绿色的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046347.png" alt="image-20221020171909705" style="zoom:80%;" /><p>在macOS和Linux下的终端里不会主动显示当前分支名字，但是也可以在某些地方看到</p><p>比如在查看仓库状态下(Windows的Git Bash里也一样)</p><p>当然，在这个终端窗口里，显示我的这个分支名字是main，那是因为我改名了hhh~</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046936.png" alt="截屏2022-10-19 19.53.52 Redacted" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046445.png" alt="image-20221020003829168" style="zoom:80%;" /></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p><strong>显示当前仓库下所有的分支</strong></p><p>这个命令可以查看当前仓库的所有分支，并用“ * ”标记出用户当前使用的分支</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046596.png" alt="image-20221020172917614" style="zoom:80%;" /><p>可以看到现在我只有一个分支master，并处在这个分支上</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 新分支名称</span><br></pre></td></tr></table></figure><p><strong>增加一个分支</strong></p><p>这个命令会增加一个分支，新增的分支会复制原有分支的所有内容，保证新分支的初始内容和原分支一样</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046663.png" alt="image-20221020173709847" style="zoom:80%;" /><p>看到新增加了一个分支a</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 想要切换到的分支</span><br></pre></td></tr></table></figure><p><strong>切换当前分支</strong></p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046764.png" alt="image-20221020174000192" style="zoom:80%;" /><p>看到切换了分支（甚至在Git Bash中还会用蓝色的字体标出来当前分支，这还是很银杏化的~~</p><p>mac和Linux泪目….</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 新分支名称</span><br></pre></td></tr></table></figure><p><strong>新增一个分支并切换到这个新分支</strong></p><p>就是上两个操作的简化~~</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046825.png" alt="image-20221020191116028" style="zoom:80%;" /></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 要合并到当前分支的分支名</span><br></pre></td></tr></table></figure><p>将某个分支合并到<strong>当前分支</strong></p><p>注意：只能将别的分支合并到当前分支，因此合并前要注意一下当前分支</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046943.png" alt="image-20221020191856740" style="zoom:80%;" /><p>可以看到，分支合并到master之后，原分支并不会被删除~</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d 要删除的分支名</span><br></pre></td></tr></table></figure><p>删除某个分支</p><p>前提：1.不能删除当前所在的分支，执行删除前记得切换分支</p><p>​2.如果一个分支在创建后<u>仓库内容被修改(提交到了Git仓库才能被追踪，才能判断被修改)</u>，并且<u>没有合并到其他分支</u>，是不允许被删除的</p><blockquote><p>在master分支下创建分支a和b</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046994.png" alt="image-20221020193904453" style="zoom:80%;" /><p>切换到分支a，在文件夹中创建一个hello.txt文件，但不提交到仓库里</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047046.png" alt="image-20221020194217899" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047219.png" alt="image-20221020194305055" style="zoom:80%;" /><p>然后切换到master，删除a，发现正常删除了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047280.png" alt="image-20221020201631869" style="zoom:80%;" /><p>但是如果分支a下，文件夹下添加的hello.txt文件提交到了Git里，再回到master分支删除分支a，就会报错，分支a尚未合并到其他分支</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047331.png" alt="image-20221020202208027" style="zoom:80%;" /></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D 要删除的分支名</span><br></pre></td></tr></table></figure><p>强制删除某个分支</p><p>”强制“在于可以删除 未合并到其他分支的 已修改的分支</p><blockquote><p>上面那张图片也说了，If you are sure you want to delete it, run ‘git branch -D a’</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047382.png" alt="image-20221020202701428" style="zoom:80%;" /></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag 标签/版本名称</span><br></pre></td></tr></table></figure><p>为当前的仓库状态添加一个标签，就像每次软件的版本一样~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><p>查看所有标签&#x2F;版本</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047440.png" alt="截屏2022-10-20 21.57.34 Redacted" style="zoom:50%;" /></blockquote><p>&#x3D;&#x3D;<strong>总结一个很重要的知识点</strong>&#x3D;&#x3D;</p><blockquote><p>如果我们在只有一个分支master的仓库，再添加一个分支a，并切换到分支a</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047509.png" alt="截屏2022-10-21 01.04.54" style="zoom:50%;" /><p>原来的时候仓库master分支里有一个test.txt文件，因为构建了一个分支，master分支里的所有文件也都复制到了a分支里</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047566.png" alt="截屏2022-10-21 01.05.41" style="zoom:50%;" /><p>现在我们正处在分支a，我们添加一个文件A.txt到分支a仓库里面</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047662.png" alt="截屏2022-10-21 01.08.08" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047725.png" alt="截屏2022-10-21 01.09.22" style="zoom:50%;" /><p>现在切换到master分支</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047769.png" alt="截屏2022-10-21 01.10.31" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047843.png" alt="截屏2022-10-21 01.11.01" style="zoom:50%;" /><ul><li>&#x3D;&#x3D;<strong>我们可以体会到：分支是相互独立的</strong>&#x3D;&#x3D;</li></ul><p>我们再切回到分支a</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047900.png" alt="截屏2022-10-21 01.12.38" style="zoom:50%;" /><p>嗯没错没毛病，A.txt又回来了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047954.png" alt="截屏2022-10-21 01.13.21" style="zoom:50%;" /><p>好，现在再在分支a的文件夹里添加一个B.txt，但是这次不提交到分支a的仓库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047024.png" alt="截屏2022-10-21 01.14.34" style="zoom:50%;" /><p>我们直接切换到分支master</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047080.png" alt="截屏2022-10-21 01.15.15" style="zoom:50%;" /><p>发现分支为master时的文件夹里，有B.txt</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047133.png" alt="截屏2022-10-21 01.16.00" style="zoom:50%;" /><p>这并不是因为B.txt从分支a的仓库复制到了分支master的仓库</p><p>而是因为B.txt既不属于分支a仓库，也不属于分支master</p><p>它并不存在于Git仓库里</p><ul><li><p>&#x3D;&#x3D;<strong>我们可以发现</strong>&#x3D;&#x3D;</p><p>&#x3D;&#x3D;<strong>Git仓库 不等于 整个文件夹，文件夹的文件提交到GIt仓库之后才属于仓库，否则只是一个存在于文件夹但是不存在于仓库的文件&#x3D;&#x3D;</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047204.png" alt="截屏2022-10-21 01.24.33" style="zoom:50%;" /></li></ul><p>现在我们切换回a分支</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047900.png" alt="截屏2022-10-21 01.12.38" style="zoom:50%;" /><p>好，之前不是在文件夹里创建了一个B.txt但是没有提交到分支a的仓库嘛</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047266.png" alt="截屏2022-10-21 01.28.55" style="zoom:50%;" /><p>现在我们将它添加到分支a的缓存区，但不提交到仓库里</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047327.png" alt="截屏2022-10-21 01.29.32" style="zoom:50%;" /><p>切换到master分支</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047387.png" alt="截屏2022-10-21 01.31.54 Redacted" style="zoom:50%;" /><p>可以发现切换的时候有一个关于B.txt的提示，并且master分支下，文件夹里还是有B.txt</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047445.png" alt="截屏2022-10-21 01.36.12" style="zoom:50%;" /><p>说明B.txt文件还是不属于Git仓库</p><p>但是能检测到B.txt的动向了，说明</p><ul><li>&#x3D;&#x3D;<strong>将文件添加到缓存区，只是给了Git跟踪文件状态的权利，但是文件并不会进入到Git仓库里，除非提交到仓库</strong>&#x3D;&#x3D;</li></ul></blockquote><p>[点这里返回刚在阅读的位置](#插一嘴:仓库的分支—-在查看仓库的时候，第一行中的”On branch XXX”是啥)</p><h6 id="4-查看隐藏文件"><a href="#4-查看隐藏文件" class="headerlink" title="4.查看隐藏文件"></a>4.查看隐藏文件</h6><p>macOS和Linux下：</p><blockquote><p>以”.”开头的文件都是隐藏文件，我们可以先打开访达</p><p>在左侧列表中找到 位置 下的个人电脑的文件夹</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047501.png" alt="截屏2022-10-19 21.34.50" style="zoom: 50%;" /><p>打开Macintosh HD - 用户 - 自己用户名的文件夹</p><p>然后在这个文件夹里按下⇧ + ⌘ +. </p><p>就可以显示隐藏文件，再按一遍就可以关闭显示隐藏文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047598.png" alt="截屏2022-10-19 21.37.12" style="zoom:50%;" /></blockquote><p><a href="#%E6%8F%92%E4%B8%80%E5%98%B4:%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6">点这里返回刚才阅读的位置</a></p><p>参考文章：《从0开始的Github》</p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从CLion和VsCode的小发现到C++的编译</title>
      <link href="/chunyujin/f61f63a.html"/>
      <url>/chunyujin/f61f63a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="一场编译环境的配置让我简单思考了一下VsCode和CLion的一个小区别"><a href="#一场编译环境的配置让我简单思考了一下VsCode和CLion的一个小区别" class="headerlink" title="一场编译环境的配置让我简单思考了一下VsCode和CLion的一个小区别"></a>一场编译环境的配置让我简单思考了一下VsCode和CLion的一个小区别</h5><ul><li>CLion、VS2022一个界面只能容纳一个项目</li></ul><p>​因此一个界面只能打开一个项目</p><blockquote><p>好像是因为这两种编译器对每个项目都配置对应的环境（我猜的，因为每个项目里面有独立的配置文件</p></blockquote><ul><li>VsCode一个界面可以容纳多个项目，在”工作区”中通过不同的文件夹区分不同的项目</li></ul><p>​因此一个界面可以打开多个项目</p><blockquote><p>VsCode一个环境配置文件可以配置整个工作区中的所有文件的环境（只要工作区一级目录包含一个配置文件文件夹，工作区的所有项目都用这个文件夹，而且配置文件夹可以添加编译环境，因为一个工作区既可以编译C、C++，也可以编辑Python等，只需要下载相应的插件并将配置添加到配置文件夹就可以</p></blockquote><blockquote><p>任何程序，一个项目里面只能存在一个main函数</p></blockquote><blockquote><p>《C++ Primer Plus 第六版》1.4中写，Windows编译器如果要编译程序，要为程序创建一个项目才行，并将组成程序的文件添加到该项目中。项目中有编译器提供的IDE(集成开发环境)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210181521940.png" alt="截屏2022-10-18 15.18.36" style="zoom:40%;" /></blockquote><p>CLion、VS2022是名副其实的“编译器”</p><p>VsCode其实算是一个“编辑器”，通过各种插件来完成编译功能</p><p>所以就编辑而言，其实VsCode还是方便一点呢，一个窗口就能编辑多个项目了；而且vscode更轻量级，打开速度更快</p><p>但是就进行开发比较大的一个项目而言，还得是Clion、Xcode、VS2022，因为术业有专攻嘛~就开发、编译而言，还是它们更全面更强大</p><blockquote><p>Python因为不需要main函数，并且Python只有一种文件类型就是.py，一个.py文件就是一个项目。所以一个界面里也就没有容纳的项目个数之说啦</p><p>PyCharm一个界面就能存在所有的项目</p><p>Python的配置环境就是下载到本地的Python环境，PyCharm用的就是本地的Python环境，因此项目里不用包含环境配置文件（大概</p><p>这应该也是PyCharm一个界面可以同时存在多个项目的原因</p></blockquote><blockquote><p>CLion的Git并不是很讨喜，因为同步的时候一个窗口只能上传一个项目，所以一个项目就会占用一个仓库</p><p>相比之下，PyCharm和VsCode则可以保证一个仓库里面存在多个项目或者文件夹，还是很方便滴～</p></blockquote><p>编译器之类的都是程序猿攻城狮的工具</p><p>当然会用的工具越多越好呀～</p><p>学会在不同的编译环境下敲代码是一件好事～～</p><p>为啥要用好用的编译器，不直接敲命令行？</p><p>因为好用的编译器能提供代码补全、报错、调试、同步到Git等等等等非常好用的功能呀～～</p><p>越专业越好用呀～</p><h5 id="编写C-程序并让它运行的过程"><a href="#编写C-程序并让它运行的过程" class="headerlink" title="编写C++程序并让它运行的过程"></a>编写C++程序并让它运行的过程</h5><blockquote><p>具体步骤根据计算机环境和C++编译器是有区别的，但是都有以下大体的过程（from《C++ Primer Plus 第六版》1.4程序创建的技巧</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210181446645.png" alt="截屏2022-10-18 14.46.17" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210181447632.png" alt="截屏2022-10-18 14.46.10" style="zoom: 20%;" /><h5 id="UNIX下用CC命令行调用cfront编译器实现C-的编译过程"><a href="#UNIX下用CC命令行调用cfront编译器实现C-的编译过程" class="headerlink" title="UNIX下用CC命令行调用cfront编译器实现C++的编译过程"></a>UNIX下用CC命令行调用cfront编译器实现C++的编译过程</h5><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210181449714.png" alt="769b9e7578283e1b368621646ba2f3ae" style="zoom:50%;" /><p>Linux则是用的g++编译器，工作方式跟标准的UNIX编译器相近，此处主要是展示一下编译过程</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_new对象加括号和不加括号的区别</title>
      <link href="/chunyujin/166a8a1f.html"/>
      <url>/chunyujin/166a8a1f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://blog.csdn.net/a2796749/article/details/46908035">https://blog.csdn.net/a2796749/article/details/46908035</a></p><p>总结起来就是：<br>如果在使用new在堆上开辟某一类型的空间的时候</p><ul><li><p>如果是非自定义类型（int等），后面加括号的话，就以为了进行初始化，如果括号内有参数，就初始化为参数，如果没有参数（就是只有括号，什么都没有），就初始化为0</p></li><li><p>如果是自定义类型（类、结构体），后面加了括号的话，说明调用构造函数（也是初始化）</p><blockquote><p>首先回顾一下关于构造函数的知识：</p><p>构造函数是用来在对象创建的时候对对象进行初始化的</p><p>用户可以自定义构造函数</p><p>构造函数分为带参数的构造函数和不带参数的构造函数</p><p>带参数的构造函数使得每次创建对象的时候可以根据不同的参数对于对象进行不同的初始化</p><p>而众所周知，带参数的函数可以进行<strong>重载</strong>（函数可重名，通过参数的个数和类型进行区分，根据参数个数和类型调用对应的同名函数）<u>所以一个类中可以有多个构造函数</u>（构造函数都是重名的，没有类型，名称跟类名一样）；也可以构造<strong>参数缺省的函数（默认参数的构造函数）</strong></p><p>一个类中可以有多个构造函数，其中不需要输入参数的函数称为默认构造函数</p><p>&#x3D;&#x3D;<strong>默认构造函数一个类中只能有一个</strong>&#x3D;&#x3D;</p><p><strong>显然，无参构造函数是默认构造函数，参数全具有默认参数的函数（全缺省函数）也是默认构造函数，所以两者不能共存</strong></p><blockquote><p>而且有了全缺省的构造函数，就不能存在别的构造函数了（有全缺省构造函数的类不能重载构造函数）</p><p>因为全缺省的构造函数覆盖了任何可能的参数情况，再存在别的构造函数的时候就会产生歧义</p><p>无参：全缺省参数全都是用默认参数</p><p>有部分参数：缺少的参数用默认参数，不缺少的用给定的参数</p><p>含全部参数：全部都用给定的参数</p><p>比如一个含有三个int类成员变量abc的类S，如果定义了一个全缺省构造函数S(int A&#x3D;1,int B&#x3D;1,int C&#x3D;1)</p><p>也定义了一个含两个参数的构造函数S(int A,int B)，那么在定义对象S s(2,2)的时候，就会产生歧义，不知道应该调用哪个构造函数</p></blockquote><blockquote><p>另外也要注意别的可能产生的歧义出现，比如如果定义的是S(int A,int B&#x3D;1,int C&#x3D;1)和S(int A,int B)</p><p>那在定义对象定义对象S s(2,2)的时候，也会产生歧义</p></blockquote><p>如果用户没有自定义出默认构造函数，系统会用系统自己具有的默认构造函数（就叫系统默认构造函数吧）。系统默认构造函数的函数体是空的，不会进行任何操作，也就是说不会真正进行初始化，只是有这么个空函数而已。如果用户自定义了默认构造函数，系统就会用用户自定义的默认构造函数（有的资料称这是过程是系统合成构造函数，就是将用户自定义的构造函数设为默认构造函数）</p></blockquote><p>如果new的对象类型后面加括号的话，分为带参数和不带参数，如果类中用户自定义了带参数的构造函数，就可以在括号里带参数进行初始化；不带参数的话，如果用户自定义了默认构造函数，new创建出的对象就会调用默认构造函数进行初始化，如果用户没有自定义默认构造函数，系统就会调用系统默认构造函数对new出来的对象进行初始化。</p><p>如果不加括号，用户自定义了默认构造函数，new创建对象的时候会调用自定义的默认构造函数；用户没有自定义默认构造函数，new创建的对象就不会初始化</p><p>&#x3D;&#x3D;<strong>总结</strong>：&#x3D;&#x3D;</p><p>加括号一定会进行初始化；</p><p>不加括号，自定义了默认构造函数会初始化，没有就不会初始化</p></li></ul><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210092056231.png" alt="new 对象加括号和不加括号的区别_丿咫尺天涯的博客-CSDN博客"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_delete和free</title>
      <link href="/chunyujin/92cc59a4.html"/>
      <url>/chunyujin/92cc59a4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++中堆区开辟和释放动态内存多用 new 和delete</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *x=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> *y=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> x;</span><br><span class="line"><span class="keyword">delete</span> []y;</span><br></pre></td></tr></table></figure><p>C中多用 malloc 和 free</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *x=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> *y=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">10</span>);</span><br><span class="line"><span class="built_in">free</span>(x);</span><br><span class="line"><span class="built_in">free</span>(y);</span><br></pre></td></tr></table></figure><p>以上两段代码，除了new的时候可以进行初始化之外，作用都是一样的</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表OJ特别篇</title>
      <link href="/chunyujin/d183517b.html"/>
      <url>/chunyujin/d183517b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="数据结构-链表OJ特别篇——环形链表"><a href="#数据结构-链表OJ特别篇——环形链表" class="headerlink" title="数据结构_链表OJ特别篇——环形链表"></a>数据结构_链表OJ特别篇——环形链表</h3><blockquote><p>前言：此类笔记仅用于个人复习，内容主要在于记录和体现个人理解，详细还请结合bite课件、录播、板书和代码。</p></blockquote><hr><p>[toc]</p><hr><p>环形链表有一个非常重要的特点，那就是一旦开始遍历，就无法停止，一直循环，会超出时间限制</p><p>常见的几种形式（圆圈内为存储的数据值）</p> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202207282048823.png" alt="PNG图像" style="zoom: 33%;" /><h4 id="解决这个题的一个比较常规的思路"><a href="#解决这个题的一个比较常规的思路" class="headerlink" title="解决这个题的一个比较常规的思路"></a>解决这个题的一个比较常规的思路</h4><blockquote><p><a href="https://leetcode.cn/problems/linked-list-cycle/description/">题目地址</a></p><p>设置一快一慢两个指针，快的指针每次走2步，慢的每次走1步</p><p>在慢的指针走到环的时候，快的指针早就到了环里了，因此可以看作快的指针跑到了慢的后面（类似于套圈吧</p><p>而且快的指针与慢的指针有差距，由于快的指针每次2步，慢的1步，因此差距在以每次为1的速度削减，直到最后减到0</p><p>此时指针相交</p><p>既然快的指针和慢的指针能相交，就说明了有环，否则快的指针一定先指向NULL，且两者一定不会相遇 </p><pre><code>&lt;img src=&quot;https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20220730201835.png&quot; alt=&quot;QQ截图20220730201835&quot; style=&quot;zoom: 75%;&quot; /&gt;</code></pre>  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20220730215140710.png" alt="image-20220730215140710" style="zoom:80%;" /></blockquote><h4 id="这个题的重点不在于这个题本身，而在于它衍生出来的疑问"><a href="#这个题的重点不在于这个题本身，而在于它衍生出来的疑问" class="headerlink" title="这个题的重点不在于这个题本身，而在于它衍生出来的疑问"></a>这个题的重点不在于这个题本身，而在于它衍生出来的疑问</h4><blockquote><blockquote><ol><li><strong>slow一次走1步，fast一次走3步，fast能追上slow吗？fast一次走4步呢？走n步呢？请证明</strong></li><li><strong>请求出链表环的入口点</strong></li></ol></blockquote><ol><li><strong>slow一次走1步，fast一次走3步，fast能追上slow吗？fast一次走4步呢？走n步呢？请证明</strong></li></ol><p>不一定能追上，特殊情况下可能永远追不上！</p><p>先看fast一次走3步的情况</p> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20220730202009.png" alt="QQ截图20220730202009" style="zoom:80%;" /><p>再看一次走4步和n步的情况 </p> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20220730202009.png" alt="QQ截图20220730202009" style="zoom: 80%;" /><p>因此fast走2步，slow走1步，两者步幅差为1，N和C一定是整数，一定能追上<br>其余情况要看N和C的大小<br>在没给出环的具体长度时， N和C都是不确定的</p><ol start="2"><li><strong>请求出链表环的入口点</strong></li></ol><p><a href="">此处为进阶的题目链接</a></p><p> 假设slow跟fast在meet结点相遇</p><p>【meet】 到 【环入口点】 的距离设为 X</p><p>【链表头】 到 【环入口点】的距离设为 L</p><p>【环】的长度设为 C</p> <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/BA954234BAC806EE774153F076F067FC.png" alt="img" style="zoom: 50%;" /><p>根据上面的分析，slow一次走一步，fast一次走两步，那么</p><p>fast走过的路程的slow的2倍</p><p>slow跟fast相遇时，slow一定是处于刚进入环的第一圈</p><blockquote><p>因为二者一定会在距离差为负数（也就是fast跑到slow前面）之前相遇，而fast的速度又比slow快</p></blockquote><p>但是fast不知道已经跑了几圈了，假设fast跑了n圈</p><p>那么slow的路程为 L+X</p><p>fast的路程为 L+X+n*C</p><p>得到等式</p><p>2*(L+X)&#x3D;L+X+n *C</p><p>L+X&#x3D;n*C</p><p>L&#x3D;n*C-X</p><p>L的长度跟n*C-X的长度一样</p><p>也就是说从meet走上n圈再往回退X步，距离跟L一样</p><p>而从meet走上n圈再往回退X步，就是环入口点的位置</p><p>L也是从head到环入口点的距离</p><p>所以得到的结论就是</p><p><strong>如果从head和从meet同时出发，一次走一步，一定会相遇在环入口点</strong></p><p>（这个结论就无关了fast绕圈次数n还有环的长度C、不带环部分的长度L了，因为测试用例不同这些值就不同，但根据公式会得到客观结论）</p><blockquote>  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20220730214711257.png" alt="image-20220730214711257" style="zoom: 80%;" /></blockquote></blockquote><h3 id="链表OJ题库"><a href="#链表OJ题库" class="headerlink" title="链表OJ题库"></a>链表OJ题库</h3><p><a href="https://leetcode.cn/tag/linked-list/problemset/">LeetCode OJ链接</a></p><p><a href="https://www.nowcoder.com/exam/oj">牛客OJ链接</a></p><h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>That’s all, thanks for reading!💐</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调试真的真的十分重要且好用!!!</title>
      <link href="/chunyujin/c1238877.html"/>
      <url>/chunyujin/c1238877.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录一下，今天是2022&#x2F;10&#x2F;4</p><p>有一个问题，我找了半天，结果调试了一下就发现在哪儿出毛病了。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_函数中的数字作为参数时</title>
      <link href="/chunyujin/67b09a09.html"/>
      <url>/chunyujin/67b09a09.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="x3D-x3D-一般来说-x3D-x3D-，函数中的参数为数字的时候，有三种情况："><a href="#x3D-x3D-一般来说-x3D-x3D-，函数中的参数为数字的时候，有三种情况：" class="headerlink" title="&#x3D;&#x3D;一般来说&#x3D;&#x3D;，函数中的参数为数字的时候，有三种情况："></a>&#x3D;&#x3D;一般来说&#x3D;&#x3D;，函数中的参数为数字的时候，有三种情况：</h5><ol><li>只是作为形参，比如尾插一个数字”1“</li><li><strong>作为”第几个“</strong>，比如一个字符串删除函数DelStr(s1,1,2)中的1，是删除第一个元素（注意，这里并不是权重，1并不是权重是1（这样的话就是指s2的第二个元素了），而是就是单纯地指第1个，<strong>一般在函数中都是单纯地指第几个而不是权重是几</strong></li><li>作为处理元素的个数，比如一个字符串删除函数DelStr(s1,2,3) 中的3，是指删除三个元素</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在模版类里使用自己时可以省略模版参数</title>
      <link href="/chunyujin/e8fa6ce6.html"/>
      <url>/chunyujin/e8fa6ce6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在模版类里使用自己(以及自己类型的指针、引用)可以省略模版参数不写</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211102228794.png" alt="截屏2022-11-10 22.27.03"></p><p>比如这个left 和 right 都是Node类型的指针</p><p>一般情况下，在使用模版类的时候，一定要写上模版参数，就像left的声明</p><p>但是如果是在本类调用自己，可以省略，像right的声明</p><blockquote><p>因为在实例化的时候知道自己的模版参数具体是什么了，都是自己内部的，不用声明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_异常处理</title>
      <link href="/chunyujin/68c7819c.html"/>
      <url>/chunyujin/68c7819c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><blockquote><p>前言：此类笔记仅用于个人复习，内容主要在于记录和体现个人理解</p></blockquote><p>[toc]</p><h4 id="什么是异常处理"><a href="#什么是异常处理" class="headerlink" title="什么是异常处理"></a>什么是异常处理</h4><blockquote><p>在程序中可能会出现各种各样的异常，比如出现了错误，常见错误主要分为语法错误和编译错误，有的错误编译器是可以检查出来的，有的错误编译器检查不出来，；又比如违背正常情况，比如要求输入小写字母，但是实际输入大写的或者数字等，这种错误编译器一般不会检查出来。</p><p>在设计程序之前，应当分析各种可能出现的异常情况，并设定相应的识别、处理方式，这就是异常处理的任务</p><p>比如如果某个数除以0，这就是一个异常，要根据除数为0的这种异常情况进行一个判断和处理（比如报错并结束程序）</p><p>当然，也可以通过断言等方式来处理一些错误，当assert中的判别式结果为false的时候，就直接异常退出程序</p></blockquote><h4 id="C-中如何实现异常处理"><a href="#C-中如何实现异常处理" class="headerlink" title="C++中如何实现异常处理"></a>C++中如何实现异常处理</h4><p>C++的异常处理机制是由三个部分组成的：检查（try）、抛出（throw）、捕捉（catch）</p><p>“异常情况“是设计者人为认定判定的：如果想要检查一段代码，在这个代码段里面出现了我们不想要的异常情况，就需要抛出”这是一个异常情况“的信号，然后由相应的捕捉代码进行捕捉，一旦捕捉到抛出的异常，就会进入到用来处理这个异常的代码。</p><p>跟assert相比，异常处理机制显然更为温和，不会直接断死代码直接退出程序</p><h5 id="throw语句"><a href="#throw语句" class="headerlink" title="throw语句"></a>throw语句</h5><blockquote><p>形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> 表达式</span><br></pre></td></tr></table></figure><p>throw关键字抛出的表达式是什么样的数据由设计者自己定，可以是常规的变量，也可以是一串字符，也可以是自定义的变量</p><p>throw的关键在于表达式的结果的类型，而不是表达式的具体的值，但还是会将表达式作为“异常信号&#x2F;信息”（异常）整个抛出去，包括值</p><blockquote><p>一旦throw抛出异常，就会在进行异常处理之后，立即跳出throw所在的函数，回到上一级函数（比如main函数）</p></blockquote></blockquote><h5 id="try-catch结构"><a href="#try-catch结构" class="headerlink" title="try-catch结构"></a>try-catch结构</h5><blockquote><p>try关键字负责划定需要检查的代码区域，在区域内的代码段会接受检查，try和被检查的代码段被合称为try块</p><p>catch关键字用于接收throw抛出的异常，并针对异常进行相应处理，catch和被检查的代码段被合称为catch块</p><p>形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">被检查的代码段</span><br><span class="line">&#125;<span class="built_in">catch</span>(异常信息类型 变量名·一般情况下不写变量名·)&#123;</span><br><span class="line">处理异常的代码段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意</p><blockquote><ol><li>如果throw的表达式是类的话，可以不用单独实例化出一个对象，直接使用匿名对象，因为有的时候会定义一些空类来专门作为异常信息用，没必要为了异常信息实例化一个对象</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">outofsize</span>&#123;&#125;；<span class="comment">//这是一个空类，专门用来当异常信息的</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">outofsize</span>();<span class="comment">//使用的outofsize的匿名对象，格式是&quot;类名&quot;+&quot;()&quot;,其中()里面为初始化参数，跟正常类的定义不同，匿名对象再没有初始化参数的时候也要跟()</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="built_in">catch</span>(outofsize)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>被检查的代码段必须放在try里，否则不起作用</p></li><li><p>try-catch结构是一个整体，catch块必须紧跟try块，catch不能脱离try单独使用，且两者之间不能夹杂其他语句；但是try块是可以单独使用的，即只检查不处理，catch块在另一个函数里面</p></li><li><p>花括号不能省略</p></li><li><p>由于一段代码中可能存在多种错误情况，所以允许一个try块后面接多个catch块，以便匹配不同的异常信息</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="built_in">catch</span>()</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="built_in">catch</span>()</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">//以上省略了内容，主要体现结构</span></span><br></pre></td></tr></table></figure><ol start="6"><li>catch也只检查异常信息的类型，而不检查异常信息的值，根据异常信息的类型匹配相应的catch块，无论doule类型的值是多少，都只会匹配catch(double)；所以一般的catch写法括号内只有异常信息类型</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span>( <span class="type">double</span> )</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里发现，在函数的定义的时候也可以只写类型，不写变量，因为参数从左到右依次传入函数  </p></blockquote><p>​catch括号内还有另一种写法，即除了指定类型之外还指定变量名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span>(<span class="type">double</span> d)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这样catch在捕捉异常信息的时候，除了捕捉变量类型，还会捕捉变量的值，这样就可以在catch中使用这个值（当然，是拷贝的）</p><ol start="7"><li><p>如果catch括号内没有写变量类型，而是写了catch(…)，这表示这个catch块可以接受任何类型的异常信息</p></li><li><p>throw语句和try-catch块在同一个函数中，也可以不在同一个函数中。throw抛出异常信息之后，会先在本函数内让catch捕捉，如果本函数没有try-catch或者没有可以匹配的catch，则跳出本函数到上一个函数，直到找到最近的可匹配的catch</p></li><li><p>某些情况下，throw后面可以不加表达式，比如如果在catch块里有throw，则catch里的throw会将catch捕捉到的catch外的throw抛出的异常原样抛出，表示“本级函数的catch不处理这个异常，给上一级的catch块处理”</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span>(<span class="type">int</span>)</span><br><span class="line">&#123;<span class="comment">//其他语句</span></span><br><span class="line">    <span class="keyword">throw</span>;<span class="comment">//将以捕获的异常信息再次原样抛出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="10"><li>如果throw抛出的异常到最后都没有catch与之匹配，系统会调用一个系统函数terminate终止程序进行</li></ol></blockquote></blockquote><h4 id="几个例子"><a href="#几个例子" class="headerlink" title="几个例子"></a>几个例子</h4><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">triangle</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>,<span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">double</span> a,b,c;</span><br><span class="line">     cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">     <span class="keyword">try</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">while</span>(a&gt;<span class="number">0</span>&amp;&amp;b&gt;<span class="number">0</span>&amp;&amp;a&gt;<span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             cout&lt;&lt;<span class="built_in">triangle</span>(a,b,c)&lt;&lt;endl;<span class="comment">//try里包含了要被检查的函数</span></span><br><span class="line">             cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="built_in">catch</span>(<span class="type">double</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;,c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;,that is not a triangle&quot;</span> &lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">     cout&lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt;endl;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">triangle</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b,<span class="type">double</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">double</span> s = ( a+b+c )/<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">if</span>( a + b &lt;= c || b + c &lt;= a || a + c &lt;= b )</span><br><span class="line">         <span class="keyword">throw</span> a;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">sqrt</span>( s + (s-a) * (s-b) * (s-c) );<span class="comment">//如果在上面的throw中抛出了异常信息，则直接跳到上一级函数，这一行代码就不会生效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;<span class="comment">//表达式的类型本质是上是字符串，也就是char指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">  z = <span class="built_in">division</span>(x, y);</span><br><span class="line">  cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">&#125;<span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) <span class="comment">//既有变量类型又有变量名，就可以在下面使用捕捉到的异常信息</span></span><br><span class="line">&#123;</span><br><span class="line">  cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">outOfSize</span> &#123;&#125;;<span class="comment">//这里定义了一个空outOfSize类，只用作异常信号，不用与其他作用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">illegalType</span> &#123;&#125;;<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addWord</span><span class="params">(<span class="type">int</span>&amp;, <span class="type">char</span>*, <span class="type">char</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a[SIZE];</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Please keyonte a~z&quot;</span>&lt;&lt;endl;</span><br><span class="line">            cin &gt;&gt; b;</span><br><span class="line">            <span class="built_in">addWord</span>(x, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (outOfSize)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Outofsize!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (illegalType)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;IllegalType!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addWord</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">char</span>* a, <span class="type">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= SIZE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">outOfSize</span>();<span class="comment">//抛出的是outOfSize类的匿名对象</span></span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="string">&#x27;a&#x27;</span> || b&gt;<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">illegalType</span>();</span><br><span class="line">    a[x] = b;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>That’s all, thanks for reading!💐</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_cin&amp;cout</title>
      <link href="/chunyujin/d0ce2bfa.html"/>
      <url>/chunyujin/d0ce2bfa.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="C-cin、cout怎么写"><a href="#C-cin、cout怎么写" class="headerlink" title="C++_cin、cout怎么写"></a>C++_cin、cout怎么写</h4><p>cout是输出流，变量a进入（输入）到输出流才能输出到屏幕，就是cout&lt;&lt;a</p><p>cin是输入流，让键盘上输入流进入（输入）到变量a才能给a赋上值，也就是cin&gt;&gt;a</p><p>另外，比如这个sstringstream类，是用来将string类转化成别的数据类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">stringToInt</span><span class="params">(string s)</span> <span class="comment">//将操作数字符串转变成int</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ss &lt;&lt; s;</span><br><span class="line">    ss &gt;&gt; i;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要将这个string类s输入入到stringstream类ss中，然后将转化结果从ss输入到i中</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_vs2022DeBug Error</title>
      <link href="/chunyujin/3bb17c40.html"/>
      <url>/chunyujin/3bb17c40.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/MIV5KC1_8NWP%7DDPB%7BUV%60QPC.png" alt="img"></p><p>这是由于从堆中释放空间内存之后，没有申请开辟，却又对那块空间执行了操作（包括再次释放</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>副本</title>
      <link href="/chunyujin/f14e76e5.html"/>
      <url>/chunyujin/f14e76e5.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h4><p>副本这个词用得好啊</p><p>比如函数的形参就是实参的副本</p><p>副本就是拷贝出来的值</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于vs2022&amp;头文件和源文件的区别</title>
      <link href="/chunyujin/7c16d58.html"/>
      <url>/chunyujin/7c16d58.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li>关于vs2022</li></ol><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20220910100800098.png" alt="image-20220910100800098"  /><ol start="2"><li>头文件和源文件的区别</li></ol><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20220910101245438.png" alt="image-20220910101245438"></p><p>头文件用于函数、自定义类型声明，源文件用于定义、实现</p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优秀代码的五大特性&amp;什么是封装</title>
      <link href="/chunyujin/4793f752.html"/>
      <url>/chunyujin/4793f752.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[toc]</p><h5 id="优秀代码的五大特性"><a href="#优秀代码的五大特性" class="headerlink" title="优秀代码的五大特性"></a>优秀代码的五大特性</h5><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20220915194347910.png" alt="image-20220915194347910"></p><h5 id="什么是封装（封装的简介"><a href="#什么是封装（封装的简介" class="headerlink" title="什么是封装（封装的简介"></a>什么是封装（封装的简介</h5><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20220915195400299.png" alt="image-20220915195400299"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 能力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类和结构体的区别</title>
      <link href="/chunyujin/c4e745c8.html"/>
      <url>/chunyujin/c4e745c8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>C中的结构体不允许存在成员函数和this指针</p></li><li><p>C++中结构体和类的唯一区别就是结构体默认成员是公有的，类默认是私有的</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_delete</title>
      <link href="/chunyujin/6cf2f2d1.html"/>
      <url>/chunyujin/6cf2f2d1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20220911105630568.png" alt="image-20220911105630568"></p>]]></content>
      
      
      <categories>
          
          <category> 编程日志 </category>
          
          <category> C&amp;C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于vscode下使用终端进入vim看不到光标的问题</title>
      <link href="/chunyujin/f07d859c.html"/>
      <url>/chunyujin/f07d859c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>关于vscode下使用终端进入vim时光标看不到光标的问题</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301091550584.png" alt="截屏2023-01-09 15.50.16" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301091550854.png" alt="截屏2023-01-09 15.49.55" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301091550988.png" alt="截屏2023-01-09 15.50.09" style="zoom:50%;" /><p>很大概率是vscode的主题配置导致的，默认的白色主题下看不到光标（如上）</p><p>换成默认的黑色主题之后就可以看到了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301091552533.png" alt="截屏2023-01-09 15.50.31" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> IDE </category>
          
          <category> VsCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VsCode </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VsCode快捷键&amp;使用技巧</title>
      <link href="/chunyujin/d25e6d9b.html"/>
      <url>/chunyujin/d25e6d9b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h4><p>⌃ + ⌥ + N</p><p>ctrl + alt + N</p><h4 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h4><p>⌥ + ⇧ + F</p><p>alt + shift + F</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202209121909898.png" alt="截屏2022-09-12 18.49.36" style="zoom: 33%;" /><h4 id="批量更改变量、函数名称"><a href="#批量更改变量、函数名称" class="headerlink" title="批量更改变量、函数名称"></a>批量更改变量、函数名称</h4><p>光标选中名称</p><p>⌘ + ⇧ + L</p><p>ctrl + shift + L</p><h4 id="深浅模式跟随系统"><a href="#深浅模式跟随系统" class="headerlink" title="深浅模式跟随系统"></a>深浅模式跟随系统</h4><p>设置中搜索</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301071256453.png" alt="截屏2023-01-07 12.54.53"></p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
          <category> IDE </category>
          
          <category> VsCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VsCode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
