<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>解决butterfly在黑色模式下主页封面过暗的问题</title>
      <link href="/chunyujin/dffbd9e1.html"/>
      <url>/chunyujin/dffbd9e1.html</url>
      
        <content type="html"><![CDATA[<p>解决黑色模式下主页封面过暗的问题</p><p>在<code>/themes/butterfly/source/css/_mode/darkmode.styl </code></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212311144894.png" alt="截屏2022-12-31 11.43.39"></p><p>调整第48行括号里的小数点后的数值，默认是.9，数值越大越暗</p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客图集(阿里云图床)</title>
      <link href="/chunyujin/c2a9db75.html"/>
      <url>/chunyujin/c2a9db75.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300142246.jpg" alt="67243791_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300145467.jpg" alt="睡莲"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300149266.png" alt="79640557_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300150858.png" alt="99940581_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300152503.jpg" alt="ss"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300157190.jpg" alt="51562163_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300159454.png" alt="101965789_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300202846.jpg" alt="78830672_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300203045.jpg" alt="74724305_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300205537.jpg" alt="100938340_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301114389.jpg" alt="100938340_p0的副本2"></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300207368.gif" alt="original"  /><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301145729.png" alt="head"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300211286.png" alt="76834683_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300216305.png" alt="A0E1D3CE-D536-443C-9583-9FC6C0BFBC5C"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212300228844.png" alt="016269CA-735E-498F-8C68-29AAAB6DAFBB"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301100230.jpg" alt="74364959_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301103690.jpg" alt="98288115_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301116378.jpg" alt="98473741_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301103283.jpg" alt="99287912_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301105836.jpg" alt="99287912_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301922412.png" alt="截屏2022-12-30 19.21.59"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301929027.png" alt="截屏2022-12-30 19.29.38"></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212301938709.jpg" alt="97451569_p0"  /><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212302043621.jpg"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212302044439.jpg"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212302109225.jpg" alt="101204641_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010017530.jpg" alt="78440564_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010140253.png" alt="截屏2023-01-01 01.38.06"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010141063.jpg" alt="100613443_p3"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010143595.jpg" alt="100307349_p0"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301011054071.jpg" alt="82492410_p0的副本"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301011057668.jpg" alt="65231299_p0的副本"></p>]]></content>
      
      
      <categories>
          
          <category> 图集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用指令&amp;权限管理</title>
      <link href="/chunyujin/1c776eb1.html"/>
      <url>/chunyujin/1c776eb1.html</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><h4 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h4><h5 id="文件的分类"><a href="#文件的分类" class="headerlink" title="文件的分类"></a>文件的分类</h5><blockquote><p><strong>普通文件</strong>，文件属性为[-]</p><p><strong>目录文件</strong>，属性为[d]，文件夹(目录)也是一种文件，是内容为文件的文件，是能用 # cd指令进入的</p><p><strong>块设备文件</strong>，属性为[b]，表示为装置文件里面的可供储存的接口设备(可随机存取装置)，比如硬盘、光驱等。例如一号硬盘的代码是 &#x2F;dev&#x2F;hda1等文件</p><p><strong>字符设备文件</strong>，属性为[c]，表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)、屏幕等</p><p><strong>套接字文件</strong>，属性为[s]，这类文件通常用在网络数据连接，可以启动一个程序来监听客户端的要求，客户端就可以通过套接字来进行数据通信。最常在 &#x2F;var&#x2F;run目录中看到这种文件类型</p><p><strong>管道文件</strong>，属性为[p]，FIFO也是一种特殊的文件类型，它主要的目的是，解决多个程序同时存取一个文件所造成的错误。FIFO是first-in-first-out(先进先出)的缩写</p><p><strong>链接文件</strong>，属性为[l]，类似于Windows里的快捷方式和macOS的替身</p></blockquote><h5 id="文件-x3D-文件属性-文件内容"><a href="#文件-x3D-文件属性-文件内容" class="headerlink" title="文件 &#x3D; 文件属性 + 文件内容"></a>文件 &#x3D; 文件属性 + 文件内容</h5><blockquote><p>当我们在电脑上创建了一个空白文档的时候，查看一下文件的详细信息，会发现这个空白文档并不是占用了0内存，它是占用了内存的。因为要存储这个文档的属性，包括创建时间、修改日期、种类、拥有者等等</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212291208514.png" alt="截屏2022-12-29 12.08.43" style="zoom:50%;" /></blockquote><h5 id="常用的单词："><a href="#常用的单词：" class="headerlink" title="常用的单词："></a>常用的单词：</h5><blockquote><p>command 命令</p><p>option 选项</p><p>dirname 目录名</p></blockquote><h4 id="建议有不懂的指令就去man查找！"><a href="#建议有不懂的指令就去man查找！" class="headerlink" title="建议有不懂的指令就去man查找！"></a>建议有不懂的指令就去man查找！</h4><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><p>一个指令由基本指令、选项、目标、其他内容组成的，除基本指令外的内容都并不是必须的，内容对应相应功能</p><p>一条指令可以添加多个选项，意味着一条指令实现多种功能的结合</p><p>&#x3D;&#x3D;<strong>凡是放方括号里的内容都代表不是必须的，可以不存在</strong>&#x3D;&#x3D;，括号外的内容都是必须的</p><p><strong>指令中，选项的位置正常来讲是可以移动的，并不是固定的必须要按照某种顺序出现在某个位置</strong></p><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><p><code>ls [选项] [指定文件]</code></p><h5 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h5><p>对于目录，该命令列出该目录下的所有文件；对于一般文件，将列出该文件。(默认是按照名称排序的)</p><p>&#x3D;&#x3D;（如果不跟指定目录或文件，则默认是当前目录）&#x3D;&#x3D;</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181010049.png" alt="截屏2022-12-18 10.10.52" style="zoom:50%;" /><h5 id="常用选项："><a href="#常用选项：" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-l # 列出各文件的详细信息。ls -l 可以简写成 ll</span><br><span class="line">-a # 列出所有文件， 包括以.开头的隐藏文件</span><br><span class="line">-d # 只显示指定目录，不显示目录内容</span><br><span class="line">-s(小写) # 显示文件的块数</span><br><span class="line">-S(大写) # 按大小降序排列</span><br><span class="line">-r # 反向排序</span><br><span class="line">-t # 按修改时间先后排序</span><br><span class="line">-h # 按用户易读的方式显示文件大小</span><br><span class="line">-k # 以k字节的形式输出大小(一般输出的时候就是以这种方式输出的，用处不是很大)</span><br><span class="line">-R # 列出所有子目录的文件(递归)</span><br><span class="line">-1 # 一行只输出一个文件</span><br><span class="line">-n # 用数字的UID、GID代替owner、group名称</span><br><span class="line">-i # 显示文件的inode(索引节点)</span><br><span class="line">-F # 在每个文件名后附上一个字符以说明该文件的类型，*表示可执行程序，/表示目录，@表示符号连接，|表示FIFOs，=表示套接字(sockets)。（目录类型识别）</span><br></pre></td></tr></table></figure><blockquote><p><strong>&#x3D;&#x3D;-l&#x3D;&#x3D; ：列出各文件的详细信息。<u>ls -l 可以简写成 ll</u></strong></p><div><center><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181050726.png" alt="image-20221218105015699" style="zoom:30%;" /><br>Linux文件默认是按照名称排序的</center></div><p><strong>&#x3D;&#x3D;-a&#x3D;&#x3D; ：列出所有文件， 包括以.开头的隐藏文件。例如：ls -a [指定目标]</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181011049.png" alt="截屏2022-12-18 10.11.38" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181015520.png" alt="截屏2022-12-18 10.15.19" style="zoom:50%;" /><blockquote><p>可以看出当前目录.和上级目录..是作为隐藏文件保存的</p><p><strong>注意：当前目录.和上级目录..算是当前目录的子目录！</strong></p><p>所以会显示当前目录.的子目录个数是7，分别是：当前目录.，上级目录..，code，date，dir1，dir1-bak，test1</p><p>显示code目录中的子目录个数是3，但是实际上一看code中只有一个子目录hellobite，这就是因为code的当前目录和上级目录也算作了code的子目录，而当前目录和上级目录是隐藏文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181038966.png" alt="截屏2022-12-18 10.38.42" style="zoom:50%;" /><p>同样，显示code的子目录hellobite含有的子目录的个数是2，但是实际上查看发现hellobite中没有子目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181039261.png" alt="截屏2022-12-18 10.39.46" style="zoom:50%;" /></blockquote><p><strong>&#x3D;&#x3D;-d&#x3D;&#x3D; ：只显示指定目录，不显示目录内容</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181016521.png" alt="截屏2022-12-18 10.16.52" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181013186.png" alt="截屏2022-12-18 10.13.50" style="zoom:50%;" /><p><strong>&#x3D;&#x3D;-s&#x3D;&#x3D;（小写 ：显示文件的块数</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181216093.png" alt="截屏2022-12-18 12.16.51" style="zoom:50%;" /><p><strong>&#x3D;&#x3D;-S&#x3D;&#x3D;（大写：按大小降序排列</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181232314.png" alt="截屏2022-12-18 12.32.31" style="zoom:50%;" /><p><strong>&#x3D;&#x3D;-r&#x3D;&#x3D; ：反向排序</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181530665.png" alt="截屏2022-12-18 15.30.32" style="zoom:50%;" /><p><strong>&#x3D;&#x3D;-t&#x3D;&#x3D; ： 按修改时间先后排序</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181706732.png" alt="image-20221218170624706" style="zoom:50%;" /><p><strong>&#x3D;&#x3D;-h&#x3D;&#x3D; ：按用户易读的方式显示文件大小</strong></p><p>就是换算了一下单位</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181640118.png" alt="截屏2022-12-18 16.40.15" style="zoom:50%;" /><p><strong>&#x3D;&#x3D;-R&#x3D;&#x3D; ： 列出所有子目录的文件(递归)</strong></p><center class = "half">        <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181722837.png" alt="截屏2022-12-18 17.22.03" style="zoom:40%;" />                <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181723755.png" alt="iShot_2022-12-18_17.21.42" style="zoom:35%;" /></center><p><strong>&#x3D;&#x3D;-1&#x3D;&#x3D; ： 一行只输出一个文件</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181736886.png" alt="截屏2022-12-18 17.36.33" style="zoom:50%;" /><p>&#x3D;&#x3D;-n&#x3D;&#x3D;：用数字的UID、GID代替owner、group名称</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181741224.png" alt="截屏2022-12-18 17.41.47" style="zoom:50%;" /><p>&#x3D;&#x3D;-i&#x3D;&#x3D;：显示文件的inode(索引节点)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181929066.png" alt="截屏2022-12-18 19.29.50" style="zoom:50%;" /><p>&#x3D;&#x3D;-F&#x3D;&#x3D;：在每个文件名后附上一个字符以说明该文件的类型，*表示可执行程序，&#x2F;表示目录，@表示符号连接，|表示FIFOs，&#x3D;表示套接字(sockets)。（目录类型识别）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212190918116.png" alt="截屏2022-12-19 09.17.01" style="zoom:50%;" /></blockquote><h4 id="文件块-简介"><a href="#文件块-简介" class="headerlink" title="文件块(简介)"></a>文件块(简介)</h4><p>(后续会详细学习)</p><p>Linux系统的心脏部分就是其文件系统，文件系统提供了层次结构的目录和文件。</p><p>一般情况下，文件系统将磁盘空间划分为<font color = red>每1024个字节一组，也称为一块</font>（有的Linux将512字节划为一块），编号从0到整个内存的最大块数。</p><p>文件访问系统访问磁盘的时候基本单位是4kb，也就是说是4个块为一个基本单位</p><p>所以在查看文件的总块数的时候会发现都是4的倍数</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181216093.png" alt="截屏2022-12-18 12.16.51" style="zoom:50%;" /><h4 id="inode索引节点-简介"><a href="#inode索引节点-简介" class="headerlink" title="inode索引节点(简介)"></a>inode索引节点(简介)</h4><p>(后续会详细学习)</p><p>用来存放档案和目录的基本信息，包含时间、档名、使用者及群组等</p><h4 id="UID和GID-简介"><a href="#UID和GID-简介" class="headerlink" title="UID和GID(简介)"></a>UID和GID(简介)</h4><p>(后续会详细学习)</p><p>登陆 Linux 系统时，虽然输入的是自己的用户名和密码，但其实 Linux 并不认识你的用户名称，它只认识用户名对应的 ID 号（也就是一串数字）。Linux 系统将所有用户的名称与 ID 的对应关系都存储在 &#x2F;etc&#x2F;passwd 文件中</p><blockquote><p>说白了，用户名并无实际作用，仅是为了方便用户的记忆而已。</p></blockquote><p>Linux 系统中，每个用户的 ID 细分为 2 种，分别是用户 ID（User ID，简称 UID）和组 ID（Group ID，简称 GID），这与文件有拥有者和拥有群组两种属性相对应</p><p>每个文件都有自己的拥有者 ID 和群组 ID，当显示文件属性时，系统会根据 &#x2F;etc&#x2F;passwd 和 &#x2F;etc&#x2F;group 文件中的内容，分别找到 UID 和 GID 对应的用户名和群组名，然后显示出来</p><center><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181915000.gif" /></center><blockquote><p>&#x2F;etc&#x2F;passwd 文件和 &#x2F;etc&#x2F;group 文件，后续文章会做详细讲解，这里只需要知道，在 &#x2F;etc&#x2F;passwd 文件中，利用 UID 可以找到对应的用户名；在 &#x2F;etc&#x2F;group 文件中，利用 GID 可以找到对应的群组名</p></blockquote><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><p><code>pwd</code></p><h5 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h5><p>显示用户当前所在目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212190925534.png" alt="image-20221219092508502" style="zoom:50%;" /><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><h5 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h5><p><code>cd [指定目录]</code></p><h5 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a>功能：</h5><p>进入到指定目录下</p><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd .. # 返回上级目录(相对路径)</span><br><span class="line">cd /home/litao/linux/ # 绝对路径 </span><br><span class="line">cd ../day02/ # 相对路径</span><br><span class="line">cd ~ # 进入用户家目录</span><br><span class="line">cd - # 返回最近访问的目录</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212190929706.png" alt="截屏2022-12-19 09.29.01" style="zoom:50%;" /><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><h5 id="语法：-3"><a href="#语法：-3" class="headerlink" title="语法："></a>语法：</h5><p><code>date [option]......[+format]</code></p><p>option用来设置时间</p><p>format用来显示时间</p><h5 id="功能：-3"><a href="#功能：-3" class="headerlink" title="功能："></a>功能：</h5><p>显示与设定系统的日期与时间</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221219111457827.png" alt="image-20221219111457827" style="zoom:80%;" /><h5 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h5><ol><li>显示时间：</li></ol><p>使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中常用的标记列表如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+%Y # 显示完整年份(0000~9999)</span><br><span class="line">+%m # 显示月份(1~12)</span><br><span class="line">+%d # 显示天(01~31)</span><br><span class="line">+%F # 显示年月日，相当于指令 +%Y-%m-%d</span><br><span class="line">+%H # 显示小时(00~23)</span><br><span class="line">+%M # 显示分钟(00~59)</span><br><span class="line">+%S # 显示秒(00~61)</span><br><span class="line">+%X # 显示时分秒，相当于指令 +%H:%M:%S</span><br></pre></td></tr></table></figure><center>  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191246406.png" alt="截屏2022-12-19 12.46.55" style="zoom:50%;" />  <br>  Mac的终端默认是中文所以输出的最后一行是中文的</center><ol start="2"><li>设定时间</li></ol><p>只有root才有权限设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">date -s # 设置当前时间，只有root权限才能设置，其他只能查看。</span><br><span class="line">date -s 20080523 # 设置成20080523，这样会把具体时间设置成空00:00:00 </span><br><span class="line">date -s 01:01:01 # 设置具体时间，不会对日期做更改</span><br><span class="line">date -s &quot;01:01:01 2008-05-23&quot; # 这样可以设置全部时间</span><br><span class="line">date -s &quot;01:01:01 20080523&quot; # 这样可以设置全部时间</span><br><span class="line">date -s &quot;2008-05-23 01:01:01&quot; # 这样可以设置全部时间</span><br><span class="line">date -s &quot;20080523 01:01:01&quot; # 这样可以设置全部时间</span><br></pre></td></tr></table></figure><p>3.时间戳转换</p><p>Unix时间戳(英文为Unix epoch, Unix time, POSIX time 或 Unix timestamp)是从1970年1月1日(UTC&#x2F;GMT的 午夜)开始所经过的秒数，不考虑闰秒</p><p>时间-&gt;时间戳：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date +%s </span><br></pre></td></tr></table></figure><p>时间戳-&gt;时间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -d@时间戳时间</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191256969.png" alt="截屏2022-12-19 12.56.52" style="zoom:50%;" /><h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><h5 id="语法：-4"><a href="#语法：-4" class="headerlink" title="语法："></a>语法：</h5><p><code>cal [option] [月份] [年份]</code></p><h5 id="功能：-4"><a href="#功能：-4" class="headerlink" title="功能："></a>功能：</h5><p>查看并输出指定年份的指定月份的日历</p><p>省略月份则输出指定年份整年的日历(如果只有一个参数，只能表示年份)</p><p>都省略则输出系统时间所在月的日历</p><h5 id="常用选项：-1"><a href="#常用选项：-1" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-3 # 显示指定日期所在的前一个月份、当前月份、后一个月份的日历</span><br><span class="line">-j # 显示指定日期在当前年中的第几天(从1月1号开始算)</span><br><span class="line">-y # 显示一整年12个月的日历</span><br></pre></td></tr></table></figure><figure class="half">  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222248298.png" alt="截屏2022-12-22 22.42.54" style="zoom:40%;" />  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222248633.png" alt="截屏2022-12-22 22.47.35" style="zoom: 40%;" /></figure><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><h5 id="语法：-5"><a href="#语法：-5" class="headerlink" title="语法："></a>语法：</h5><p><code>touch [选项]……[文件]……</code></p><h5 id="功能：-5"><a href="#功能：-5" class="headerlink" title="功能："></a>功能：</h5><ol><li>如果文件已存在，更改文件(包括目录文件)的时间记录，包括存取时间和修改时间</li><li>如果文件不存在，创建这个文件(不能新建目录)</li></ol><center class = "half">  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191000119.png" alt="截屏2022-12-19 09.59.53" style="zoom:45%;" />  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191000049.png" alt="截屏2022-12-19 10.00.01" style="zoom:45%;" />  </center><h5 id="常用选项：-2"><a href="#常用选项：-2" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-a，--time=atime，--time=access，--time=use # 只更改存取时间</span><br><span class="line">-m，--time=mtime，--time=modify # 只更改修改时间</span><br><span class="line">-c，--no-creat # 不创建文件</span><br><span class="line">-d [时间] # 将时间记录改为给定的时间，时间可以使用各种不同的格式</span><br><span class="line">-t [时间] # 将时间记录改为给定的时间，时间必须使用[[YY]YY]MMDDhhmm[.SS]，不再放括号里的是必须有的，方括号里的是可以省略的</span><br><span class="line">-r [参考文件] # 将时间记录改为跟参考文件一样的时间</span><br><span class="line">-f # 会被忽略处理，是为了与其他 unix 系统的相容性而保留</span><br></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;-a&#x3D;&#x3D;</p><p>无法直观展示</p><p>&#x3D;&#x3D;-m&#x3D;&#x3D;</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191004398.png" alt="image-20221219100439373" style="zoom:50%;" /><p>&#x3D;&#x3D;-c&#x3D;&#x3D;</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191005165.png" alt="image-20221219100520143" style="zoom:50%;" /><p>&#x3D;&#x3D;-d [时间]&#x3D;&#x3D;</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191008543.png" alt="截屏2022-12-19 10.07.57" style="zoom:50%;" /><p>&#x3D;&#x3D;-t&#x3D;&#x3D; [时间]</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191713110.png" alt="截屏2022-12-19 17.13.54" style="zoom:50%;" /></blockquote><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><h5 id="语法：-6"><a href="#语法：-6" class="headerlink" title="语法："></a>语法：</h5><p><code>mkdir [-p] DIRNAME</code></p><h5 id="功能：-6"><a href="#功能：-6" class="headerlink" title="功能："></a>功能：</h5><p>在当前目录下创建一个名为DIRNAME的目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191720623.png" alt="截屏2022-12-19 17.20.02" style="zoom:50%;" /><h5 id="常用选项：-3"><a href="#常用选项：-3" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p # 后跟一个路径。如果路径中有不存在的目录，则会创建出这些不存在的路径。也就是可以一次性创建一个路径，多个目录。（或--parents）</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191725268.png" alt="截屏2022-12-19 17.25.07" style="zoom:50%;" /><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><h5 id="语法：-7"><a href="#语法：-7" class="headerlink" title="语法："></a>语法：</h5><p><code>rmdir [-p] 目录</code></p><h5 id="适用对象："><a href="#适用对象：" class="headerlink" title="适用对象："></a>适用对象：</h5><p>具有指定目录的权限的所有使用者</p><h5 id="功能：-7"><a href="#功能：-7" class="headerlink" title="功能："></a>功能：</h5><p>删除指定目录，目录必须是空的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191733118.png" alt="截屏2022-12-19 17.33.29" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191736474.png" alt="截屏2022-12-19 17.36.12" style="zoom:50%;" /><h5 id="常用选项：-4"><a href="#常用选项：-4" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-p # 当指定目录被删除后它的父目录变成空的话，连同父目录一起删除</span><br><span class="line">* # 借助通配符*，满足匹配条件的文件都会被复制。</span><br><span class="line">? # 同上</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212191739720.png" alt="截屏2022-12-19 17.39.04" style="zoom:50%;" /><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><h5 id="语法：-8"><a href="#语法：-8" class="headerlink" title="语法："></a>语法：</h5><p><code>rm [option] 文件</code></p><h5 id="适用对象：-1"><a href="#适用对象：-1" class="headerlink" title="适用对象："></a>适用对象：</h5><p>所有使用者</p><h5 id="功能：-8"><a href="#功能：-8" class="headerlink" title="功能："></a>功能：</h5><p>删除文件，搭配选项可以删除目录</p><p>注意，文件一旦删除无法恢复！</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212200955025.png" alt="截屏2022-12-20 09.55.42" style="zoom:50%;" /><h5 id="常用选项：-5"><a href="#常用选项：-5" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-r # 删除目录及其下所有文件</span><br><span class="line">* # 借助通配符*，满足匹配条件的文件都会被复制。</span><br><span class="line">? # 同上</span><br><span class="line">-f # 即使文件属性为只读(即写保护)，亦直接删除，无需逐一确认</span><br><span class="line">-i # 删除前逐一询问确认</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201000703.png" alt="截屏2022-12-20 10.00.09" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201003511.png" alt="截屏2022-12-20 10.03.31" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201000976.png" alt="截屏2022-12-20 10.00.26" style="zoom:50%;" /><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><h5 id="语法：-9"><a href="#语法：-9" class="headerlink" title="语法："></a>语法：</h5><p><code>man [option] command</code></p><h5 id="功能：-9"><a href="#功能：-9" class="headerlink" title="功能："></a>功能：</h5><p>查找指定命令的用法</p><h5 id="补充说明："><a href="#补充说明：" class="headerlink" title="补充说明："></a>补充说明：</h5><ol><li><p>Linux手册是联机手册，进行联机查找</p></li><li><p>执行<code>man man</code>指令可以查询man的详细信息，包括用法、每章节的内容分类等</p></li><li><p>帮助文档分为8章：</p><blockquote><p>1 是普通的命令 </p><p>2 是系统调用,如open,write之类的(通过这个，至少可以很方便的查到调用这个函数，需要加什么头文 件) </p><p>3 是库函数,如printf,fread</p><p>4 是特殊文件,也就是&#x2F;dev下的各种设备文件 </p><p>5 是指文件的格式,比如passwd, 就会说明这个文件中各个字段的含义 </p><p>6 是给游戏留的,由各个游戏自己定义</p><p>7 是附件还有一些变量,比如向environ这种全局变量在这里就有说明 </p><p>8 是系统管理用的命令,这些命令只能由root使用,如ifconfig </p></blockquote></li><li><p>man 命令中常用按键以及用途</p><table><thead><tr><th>按键</th><th>用途</th></tr></thead><tbody><tr><td>空格键</td><td>向下翻一页</td></tr><tr><td>PaGe down</td><td>向下翻一页</td></tr><tr><td>PaGe up</td><td>向上翻一页</td></tr><tr><td>home</td><td>直接前往首页</td></tr><tr><td>end</td><td>直接前往尾页</td></tr><tr><td>&#x2F;</td><td>从上至下搜索某个关键词，如“&#x2F;linux”</td></tr><tr><td>？</td><td>从下至上搜索某个关键词，如“?linux”</td></tr><tr><td>n</td><td>定位到下一个搜索到的关键词</td></tr><tr><td>N</td><td>定位到上一个搜索到的关键词</td></tr><tr><td>q</td><td>退出帮助文档</td></tr><tr><td>鼠标滚轮</td><td>上下翻页</td></tr></tbody></table></li></ol><h5 id="常用选项：-6"><a href="#常用选项：-6" class="headerlink" title="常用选项："></a><a href="https://cloud.tencent.com/developer/article/1725969">常用选项：</a></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num # 只在第num章节中进行查找</span><br><span class="line">-k # 后面的command可以是缺省的，进行模糊查找</span><br><span class="line">-a，--all # 寻找所有匹配的手册页</span><br><span class="line">-f，--whatis # 相当于whatis</span><br><span class="line">-i，--ignore-case # 查找手册页时不区分大小写(默认)</span><br><span class="line">-I，--match-case # 区分大小写</span><br></pre></td></tr></table></figure><h4 id="whatis"><a href="#whatis" class="headerlink" title="whatis"></a>whatis</h4><p>Linux 中的 <code>whatis</code> 命令可以从它的字面意思可以看出来，就是“这是什么”，通过它可以知道某命令是用来干什么的，而且是用很简短的方式来描述。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201055267.png" alt="截屏2022-12-20 10.55.10" style="zoom:50%;" /><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><h5 id="语法：-10"><a href="#语法：-10" class="headerlink" title="语法："></a>语法：</h5><p><code>cp [option] 源文件 指定目录下的目标文件</code></p><h5 id="功能：-10"><a href="#功能：-10" class="headerlink" title="功能："></a>功能：</h5><p>将 源文件 在指定目录下 复制出指定文件</p><blockquote><p>如果省略指定目录，则默认是当前目录</p><p>如果省略目标文件，则会在指定目录下复制出跟源文件同名的文件</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201625241.png" alt="截屏2022-12-20 16.25.29" style="zoom:50%;" /><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><ol><li><p>本质过程是根据源文件复制创建出一个新的文件，所以如果目标文件跟已存在的文件重名，会覆盖已存在的文件(且默认不会询问)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201628004.png" alt="截屏2022-12-20 16.28.04" style="zoom:50%;" /></li><li><p>如果要复制目录，则必须加上<code>-r</code>选项，</p></li><li><p>指定文件的类型必须跟源文件类型一样，普通文件只能复制出普通文件，源文件只能复制出源文件</p></li><li><p>可以一次性复制多个源文件，各个源文件之间用空格间隔，最后跟一个指定目录，各个源文件会复制到指定目录中去</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201630006.png" alt="截屏2022-12-20 16.30.35" style="zoom:50%;" /></li></ol><h5 id="常用选项：-7"><a href="#常用选项：-7" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-r # 复制目录(并递归复制该源目录下所有的子目录和文件)</span><br><span class="line">-f，--force # 强制复制，且覆盖已经存在的文件之前不询问用户。如果文件不能打开，可以用它强行复制</span><br><span class="line">-i，--interactive # 在覆盖已存在的文件之前选询问用户(与-f相反)</span><br><span class="line">-u # 当源文件比目标文件新时才会复制，否则不复制成目标文件</span><br><span class="line">* # 借助通配符*，满足匹配条件的文件都会被复制。</span><br><span class="line">? # 同上</span><br></pre></td></tr></table></figure><h4 id="通配符-简介"><a href="#通配符-简介" class="headerlink" title="通配符(简介)"></a>通配符(简介)</h4><p>(后续会详细学习)</p><p>linux常用通配符有* ，？，[ ]，[^]，[:space:]，[:punct:]，[:lower:]，[:upper:]，[:digit:]，[:alnum:]等等</p><p>它是由shell解析，并且一般用于匹配文件名，实际上就是shell解释器去解析的特殊符号</p><blockquote><blockquote><ol><li><p>&#x3D;&#x3D;<strong>通配符不仅会匹配当前目录下的满足条件的文件，还会<u>递归匹配</u>子目录下的满足条件的文件</strong>&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;<strong>开始字符和结束字符都可以省略</strong>&#x3D;&#x3D;</p><blockquote><p>在匹配文件的时候，被匹配的文件名会被分成三部分：开始字符、中间字符、结束字符</p><p>分别对应文件名的开头、中间、结尾</p><blockquote><p>如果开始字符被省略，那么被匹配的字符就变成了：中间字符、结束字符</p><p>则文件名的开头、中间都被视为中间字符，结尾被视为结束字符</p><p>匹配时寻找 文件名结尾 跟 结束字符 相同，且 文件名开头和中间 满足中间字符要求 的文件</p><p>(比如有的通配符要求中间只能有一个字符，那么只有文件名结尾跟结束字符相同，且除了文件名结尾之外的部分(也就是开头和中间)只有一个字符的才能满足匹配要求)</p></blockquote><blockquote><p>如果结束字符被省略，那么被匹配的字符就变成了：开始字符、结束字符</p><p>那么文件名的开头被视为开始字符，中间和结尾被视为结束字符</p><p>匹配时寻找 文件名开头 跟 开始字符 相同，且 文件名中间和结尾 满足中间字符要求 的文件</p></blockquote><blockquote><p>如果开始字符和结束字符都被省略，被匹配的字符只有中间字符</p><p>整个文件名都被视为中间字符，所有 满足中间字符要求 的文件名都会被匹配上</p></blockquote></blockquote></li></ol></blockquote><p>**&#x3D;&#x3D;<em>：匹配任意多个字符&#x3D;&#x3D;</em>*</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开始字符*结束字符 # 会匹配满足 文件名开头 和 文件名结尾 分别与开始字符和结束字符相同的、中间有任意多个字符的文件</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201812569.png" alt="截屏2022-12-20 18.12.08" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212201940130.jpeg" alt="IMG_0865" style="zoom:40%;" /><p><strong>&#x3D;&#x3D;?：匹配任意一个字符&#x3D;&#x3D;</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开始字符?结束字符 # 会匹配满足 文件名开头 和 文件名结尾 分别与开始字符和结束字符相同的、中间只有一个字符的文件。</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202250451.png" alt="截屏2022-12-20 22.50.14" style="zoom:50%;" /><p>&#x3D;&#x3D;<strong>[…]：匹配中括号内出现的任意一个字符</strong>&#x3D;&#x3D;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开始字符[…]结束字符 # 会匹配满足 文件名开头 和 文件名结尾 分别与开始字符和结束字符相同的、中间存在于[]内且只有一个字符的文件</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202311425.png" alt="截屏2022-12-20 23.11.52" style="zoom:50%;" /><p>&#x3D;&#x3D;<strong>[!…]：不匹配中括号内出现的任意一个字符</strong>&#x3D;&#x3D;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开始字符[!…]结束字符 # 会匹配满足 文件名开头 和 文件名结尾 分别与开始字符和结束字符相同的、中间不存在于[]内且只有一个字符的文件</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202317821.png" alt="截屏2022-12-20 23.17.01" style="zoom:50%;" /></blockquote><p><strong>&#x3D;&#x3D;通配符可以作为一个选项，在非常多的命令中都可以用到，用来匹配文件名&#x3D;&#x3D;</strong></p><p>一般出现在要shell命令或脚本中，匹配特定的文件名</p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><h5 id="语法：-11"><a href="#语法：-11" class="headerlink" title="语法："></a>语法：</h5><p><code>mv [option] 源文件 指定目录</code></p><p><code>mv [option] 源文件 文件名</code>(文件名也可以是指定目录下的某个文件的文件名，但是这样不是多此一举了吗)</p><h5 id="功能：-11"><a href="#功能：-11" class="headerlink" title="功能："></a>功能：</h5><p>将 源文件 <strong>移动</strong> 到指定目录下。如果指定目录下存在与源文件重名的文件，则默认会被刚移动进来的源文件覆盖掉</p><p>将 源文件 <strong>改名</strong>为 给定的文件名。如果当前目录下已经存在与给定文件名重名的文件，则默认会被新改过名的源文件覆盖掉</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202331000.png" alt="截屏2022-12-20 23.31.16" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202343117.png" alt="截屏2022-12-20 23.43.13" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202333934.png" alt="截屏2022-12-20 23.33.52" style="zoom:50%;" /><h5 id="常用选项：-8"><a href="#常用选项：-8" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-f # force强制，在移动或改名时，如果出现了重名情况，不会询问而是直接复覆盖</span><br><span class="line">-i # 在移动或改名时，如果出现了重名情况，会询问是否覆盖</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202348339.png" alt="截屏2022-12-20 23.48.30" style="zoom:50%;" /><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><h5 id="语法：-12"><a href="#语法：-12" class="headerlink" title="语法："></a>语法：</h5><p><code>cat [选项] [目标文件]</code></p><h5 id="功能：-12"><a href="#功能：-12" class="headerlink" title="功能："></a>功能：</h5><p>输出内容到指定输出设备(默认指定输出设备是显示器)：</p><p>如果目标文件没被省略，<strong>打印&#x2F;输出</strong>目标文件的内容</p><p>如果目标文件被省略，则是<strong>打印&#x2F;输出</strong>刚刚从键盘上输入的内容(Linux下一切皆文件，默认将键盘视为了文件)，ctrl + c结束</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212202353491.png" alt="image-20221220235315449" style="zoom:50%;" /><h5 id="常用选项：-9"><a href="#常用选项：-9" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-b # 对非空输出行编号 </span><br><span class="line">-n # 对输出的所有行编号</span><br><span class="line">-s # 不输出多行空行 </span><br></pre></td></tr></table></figure><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><h5 id="语法：-13"><a href="#语法：-13" class="headerlink" title="语法："></a>语法：</h5><p><code>more [选项] 文件</code></p><h5 id="功能：-13"><a href="#功能：-13" class="headerlink" title="功能："></a>功能：</h5><p>类似于cat，但是逐页后翻逐页<strong>打印&#x2F;输出</strong>，并可以查看前面已<strong>打印&#x2F;输出</strong>的内容，支持跳转</p><h5 id="按键用途："><a href="#按键用途：" class="headerlink" title="按键用途："></a>按键用途：</h5><blockquote><table><thead><tr><th>按键</th><th>用途</th></tr></thead><tbody><tr><td>空格space，f，ctrl+f</td><td>向下滚动一屏(后翻，下一页)</td></tr><tr><td>b(意味着back)，ctrl+b</td><td>向上滚动一屏(前翻，上一页)</td></tr><tr><td>q</td><td>退出查看</td></tr><tr><td>enter</td><td>向下n行，需要定义。默认为1行</td></tr><tr><td>&#x3D;</td><td>输出当前的行号</td></tr><tr><td>!命令</td><td>调用shell，并执行命令</td></tr><tr><td>v</td><td>调用vi编辑器</td></tr></tbody></table></blockquote><blockquote><p>向后翻页</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212211159652.gif" alt="Dec-21-2022 11-58-30" style="zoom: 80%;" /><p>向前翻页，按q退出</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212211200255.gif" alt="Dec-21-2022 11-59-56" style="zoom:80%;" /><p>文件内容是被打印出来的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212211204121.gif" alt="Dec-21-2022 12-03-52" style="zoom:80%;" /></blockquote><h5 id="常用选项：-10"><a href="#常用选项：-10" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+NUM # 从文件的第NUM行开始打印</span><br><span class="line">-NUM # 每页只输出NUM行</span><br><span class="line">+/STRING # 在目标文件中寻找含有字符串STRING的一行，并从它的前两行开始打印</span><br><span class="line">-p # 不滚屏，清屏并打印文本</span><br><span class="line">-c # 不滚屏，打印文本并清理行尾</span><br><span class="line">-u # 不打印文件中的下划线</span><br><span class="line">-s # 压缩多个连续空行为一个空行</span><br><span class="line">-d # 显示帮助，提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能</span><br><span class="line">-f # 统计逻辑行数而不是屏幕行数</span><br><span class="line">-l # 忽略ctrl+l(换页)字符，抑制换页(form feed)后的暂停</span><br></pre></td></tr></table></figure><h5 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h5><p>cat和more指令的本质是将文件内容&#x3D;&#x3D;<strong>打印</strong>&#x3D;&#x3D;出来。</p><p>因此实际上只能不断打印输出文件后面的内容，对于文件前面的内容，只能通过翻页的方式查看已经打印出来的。</p><p>当用 more +NUM，从第NUM行开始查看的时候，NUM行之前的内容由于没有被打印出来，所以无法查看到。</p><p>&#x3D;&#x3D;所以cat和more指令更像是文件内容打印指令，而不是正统的文件内容查看指令。&#x3D;&#x3D;</p><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><h5 id="说明：-2"><a href="#说明：-2" class="headerlink" title="说明："></a>说明：</h5><p>&#x3D;&#x3D;Linux正统的文件内容查看工具&#x3D;&#x3D;</p><p>less是进入文件内部加载，进行浏览查看，而不是将文件内容打印出来再进行查看</p><p>less在查看之前不会加载整个文件，只加载浏览位置的内容</p><p>less可以随意浏览文件内容，可以用上下、翻页(pagedown\pageup)、空格、回车、b、f等按键 随意前后移动查看，功能强大，用法具有弹性</p><blockquote><p>前后移动查看</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212211220727.gif" alt="Dec-21-2022 12-20-22" style="zoom:80%;" /><p>退出，发现less并不是将文件内容打印出来，而是进入文件加载，进行浏览查看</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212211223871.gif" alt="Dec-21-2022 12-22-53" style="zoom:80%;" /></blockquote><h5 id="语法：-14"><a href="#语法：-14" class="headerlink" title="语法："></a>语法：</h5><p><code>less [option] 文件</code></p><h5 id="按键用途：-1"><a href="#按键用途：-1" class="headerlink" title="按键用途："></a>按键用途：</h5><table><thead><tr><th>按键</th><th>用途</th></tr></thead><tbody><tr><td>按键</td><td>用途</td></tr><tr><td>空格space，f，ctrl+f，pageup</td><td>向下滚动一屏(后翻，下一页)</td></tr><tr><td>b(意味着back)，ctrl+b，pagedown</td><td>向上滚动一屏(前翻，上一页)</td></tr><tr><td>d，ctrl + d</td><td>向下滚动半屏</td></tr><tr><td>u，ctrl + u</td><td>向上移动半屏</td></tr><tr><td>↓，j</td><td>向下滚动一行</td></tr><tr><td>↑，k</td><td>向上滚动一行</td></tr><tr><td>g</td><td>移动到第一行</td></tr><tr><td>NUMg</td><td>移动到文件的第NUM行</td></tr><tr><td>G</td><td>移动到最后一行</td></tr><tr><td>enter</td><td>向下n行，需要定义。默认为1行</td></tr><tr><td>q，ZZ</td><td>退出查看</td></tr><tr><td>&#x2F;STRING</td><td>向下搜索“STRING”</td></tr><tr><td>?STRING</td><td>向上搜索“STRING”</td></tr><tr><td>n</td><td>重复前一个搜索（与 &#x2F; 或 ? 有关）</td></tr><tr><td>N</td><td>反向重复前一个搜索（与 &#x2F; 或 ? 有关）</td></tr><tr><td>ma</td><td>使用a标记文本的当前位置</td></tr><tr><td>a</td><td>跳转到a标记处</td></tr><tr><td>h</td><td>显示less的帮助文档</td></tr><tr><td>!命令</td><td>调用shell，并执行命令</td></tr><tr><td>v</td><td>调用vi编辑器</td></tr></tbody></table><h5 id="常用选项-可以在浏览文件时使用"><a href="#常用选项-可以在浏览文件时使用" class="headerlink" title="常用选项(可以在浏览文件时使用):"></a>常用选项(可以在浏览文件时使用):</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-i # 忽略搜索时的大小写</span><br><span class="line">-N # 显示每行的行号，再用一次会取消显示每行的行号</span><br></pre></td></tr></table></figure><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><h5 id="语法：-15"><a href="#语法：-15" class="headerlink" title="语法："></a>语法：</h5><p><code>head [option] 文件</code></p><h5 id="功能：-14"><a href="#功能：-14" class="headerlink" title="功能："></a>功能：</h5><p>从指定文件的开头开始输出到标准输出，到文件的某位置结束。默认打印前10行</p><h5 id="常用选项：-11"><a href="#常用选项：-11" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-n +NUM # 打印前NUM行，可以简写成 -n NUM 或 -nNUM 或者 -NUM</span><br><span class="line">-n -NUM # 从第一行开始打印，到倒数第NUM行停止。</span><br><span class="line">-c +SIZE # 从头开始打印，到SIZE个字节停止。可以简写成 -c SIZE 或 -cSIZE</span><br><span class="line">-c -SIZE # 从头开始打印，到倒数第SIZE个字节停止。</span><br><span class="line">-q # 不显示详细处理信息，比如文件名 (默认就是隐藏的)</span><br><span class="line">-v # 显示详细处理信息</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222148587.png" alt="image-20221222214831555" style="zoom:50%;" /><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><h5 id="语法：-16"><a href="#语法：-16" class="headerlink" title="语法："></a>语法：</h5><p><code>tail [option] [文件]</code></p><h5 id="功能：-15"><a href="#功能：-15" class="headerlink" title="功能："></a>功能：</h5><p>有指定文件时，用于从文件某位置开始输出到标准输出，到文件末尾结束。默认打印文件的最后10行。</p><p>无指定文件时，作为输入信息进行处理。</p><p>常用来查看日志文件。</p><h5 id="常用选项：-12"><a href="#常用选项：-12" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-n -NUM # 从倒数第NUM行开始输出，到结尾结束。可以简写成 -n NUM 或 -nNUM 或 -NUM。</span><br><span class="line">-n +NUM # 从正数第NUM行开始输出，到结尾结束。</span><br><span class="line">-c -SIZE # 从倒数第SIZE个字节开始输出，到结尾结束。可以简写成 -c SIZE 或 -cSIZE</span><br><span class="line">-c +SIZE # 从正数第SIZE个字节开始输出，到结尾结束。</span><br><span class="line">-f # 循环读取</span><br><span class="line">-p # 不显示详细处理信息，比如文件名(默认就是不显示的)</span><br><span class="line">-v # 显示详细的处理信息</span><br><span class="line">-s S # 与-f合用，表示在每反复的间隔休息S秒</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222152371.png" alt="截屏2022-12-22 21.52.01" style="zoom:50%;" /><blockquote><p>现在创建了一个一共100行的文件，请取出第50行</p><center>  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222153309.png" alt="截屏2022-12-22 21.53.18" style="zoom:50%;" /><br>生成1到100的序列并输出重定向到文件atest</center><p>方法一：</p><blockquote><p>将atest的前50行输出重定向到新文件tmp中</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222157524.png" alt="截屏2022-12-22 21.57.55" style="zoom:50%;" /><p>输出tmp的最后一行</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222158536.png" alt="截屏2022-12-22 21.58.37" style="zoom:50%;" /></blockquote><p>方法二：</p><blockquote><p>利用管道，输出atest的前五十行的最后一行s</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222159422.png" alt="截屏2022-12-22 21.59.30" style="zoom:50%;" /></blockquote></blockquote><h4 id="管道-简介"><a href="#管道-简介" class="headerlink" title="管道(简介)"></a>管道(简介)</h4><p>将两个或者多个命令（程序或者进程）连接到一起，把一个命令的输出作为下一个命令的输入，以这种方式连接的两个或者多个命令就形成了<strong>管道（pipe）</strong></p><p>管道可以级联多个命令，将上一个命令的输出作为下一个命令的输入，实现流水线式的操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command1 | command2</span><br><span class="line">command1 | command2 |......| commandN </span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212220959035.png" alt="截屏2022-12-22 09.59.25" style="zoom:50%;" /><p>当在两个命令之间设置管道时，管道符<code>|</code>左边命令的输出就变成了右边命令的输入。只要第一个命令向标准输出写入，而第二个命令是从标准输入读取，那么这两个命令就可以形成一个管道。大部分的 Linux 命令都可以用来形成管道。</p><blockquote><p>这里需要注意，command1 必须有正确输出，而 command2 必须可以处理 command2 的输出结果；而且 command2 只能处理 command1 的正确输出结果，不能处理 command1 的错误信息。</p></blockquote><p>多个被级联起来的命令就像是组成了几条管道联通起来，数据资源在里面进行了传输，非常形象</p><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><h5 id="语法：-17"><a href="#语法：-17" class="headerlink" title="语法："></a>语法：</h5><p><code>echo [option] 输出内容 [输出重定向]</code></p><h5 id="功能：-16"><a href="#功能：-16" class="headerlink" title="功能："></a>功能：</h5><p>将内容输出到到标准输出(默认输出设备是显示器，可以通过输出重定向进行更改输出设备)</p><h5 id="常用选项：-13"><a href="#常用选项：-13" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-e # 支持反斜杠控制的字符转换(具体参见下表)</span><br><span class="line">-n # 取消输出后行末的换行符号(内容输出后换行)</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222100949.png" alt="截屏2022-12-22 21.00.02" style="zoom:50%;" /><center>控制字符表⬇️</center><table><thead><tr><th>控制字符</th><th>作 用</th></tr></thead><tbody><tr><td>\</td><td>输出\本身</td></tr><tr><td>\a</td><td>输出警告音</td></tr><tr><td>\b</td><td>退格键，也就是向左删除键</td></tr><tr><td>\c</td><td>取消输出行末的换行符。和“-n”选项一致</td></tr><tr><td>\e</td><td>Esc键</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\r</td><td>回车键</td></tr><tr><td>\t</td><td>制表符，也就是Tab键</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\Onnn</td><td>按照八进制 ASCII 码表输出字符。其中 0 为数字 0，nnn 是三位八进制数</td></tr><tr><td>\xhh</td><td>按照十六进制 ASCH 码表输出字符。其中 hh 是两位十六进制数</td></tr></tbody></table><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222106931.png" alt="截屏2022-12-22 21.06.54" style="zoom:50%;" /><p>echo经常搭配输出重定向使用，将输入输出到指定文件中，而且如果指定文件不存在，还会创建出来(输出重定向的作用)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222108421.png" alt="截屏2022-12-22 21.08.08" style="zoom:50%;" /><p><a href="http://c.biancheng.net/linux/echo.html">更高级的玩法还看这里</a></p><h4 id="重定向-简介"><a href="#重定向-简介" class="headerlink" title="重定向(简介)"></a>重定向(简介)</h4><p>Linux 中标准的<strong>输入设备&#x2F;标准输入 默认是 键盘</strong>，标准的<strong>输出设备&#x2F;标准输入 默认是 显示器</strong></p><ul><li>输入重定向：指的是重新指定设备来代替键盘作为新的输入设备；</li><li>输出重定向：指的是重新指定设备来代替显示器作为新的输出设备。</li></ul><blockquote><p>新的输入设备：通常是指文件或者命令的执行结果</p><p>新的输出设备：通常是指文件</p></blockquote><p><strong>输入重定向：</strong></p><blockquote><table><thead><tr><th>命令符号格式</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将指定文件作为命令的输入设备</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>表示从标准输入设备（键盘）中读入，直到遇到分界符才停止（读入的数据不包括分界符），这里的分界符其实就是自定义的字符串</td></tr><tr><td>命令 &lt; 文件 1 &gt; 文件 2</td><td>将文件 1 作为命令的输入设备，该命令的执行结果输出到文件 2 中。</td></tr></tbody></table><p>命令 &lt; 文件：用文件代替默认输入设备(键盘)的输入</p><blockquote><p>当使用cat命令时，如果不加目标文件，会从默认输入设备上获取输入并输出到默认输出设备</p><p>更改默认输入设备为指定文件(这就跟cat命令后面加目标文件一个效果了)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212221723418.png" alt="截屏2022-12-22 17.23.54" style="zoom:50%;" /></blockquote><p>命令 &lt;&lt; 分界符：</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212221724262.png" alt="截屏2022-12-22 17.24.45" style="zoom:50%;" /></blockquote><p>命令 &lt; 文件 1 &gt; 文件 2：是输入重定向和输出重定向的结合使用</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212221727249.png" alt="截屏2022-12-22 17.27.12" style="zoom:50%;" /></blockquote></blockquote><p><strong>输出重定向：</strong></p><p>使用频率更高，将命令的结果重定向输出到指定的新输出设备(即文件)中</p><p><strong>&#x3D;&#x3D;注意&#x3D;&#x3D;如果指定的文件是不存在的，输出重定向的时候会创建出这个文件</strong></p><p>输出重定向按<u>性质</u> 分为 标准输出重定向和 错误输出重定向 两种</p><blockquote><p>当命令正确执行时，会产生正确的输出结果，此时将正确的输出结果作为输出设备时是标准输出重定向</p><p>当命令执行失败时，会产生错误输出信息，此时将错误输出信息作为输出设备时时错误输出重定向</p><p>两种在写法上没有区别，只是按照命令的执行成功与否进行了分类</p></blockquote><p>输出重定向按<u>用法</u> 分为 清空写入重定向(&gt;) 和 追加写入重定向(&gt;&gt;)</p><blockquote><p>清空写入重定向(&gt;)：将命令的结果重定向输出到指定的文件中，如果该文件原来已经包含数据，会清空原有数据，再写入新数据</p><p>追加写入重定向(&gt;&gt;)：将命令的结果重定向输出到指定的文件中，如果该文件原来已经包含数据，新数据会写入原有数据的后面</p></blockquote><blockquote><table><thead><tr><th>命令符号格式</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，会清空原有数据，再写入新数据。</td></tr><tr><td>命令 2&gt; 文件</td><td>将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，会清空原有数据，再写入新数据。<br />注意，”2&gt;”是固定格式</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，新数据将写入到原有内容的后面。</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，新数据将写入到原有内容的后面。<br />注意，”2&gt;”是固定格式</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或者 命令 &amp;&gt;&gt; 文件</td><td>将标准输出或者错误输出写入到指定文件，如果该文件中已包含数据，新数据将写入到原有内容的后面。<br />注意，第一种写法中，最后的 “2&gt;&amp;1” 是一体的，可以认为是固定写法。</td></tr></tbody></table><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212222048427.png" alt="截屏2022-12-22 20.47.56" style="zoom:50%;" /></blockquote><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><h5 id="语法：-18"><a href="#语法：-18" class="headerlink" title="语法："></a>语法：</h5><p><code>find [pathname] [option]</code></p><h5 id="功能：-17"><a href="#功能：-17" class="headerlink" title="功能："></a>功能：</h5><p>在指定目录下查找文件</p><p>任何位于选项参数之前的字符串都被视为指定目录</p><p>如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p><h5 id="常用选项：-14"><a href="#常用选项：-14" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-name &quot;NAME&quot; # 在指定目录和子目录下查找文件名为NAME的文件，双引号可以省略。可以结合通配符使用，这个时候加上双引号搜索到的才是是全面的</span><br><span class="line">-type TYPE # 文件类型是TYPE的文件。f是普通文件，d是目录</span><br></pre></td></tr></table></figure><blockquote><p>查看更多用法<a href="https://www.runoob.com/linux/linux-comm-find.html">点这里</a></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212241118537.png" alt="截屏2022-12-24 11.18.40" style="zoom:50%;" /><blockquote><p>Linux下find命令提供了相当多的查找条件，功能很强大。由于find具有强大的功能，所以它的选项也很 多，其中大部分选项都值得我们花时间来了解一下。</p><p>即使系统中含有网络文件系统( NFS)，find命令在该文件系统中同样有效，只你具有相应的权限。</p><p>在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系 统可能会花费很长的时间(这里是指30G字节以上的文件系统)。 </p></blockquote></blockquote><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>行文本过滤工具</p><h5 id="语法：-19"><a href="#语法：-19" class="headerlink" title="语法："></a>语法：</h5><p><code>grep [option] &quot;STRING&quot; 指定文件</code></p><h5 id="功能：-18"><a href="#功能：-18" class="headerlink" title="功能："></a>功能：</h5><p>用于查找指定文件里包含STRING的行，将其打印出来</p><p>双引号可以省略</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212241130543.png" alt="截屏2022-12-24 11.30.14" style="zoom:50%;" /><h5 id="常用选项：-15"><a href="#常用选项：-15" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-i # 查找时忽略大小写</span><br><span class="line">-n # 顺便输出在文件中的行号</span><br><span class="line">-v # 反向选择，即打印出不包含被查找的字符串的行</span><br></pre></td></tr></table></figure><figure style=half>  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212241150576.png" alt="截屏2022-12-24 11.49.36" style="zoom:50%;" />  <img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212241150581.png" alt="截屏2022-12-24 11.49.46" style="zoom:50%;" /></figure><h3 id="打包-和-压缩："><a href="#打包-和-压缩：" class="headerlink" title="打包 和 压缩："></a>打包 和 压缩：</h3><p>&#x3D;&#x3D;打包&#x3D;&#x3D;：也称归档、备份，指的是一个文件或者目录的集合，而这个集合被存储在一个文件中。打包文件没有经过压缩，因此占用的空间就是打包文件中所有文件的总空间。</p><blockquote><p>将多个文件打包形成一个包</p></blockquote><p>&#x3D;&#x3D;压缩&#x3D;&#x3D;：利用算法将文件进行处理，以达到保留最大文件信息而让文件体积变小的目的。</p><blockquote><p>只能将一个文件压缩成一个压缩包</p></blockquote><p>打包就像是将行李放进行李箱。压缩就像是为了减少行李的大小，用收纳法将行李的体积折叠的尽可能小，这样就能在箱子里放入更多的行李，也可以将打包好的行李进行收纳，这样行李占用的体积就更小，可以用更小的行李箱。</p><p>压缩是将文件的大小减小，起到减少资源占用的作用。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212261737354.jpeg" alt="IMG_0891" style="zoom:50%;" /><p>如果想一次性压缩许多零零散散的文件或目录，就得要先把它们打成一个包，然后把这个包压缩。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212261747026.jpeg" alt="IMG_0892" style="zoom:50%;" /><p>压缩软件打包压缩格式界面：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212261740678.jpeg" alt="截屏2022-12-26 17.36.56" style="zoom:50%;" /><h3 id="关于普通文件类型的说明："><a href="#关于普通文件类型的说明：" class="headerlink" title="关于普通文件类型的说明："></a>关于普通文件类型的说明：</h3><p>文件的分类就分为<a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB">上面介绍的几类</a></p><p>在Linux中，并不以文件的后缀来区分文件类型，无论是<code>.c</code> <code>.cpp</code> <code> .zip</code> <code> .tar</code> <code>.txt</code>等，都是普通文件类型，文件后缀只是在处理文件的时候进行区分，比如只有<code>.zip</code>等才能解压，<code>.c</code> <code> .cpp</code>等才能编译等。它们都是普通文件。</p><h3 id="zip-x2F-unzip压缩"><a href="#zip-x2F-unzip压缩" class="headerlink" title="zip&#x2F;unzip压缩"></a>zip&#x2F;unzip压缩</h3><p>压缩包拓展名&#x2F;后缀 是<code>.zip</code></p><h5 id="语法-x2F-功能："><a href="#语法-x2F-功能：" class="headerlink" title="语法&#x2F;功能："></a>语法&#x2F;功能：</h5><p><code>zip [option] ZIPNAME 目标文件 </code>：将目标文件压缩为名称为ZIPNAME的压缩包。压缩包的<code>.zip</code>后缀可带可不带，会自动补上</p><p><code>unzip [option] 指定压缩包  </code>：将压缩包解压到当前目录下。若当前目录下有文件与解压后文件重名，会进行询问是否覆盖。注意，解压后文件的名称是压缩前文件的名称，并不是压缩包的名称。</p><h5 id="常用选项：-16"><a href="#常用选项：-16" class="headerlink" title="常用选项："></a>常用选项：</h5><p>zip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-r # 递归处理，将指定目录下的所有文件和子目录一并处理，分别形成单独的压缩包</span><br><span class="line">-m # 将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中</span><br><span class="line">-v # 显示详细的压缩过程信息(默认)</span><br><span class="line">-q # 在压缩的时候不显示命令的执行过程</span><br><span class="line">-数字 # 压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好</span><br><span class="line">-u # 更新压缩文件，即往压缩文件中添加新文件</span><br></pre></td></tr></table></figure><p>unzip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-d 指定目录 # 将压缩包解压到指定目录</span><br><span class="line">-n # 解压时不覆盖已经存在的文件</span><br><span class="line">-o # 解压时覆盖已经存在的文件，且不向用户询问</span><br><span class="line">-v # 不解压，只是查看压缩包的详细信息，包括压缩包中包含的文件大小、文件名、压缩比等</span><br><span class="line">-t # 不解压，测试压缩包有损坏</span><br><span class="line">-x 文件列表 # 解压，但不包含文件列表中的指定文件</span><br></pre></td></tr></table></figure><h4 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h4><p>只能压缩普通文件。</p><p>就算指定了目录，也是将目录下的所有普通文件一一单独压缩出来。压缩文件的拓展名&#x2F;后缀是<code>.gz</code></p><blockquote><p>gzip压缩完之后源文件会被删除</p></blockquote><h5 id="语法-x2F-功能：-1"><a href="#语法-x2F-功能：-1" class="headerlink" title="语法&#x2F;功能："></a>语法&#x2F;功能：</h5><p><code>gzip [option] 指定文件</code></p><blockquote><p>gzip命令十分简单，不需要指定压缩后的文件的名称，压缩后文件的名称是 <code>源文件名.gz</code></p></blockquote><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令:"></a>常用命令:</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-c # 将压缩数据输出到标准输出中，并保留源文件。可以将数据重定向到压缩包中，这样在不删除源文件的同时还不会将数据打印到屏幕上</span><br><span class="line">-d # 对压缩包解压</span><br><span class="line">-f # 强行压缩或解压文件，不理会文件名或者硬连接是否存在以及该文件是否为符号连接。</span><br><span class="line">-r # 递归压缩指定目录下及其子目录下的所有普通文件</span><br><span class="line">-v # 压缩和解压时，显示压缩包的文件名和压缩比等详细信息</span><br><span class="line">-l # 显示每个压缩文件的大小、压缩比，未压缩文件的大小、未压缩文件的名称等详细信息</span><br><span class="line">-数字 # 压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好</span><br><span class="line">-h # 显示帮助</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212251324128.png" alt="截屏2022-12-25 13.23.46" style="zoom:50%;" /><h4 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h4><p>只能压缩普通文件。</p><p>就算指定了目录，也是将目录下的所有普通文件一一单独压缩出来。压缩文件的拓展名&#x2F;后缀是<code>.bz2</code></p><p>从理论上来讲，bzip2的算法比gzip更先进、压缩比更好；而gzip的压缩速度相对来讲更快</p><blockquote><p>bzip2压缩完之后源文件会被删除</p></blockquote><h5 id="语法：-20"><a href="#语法：-20" class="headerlink" title="语法："></a>语法：</h5><p><code>bzip2 [option] 指定文件</code></p><blockquote><p>gzip命令十分简单，不需要指定压缩后的文件的名称，压缩后文件的名称是 <code>源文件名.bz2</code></p></blockquote><h5 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-c # 将压缩和解压的结果送到标准输出</span><br><span class="line">-d # 解压</span><br><span class="line">-f # 压缩或解压时，若出现输出文件与现有文件重名，会直接覆盖。(默认是不会覆盖的)</span><br><span class="line">-h # 显示帮助</span><br><span class="line">-k # 在压缩或解压后不会删除源文件</span><br><span class="line">-s # 强制进行压缩</span><br><span class="line">-V # 显示版本信息</span><br></pre></td></tr></table></figure><h3 id="tar打包-x2F-解包"><a href="#tar打包-x2F-解包" class="headerlink" title="tar打包&#x2F;解包"></a>tar打包&#x2F;解包</h3><h5 id="语法：-21"><a href="#语法：-21" class="headerlink" title="语法："></a>语法：</h5><p><code>tar [option] 指定文件</code></p><h4 id="打包："><a href="#打包：" class="headerlink" title="打包："></a>打包：</h4><p>也称归档、备份</p><p>打包并不是压缩，只是将文件打包到一个集合中，但是如果想要将一堆文件进行压缩的话，首先就得先把这堆零零散散的文件打一个包，这样才方便压缩。所以打包是很重要的。打包后的文件后缀为<code>.tar</code></p><h5 id="常用选项：-17"><a href="#常用选项：-17" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-c # 进行打包的指令</span><br><span class="line">-f TARNAME # 指定包的文件名为TARNAME。注意要加上.tar后缀</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本质上是将打包好的内容输出到名为TARNAME的tar包中</span></span><br><span class="line">-v # 显示详细过程信息</span><br><span class="line">-A # 追加tar文件到打包文件中</span><br><span class="line">-z TARGZIPNAME # 询问是否在打包后同时进行gzip压缩，并将压缩包命名为TARGZIPNAME。注意要加上后缀.tar.gz</span><br><span class="line">-j TARBZIP2NAME # 询问是否在打包后同时进行bzip2压缩，并将压缩包命名为TAEBZIP2NAME。要加后缀.tar.bz2</span><br><span class="line">-p # 打包的时候保留源文件的属性（权限等）</span><br><span class="line">-N &quot;YYYY/MM/DD&quot; # 打包比某日期新的文件</span><br><span class="line">--exclude 文件 # 打包时不打包该文件</span><br><span class="line">-u # 更新原压缩包的文件</span><br></pre></td></tr></table></figure><h5 id="说明：-3"><a href="#说明：-3" class="headerlink" title="说明："></a>说明：</h5><blockquote><ol><li>-cfv 常视作打包的习惯用法</li><li>tar命令的选项中 <code>-</code> 是可加可不加的，比如 <code>-cfv</code> 和 <code>cfv</code> 是一样的</li><li>tar可以将多个文件进行打包，文件之间用空格间隔开就可以。</li><li>tar也可以将目录下的所有文件都打包，例如将date目录下的所有文件都打包：<code>tar -cvf date.tar ./date/</code></li><li>通常都是在打包时同时进行gzip或者bzip2压缩</li><li><u>要注意，一般情况Linux命令的选项是可以不管顺序的，但是在这里</u>，-f后面紧跟包的名称，所以压缩的时候要把-f放在选项最后，否则会报错</li></ol></blockquote><h5 id="应用举例："><a href="#应用举例：" class="headerlink" title="应用举例："></a>应用举例：</h5><blockquote><ol><li><p>将 .&#x2F;test 目录下的文件全部打包为<code>test.tar</code></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271109047.png" alt="截屏2022-12-27 11.09.06" style="zoom:50%;" /></li><li><p>将test目录下的文件全部打包并压缩为<code>tt.tar.gz</code></p><blockquote><p>注意选项的顺序，-f要放在选项的最后面，否则会报错</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271116816.png" alt="image-20221227111606770" style="zoom:50%;" /></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271116841.png" alt="截屏2022-12-27 11.16.26" style="zoom:50%;" /></li><li><p>打包 .&#x2F;test 和 .&#x2F;date并压缩为<code>myfile.tar.gz</code>，但是不打包.&#x2F;test中的date</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271124056.png" alt="截屏2022-12-27 11.24.12" style="zoom:50%;" /></li><li><p>将用户目录下的所有文件备份并压缩，且保留其权限</p><p>(使用的相对路径，也可以使用绝对路径)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271217612.png" alt="截屏2022-12-27 12.17.13" style="zoom:50%;" /><blockquote><p>在最后一行会提示：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271217195.png" alt="截屏2022-12-27 12.17.34" style="zoom:50%;" /><p>这是因为我们将用户目录中的所有文件都备份并压缩了，在执行完命令之后，会在当前目录下生成压缩包</p><p>而当前目录就是用户目录，所以压缩包声明在了用户目录下</p><p>原来的目标文件，也是用户目录，所以原来的目标文件内容发生了变化，就会给出这个提示</p><p>如果再执行一次这个命令(使用的绝对路径，也可以使用相对路径)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271223698.png" alt="截屏2022-12-27 12.23.07" style="zoom:50%;" /><p>会在压缩的时候显示</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271224909.png" alt="截屏2022-12-27 12.23.57" style="zoom:50%;" /><p>因为在压缩之前已经有了yujin.tar.gz这个文件，在压缩用户目录的时候会将它压缩，然后在压缩完用户目录之后又会生成yujin.tar.gz这个压缩包，相当于时间先后、新旧文件的更改，所以会给出这种说明</p></blockquote></li><li><p>在test目录下，比2022&#x2F;12&#x2F;26新的文件才会被打包</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271232344.png" alt="截屏2022-12-27 12.32.14" style="zoom:50%;" /><blockquote><p>命令的最后面可以是<code>./test</code>也可以是<code>./test/</code>或者<code>test</code>、 <code>test/</code></p></blockquote></li></ol></blockquote><h4 id="解包："><a href="#解包：" class="headerlink" title="解包："></a>解包：</h4><h5 id="常用选项：-18"><a href="#常用选项：-18" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-t # 不解包，直接查看tar包里的内容</span><br><span class="line">-x # 解包</span><br><span class="line">-v # 显示详细过程信息</span><br><span class="line">-f # 查看或解包.tar时带上这个选项</span><br><span class="line">-z # 如果压缩包是.tar.gz，那么查看或者解包的时候要加上这个选项</span><br><span class="line">-j # 如果压缩包是.tar.bz2，那么查看或者解包的时候要加上这个选项</span><br><span class="line">-C 指定目录 # 解压到指定目录。如果不带此选项，默认是解包到当前目录</span><br></pre></td></tr></table></figure><h5 id="应用举例：-1"><a href="#应用举例：-1" class="headerlink" title="应用举例："></a>应用举例：</h5><blockquote><ol><li><p>查看上面压缩的<code>mylife.tar.gz</code>中的文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271147961.png" alt="截屏2022-12-27 11.47.24" style="zoom:50%;" /></li><li><p>将<code>test.tar</code>解包到date目录下</p><p>可以先进入到指定目录，再解压到当前目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271152042.png" alt="截屏2022-12-27 11.52.25" style="zoom:50%;" /><p>也可以用选项-C直接解压到指定目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271240994.png" alt="image-20221227124038949" style="zoom:50%;" /></li><li><p>只想将<code>test.tar.gz</code>中的dir1解开到当前目录</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271813984.png" alt="截屏2022-12-27 18.13.21" style="zoom:50%;" /><blockquote><p>可以看到，解压出的文件是按照原来的层级形成的，解压出test目录下的dir1目录下的mytest.c</p></blockquote></li><li><p>将a目录进行打包，并立即在dir1目录下解开它(这就相当于将a目录移动到dir1目录下，跟cp类似)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212271749705.png" alt="截屏2022-12-27 17.49.53" style="zoom:50%;" /><blockquote><p>运用了管道，将前一个命令的输出作为后一个命令的输入</p><p>这里的单独的<code>-</code>意思是标准输入输出(standard input , standard output)</p><p>在前面的命令中，是将a目录进行打包，然后输出到-f 后面的文件中，-f后面跟的是-，也就是标准输出，所以就是将打包好的a目录输出到了标准输出</p><p>在后面的命令中，-xvf 后面跟的是 - ，也就是要解压的包是标准输出上的，并解压到dir1</p><p>这样就用管道命令和标准输入输出实现了</p></blockquote></li></ol></blockquote><h3 id="bc"><a href="#bc" class="headerlink" title="bc"></a>bc</h3><p>可以很方便进行浮点运算，用的时候man一下查找用法即可，此处不再赘述</p><h3 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h3><h5 id="语法：-22"><a href="#语法：-22" class="headerlink" title="语法："></a>语法：</h5><p><code>uname [option]</code></p><h5 id="功能：-19"><a href="#功能：-19" class="headerlink" title="功能："></a>功能：</h5><p>显示电脑的操作系统等信息</p><h5 id="常用选项：-19"><a href="#常用选项：-19" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a # 输出所有详细信息，依次为内核名称、主机名、内核版本号、内核版本、硬件名、处理器类型、硬件平台信息、操作系统名称</span><br></pre></td></tr></table></figure><h3 id="几个重要的热键"><a href="#几个重要的热键" class="headerlink" title="几个重要的热键"></a>几个重要的热键</h3><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>Tab</td><td>命令补全、档案补齐</td></tr><tr><td>ctrl + c</td><td>终止当前进程</td></tr><tr><td>ctrl + d</td><td>代表“键盘输入结束(End of file,EOF,End of input)“的意思；<br />另外，也可以取代exit命令来登出Linux账户</td></tr></tbody></table><p><u>更多快捷键请见linuxJournal中的快捷键整理</u></p><h2 id="Linux权限的概念"><a href="#Linux权限的概念" class="headerlink" title="Linux权限的概念"></a>Linux权限的概念</h2><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>Linux中有两种用户：超级用户(root)、普通用户</p><blockquote><p>超级用户：可以在Linux系统内做任何事情，不受限制。命令提示符是：#</p><p>普通用户：在Linux下做有限的事情。命令提示符是：$</p></blockquote><h4 id="用户切换指令：su"><a href="#用户切换指令：su" class="headerlink" title="用户切换指令：su"></a>用户切换指令：su</h4><h5 id="语法：-23"><a href="#语法：-23" class="headerlink" title="语法："></a>语法：</h5><p><code>su [USERNAME]</code></p><h5 id="功能：-20"><a href="#功能：-20" class="headerlink" title="功能："></a>功能：</h5><p>切换用户</p><h5 id="说明：-4"><a href="#说明：-4" class="headerlink" title="说明："></a>说明：</h5><p>当只使用su命令的时候，是切换到root用户，输入root用户的密码</p><p>当使用 su USERNAME 的时候，是切换到名称为USERNAME的普通用户，并要输入那个用户的密码；如果是从root切换到别的普通用户，不需要输入密码</p><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><h5 id="语法：-24"><a href="#语法：-24" class="headerlink" title="语法："></a>语法：</h5><p><code>sudo [option] 指令</code></p><h5 id="功能：-21"><a href="#功能：-21" class="headerlink" title="功能："></a>功能：</h5><p>以root身份执行当前指令</p><h5 id="说明：-5"><a href="#说明：-5" class="headerlink" title="说明："></a>说明：</h5><p>不会切换身份，只是用root身份执行指令，当前用户(使用sudo命令的用户)不变，相当于在执行指令的时候暂时提高了权限</p><h5 id="常用选项：-20"><a href="#常用选项：-20" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-u USERNAME # 以USERNAME身份执行当前命令</span><br><span class="line">-l # 显示当前用户(使用sudo命令的用户)的权限</span><br></pre></td></tr></table></figure><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><h4 id="文件访问者的分类："><a href="#文件访问者的分类：" class="headerlink" title="文件访问者的分类："></a>文件访问者的分类：</h4><p>访问文件的人有三种</p><blockquote><p>文件的所有者：u——User</p><p>文件所有者所在组的用户：g——Group</p><p>其他用户：o——Others</p></blockquote><p>其中，文件的创建者不一定就是文件的所有者，文件的所有权是可以转让的</p><p>Group，在工作中，一般是以团队进行的，文件的所有者是属于某一个团队的，这个团队的人有时就需要访问这个文件，文件所有者可以创建一个Group，指定在Group里的所有人对于这个文件的访问权限。文件所有者本人本身就是一个团队，他可以往团队里加人。</p><p>Others就是不属于前两者的人。</p><h4 id="文件类型和访问权限-文件属性-："><a href="#文件类型和访问权限-文件属性-：" class="headerlink" title="文件类型和访问权限(文件属性)："></a>文件类型和访问权限(文件属性)：</h4><p>在使用<code>ll</code>命令的时候会展示出文件的详细信息</p><div><center><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212181050726.png" alt="image-20221218105015699" style="zoom:30%;" /><br>Linux文件默认是按照名称排序的</center></div><p>文件属性包括文件类型和文件权限，文件类型就是文件的种类，包括普通文件、目录文件等，详细在一开始有讲过<a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB">在这里可以查看一下</a></p><p>文件权限就是，文件访问者对于文件的访问权限是如何的</p><blockquote><ul><li><p>读(r):Read 对文件而言，具有读取文件内容的权限；对目录来说，具有ls浏览该目录信息的权限</p></li><li><p>写(w):Write 对文件而言，具有修改文件内容的权限；对目录来说具有创建删除移动目录内文件的权限 </p></li><li><p>执行(x):execute 对文件而言，具有执行文件的权限；对目录来说，具有cd进入目录的权限</p></li><li><p>“-“表示不具有该项权限</p></li></ul><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212281710542.png" alt="截屏2022-12-28 17.10.03" style="zoom: 33%;" /></blockquote><h4 id="文件权限的表示方法："><a href="#文件权限的表示方法：" class="headerlink" title="文件权限的表示方法："></a>文件权限的表示方法：</h4><ol><li><p>字符表示方法</p><table><thead><tr><th align="center">Linux字符表示</th><th align="center">权限说明</th><th align="center">Linux字符表示</th><th align="center">权限说明</th></tr></thead><tbody><tr><td align="center">r–</td><td align="center">只读</td><td align="center">-w-</td><td align="center">仅可写</td></tr><tr><td align="center">–x</td><td align="center">仅可执行</td><td align="center">rw-</td><td align="center">可读可写</td></tr><tr><td align="center">-wx</td><td align="center">可写可执行</td><td align="center">r-x</td><td align="center">可读可执行</td></tr><tr><td align="center">rwx</td><td align="center">全部权限</td><td align="center">—</td><td align="center">无任何权限</td></tr></tbody></table></li><li><p>8进制数值表示方法</p><p>对于权限的顺序，可以排列为r、w、x</p><p>对于权限的有无，可以用二进制表示，0表示没有这个权限，1表示有这个权限</p><p>故r、w、x这三个权限可以用三个二进制数表示，而三个二进制数又能被一个八进制数表示</p><table><thead><tr><th>权限符号</th><th>二进制</th><th>八进制</th></tr></thead><tbody><tr><td>—</td><td>000</td><td>0</td></tr><tr><td>r–</td><td>100</td><td>4</td></tr><tr><td>-w-</td><td>010</td><td>2</td></tr><tr><td>–r</td><td>001</td><td>1</td></tr><tr><td>rw-</td><td>110</td><td>6</td></tr><tr><td>r-x</td><td>101</td><td>5</td></tr><tr><td>-wx</td><td>011</td><td>3</td></tr><tr><td>rwx</td><td>111</td><td>7</td></tr></tbody></table></li></ol><h4 id="文件访问权限的设置方法："><a href="#文件访问权限的设置方法：" class="headerlink" title="文件访问权限的设置方法："></a>文件访问权限的设置方法：</h4><h5 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h5><h6 id="功能：-22"><a href="#功能：-22" class="headerlink" title="功能："></a>功能：</h6><p>设置文件的访问权限</p><h6 id="语法：-25"><a href="#语法：-25" class="headerlink" title="语法："></a>语法：</h6><p><code>chmod [option] 权限 文件</code></p><h6 id="说明：-6"><a href="#说明：-6" class="headerlink" title="说明："></a>说明：</h6><p>只有文件所有者和root用户才能修改文件访问权限的权限</p><h6 id="常用选项：-21"><a href="#常用选项：-21" class="headerlink" title="常用选项："></a>常用选项：</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R # 递归修改目录文件的权限</span><br></pre></td></tr></table></figure><h6 id="权限格式一："><a href="#权限格式一：" class="headerlink" title="权限格式一："></a>权限格式一：</h6><p>用户表示符 +或-或&#x3D; 文件权限字符</p><blockquote><p>用户表示符：</p><ul><li>u拥有者</li><li>g同组者</li><li>o其他用户</li><li>a所有用户</li></ul><p>+：向用户增加(追加)权限</p><p>-：向用户取消(减少)权限</p><p>&#x3D;：向用户赋予权限，也就是用户只有被赋予的权限</p></blockquote><blockquote><p>向hello.txt的拥有者追加执行权限</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282037692.png" alt="截屏2022-12-28 20.36.43" style="zoom:50%;" /><p>向hello.txt的同组者减少可写权限</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282040631.png" alt="截屏2022-12-28 20.40.03" style="zoom:50%;" /><p>向hello.txt的其他人只赋予可写权限</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282041865.png" alt="截屏2022-12-28 20.41.15" style="zoom:50%;" /><blockquote><p>可以看到others原来是有rw权限，但是被赋予w权限之后，就只有w权限了</p></blockquote></blockquote><h6 id="权限格式二："><a href="#权限格式二：" class="headerlink" title="权限格式二："></a>权限格式二：</h6><p>三个8进制数表示权限   （方便常用）</p><blockquote><p>第一个八进制数表示user的权限</p><p>第二个表示group的权限</p><p>第三个表示other的权限</p><p>跟文件的权限对应</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212281710542.png" alt="截屏2022-12-28 17.10.03" style="zoom: 25%;" /></blockquote><blockquote><p>将hello.txt的文件权限设置为rwx rwx rwx</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282045567.png" alt="截屏2022-12-28 20.45.01" style="zoom:50%;" /><blockquote><p>rwx对应的二进制就是111，对应的八进制数就是7</p></blockquote><p>将hello.txt的文件权限设置为555</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282049750.png" alt="截屏2022-12-28 20.49.33" style="zoom:50%;" /><blockquote><p>5对应的权限就是101即r-x</p></blockquote><p>将hello.txt的文件权限设置为754</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282050739.png" alt="截屏2022-12-28 20.50.54" style="zoom:50%;" /></blockquote><h5 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h5><h6 id="功能：-23"><a href="#功能：-23" class="headerlink" title="功能："></a>功能：</h6><p>修改文件的拥有者</p><h6 id="语法：-26"><a href="#语法：-26" class="headerlink" title="语法："></a>语法：</h6><p><code>chown [option] 用户名 文件名</code></p><h6 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h6><p>只有root用户才有权限使用这个命令</p><h6 id="常用选项：-22"><a href="#常用选项：-22" class="headerlink" title="常用选项："></a>常用选项：</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-v # 显示详细过程信息</span><br><span class="line">-R # 递归更改目录的拥有者</span><br><span class="line">-help # 查看用法帮助</span><br><span class="line">-f # 忽略错误信息</span><br></pre></td></tr></table></figure><h6 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h6><blockquote><p>把hello.txt的所属权从yujin转给chenyujin</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282101595.png" alt="截屏2022-12-28 21.01.19" style="zoom:50%;" /></blockquote><h5 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h5><h6 id="功能：-24"><a href="#功能：-24" class="headerlink" title="功能："></a>功能：</h6><p>修改文件所属组 </p><h6 id="语法：-27"><a href="#语法：-27" class="headerlink" title="语法："></a>语法：</h6><p><code>chgrp [option] 用户组名 文件名</code></p><h6 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h6><p>与chown不同，只要是文件原组里的用户，就可以修改文件的所属组</p><h6 id="常用选项：-23"><a href="#常用选项：-23" class="headerlink" title="常用选项："></a>常用选项：</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-v # 显示详细过程信息</span><br><span class="line">-c # 效果类似&quot;-v&quot;参数，但仅显示更改的部分。</span><br><span class="line">-R # 递归更改目录的拥有者</span><br></pre></td></tr></table></figure><h5 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h5><h6 id="功能：-25"><a href="#功能：-25" class="headerlink" title="功能："></a>功能：</h6><p>查看或修改文件权限掩码</p><h6 id="语法：-28"><a href="#语法：-28" class="headerlink" title="语法："></a>语法：</h6><p><code>umask 权限掩码值</code></p><h6 id="说明：-7"><a href="#说明：-7" class="headerlink" title="说明："></a>说明：</h6><p>将现有的默认权限减去权限掩码，即可产生创建文件时的预设权限</p><h5 id="权限掩码-简介"><a href="#权限掩码-简介" class="headerlink" title="权限掩码(简介)"></a>权限掩码(简介)</h5><p>在创建目录文件的时候，默认权限是775</p><p>在创建普通文件的时候，默认权限是664</p><p>（不同系统上可能有差别，此处以centOS7为例</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212171711414.png" alt="202212171709806" style="zoom:50%;" /><p>但是实际上：</p><blockquote><ol><li>普通目录的默认起始预设权限是777，普通文件的默认起始预设权限是666</li><li>权限掩码umask会在用户创建目录或者文件时拿掉一些默认起始权限，得到的才是创建之后的默认权限</li></ol><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask # 查看权限掩码</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212171704218.png" alt="截屏2022-12-17 17.03.59" style="zoom:50%;" /><p>当前系统下的权限掩码是0002（第一位不用看，代表特殊权限，此处暂不讨论。当然，在写权限的时候是可以带上的，比如0777</p><p>系统会拿掉权限掩码对应的权限，002则对应着owner: 0, grouper: 0, other: 2</p><p>意味着other会被拿掉2权限(2是八进制数，对应的二进制数是010，也就是w权限)</p><p>对于目录，ohter的默认起始权限是<strong>7</strong>(也就是111,rwx)，被拿掉<strong>2</strong>(也就是010,w)之后就变成了<strong>5</strong>(也就是101,rx)，所以创建出的目录的默认权限就变成了775</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212171731199.png" alt="截屏2022-12-17 17.31.22" style="zoom:40%;" /><p>对于文件，other的默认起始权限是<strong>6</strong>(110,rw)，被拿掉<strong>2</strong>(010,w)之后就变成了<strong>4</strong>(100,r)，所以创建出的文件默认权限就是664</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212171732621.png" alt="截屏2022-12-17 17.32.26" style="zoom:40%;" /></blockquote></blockquote><h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><h5 id="功能：-26"><a href="#功能：-26" class="headerlink" title="功能："></a>功能：</h5><p>查看文件类型</p><h5 id="语法：-29"><a href="#语法：-29" class="headerlink" title="语法："></a>语法：</h5><p><code>file [option] 文件</code></p><h5 id="常用选项：-24"><a href="#常用选项：-24" class="headerlink" title="常用选项："></a>常用选项：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-c # 显示详细执行过程，便于排错或分析程序执行的情形 </span><br><span class="line">-z # 尝试去解读压缩文件的内容</span><br></pre></td></tr></table></figure><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282224254.png" alt="截屏2022-12-28 22.24.01" style="zoom:50%;" /></blockquote><h4 id="粘滞位"><a href="#粘滞位" class="headerlink" title="粘滞位"></a>粘滞位</h4><p>让我们回顾一下目录的权限：</p><blockquote><ul><li><p>读(r):Read 对目录来说，具有ls浏览该目录信息的权限</p></li><li><p>写(w):Write 对目录来说具有创建删除移动目录内文件的权限 </p></li><li><p>执行(x):execute 对目录来说，具有cd进入目录的权限</p></li></ul></blockquote><p>那这样的话，只要用户具有目录的w权限，就能删除目录中的文件。</p><p>那么问题来了，当张三和李四对于一个目录都有w的权限的时候，张三创建了一个文件，结果被李四删除了！我张三创建的文件你李四凭什么给我删除了！？这不科学呀</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282254005.png" alt="截屏2022-12-28 22.53.59" style="zoom:50%;" /><blockquote><p>这里yujin具有work目录的w权限(属于others)，他将work里root创建的root_work删除了</p></blockquote><p>为了解决这个不科学的问题，就出现了粘滞位</p><h5 id="说明-amp-功能-amp-用法："><a href="#说明-amp-功能-amp-用法：" class="headerlink" title="说明&amp;功能&amp;用法："></a>说明&amp;功能&amp;用法：</h5><p>目录的所有者可以对目录添加粘滞位，加上了粘滞位的目录，具有w权限的用户不能删除目录下别人的文件了，只能删除自己的文件</p><p><code>chmod +t 目录</code></p><blockquote><p>只有 root 和 目录所有者 才能给目录加上粘滞位</p></blockquote><blockquote><p>将work目录加上粘滞位之后，yujin就没办法删除root创建的文件root_work2了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212282310392.png" alt="image-20221228231028314" style="zoom:50%;" /></blockquote><p><strong>当一个目录被加上粘滞位的时候，该目录下的文件只能由</strong></p><blockquote><ol><li><strong>root删除</strong></li><li><strong>该目录的所有者删除</strong></li><li><strong>该文件的所有者删除</strong></li></ol></blockquote><h4 id="关于权限的总结"><a href="#关于权限的总结" class="headerlink" title="关于权限的总结"></a>关于权限的总结</h4><blockquote><ul><li>目录的可执行权限是表示你可否在目录下执行命令</li><li>如果目录没有-x权限，则无法对目录执行任何命令，甚至无法cd 进入目, 即使目录仍然有-r 读权限(这 个地方很容易犯错，认为有读权限就可以进入目录读取目录下的文件) </li><li>而如果目录具有-x权限，但没有-r权限，则用户可以执行命令，可以cd进入目录。但由于没有目录的读 权限,所以在目录下，即使可以执行ls命令，但仍然没有权限读出目录下的文档。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电脑正确坐姿：健康才是是第一生产力</title>
      <link href="/chunyujin/768897a3.html"/>
      <url>/chunyujin/768897a3.html</url>
      
        <content type="html"><![CDATA[<p>🧑🏻‍💻</p><h3 id="电脑正确坐姿-健康才是是第一生产力！！"><a href="#电脑正确坐姿-健康才是是第一生产力！！" class="headerlink" title="电脑正确坐姿_健康才是是第一生产力！！"></a>电脑正确坐姿_健康才是是第一生产力！！</h3><blockquote><p>以下所有都只是建议，要根据自己情况来就行</p></blockquote><h4 id="挺直腰背。腰背可以靠在靠背上，放松，让靠背承力"><a href="#挺直腰背。腰背可以靠在靠背上，放松，让靠背承力" class="headerlink" title="挺直腰背。腰背可以靠在靠背上，放松，让靠背承力"></a>挺直腰背。腰背可以靠在靠背上，放松，让靠背承力</h4><h4 id="放松肩部肌肉，不要耸肩，颈肩背不要前倾，不要用肩膀承力"><a href="#放松肩部肌肉，不要耸肩，颈肩背不要前倾，不要用肩膀承力" class="headerlink" title="放松肩部肌肉，不要耸肩，颈肩背不要前倾，不要用肩膀承力"></a>放松肩部肌肉，不要耸肩，颈肩背不要前倾，不要用肩膀承力</h4><p>避免含胸驼背！！</p><p>建议购买人体工学椅或升降桌，调整高度到自己舒服的位置</p><h4 id="调整键盘位置：，大臂放松，自然下垂于身体两侧，键盘不要离身体太远，使大臂与小臂呈大约90～120度-键盘太远会导致前倾-；键盘高度最好位于肚脐高度附近，小臂自然舒适放在桌面上，使不会耸肩，不会使肩膀、大臂前倾，还能使视线能自然看到双手和键盘【根据自身舒适情况调整"><a href="#调整键盘位置：，大臂放松，自然下垂于身体两侧，键盘不要离身体太远，使大臂与小臂呈大约90～120度-键盘太远会导致前倾-；键盘高度最好位于肚脐高度附近，小臂自然舒适放在桌面上，使不会耸肩，不会使肩膀、大臂前倾，还能使视线能自然看到双手和键盘【根据自身舒适情况调整" class="headerlink" title="调整键盘位置：，大臂放松，自然下垂于身体两侧，键盘不要离身体太远，使大臂与小臂呈大约90～120度(键盘太远会导致前倾)；键盘高度最好位于肚脐高度附近，小臂自然舒适放在桌面上，使不会耸肩，不会使肩膀、大臂前倾，还能使视线能自然看到双手和键盘【根据自身舒适情况调整"></a>调整键盘位置：，大臂放松，自然下垂于身体两侧，键盘不要离身体太远，使大臂与小臂呈大约90～120度(键盘太远会导致前倾)；键盘高度最好位于肚脐高度附近，小臂自然舒适放在桌面上，使不会耸肩，不会使肩膀、大臂前倾，还能使视线能自然看到双手和键盘【根据自身舒适情况调整</h4><h4 id="保证视线平视显示器而不低头；与显示器保持合适距离，一般建议在1-5～2倍显示器高度之间，这样才能使观感舒适（比如27寸显示器高度为35～37cm，建议眼睛距离显示器52-5～70cm之间以达到舒适的观感"><a href="#保证视线平视显示器而不低头；与显示器保持合适距离，一般建议在1-5～2倍显示器高度之间，这样才能使观感舒适（比如27寸显示器高度为35～37cm，建议眼睛距离显示器52-5～70cm之间以达到舒适的观感" class="headerlink" title="保证视线平视显示器而不低头；与显示器保持合适距离，一般建议在1.5～2倍显示器高度之间，这样才能使观感舒适（比如27寸显示器高度为35～37cm，建议眼睛距离显示器52.5～70cm之间以达到舒适的观感"></a>保证视线平视显示器而不低头；与显示器保持合适距离，一般建议在1.5～2倍显示器高度之间，这样才能使观感舒适（比如27寸显示器高度为35～37cm，建议眼睛距离显示器52.5～70cm之间以达到舒适的观感</h4><p>如果显示器高度不够，可以购买增高支架或者桌面置物架来增高</p><h4 id="达到观感、腰背、肩膀、手臂、腰部都能十分舒适的平衡点"><a href="#达到观感、腰背、肩膀、手臂、腰部都能十分舒适的平衡点" class="headerlink" title="达到观感、腰背、肩膀、手臂、腰部都能十分舒适的平衡点"></a>达到观感、腰背、肩膀、手臂、腰部都能十分舒适的平衡点</h4><h3 id="总之，核心就是舒服：肩膀舒服，脖子舒服，腰部舒服，眼睛舒服，使用键鼠方便。"><a href="#总之，核心就是舒服：肩膀舒服，脖子舒服，腰部舒服，眼睛舒服，使用键鼠方便。" class="headerlink" title="总之，核心就是舒服：肩膀舒服，脖子舒服，腰部舒服，眼睛舒服，使用键鼠方便。"></a>总之，核心就是舒服：肩膀舒服，脖子舒服，腰部舒服，眼睛舒服，使用键鼠方便。</h3><h5 id="购买建议："><a href="#购买建议：" class="headerlink" title="购买建议："></a>购买建议：</h5><blockquote><p>人体工学椅</p><p>显示器支架臂</p></blockquote><hr><h4 id="关于为什么要把键盘放在桌面上而不是键盘托盘上："><a href="#关于为什么要把键盘放在桌面上而不是键盘托盘上：" class="headerlink" title="关于为什么要把键盘放在桌面上而不是键盘托盘上："></a>关于为什么要把键盘放在桌面上而不是键盘托盘上：</h4><p>[知乎链接](既然大家都喜欢把键盘放在桌子上，为什么电脑桌还要设计托盘？ - 华而无为的回答 - 知乎 <a href="https://www.zhihu.com/answer/2808056675">https://www.zhihu.com/answer/2808056675</a>)</p><p>最近本人一直在被这个问题纠结。本人在学校的时候宿舍使用了人体工学椅，可以调节高度到健康的位置。但是家里的办公桌是大电脑桌，有一个键盘托盘，桌子高度75cm，电脑托盘高度是60cm，本人身高较高，当键盘放在桌子上的时候，键盘会略微高于手肘，但是将手肘放到桌子上的时候，颈肩肘都是可以得到放松的，这属于比较小的误差吧。当键盘放在托盘上的时候，会感觉不习惯，而且本人用的是很薄的键盘，打字要去够才能够到。</p><ol><li><p>起始电脑托盘的存在属于电脑桌这个外设跟不上电子产品发展，电脑托盘属于落后的产物，电脑桌的传统设计在国内也没有更改过。电脑桌的基本设计理念一直延续着它刚诞生的情况，现在很多新的人体工程电脑桌要不就是升降的，要不就是不带键盘托盘的。</p></li><li><p>另一个方面，看现在的键盘，比较传统的薄膜键盘和机械键盘的厚度基本上是和上世纪的键盘厚度一样， 放到键盘托盘上还是可以比较容易敲击的；现在生产的比较新的薄膜键盘，都是极薄设计的，这种设计就是在桌面上用的比较爽的。 </p></li><li><p>当你将键盘放在托盘上的时候，你的姿势会维持在一个固定的角度，就像是身体被卡在了那里，虽然姿势满足健康坐姿，但是久坐之后对于身体是很不好的。当键盘鼠标放在桌子上的时候，可以很轻松调整自己的坐姿和更改键盘的位置，避免久坐不动的现象。</p></li><li><p>将键盘放到托盘里，人会里显示器很远，看不清显示器</p></li><li><p>将键盘放在托盘里，人很难看到键盘(要低头)，而且手感会下降(玄学，但是尝试一下会发现放在托盘里敲键盘的姿势是缩着手从上而下敲击键盘，感受不到键盘的手感)，视觉上不舒服，心理上不舒服(这一点对强迫症比较重要～～～)</p></li></ol><p>对于正确的电脑桌前坐姿而言，只要能满足健康的坐姿，建议还是将键盘放在桌子上的。如果不满足条件，可以通过调整座位高度或桌子高度实现。</p><p>现在去淘宝搜索人体工学办公桌，也都是舍弃了电脑托盘的设计居多，很少再见到带托盘的了，除非是在家具城买的老式的办公桌子。</p>]]></content>
      
      
      <categories>
          
          <category> 健康 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 健康 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Linux</title>
      <link href="/chunyujin/7ef7519f.html"/>
      <url>/chunyujin/7ef7519f.html</url>
      
        <content type="html"><![CDATA[<h3 id="Linux是一种开源的操作系统"><a href="#Linux是一种开源的操作系统" class="headerlink" title="Linux是一种开源的操作系统"></a>Linux是一种开源的操作系统</h3><h4 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h4><p>计算机本质是许多硬件组成的一个整体</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212180856455.png" alt="image-20221218085649201" style="zoom:50%;" /><blockquote><p>设备驱动直接控制计算机的硬件，用户通过应用软件使用计算机</p><p>应用程序会调用多种设备驱动，驱动程序提供给应用程序接口，供应用程序调用接口来使用硬件</p><p>一个计算机上会有很多硬件，所以会有很多设备驱动，每个硬件对应的设备驱动也不一样；每个应用程序都会与很多设备驱动对接，还会经常有多个应用占用同一个硬件的情况，如何进行资源管理和分配是对于设计者来说是一件很麻烦的事情。</p><p>于是就有了操作系统，操作系统是用来管理软件和硬件的对接，并将硬件驱动程序的接口抽象化，行成一套简单的接口给上层的应用程序使用。</p><p>另外，设备驱动是嵌入到操作系统里的，上面讲的只是为了体现这几者的关系。</p></blockquote><p>世界三大操作系统：Windows，macOS，Linux</p><p>Windows是世界上市场份额占比最大的终端操作系统；macOS是基于Unix内核的操作系统；Linux是开源的操作系统，被广泛用于服务器、嵌入式，并且智能手机上的android操作系统正是基于Linux开发的子系统。</p><h4 id="为什么是开源"><a href="#为什么是开源" class="headerlink" title="为什么是开源"></a>为什么是开源</h4><p>开源是Linus大神的非常强烈的信念，当时在接触MINIX的时候，被MINIX只允许用在教育上的使用很不满，于是他便开始编写自己的开源操作系统，并一直坚持开源理念。</p><p>开源，即<u>开放源代码</u></p><p>这意味着任何人都可以使用，但请记得注明来源。</p><blockquote><p><strong>开放源代码</strong>（英语：Open Source）是一种在电脑程序出品前和开发中提供其内部代码的做法。</p><p>开放源代码在互联网上获得广泛使用，参加者需要大量更新电脑源代码。开放源代码使得生产模块、通信管道、交互社群获得改善。随后，一个新著作权、软件授权条款、域名和消费者提供创建的，一个新词开源软件诞生。</p><p>开源模型概念包括同时间不同时程和方法来生产，相对而言，更加集中式的软体设计模型，例如典型的商业软体公司。一个开源软体开发的主要原则和惯例是易货贸易和合作的同侪生产，经由免费公开的最终产品、原始信息、蓝图和文件。这逐渐应用在其它领域，例如生物技术。———<em>来源<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81">维基百科</a></em></p></blockquote><p>代码开源，意味着更安全、更高效、更稳定</p><p>因为全部的使用者都在使用且知悉源代码，一旦出现问题会被用户群体立即指出，甚至用户群体可以立即给出各种解决方案！</p><p>代码闭源则只能由商业公司内部维护</p><h3 id="Linux的应用场景"><a href="#Linux的应用场景" class="headerlink" title="Linux的应用场景"></a>Linux的应用场景</h3><p>服务器后台</p><p>嵌入式、树莓派</p><p>智能家电</p><p>车载系统</p><p>物联网</p><p>手机、平板电脑</p><p>……</p><p>一切都是基于Linux的开源特性</p><p>还有就是Linux确实很好用</p><p>这为无数人提供了便利！</p><h3 id="生动的补充"><a href="#生动的补充" class="headerlink" title="生动的补充"></a>生动的补充</h3><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212180928015.png" alt="image-20221218092828996"></p><h3 id="Linux下一切皆文件！！！"><a href="#Linux下一切皆文件！！！" class="headerlink" title="Linux下一切皆文件！！！"></a>Linux下一切皆文件！！！</h3>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinGw配置(Windows电脑)</title>
      <link href="/chunyujin/1ee5d0ce.html"/>
      <url>/chunyujin/1ee5d0ce.html</url>
      
        <content type="html"><![CDATA[<h4 id="安装MinGW"><a href="#安装MinGW" class="headerlink" title="安装MinGW"></a>安装MinGW</h4><p>相比在 Linux 平台上安装 GCC 编译环境，在 Windows 平台上安装 MinGW 是比较简单的，只需经历以下几个过程。</p><ol><li><p>打开 <a href="https://osdn.net/projects/mingw/">MinGW 官网</a>（点击即可进入官网），下载 MinGW 安装包。</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215731250.png" alt="image-20221215215731250" style="zoom:67%;" /></li><li><p>下载完成后，会得到一个名为 mingw-get-setup.exe 的安装包，双击打开它，可以看到如下的对话框：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215752602.png" alt="image-20221215215752602" style="zoom:67%;" /></li><li><p>直接点击“Install”，进入下面的对话框，自定义安装位置，然后选择continue</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215808186.png" alt="image-20221215215808186" style="zoom:67%;" /></li><li><p>进入安装 MinGW 配置器的界面。安装完成之后，得到一个名为 “MinGW Installer Manager” 的软件，借助它，可以随时根据需要修改 GCC 编译器的配置。点击“continue”,会自动弹出配置界面，如下所示：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215823311.png" alt="image-20221215215823311" style="zoom:67%;" /></li><li><p>为使 GCC 同时支持编译 C 语言和 C++，需勾选图中标注的 2 项。我们知道，GCC 还支持其它编程语言，读者可借助此配置器，随时实际需要安装自己需要的编译环境。勾选完成后，在菜单栏中选择<code>Installation -&gt; Apply Changes</code>，弹出如下对话框：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215215851706.png" alt="image-20221215215851706" style="zoom:67%;" /></li></ol><p>选择“Apply”。然后耐心等待，直至安装成功，即可关闭此界面。注意，整个安装过程中可能会提示某些组件下载失败，但没关系，后续需要时，可以通过 MinGw Installer（图 4 所示）安装界面中的 “All Packages”选项中，手动选择指定的安装包进行安装。</p><h4 id="添加到环境变量"><a href="#添加到环境变量" class="headerlink" title="添加到环境变量"></a>添加到环境变量</h4><p>打开<code>我的电脑</code>-&gt;<code>属性</code>-&gt;<code>高级系统设置</code>-&gt;<code>“高级”中的环境变量</code></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213001922.png" alt="image-20221215213001922" style="zoom:67%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213141396.png" alt="image-20221215213141396" style="zoom: 67%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213248912.png" alt="image-20221215213248912" style="zoom:67%;" /><p>在上方的“用户变量”的Path变量中添加MinGW的bin的位置</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213407962.png" alt="image-20221215213407962" style="zoom:67%;" /><blockquote><p>也可以在下方的“系统变量”的Path中添加MinGW的bin的位置</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215213829809.png" alt="image-20221215213829809" style="zoom:67%;" /><p>环境变量、系统变量、用户变量的关系：</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215214853021.png" alt="image-20221215214853021" style="zoom: 50%;" /><p>环境变量只是一个总称，代表了系统变量和用户变量，因此我们说环境变量都是指的系统变量和用户变量。系统变量就是系统级别的变量，用户需要使用系统变量。如果系统变量被修改了，而任何系统用户都在用系统变量，因此每个系统用户都将受到影响。用户变量运行在系统变量之上的，每个用户拥有不同的用户变量，不同用户的用户变量之间是并列的，也是互不干扰的。</p></blockquote><h4 id="检验配置完成"><a href="#检验配置完成" class="headerlink" title="检验配置完成"></a>检验配置完成</h4><p>打开命令行提示符，输入<code>gcc -v</code>或者<code>g++ -v</code></p><p>出现下面则说明成功</p><p><img>(<a href="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-12-15%20220238.png">https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-12-15%20220238.png</a>)</p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MinGw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NotePad++配置</title>
      <link href="/chunyujin/55caa4ef.html"/>
      <url>/chunyujin/55caa4ef.html</url>
      
        <content type="html"><![CDATA[<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>安装MinGW并添加到环境变量：</p><p><a href="">点此查看步骤(建议右键选择在新窗口中打开)</a></p><p>创建一个cpp文件并写一段测试代码</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215200029209.png" alt="image-20221215200029209"></p><p>点击顶部菜单栏的“运行”或者直接按F5</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221215200205821.png" alt="image-20221215200205821"></p><p>输入一下宏定义命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd /k pushd &quot;$(CURRENT_DIRECTORY)&quot; &amp;&amp; g++ -o &quot;$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp;&amp; &quot;$(NAME_PART)&quot;.exe &amp; PAUSE &amp; EXIT</span><br></pre></td></tr></table></figure><p>点击运行即可</p><p>建议选择“保存”按键，将宏定义保存到快捷键，比如<code>ctrl + alt + n</code>(跟vscode的coderunner插件一样的快捷键)，下次运行直接快捷键即可</p><blockquote><p><code>cmd /k</code>：<strong>打开</strong> cmd 控制台，运行完程序让其停留而不自动关闭。</p><p><code>pushd &quot;$(CURRENT_DIRECTORY)&quot;</code>：<strong>将工作路径更换到源文件所在的路径</strong>，例如’pushd E:\kkk’相当于 cmd 中先<code>e:</code>再<code>cd kkk</code>，这条命令在源代码要调用同目录文件而只写了相对路径时尤为重要。因为 Notepad++ 的默认工作路径是它自己的安装路径。</p><p><code>g++ -o &quot;$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot;</code>：调用环境变量中的编译器 g++.exe 来将源代码<strong>编译</strong>成同名 exe 文件并输出到相同路径。</p><p><code>&quot;$(NAME_PART)&quot;.exe</code>：<strong>运行</strong>源代码编译出的可执行文件。</p><p><code>PAUSE</code>：暂停，提示<strong>“按任意键继续”</strong>，配合下一条命令实现“按任意键关闭”的效果，两者都没有的话程序运行完就会秒关。</p><p><code>EXIT</code>：<strong>关闭</strong> cmd 控制台，没有的话按任意键会退到 cmd 命令台，等待输入下一条命令。</p><ul><li><p>$(CURRENT_DIRECTORY)代表文件所在目录的路径。</p></li><li><p>$(NAME_PART)表示该文件无后缀部分的文件名。</p></li><li><p>$(FULL_CURRENT_PATH)代表当前完整的文件路径。</p></li><li><p>双引号（半角）：用于防止目录或文件名中含空格的情况。</p></li><li><p>“&amp;&amp;”和“&amp;”：前者表示上一条命令正常执行完再执行下一条命令，非正常则不执行下一条；后者无顾虑。例如一分为六后的后两条子命令，表示不管源代码编译、运行是否成功，都会出现“按任意键继续”字样，并且按任意键后关闭 cmd 控制台。</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NotePad++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VsCode_C++环境搭建(Mac m1芯片版本)</title>
      <link href="/chunyujin/1580f89a.html"/>
      <url>/chunyujin/1580f89a.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/BYGAO/p/15135609.html">文章转载自百叶的自留地(2021年8月)，非商业用途，侵删</a></p><p>文末放了我的三个json文件配置，可以参考。</p><h2 id="1-下载VS-code"><a href="#1-下载VS-code" class="headerlink" title="1.下载VS code"></a>1.下载VS code</h2><p>VS code已针对m1 芯片进行了适配，去官网下载VS code Apple Silicon版并安装。</p><h2 id="2-确保clang已安装"><a href="#2-确保clang已安装" class="headerlink" title="2.确保clang已安装"></a>2.确保clang已安装</h2><p>在终端里输入<code>clang --version</code>查看是否已安装，若未安装，输入<code>xcode-select --install</code>读完条款输入agree安装即可。</p><h2 id="3-下载扩展"><a href="#3-下载扩展" class="headerlink" title="3.下载扩展"></a>3.下载扩展</h2><p>一共有三个扩展需要下载。<br>1.C&#x2F;C++<br>2.C++ Intellisense<br>3.CodeLLDB<br>4.Chinese(中文插件，可选)</p><h2 id="4-新建cpp文件"><a href="#4-新建cpp文件" class="headerlink" title="4.新建cpp文件"></a>4.新建cpp文件</h2><p>这里直接采用<a href="https://code.visualstudio.com/docs/cpp/config-clang-mac">微软官方文档</a>里的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; msg &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;from&quot;</span>, <span class="string">&quot;VS Code&quot;</span>, <span class="string">&quot;and the C++ extension!&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> string&amp; word : msg)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; word &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，在文件第10行输入<code>msg.</code>应该是能看到VS code跳出<code>assign</code>之类的提示的。</p><h2 id="5-配置文件"><a href="#5-配置文件" class="headerlink" title="5.配置文件"></a>5.配置文件</h2><h3 id="1-配置tasks-json文件"><a href="#1-配置tasks-json文件" class="headerlink" title="1.配置tasks.json文件"></a>1.配置tasks.json文件</h3><p>首先点击<code>终端</code>—<code>配置默认生成任务</code>—<code>C/C++ clang++</code>，会生成一个tasks.json文件，这是默认生成的，需要修改其中的<code>args</code>选项,添加一个<code>&quot;-std=c++17&quot;</code>，修改后为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;args&quot;</span>: [</span><br><span class="line"><span class="string">&quot;-g&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;file&#125;</span>&quot;</span>,</span><br><span class="line"><span class="string">&quot;-std=c++17&quot;</span>,</span><br><span class="line"><span class="string">&quot;-o&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;fileDirname&#125;</span>/<span class="variable">$&#123;fileBasenameNoExtension&#125;</span>&quot;</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>配置完后，会发现VS code提示语法错误，不要急，接下来就修正它。</p><h3 id="2-配置c-cpp-properties-json文件"><a href="#2-配置c-cpp-properties-json文件" class="headerlink" title="2.配置c_cpp_properties.json文件"></a>2.配置c_cpp_properties.json文件</h3><p>使用组合键<code>shift+command+p</code>（mac下shift就是<code>fn</code>键上面那个啦），调出<code>C/C++:编辑配置（json）</code>，会自动生成一个<code>c_cpp_properties.json</code>文件。</p><p>将<code>&quot;compilerPath&quot;: &quot;/usr/bin/clang&quot;,</code>修改为<code>&quot;compilerPath&quot;: &quot;/usr/bin/clang++&quot;,</code><br>将<code>&quot;&quot;cppStandard&quot;: &quot;c++98&quot;,</code>修改为<code>&quot;cppStandard&quot;: &quot;c++17&quot;,</code></p><p>其实只是将编译器修改为clang++，cpp标准修改为C++ 17.</p><h3 id="3-编译生成文件"><a href="#3-编译生成文件" class="headerlink" title="3.编译生成文件"></a>3.编译生成文件</h3><p>这么配置完后，其实VS code还是会报两个语法错误，不过这不要紧，这是因为还没更新的缘故。<br>点击<code>终端</code>—<code>运行生成任务</code>，运行完后会生成一个二进制文件，语法报错也没了，表示我们编译成功了。<br>如果想测试的话，新建一个终端，使用<code>./你的二进制文件名</code>，即可看到输出结果。</p><h3 id="4-配置launch-json文件"><a href="#4-配置launch-json文件" class="headerlink" title="4.配置launch.json文件"></a>4.配置launch.json文件</h3><p>点击<code>运行</code>—<code>添加配置</code>—<code>C++(GDB/LLDB)</code>—<code>clang++</code>，会生成一个<code>launch.json</code>文件。<br>将<code>&quot;type&quot;: &quot;cppdbg&quot;,</code>修改为<code>&quot;type&quot;: &quot;lldb&quot;,</code><br>至此，所有文件就配置完了。</p><h3 id="5-调试"><a href="#5-调试" class="headerlink" title="5.调试"></a>5.调试</h3><p>在文件的第10行放一个断点，点击<code>运行</code>—<code>启动调试</code>，就可以看到各种变量了。</p><h2 id="我的文件配置"><a href="#我的文件配置" class="headerlink" title="我的文件配置"></a>我的文件配置</h2><p>以下是我的三个json文件配置代码。<br><code>tasks.json</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line"><span class="string">&quot;tasks&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppbuild&quot;</span>,</span><br><span class="line"><span class="string">&quot;label&quot;</span>: <span class="string">&quot;C/C++: clang++ 生成活动文件&quot;</span>,</span><br><span class="line"><span class="string">&quot;command&quot;</span>: <span class="string">&quot;/usr/bin/clang++&quot;</span>,</span><br><span class="line"><span class="string">&quot;args&quot;</span>: [</span><br><span class="line"><span class="string">&quot;-g&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;file&#125;</span>&quot;</span>,</span><br><span class="line"><span class="string">&quot;-std=c++17&quot;</span>,</span><br><span class="line"><span class="string">&quot;-o&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;fileDirname&#125;</span>/<span class="variable">$&#123;fileBasenameNoExtension&#125;</span>&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;options&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;<span class="variable">$&#123;fileDirname&#125;</span>&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;problemMatcher&quot;</span>: [</span><br><span class="line"><span class="string">&quot;<span class="variable">$gcc</span>&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;group&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line"><span class="string">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;detail&quot;</span>: <span class="string">&quot;编译器: /usr/bin/clang++&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>c_cpp_properties.json</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Mac&quot;</span>,</span><br><span class="line">            <span class="string">&quot;includePath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;<span class="variable">$&#123;workspaceFolder&#125;</span>/**&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;defines&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;macFrameworkPath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;compilerPath&quot;</span>: <span class="string">&quot;/usr/bin/clang++&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cStandard&quot;</span>: <span class="string">&quot;c17&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cppStandard&quot;</span>: <span class="string">&quot;c++17&quot;</span>,</span><br><span class="line">            <span class="string">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;macos-clang-arm64&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>launch.json</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;clang++ - 生成和调试活动文件&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;lldb&quot;</span>,</span><br><span class="line">            <span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="string">&quot;program&quot;</span>: <span class="string">&quot;<span class="subst">$&#123;fileDirname&#125;</span>/<span class="subst">$&#123;fileBasenameNoExtension&#125;</span>&quot;</span>,</span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;<span class="subst">$&#123;fileDirname&#125;</span>&quot;</span>,</span><br><span class="line">            <span class="string">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;MIMode&quot;</span>: <span class="string">&quot;lldb&quot;</span>,</span><br><span class="line">            <span class="string">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;C/C++: clang++ 生成活动文件&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VsCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Calibre实现Kindle带封面传书</title>
      <link href="/chunyujin/35444f4.html"/>
      <url>/chunyujin/35444f4.html</url>
      
        <content type="html"><![CDATA[<h4 id="Kindle如何带封面传书"><a href="#Kindle如何带封面传书" class="headerlink" title="Kindle如何带封面传书"></a>Kindle如何带封面传书</h4><p>软件：Calibre</p><p>Kinlde传书以往分为两种方式，一种是邮件传输，另一种是数据线连接电脑传输</p><h5 id="邮件传书"><a href="#邮件传书" class="headerlink" title="邮件传书"></a>邮件传书</h5><blockquote><p>每部Kindle都有自己的邮箱，通过附件的方式给Kindle邮箱发送邮件就可以传书</p><p>但是Kinlde在2022年8月份就宣布停止mobi格式书籍的邮箱传输，并只支持epub</p><p>Kindle机器本身只支持azw格式，Kindle可以对mobi进行转换，成为azw格式</p><p>通过邮件传书，无论是mobi还是epub格式都是先通过线上转换，变成azw格式之后发送到kindle去的，而mobi格式通过邮箱传输可以保留原来的封面，epub格式则会失去封面，用邮箱传书的话要带封面只能用mobi格式</p><p>亚马逊以后将停止kindle邮箱传书，只能选择数据线传书</p></blockquote><h5 id="数据线传书"><a href="#数据线传书" class="headerlink" title="数据线传书"></a>数据线传书</h5><blockquote><p>mobi的书籍通过数据线传输之后会丢失封面，epub则因为Kindle硬件无法进行格式转换，无法读取。</p><p>网络上获取的资源一般都是mobi格式以及epub格式的</p></blockquote><p>以下是通过数据线带封面传书的步骤</p><p><strong>如果书籍带有封面，并且不需要更换，跳过2、3步骤，如果书籍没有封面或者封面不官方和美观，执行2、3步骤</strong></p><ol><li>将需要传输的书籍放到calibre里面</li><li><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202208231507207.png" alt="截屏2022-08-23 15.06.53" style="zoom:50%;" /></li><li><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202208231508238.png" alt="截屏2022-08-23 15.08.01" style="zoom:50%;" /></li><li><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202208231509350.png" alt="截屏2022-08-23 15.09.53" style="zoom:50%;" /></li><li>推出Kindle，但是不要关闭calibre</li><li>保持Kindle的wifi打开的状态，等待亚马逊删除封面</li><li>再次连接Kindle到电脑，等到calibre读取到Kindle，此时calibre会恢复刚刚导入到Kindle书籍的封面</li><li>大功告成，可以推出Kindle以及关闭calibre</li></ol><h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h5><blockquote><ol><li>关于“步骤6”中“亚马逊删除封面“，因为Kindle图书的正规获取渠道是亚马逊图书商城，对于图书的封面，亚马逊是从网络上获取的，网络获取分为邮件和亚马逊商城，通过邮件推送来的mobi格式的图书，自带封面信息，因此Kindle可以通过网络（邮件）下载到图书封面，从亚马逊图书商城里获得的图书，自然也会下载到图书封面信息。</li><li>通过数据线传输书籍，书籍信息中的封面信息无法作为元数据保存为图书信息，还会占用掉封片信息，因此需要等亚马逊删除掉封面之后再由calibre恢复（写入）元数据信息（书籍封面）</li><li>calibre的原理：</li></ol><blockquote><p>更改书籍的信息（元数据），从名称作者到封面</p><p>都可以自定义更改</p><p>并且还可以从官方根据书籍名称获取书籍元数据，并下载保存在图书中</p></blockquote></blockquote><h5 id="自己制作封面："><a href="#自己制作封面：" class="headerlink" title="自己制作封面："></a>自己制作封面：</h5><blockquote><blockquote><p>如果无法获取到在线的封面，可以自己制作封面，一般来说书籍中的第一页就是书的封面，我们可以在calibre双击打开书籍，然后截取封面。进入编辑原数据，将截图设定为封面</p></blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212230933831.png" alt="截屏2022-12-23 09.31.25"  /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212230934612.png" alt="截屏2022-12-23 09.31.48"  /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212230934010.png" alt="截屏2022-12-23 09.31.59"  /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212230934909.png" alt="截屏2022-12-23 09.32.58"  /><p>完成之后不要忘了点左下角的确定</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212230934041.png" alt="截屏2022-12-23 09.33.07" style="zoom:50%;" /></blockquote><p>信息来源</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202208231555992.png" alt="截屏2022-08-23 15.33.18" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kindle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_历史命令</title>
      <link href="/chunyujin/6694219c.html"/>
      <url>/chunyujin/6694219c.html</url>
      
        <content type="html"><![CDATA[<h3 id="Linux会保存用户的历史指令"><a href="#Linux会保存用户的历史指令" class="headerlink" title="Linux会保存用户的历史指令"></a>Linux会保存用户的历史指令</h3><p>历史指令保存在用户目录下的.bash_history文件(历史记录文件)中，并且每条指令都用时间戳的形式记录了执行时刻</p><p>当用户通过shell进入Linux系统时，Linux系统会先将.bash_history中的保存的之前的历史指令读取到历史记录缓存区中，在用户正常退出shell之前，执行的所有指令也会先记录在缓存区中，当用户正常退出shell(exit或者control+d)时，shell进程会自动将历史记录缓存区中的所有历史记录写入到.bash_history中</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209114140665.png" alt="image-20221209114140665"></p><h4 id="查看历史缓冲区"><a href="#查看历史缓冲区" class="headerlink" title="查看历史缓冲区"></a>查看历史缓冲区</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history #查看历史记录缓存区中保存的历史指令</span><br></pre></td></tr></table></figure><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20221209112431.png" alt="QQ截图20221209112431"  /><p>从最开始到现在为止</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E6%88%AA%E5%9B%BE20221209112449.png"></p></blockquote><h5 id="通过键盘上下键快捷查看历史缓冲区"><a href="#通过键盘上下键快捷查看历史缓冲区" class="headerlink" title="通过键盘上下键快捷查看历史缓冲区"></a>通过键盘上下键快捷查看历史缓冲区</h5><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E5%BD%95%E5%B1%8F20221209120917.gif" alt="QQ录屏20221209120917"></p><h5 id="定量查看历史缓冲区的历史指令"><a href="#定量查看历史缓冲区的历史指令" class="headerlink" title="定量查看历史缓冲区的历史指令"></a>定量查看历史缓冲区的历史指令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history &lt;数字&gt; #查看缓冲区中最近的n条历史指令</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209172316597.png" alt="image-20221209172316597"></p><h4 id="手动写入-bash-history"><a href="#手动写入-bash-history" class="headerlink" title="手动写入.bash_history"></a>手动写入.bash_history</h4><p>如果执行了几条指令，比如执行两次<code>ls</code>和<code>ll</code>，查看一下历史缓存区</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209115827151.png" alt="image-20221209115827151"></p><p>再查看.bash_history，发现没有记录在里面，因为历史记录保存在了历史缓存区，当退出shell的时候才会自动从缓存区写入.bash_history</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209115907240.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history -w #手动将历史缓存写入用户目录下的.bash_history</span><br></pre></td></tr></table></figure><p>正常情况下，只有在 Shell 正常退出时，才会将缓冲区内容保存到.bash_history。如果想主动保存缓冲区的历史记录，执行 <code>-w</code> 选项即可</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209120133565.png" alt="image-20221209120133565"></p><h4 id="清除历史缓冲区"><a href="#清除历史缓冲区" class="headerlink" title="清除历史缓冲区"></a>清除历史缓冲区</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history -c #清除历史缓冲区</span><br></pre></td></tr></table></figure><p>历史缓冲区写入.bash_history其实就是用新内容覆盖掉原有内容，所以清除历史缓冲区就是清除本次登录用户时的所有操作的记录，不会删除之前的历史记录</p><h4 id="重复执行缓冲区历史指令"><a href="#重复执行缓冲区历史指令" class="headerlink" title="重复执行缓冲区历史指令"></a>重复执行缓冲区历史指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!&lt;数字&gt; #重复执行缓冲区中的第n条历史指令</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209173229978.png" alt="image-20221209173229978"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!-&lt;数字&gt; #重复执行缓冲区中倒数第n行历史指令</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209174342766.png" alt="image-20221209174342766"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!! #重复执行上一条命令</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221209174410518.png" alt="image-20221209174410518"></p><h4 id="搜索历史命令"><a href="#搜索历史命令" class="headerlink" title="搜索历史命令"></a>搜索历史命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + r# 输入残缺指令，搜索对应完整历史指令</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212121356384.gif" alt="Dec-12-2022 13-56-09"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VsCode快捷键&amp;使用技巧</title>
      <link href="/chunyujin/d25e6d9b.html"/>
      <url>/chunyujin/d25e6d9b.html</url>
      
        <content type="html"><![CDATA[<h4 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h4><p>⌃ + ⌥ + N</p><p>ctrl + alt + N</p><h4 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h4><p>⌥ + ⇧ + F</p><p>alt + shift + F</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202209121909898.png" alt="截屏2022-09-12 18.49.36" style="zoom: 33%;" /><h4 id="批量更改变量、函数名称"><a href="#批量更改变量、函数名称" class="headerlink" title="批量更改变量、函数名称"></a>批量更改变量、函数名称</h4><p>光标选中名称</p><p>⌘ + ⇧ + L</p><p>ctrl + shift + L</p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VsCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JB全家桶快捷键&amp;操作</title>
      <link href="/chunyujin/1d504d03.html"/>
      <url>/chunyujin/1d504d03.html</url>
      
        <content type="html"><![CDATA[<h4 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h4><p>⌃  + R</p><p>ctrl + R</p><h4 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h4><p>⌘ + ⌥  + L</p><p>win + alt + L　</p><h4 id="批量更改变量、函数名称"><a href="#批量更改变量、函数名称" class="headerlink" title="批量更改变量、函数名称"></a>批量更改变量、函数名称</h4><p>光标<strong>移动到</strong>变量、函数名称上</p><p>⇧  + F6</p><p>Shift + F6</p><h4 id="CLion-vscode风格代码高亮插件"><a href="#CLion-vscode风格代码高亮插件" class="headerlink" title="CLion_vscode风格代码高亮插件"></a>CLion_vscode风格代码高亮插件</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210272216897.png" alt="截屏2022-10-27 22.16.17" style="zoom:50%;" /><h4 id="CLion-vscode风格代码样式-用于格式化样式"><a href="#CLion-vscode风格代码样式-用于格式化样式" class="headerlink" title="CLion_vscode风格代码样式(用于格式化样式)"></a>CLion_vscode风格代码样式(用于格式化样式)</h4><p>Microsoft风格（vscode</p><p>舒服😌</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210272214080.png" alt="截屏2022-10-27 22.10.18" style="zoom:50%;" /><p>设置解引用符号*的位置</p><p>第一种舒服😌</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210301112448.png" alt="截屏2022-10-30 11.10.27" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210301112444.png" alt="截屏2022-10-30 11.10.50" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210301112437.png" alt="截屏2022-10-30 11.11.03" style="zoom:50%;" /><h4 id="设置背景"><a href="#设置背景" class="headerlink" title="设置背景"></a>设置背景</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202210272217806.png" alt="截屏2022-10-27 22.16.48" style="zoom:50%;" /><h4 id="如果在CLion外部更改了项目中的文件的属性"><a href="#如果在CLion外部更改了项目中的文件的属性" class="headerlink" title="如果在CLion外部更改了项目中的文件的属性"></a>如果在CLion外部更改了项目中的文件的属性</h4><p><strong>比如我在CLion外部将原本的main.c改名成为了GuessingGame.c</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031163458930.png" alt="image-20221031163458930" style="zoom: 80%;" /><p>clion会报错</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031163348563.png" alt="image-20221031163348563" style="zoom: 80%;" /><p>发现CmakeLists.txt文件包含的文件是aaa main.c而不是aaa GuessingGame.c，说明并没有将GuessingGame.c包含在项目里</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031163553021.png" alt="image-20221031163553021" style="zoom:80%;" /><p>将第6行括号里的main.c改成GuesingGame.c即可</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031164432573.png" alt="image-20221031164432573" style="zoom:80%;" /><blockquote><p>注意，如果不是替换掉main.c，而只是添加GuessingGame.c的话，CLion中其实main.c是不存在的，那么就找不到main.c，当然也会报错</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031165612625.png" alt="image-20221031165612535" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031165619957.png" alt="image-20221031165619808" style="zoom:80%;" /></blockquote><p>然后会发现提示CMake项目需要重新加载，重新加载即可</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E5%9B%BE%E7%89%8720221031164540.jpg" alt="QQ图片20221031164540" style="zoom:80%;" /><p><strong>同样，如果在CLion外部，将文件添加到项目中，在CLion中也会报错</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031164230637.png" alt="image-20221031164230449" style="zoom:67%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031164247033.png" alt="image-20221031164247033" style="zoom:67%;" /><p>在CmakeLists.txt文件中添加上这几个文件就可以</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031165652840.png" alt="image-20221031165652840" style="zoom:80%;" /><blockquote><p>&#x3D;&#x3D;<strong>注意在CmakeLists.txt中添加文件的写法格式，上图就是正确的格式</strong>&#x3D;&#x3D;</p></blockquote><p>如果是在CLion内部新建头文件或者源文件，在添加的时候，勾选上添加到目标即可</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211102142435.png" alt="截屏2022-11-10 21.40.22" style="zoom:50%;" /><p>忘记勾选也没事，在CmakeLists.txt文件中添加上就可以</p><h4 id="可以直接将没有配置环境的文件夹直接在CLion中打开"><a href="#可以直接将没有配置环境的文件夹直接在CLion中打开" class="headerlink" title="可以直接将没有配置环境的文件夹直接在CLion中打开"></a>可以直接将没有配置环境的文件夹直接在CLion中打开</h4><p>众所周知，CLion会对每一个项目配置环境，前提是这是CLion的项目</p><p>如果一个文件夹不是CLion的项目，我们在CLion中打开，CLion会提示是否配置环境</p><p>(CLion项目中的环境配置文件↓)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-10-31%20170055.png" alt="屏幕截图 2022-10-31 170055" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/QQ%E5%9B%BE%E7%89%8720221031170119.jpg" alt="QQ图片20221031170119" style="zoom:80%;" /><p>如果一个不是CLion项目的文件夹（也就是说没有配置环境），在CLion中打开</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031170502825.png" alt="image-20221031170502825" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031170513665.png" alt="image-20221031170513665" style="zoom:80%;" /><p>会提示是否创建CMake项目</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/image-20221031170644553.png" alt="image-20221031170644553" style="zoom:80%;" /><p>选择“创建”即可</p><p>这样CLion就会在文件夹中生成环境文件了，文件夹就变成了一个CLion项目</p><h4 id="Windows下CLion运行结果中文输出是乱码"><a href="#Windows下CLion运行结果中文输出是乱码" class="headerlink" title="Windows下CLion运行结果中文输出是乱码"></a>Windows下CLion运行结果中文输出是乱码</h4><ol><li>那就不输出中文呗</li><li>或者不选择”运行”，选择”调试”(不打断点)</li></ol><h4 id="彩虹括号-插件"><a href="#彩虹括号-插件" class="headerlink" title="彩虹括号 插件"></a>彩虹括号 插件</h4><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202211120940116.png" alt="截屏2022-11-12 09.40.19" style="zoom:50%;" /><p>会让编译器代码高亮变慢，所以已经卸载……</p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JetBrains </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git！从零开始连接远程仓库</title>
      <link href="/chunyujin/b51810cf.html"/>
      <url>/chunyujin/b51810cf.html</url>
      
        <content type="html"><![CDATA[<h3 id="Git！从零开始用连接远程仓库！！-全平台"><a href="#Git！从零开始用连接远程仓库！！-全平台" class="headerlink" title="Git！从零开始用连接远程仓库！！[全平台]"></a>Git！从零开始用连接远程仓库！！[全平台]</h3><p>[toc]</p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>无论你正在使用的是macOS、Linux还是Windows，总是可以使用Git这个无人争锋的 <u>版本控制系统</u>软件 进行本地仓库的构建以及将本地仓库和远程仓库(GItHub、GItee等)链接</p><p>因为原理都是一样的！</p></blockquote><p>&#x3D;&#x3D;所以实际操作都用高亮（就像是这段文字）标识出来并设为标题，方便快速操作&#x3D;&#x3D;</p><p>&#x3D;&#x3D;没有标明是在macOS、Linux还是Windows系统，说明操作基本是一样的&#x3D;&#x3D;</p><p>因为在下是苦bee大学僧，经常去教室上课，mac又是放在宿舍里的，所以有些非单一场景独占的掩饰有时是mac终端，有时是Windows Git Bash，这两者除了外观不一样，基本操作都是一样的～～</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><blockquote><p>macOS和Linux的用户电脑如今一般都自带Git～</p><p>Windows用户到官网中进行安装Git即可～</p><p>&#x3D;&#x3D;macOS、Linux的终端，与Windows的Git Bash窗口，操作命令完全是一致的！因为macOS的终端包含Git，而Windows的Git就是Git呀~&#x3D;&#x3D;</p></blockquote><p>下面让在下来展示从建立仓库到连接远程仓库的过程～～</p><h4 id="x3D-x3D-🌱步骤一➡️配置你的Git个人用户信息-x3D-x3D"><a href="#x3D-x3D-🌱步骤一➡️配置你的Git个人用户信息-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;🌱步骤一➡️配置你的Git个人用户信息&#x3D;&#x3D;"></a>&#x3D;&#x3D;🌱步骤一➡️配置你的Git个人用户信息&#x3D;&#x3D;</h4><blockquote><p>git作为一个软件，而且是作为一个版本控制的软件，每每都会涉及到文件的更改，我们对于文件的每一次更改都保存在了Git里面，所以，知道 更改文件的人是谁 是肥肠重要滴～</p><p>在git里，你需要先配置好自己的用户名和邮箱，这样你才是一个值得被信任的用户～到时候连接人家的远程仓库，人家才敢跟你连接(如果有的话～)</p></blockquote><p>Git 提供了一个叫做 <strong>git config</strong> 的工具，是专门用来 配置 和 读取 相应的工作环境变量的</p><blockquote><p>git的工作环境就是git正在工作的环境嘛（</p><p>也就是你在什么地方正在使用git，如果你在终端打开了git，那么它的工作环境就是当前整个电脑下，如果是在电脑的某个文件文件夹目录下，那git的工作环境就是在这个文件夹目录下～</p><p>工作环境变量就是工作环境的一些信息，用户信息就属于工作环境变量～</p></blockquote><p><strong>步骤</strong></p><ol><li><strong>配置个人用户名和邮箱的命令：</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email 你的邮箱</span><br></pre></td></tr></table></figure><blockquote><p>–global选项的意思是“全局”，也就是说更改的配置就在你的用户主目录</p><p>为了以后不用每个目录底下都配置一遍用户信息，我们当然选择进行全局配置鸟～</p></blockquote><ol start="2"><li><strong>配置好了之后就可以看自己的用户信息:</strong></li></ol><p>可以选择将所有的信息列出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p>也可以选择查看某个信息，比如只查看用户名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br></pre></td></tr></table></figure><p>如果不知道之前自己有没有配置用户信息，可以用查看信息的命令查看一下～～</p><blockquote><p>除了用户名和邮箱，还可以配置用户密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.password 你的密码</span><br></pre></td></tr></table></figure></blockquote><p>&#x3D;&#x3D;<u><strong>具体操作：</strong></u>&#x3D;&#x3D;</p><h5 id="x3D-x3D-macos和Linux下：-x3D-x3D"><a href="#x3D-x3D-macos和Linux下：-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;macos和Linux下：&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>macos和Linux下：</strong>&#x3D;&#x3D;</h5><blockquote><ul><li>打开一个新的<strong>终端</strong>界面</li></ul><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046666.png" alt="截屏2022-10-19 17.08.30 Redacted" style="zoom: 50%;" /><ul><li><strong>输入配置用户信息的指令</strong></li></ul><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046709.png" alt="截屏2022-10-19 17.14.58 Redacted" style="zoom:50%;" /><ul><li><strong>检查一下是否配置好</strong></li></ul><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046835.png" alt="截屏2022-10-19 17.15.05 Redacted" style="zoom:50%;" /><p>如果灰色标记标出来的三行信息跟自己刚才的配置的一样，说明成功了哦～</p></blockquote><h5 id="x3D-x3D-Windows下：-x3D-x3D"><a href="#x3D-x3D-Windows下：-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Windows下：&#x3D;&#x3D;"></a>&#x3D;&#x3D;Windows下：&#x3D;&#x3D;</h5><blockquote><ul><li><p>打开<strong>Git Bash</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046894.png" alt="image-20221020000813500" style="zoom:80%;" /></li><li><p><strong>输入配置用户信息的指令</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046946.png" alt="image-20221020002543410" style="zoom:80%;" /></li><li><p><strong>检查一下是否配置好</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046091.png" alt="image-20221020002655079" style="zoom:80%;" /></li></ul></blockquote><p>🎉恭喜，到这里，Git需要配置的前期工作已经完成了🎉</p><hr><h6 id="插一嘴-如何修改用户的配置"><a href="#插一嘴-如何修改用户的配置" class="headerlink" title="插一嘴:如何修改用户的配置"></a>插一嘴:<a href="#1.%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE">如何修改用户的配置</a></h6><hr><h4 id="x3D-x3D-🌱步骤二➡️拥有-x2F-建立一个本地仓库，并将本地文件夹文件提交进本地仓库-x3D-x3D"><a href="#x3D-x3D-🌱步骤二➡️拥有-x2F-建立一个本地仓库，并将本地文件夹文件提交进本地仓库-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;🌱步骤二➡️拥有&#x2F;建立一个本地仓库，并将本地文件夹文件提交进本地仓库&#x3D;&#x3D;"></a>&#x3D;&#x3D;🌱步骤二➡️拥有&#x2F;建立一个本地仓库，并将本地文件夹文件提交进本地仓库&#x3D;&#x3D;</h4><blockquote><p>你可以新建空的文件夹作为试验，建立一个Git的仓库，也可以用一个已经保存了文件的文件夹建成一个Git仓库</p><p>因为这都是一样的，都只是一个 <strong>将已有的文件夹</strong> 设定为 <strong>一个Git仓库</strong> 的过程</p></blockquote><p><strong>这里我就用我已经拥有的文件夹来开始</strong></p><p><strong>步骤：</strong></p><ol><li><strong>在你想要建立成仓库的文件夹打开Git</strong></li><li><strong>将这个文件夹初始化为一个Git本地仓库</strong></li></ol><p>命令为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>如果显示了 Initialized empty Git repository in …….</p><p>说明你的仓库已经初始化好了，现在有了一个空的位于当前文件夹的空仓库</p><hr><h6 id="插一嘴-如何查看仓库的状态"><a href="#插一嘴-如何查看仓库的状态" class="headerlink" title="插一嘴:如何查看仓库的状态"></a>插一嘴:<a href="#2.%E6%9F%A5%E7%9C%8B%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81">如何查看仓库的状态</a></h6><hr><ol start="3"><li><p><strong>将文件夹里的 一个文件或者所有文件 提交到Git仓库中</strong></p><ol><li>将文件添加到GIt的缓存区</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .         # 如果你想要将文件夹里所有的文件都提交到Git仓库，可以用 . 来表示当前文件夹（当前文件夹就含有所有文件不是吗</span><br><span class="line">git add 文件名(如果不是文件夹还要包涵文件后缀)       # 如果你想提交单个文件/文件夹</span><br></pre></td></tr></table></figure><blockquote><ol><li>“ .”是相对路径的写法，表示当前目录，当前目录就是现在打开的这个刚创建了一个Git仓库的文件夹呀～</li><li>为什么要先放到GIt缓存区：因为安全，放到了缓存区之后再正式提交到Git本地仓库，有了可以撤回的空间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached 文件       # 撤回刚才放到缓存区的文件</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li>查看一下此时仓库的状态，会发现有Changes to be committed的提示</li></ol><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046145.png" alt="截屏2022-10-19 22.09.22" style="zoom:50%;" /><p>​说明缓存区内有文件未提交到Git仓库</p><ol start="3"><li>将缓存区提交到Git仓库</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;提交时你想要添加的说明&quot;</span><br></pre></td></tr></table></figure><blockquote><p>”说明“是必须添加的内容，因为Git的一个作用就是追踪你对于仓库的操作，记录你何时因为什么原因更新了仓库文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046311.png" alt="截屏2022-10-21 01.00.35" style="zoom:50%;" /></blockquote></li></ol><p>&#x3D;&#x3D;具体操作：&#x3D;&#x3D;</p><h5 id="x3D-x3D-macOS和Linux下：-x3D-x3D"><a href="#x3D-x3D-macOS和Linux下：-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;macOS和Linux下：&#x3D;&#x3D;"></a>&#x3D;&#x3D;macOS和Linux下：&#x3D;&#x3D;</h5><blockquote><ul><li><p><strong>进入到想要建立成仓库的文件夹终端下：</strong></p><p>有两种方法：</p><p>方法一：用鼠标</p><p>鼠标移动到文件夹上，右击鼠标，找到“服务”</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046536.png" alt="截屏2022-10-19 19.31.47" style="zoom:50%;" /><p>“新建位于文件夹位置的终端标签页” 和 “新建位于文件夹位置的终端窗口” 都可以</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046598.png" alt="截屏2022-10-19 19.33.31 Redacted" style="zoom:50%;" /><p>此时发现进入到了文件夹的终端窗口</p><p>  方法二：用终端命令行</p><p>首先我们需要知道文件夹的路径</p><p>如果不知道可以打开一个终端窗口，并将文件夹拖进去，就可以得到这个文件夹的路径了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046704.png" alt="截屏2022-10-19 19.36.55 Redacted" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046766.png" alt="截屏2022-10-19 19.37.17 Redacted" style="zoom:50%;" /><p>我们将这个文件夹的路径复制一下</p><p>在终端中用cd指令就可以打开文件夹下的终端了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd 你刚刚复制的文件夹路径</span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046821.png" alt="截屏2022-10-19 19.37.57 Redacted" style="zoom:50%;" />&gt;</p><blockquote><p>cd指令可以直接在终端中进入指定的文件路径</p></blockquote></li><li><p><strong>文件夹初始化为Git仓库</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046884.png" alt="截屏2022-10-19 19.47.11 Redacted" style="zoom:50%;" /></li><li><p>查看一下这个Git仓库状态</p><p>～如果文件夹原来没东西，应该是这样的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046936.png" alt="截屏2022-10-19 19.53.52 Redacted" style="zoom:50%;" /><p>~如果文件夹内有东西（我的CLion文件夹里放入的是hello.c），应该是这样的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046015.png" alt="截屏2022-10-19 19.55.49 Redacted" style="zoom:50%;" /><blockquote><p>关于“Unteacked files:“的信息，在<a href="#2.%E6%9F%A5%E7%9C%8B%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81">补充的内容：2.查看仓库状态</a>中有说明</p></blockquote></li><li><p>如果文件夹中原来没有文件，现在可以放入一个文件，以便测试一下下一步的操作</p><p>我的CLion文件夹里已经放入了一个 hello.c</p></li><li><p><strong>将文件夹中的 所有文件或者单个文件 添加到Git缓冲区</strong></p><p>此处我添加所有的文件（文件夹里其实也就一个hello.c文件）</p><p>并查看一下Git仓库状态</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046046.png" alt="截屏2022-10-19 19.50.17 Redacted" style="zoom:50%;" /><p>说明hello.c这个文件添加到了缓存区</p><blockquote><p>并且Git还细心提示可以用</p></blockquote></li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git rm --cached 文件</span><br></pre></td></tr></table></figure><p>来<strong>撤销刚才添加到缓存区的文件</strong></p></blockquote><ul><li><p><strong>将缓存区的文件提交到Git仓库</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046116.png" alt="截屏2022-10-19 20.01.47 Redacted" style="zoom:50%;" /><p>我添加的说明是”This is a test”，想添加什么都可以，尽量用英文</p><p>查看一下仓库状态</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046189.png" alt="截屏2022-10-19 20.03.10 Redacted" style="zoom:50%;" /><p>”nothing to commit, working tree clean“无事可做，工作树干净</p><p>意思是之前的文件都提交了，现在没有需要提交的文件了，工作树（缓存区）很干净（因为缓存区都提交了</p></li></ul></blockquote><h5 id="x3D-x3D-Windows下：-x3D-x3D-1"><a href="#x3D-x3D-Windows下：-x3D-x3D-1" class="headerlink" title="&#x3D;&#x3D;Windows下：&#x3D;&#x3D;"></a>&#x3D;&#x3D;Windows下：&#x3D;&#x3D;</h5><blockquote><ul><li><p>找到想要设为Git本地仓库的文件夹，右击，点击<strong>Git Bash Here</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046246.png" alt="image-20221020002832274" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046313.png" alt="image-20221020003438024" style="zoom:80%;" /><p>这样就在Git中进入了文件夹</p></li><li><p><strong>文件夹初始化为Git仓库</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046369.png" alt="image-20221020003654246" style="zoom:80%;" /></li><li><p>查看一下这个Git仓库的状态</p><p>如果文件夹中原来没有文件，应该是这样的~</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046445.png" alt="image-20221020003829168" style="zoom:80%;" /><p>如果文件夹中原来有文件（比如我的CLion文件夹原来有一个hello.c文件)，是这样的~</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046499.png" alt="image-20221020005253111" style="zoom:80%;" /><blockquote><p>关于“Unteacked files:“的信息，在<a href="#2.%E6%9F%A5%E7%9C%8B%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81">补充的内容：2.查看仓库状态</a>有说明</p></blockquote></li><li><p>如果文件夹中原来没有文件，现在可以放入一个文件，以便测试一下下一步的操作</p><p>我的CLion文件夹里已经放入了一个 hello.c</p></li><li><p><strong>将文件夹中的 所有文件或者单个文件 添加到Git缓冲区</strong></p><p>此处我添加所有的文件（文件夹里其实也就一个hello.c文件）</p><p>并查看一下Git仓库状态</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046563.png" alt="image-20221020010248818" style="zoom:80%;" /><p>说明hello.c这个文件添加到了缓存区</p><blockquote><p>并且Git还细心提示可以用 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached 文件</span><br></pre></td></tr></table></figure><p>来撤销刚才添加到缓存区的文件</p></blockquote></li><li><p><strong>将缓存区的文件提交到Git仓库</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046613.png" alt="image-20221020010408321" style="zoom:80%;" /><p>我添加的说明是”This is a test”，想添加什么都可以，尽量用英文</p><p>查看一下仓库状态</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046665.png" alt="image-20221020010442512" style="zoom:80%;" /><p>”nothing to commit, working tree clean“无事可做，工作树干净</p><p>意思是之前的文件都提交了，现在没有需要提交的文件了，工作树（缓存区）很干净（因为缓存区都提交了</p></li></ul></blockquote><p>🎉恭喜，到这一步，你已经有了一个Git本地仓库，并学会了如何往仓库中提交文件🎉</p><hr><h6 id="插一嘴-仓库的分支—-在查看仓库的时候，第一行中的”On-branch-XXX”是啥"><a href="#插一嘴-仓库的分支—-在查看仓库的时候，第一行中的”On-branch-XXX”是啥" class="headerlink" title="插一嘴:仓库的分支—-在查看仓库的时候，第一行中的”On branch XXX”是啥"></a>插一嘴:<a href="#3.%5B%E9%87%8D%E7%82%B9%5D%E4%BB%93%E5%BA%93%E7%9A%84%E5%88%86%E6%94%AF">仓库的分支—-在查看仓库的时候，第一行中的”On branch XXX”是啥</a></h6><hr><h4 id="x3D-x3D-🌱步骤三➡️拥有-x2F-建立一个远程仓库，并将你的本地GIt的SSH-key公钥添加到远程仓库-—-Gitee为例-x3D-x3D"><a href="#x3D-x3D-🌱步骤三➡️拥有-x2F-建立一个远程仓库，并将你的本地GIt的SSH-key公钥添加到远程仓库-—-Gitee为例-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;🌱步骤三➡️拥有&#x2F;建立一个远程仓库，并将你的本地GIt的SSH key公钥添加到远程仓库 —-Gitee为例&#x3D;&#x3D;"></a>&#x3D;&#x3D;🌱步骤三➡️拥有&#x2F;建立一个远程仓库，并将你的本地GIt的SSH key公钥添加到远程仓库 —-Gitee为例&#x3D;&#x3D;</h4><blockquote><p>因为macOS和Linux都是默认安装Git的，所以自带Git的SSH key</p><p>Windows安装了Git之后就自带Git的SSH key了</p></blockquote><blockquote><p>SHH key分为公钥和密钥</p><p>如果想要远程仓库能 接收 本地仓库的文件，需要在远程仓库中添加本地Git的公钥，授权成功后，远程仓库根据本地Git的公钥匹配本地Git的密钥，Git才有权将本地仓库的文件上传到远程仓库</p><p>否则就算与远程仓库建立了链接，也只能获取远程仓库的文件而不能上传到远程仓库（本地Git对远程仓库只能读不能写</p></blockquote><h5 id="x3D-x3D-建立一个远程仓库—-Gitee为例-x3D-x3D"><a href="#x3D-x3D-建立一个远程仓库—-Gitee为例-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;建立一个远程仓库—-Gitee为例&#x3D;&#x3D;"></a>&#x3D;&#x3D;建立一个远程仓库—-Gitee为例&#x3D;&#x3D;</h5><blockquote><ul><li><p>进入到Gitee官网，网页右上角会发现</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046713.png" alt="截屏2022-10-19 22.27.47" style="zoom: 40%;" /></li><li><p>填写仓库名称，”初始化仓库“的选项勾不勾都是可以的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046789.png" alt="截屏2022-10-19 22.29.13 Redacted" style="zoom:50%;" /></li><li><p>进入到仓库中会是这样的（如果勾选了“初始化仓库”，仓库中会有下图的文件，没有的话就没有）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046868.png" alt="截屏2022-10-19 22.29.39 Redacted" style="zoom:50%;" /></li><li><p>这样一个远程仓库就建立好了</p></li><li><p>🎉这一步就完成了</p></li></ul></blockquote><h5 id="x3D-x3D-macOS和Linux下获取本地Git的SSH-key公钥：-x3D-x3D"><a href="#x3D-x3D-macOS和Linux下获取本地Git的SSH-key公钥：-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;macOS和Linux下获取本地Git的SSH key公钥：&#x3D;&#x3D;"></a>&#x3D;&#x3D;macOS和Linux下获取本地Git的SSH key公钥：&#x3D;&#x3D;</h5><blockquote><ul><li><p>打开一个终端</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046938.png" alt="image-20221020151601824" style="zoom:80%;" /></li><li><p>以防万一，先测试一下Git是否安装了SSH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh</span><br></pre></td></tr></table></figure><p>如果出现了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046002.png" alt="截屏2022-10-19 21.01.32 Redacted" style="zoom:50%;" /><p>说明带有SSH，否则自行下载安装（在终端中输出<code>sudo apt-get install ssh</code>即可）</p></li><li><p>紧接着，输入以下指令【注意，如果确定本地ssh已经生成了密钥和公钥，请跳过这一步】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>就会在<strong>安装了SSH的路径</strong>上生成<strong>id-rsa (密钥文件</strong>)和<strong>id-rsa.pub (公钥文件)</strong></p></li><li><p>macOS和Linux的SSH路径在~&#x2F;.ssh下</p><blockquote><p>~的意思是个人文件夹</p><p>就是   &#x2F;Users&#x2F;你自己的用户名</p><p>所以~&#x2F;.ssh 就是 &#x2F;User&#x2F;你自己的用户名&#x2F;.ssh</p></blockquote></li><li><p>获得SSH公钥：</p><p>方法一:</p><p>打开一个终端，在终端中输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /User/你自己的用户名/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046064.png" alt="截屏2022-10-19 21.45.49 Redacted Redacted" style="zoom:50%;" /><p><strong><u>中间的这一大段的就是本地Git的SSH 公钥，复制它即可</u></strong></p><p>方法二：</p><p>打开一个终端，直接用cd指令进入到.ssh文件夹下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046169.png" alt="截屏2022-10-20 00.02.44 Redacted" style="zoom:50%;" /><p><strong><u>中间的这一大段就是本地Git的SSH 公钥，复制它即可</u></strong></p></li><li><p>🎉这一步就完成了</p></li></ul></blockquote><h5 id="x3D-x3D-Windows下获取本地Git的SSH-key公钥：-x3D-x3D"><a href="#x3D-x3D-Windows下获取本地Git的SSH-key公钥：-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Windows下获取本地Git的SSH key公钥：&#x3D;&#x3D;"></a>&#x3D;&#x3D;Windows下获取本地Git的SSH key公钥：&#x3D;&#x3D;</h5><blockquote><ul><li><p>打开Git Bash</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046309.png" alt="image-20221020151305597" style="zoom:80%;" /></li><li><p>以防万一，先看一下Git有没有安装SSH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh</span><br></pre></td></tr></table></figure><p>如果出现了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046366.png" alt="image-20221020150100500" style="zoom:80%;" /><p>说明安装了SSH，否则请自行下载安装（在Git Bash中输入<code>sudo apt-get install ssh</code>即可）</p></li><li><p>紧接着，输入以下指令 【注意，如果确定本地ssh已经生成了密钥和公钥，请跳过这一步】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>就会在<strong>安装了SSH的路径</strong>上生成<strong>id-rsa (密钥文件</strong>)和<strong>id-rsa.pub (公钥文件)</strong></p></li><li><p>Windows的SSH路径在~&#x2F;.ssh下</p><blockquote><p>~的意思是个人文件夹</p><p>就是   &#x2F;Users&#x2F;你自己的用户名</p><p>所以~&#x2F;.ssh 就是 &#x2F;User&#x2F;你自己的用户名&#x2F;.ssh</p></blockquote></li><li><p><strong>获得SSH公钥：</strong></p><p>方法一:</p><p>在Git Bash中输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /User/你自己的用户名/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046410.png" style="zoom:80%;" /><p><strong><u>中间的这一大段就是本地Git的SSH 公钥，复制它即可</u></strong></p><p>方法二：</p><p>在Git Bash中，直接用cd指令进入到.ssh文件夹下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046482.png" alt="image-20221020151035414" style="zoom:80%;" /><p><strong><u>中间的这一大段就是本地Git的SSH 公钥，复制它即可</u></strong></p></li><li><p>🎉这一步就完成了</p></li></ul></blockquote><hr><h6 id="插一嘴-如何查看隐藏文件"><a href="#插一嘴-如何查看隐藏文件" class="headerlink" title="插一嘴:如何查看隐藏文件"></a>插一嘴:<a href="#4.%E6%9F%A5%E7%9C%8B%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6">如何查看隐藏文件</a></h6><hr><h5 id="x3D-x3D-将本地Git的SSH-key公钥添加到远程Gitee仓库：-x3D-x3D"><a href="#x3D-x3D-将本地Git的SSH-key公钥添加到远程Gitee仓库：-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;将本地Git的SSH key公钥添加到远程Gitee仓库：&#x3D;&#x3D;"></a>&#x3D;&#x3D;将本地Git的SSH key公钥添加到远程Gitee仓库：&#x3D;&#x3D;</h5><blockquote><ul><li><p>点击GItee的<strong>头像-设置</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046574.png" alt="截屏2022-10-19 22.56.01" style="zoom:50%;" /></li><li><p>点击左侧的<strong>SHH公钥</strong>（因为我已经添加了一个公钥了，所以显示的是公钥数为1，否则是0）</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046666.png" alt="截屏2022-10-19 22.56.33 Redacted" style="zoom:50%;" /></li><li><p>将之前获得的SSH 公钥填进第二个框，第一个框就自动填充了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046723.png" alt="截屏2022-10-19 22.42.12" style="zoom:40%;" /></li><li><p>添加好了就是这样的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046838.png" alt="截屏2022-10-19 22.48.15 Redacted" style="zoom:50%;" /></li></ul></blockquote><h5 id="x3D-x3D-本地仓库连接到远程Gitee仓库：-x3D-x3D"><a href="#x3D-x3D-本地仓库连接到远程Gitee仓库：-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;本地仓库连接到远程Gitee仓库：&#x3D;&#x3D;"></a>&#x3D;&#x3D;本地仓库连接到远程Gitee仓库：&#x3D;&#x3D;</h5><blockquote><ul><li><p>获取Gitee仓库的ssh链接，直接复制</p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046966.png" alt="截屏2022-10-19 22.59.35 Redacted"></p></li><li><p>在本地Git仓库里输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin 你刚才复制的Gitee仓库的ssh</span><br></pre></td></tr></table></figure><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046981.png" alt="截屏2022-10-19 23.04.34 Redacted" style="zoom:50%;" /><p>没有报错说明连接上了</p></li><li><p>🎉这一步就完成了</p></li></ul></blockquote><h4 id="x3D-x3D-🌱步骤四➡️pull-和-push-本地仓库与远程仓库的文件提交和获取-x3D-x3D"><a href="#x3D-x3D-🌱步骤四➡️pull-和-push-本地仓库与远程仓库的文件提交和获取-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;🌱步骤四➡️pull 和 push(本地仓库与远程仓库的文件提交和获取)&#x3D;&#x3D;"></a>&#x3D;&#x3D;🌱步骤四➡️pull 和 push(本地仓库与远程仓库的文件提交和获取)&#x3D;&#x3D;</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin 远程仓库分支名</span><br><span class="line">git pull origin 远程仓库分支名</span><br></pre></td></tr></table></figure><blockquote><p><strong>push：“推”，将本地仓库当前分支的文件 上传合并&#x2F;推送合并 到远程仓库某个分支</strong></p><p><strong>pull：“拉”，将远程仓库某个分支的文件 下拉合并&#x2F;获取合并 到本地仓库当前分支</strong></p></blockquote><p>比如我们现在将这个”测试用文件夹”master分支的仓库，push到已经连接的远程仓库test的master分支</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046029.png" alt="截屏2022-10-21 01.45.01" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046093.png" alt="截屏2022-10-21 01.44.30" style="zoom:50%;" /><p>可以看到远程仓库里已经有了本地仓库的所有文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046170.png" alt="截屏2022-10-21 01.47.20" style="zoom:50%;" /><p>然后我们随便在远程仓库添加一个文件，来模拟别的本地仓库push文件到远程仓库test</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046214.png" alt="截屏2022-10-21 01.49.21" style="zoom:50%;" /><p>现在在本地仓库pull远程仓库test的master分支仓库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046274.png" alt="截屏2022-10-21 01.52.04" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046329.png" alt="截屏2022-10-21 01.53.07" style="zoom:50%;" /><p>成功了（好耶</p><blockquote><p>⚠️push、pull总是取双方仓库每个文件的最新状态</p><p>⚠️因为是Git仓库，所以无论是push还是pull，都是对于仓库内的文件进行的下拉、提交，没有提交到仓库里的文件，Git是无权管理的</p><blockquote><p>比如，我在当前分支(master)CLion文件夹里添加了一个hello.c文件，并不把它提交到仓库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046385.png" alt="截屏2022-10-20 22.08.04" style="zoom:50%;" /><p>现在我将远程仓库master分支的所有文件下拉到本地仓库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046454.png" alt="截屏2022-10-20 22.09.05 Redacted" style="zoom:50%;" /><p>远程仓库的master分支里本来是没有hello.c文件的，而本地仓库master分支里也没有(因为没提交到仓库)，所以没有涉及到关于hello.c文件的跟踪，hello.c还是存在于CLion文件夹(但并不在本地仓库master分支里)</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046385.png" alt="截屏2022-10-20 22.08.04" style="zoom:50%;" /><p>如果现在查看仓库状态</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046498.png" alt="截屏2022-10-20 22.12.02 Redacted" style="zoom:50%;" /><p>Look，确实是这样的</p><p>如果将hello.c添加到本地仓库master分支，再从远程仓库master分支pull到本地仓库当前分支</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046735.png" alt="截屏2022-10-20 22.14.15 Redacted" style="zoom:50%;" /><p>发现，诶？不对诶，怎么CLion文件夹中还有hello.c文件？</p><p>因为Git跟踪的hello.c状态，远程与本地相比，在本地的状态是最新的，因为远程：没跟踪到hello.c文件(连状态都没有)，本地：于XX日期XX时刻创建了hello.c文件，当然是本地的最新啦</p><p>那么，我们先将本地仓库push到远程仓库，再到远程仓库去删除这个hello.c文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046893.png" alt="截屏2022-10-20 22.19.34 Redacted" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046957.png" alt="截屏2022-10-20 22.19.45 Redacted" style="zoom:50%;" /><p>那这样远程仓库的hello.c状态就比本地仓库新了：于xxx时刻被删除</p><p>再次将远程仓库pull到本地仓库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046131.png" alt="截屏2022-10-20 22.22.35 Redacted" style="zoom:50%;" /><p>(界面往往包含很多信息，比如这个，显示hello.c的最新的状态是在远程仓库被删除了)</p><p>看一下本地CLion文件夹</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046186.png" alt="截屏2022-10-20 22.24.17" style="zoom:50%;" /><p>明白了吧～～</p></blockquote></blockquote><p>因为不止一个本地仓库可以访问远程仓库，所以如果你不知道自己本地仓库的版本比远程仓库是新还是旧</p><p>每次开始工作时建议先将远程仓库pull到本地仓库，因为pull和push总是取文件最新状态嘛～～</p><p><a href="https://blog.csdn.net/wys0127/article/details/123856744">git 为什么要先commit，然后pull，最后再push？而不是commit然后直接push？</a></p><p>🎉恭喜，到这一步，你已经掌握了如何在本地仓库和远程仓库进行文件提交和获取了🎉</p><h4 id="“插一嘴”补充的内容："><a href="#“插一嘴”补充的内容：" class="headerlink" title="“插一嘴”补充的内容："></a>“插一嘴”补充的内容：</h4><h6 id="1-如何修改用户配置"><a href="#1-如何修改用户配置" class="headerlink" title="1.如何修改用户配置"></a>1.如何修改用户配置</h6><blockquote><p>如果单纯想要修改用户配置，只需要用添加用户配置的命令就可以了，因为新的配置会覆盖旧的配置</p></blockquote><blockquote><p>如果想要删除用户配置，比如删除用户名、邮箱、密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset user.name</span><br><span class="line">git config --global --unset user.email</span><br><span class="line">git config --global --unset user.password</span><br></pre></td></tr></table></figure><p>删除了用户名和邮箱，在连接远程仓库的时候可能会被认为本地Git不安全（因为都没有报上名来~~</p><p>删除了密码，则在进行一些操作时会跳过输入密码的环节，方便但是不是很安全，因为往往是在一些“确认要进行操作吗”的操作时需要你输入密码来确认，如果没有密码就直接跳过了~</p></blockquote><p><a href="#%E6%8F%92%E4%B8%80%E5%98%B4:%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E7%9A%84%E9%85%8D%E7%BD%AE">点这里返回上次阅读的位置</a></p><h6 id="2-查看仓库状态"><a href="#2-查看仓库状态" class="headerlink" title="2.查看仓库状态"></a>2.查看仓库状态</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>这是一个使用很频繁的命令，有时候你就是想看看现在仓库处于什么状态，有时候你会忘记自己有没有将文件夹下已经更改的文件提交到Git仓库，等等等等，反正只要你想看一下仓库状态，就会用它～</p><blockquote><p>比如到现在为止，我们只是完成了仓库的初始化，还没有向仓库中提交任何文件</p><ul><li>如果文件夹中本来是没有文件的，我们查看一下仓库的状态</li></ul><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046235.png" alt="截屏2022-10-19 17.53.32 Redacted" style="zoom:50%;" /><p>可以看到 “No commits yet”（还没有任何提交）</p><ul><li>如果文件夹里原来是有文件的（比如一个文件hello.c），我们查看一下仓库的状态</li></ul><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046288.png" alt="截屏2022-10-19 19.19.26 Redacted" style="zoom:50%;" /><p>可以看到Git检测到文件夹里有一个新的文件”未被跟踪”（Untracked files ：）</p><p>在括号里提示了用什么命令来将hello.c文件放入缓存区</p><p>下面的红色的hello.c就是未被添加到缓存区的文件</p><blockquote><p>“跟踪”，因为Git本身是一个版本控制软件，说白了就是记录并保存下来你每次对于文件的更改（这个就叫跟踪，知道你什么时候修改的什么文件）</p><p>&#x3D;&#x3D;<strong>只有将修改了的文件添加到Git的缓存区，文件状态才能被Git跟踪</strong>&#x3D;&#x3D;</p><p>&#x3D;&#x3D;当你完成了所有的工作、已经不需要再对任何文件进行更改，就执行最后一步：将缓存区的文件提交到Git，这样仓库里的文件就会更新了&#x3D;&#x3D;</p><blockquote><p>修改，当然是包括添加新文件、删除旧文件、更改现有文件等~</p></blockquote></blockquote></blockquote><p><a href="#%E6%8F%92%E4%B8%80%E5%98%B4:%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%BB%93%E5%BA%93%E7%9A%84%E7%8A%B6%E6%80%81">点这里返回刚才阅读的位置</a></p><h6 id="3-重点-仓库的分支"><a href="#3-重点-仓库的分支" class="headerlink" title="3.[重点]仓库的分支"></a>3.[重点]仓库的分支</h6><p>branch 即为“分支”</p><p>如果用户a和用户b同时对于项目进行修改，仓库为了防止两人的修改相互影响，会形成两条分支来分别保存a、b的修改，这样a、b对于项目的修改都在自己的那条分支上，等到ab的工作完成了，就可以选择统一将分支合并起来</p><blockquote><p>在仓库初始化(执行了git init)之后，会默认生成一个主分支master，也就是在Windows的Git Hash窗口中显示的这个绿色的</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046347.png" alt="image-20221020171909705" style="zoom:80%;" /><p>在macOS和Linux下的终端里不会主动显示当前分支名字，但是也可以在某些地方看到</p><p>比如在查看仓库状态下(Windows的Git Bash里也一样)</p><p>当然，在这个终端窗口里，显示我的这个分支名字是main，那是因为我改名了hhh~</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046936.png" alt="截屏2022-10-19 19.53.52 Redacted" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046445.png" alt="image-20221020003829168" style="zoom:80%;" /></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p><strong>显示当前仓库下所有的分支</strong></p><p>这个命令可以查看当前仓库的所有分支，并用“ * ”标记出用户当前使用的分支</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046596.png" alt="image-20221020172917614" style="zoom:80%;" /><p>可以看到现在我只有一个分支master，并处在这个分支上</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 新分支名称</span><br></pre></td></tr></table></figure><p><strong>增加一个分支</strong></p><p>这个命令会增加一个分支，新增的分支会复制原有分支的所有内容，保证新分支的初始内容和原分支一样</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046663.png" alt="image-20221020173709847" style="zoom:80%;" /><p>看到新增加了一个分支a</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 想要切换到的分支</span><br></pre></td></tr></table></figure><p><strong>切换当前分支</strong></p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046764.png" alt="image-20221020174000192" style="zoom:80%;" /><p>看到切换了分支（甚至在Git Bash中还会用蓝色的字体标出来当前分支，这还是很银杏化的~~</p><p>mac和Linux泪目….</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 新分支名称</span><br></pre></td></tr></table></figure><p><strong>新增一个分支并切换到这个新分支</strong></p><p>就是上两个操作的简化~~</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046825.png" alt="image-20221020191116028" style="zoom:80%;" /></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 要合并到当前分支的分支名</span><br></pre></td></tr></table></figure><p>将某个分支合并到<strong>当前分支</strong></p><p>注意：只能将别的分支合并到当前分支，因此合并前要注意一下当前分支</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046943.png" alt="image-20221020191856740" style="zoom:80%;" /><p>可以看到，分支合并到master之后，原分支并不会被删除~</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d 要删除的分支名</span><br></pre></td></tr></table></figure><p>删除某个分支</p><p>前提：1.不能删除当前所在的分支，执行删除前记得切换分支</p><p>​2.如果一个分支在创建后<u>仓库内容被修改(提交到了Git仓库才能被追踪，才能判断被修改)</u>，并且<u>没有合并到其他分支</u>，是不允许被删除的</p><blockquote><p>在master分支下创建分支a和b</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010046994.png" alt="image-20221020193904453" style="zoom:80%;" /><p>切换到分支a，在文件夹中创建一个hello.txt文件，但不提交到仓库里</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047046.png" alt="image-20221020194217899" style="zoom:80%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047219.png" alt="image-20221020194305055" style="zoom:80%;" /><p>然后切换到master，删除a，发现正常删除了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047280.png" alt="image-20221020201631869" style="zoom:80%;" /><p>但是如果分支a下，文件夹下添加的hello.txt文件提交到了Git里，再回到master分支删除分支a，就会报错，分支a尚未合并到其他分支</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047331.png" alt="image-20221020202208027" style="zoom:80%;" /></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D 要删除的分支名</span><br></pre></td></tr></table></figure><p>强制删除某个分支</p><p>”强制“在于可以删除 未合并到其他分支的 已修改的分支</p><blockquote><p>上面那张图片也说了，If you are sure you want to delete it, run ‘git branch -D a’</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047382.png" alt="image-20221020202701428" style="zoom:80%;" /></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag 标签/版本名称</span><br></pre></td></tr></table></figure><p>为当前的仓库状态添加一个标签，就像每次软件的版本一样~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><p>查看所有标签&#x2F;版本</p><blockquote><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047440.png" alt="截屏2022-10-20 21.57.34 Redacted" style="zoom:50%;" /></blockquote><p>&#x3D;&#x3D;<strong>总结一个很重要的知识点</strong>&#x3D;&#x3D;</p><blockquote><p>如果我们在只有一个分支master的仓库，再添加一个分支a，并切换到分支a</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047509.png" alt="截屏2022-10-21 01.04.54" style="zoom:50%;" /><p>原来的时候仓库master分支里有一个test.txt文件，因为构建了一个分支，master分支里的所有文件也都复制到了a分支里</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047566.png" alt="截屏2022-10-21 01.05.41" style="zoom:50%;" /><p>现在我们正处在分支a，我们添加一个文件A.txt到分支a仓库里面</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047662.png" alt="截屏2022-10-21 01.08.08" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047725.png" alt="截屏2022-10-21 01.09.22" style="zoom:50%;" /><p>现在切换到master分支</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047769.png" alt="截屏2022-10-21 01.10.31" style="zoom:50%;" /><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047843.png" alt="截屏2022-10-21 01.11.01" style="zoom:50%;" /><ul><li>&#x3D;&#x3D;<strong>我们可以体会到：分支是相互独立的</strong>&#x3D;&#x3D;</li></ul><p>我们再切回到分支a</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047900.png" alt="截屏2022-10-21 01.12.38" style="zoom:50%;" /><p>嗯没错没毛病，A.txt又回来了</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047954.png" alt="截屏2022-10-21 01.13.21" style="zoom:50%;" /><p>好，现在再在分支a的文件夹里添加一个B.txt，但是这次不提交到分支a的仓库</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047024.png" alt="截屏2022-10-21 01.14.34" style="zoom:50%;" /><p>我们直接切换到分支master</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047080.png" alt="截屏2022-10-21 01.15.15" style="zoom:50%;" /><p>发现分支为master时的文件夹里，有B.txt</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047133.png" alt="截屏2022-10-21 01.16.00" style="zoom:50%;" /><p>这并不是因为B.txt从分支a的仓库复制到了分支master的仓库</p><p>而是因为B.txt既不属于分支a仓库，也不属于分支master</p><p>它并不存在于Git仓库里</p><ul><li><p>&#x3D;&#x3D;<strong>我们可以发现</strong>&#x3D;&#x3D;</p><p>&#x3D;&#x3D;<strong>Git仓库 不等于 整个文件夹，文件夹的文件提交到GIt仓库之后才属于仓库，否则只是一个存在于文件夹但是不存在于仓库的文件&#x3D;&#x3D;</strong></p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047204.png" alt="截屏2022-10-21 01.24.33" style="zoom:50%;" /></li></ul><p>现在我们切换回a分支</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047900.png" alt="截屏2022-10-21 01.12.38" style="zoom:50%;" /><p>好，之前不是在文件夹里创建了一个B.txt但是没有提交到分支a的仓库嘛</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047266.png" alt="截屏2022-10-21 01.28.55" style="zoom:50%;" /><p>现在我们将它添加到分支a的缓存区，但不提交到仓库里</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047327.png" alt="截屏2022-10-21 01.29.32" style="zoom:50%;" /><p>切换到master分支</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047387.png" alt="截屏2022-10-21 01.31.54 Redacted" style="zoom:50%;" /><p>可以发现切换的时候有一个关于B.txt的提示，并且master分支下，文件夹里还是有B.txt</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047445.png" alt="截屏2022-10-21 01.36.12" style="zoom:50%;" /><p>说明B.txt文件还是不属于Git仓库</p><p>但是能检测到B.txt的动向了，说明</p><ul><li>&#x3D;&#x3D;<strong>将文件添加到缓存区，只是给了Git跟踪文件状态的权利，但是文件并不会进入到Git仓库里，除非提交到仓库</strong>&#x3D;&#x3D;</li></ul></blockquote><p>[点这里返回刚在阅读的位置](#插一嘴:仓库的分支—-在查看仓库的时候，第一行中的”On branch XXX”是啥)</p><h6 id="4-查看隐藏文件"><a href="#4-查看隐藏文件" class="headerlink" title="4.查看隐藏文件"></a>4.查看隐藏文件</h6><p>macOS和Linux下：</p><blockquote><p>以”.”开头的文件都是隐藏文件，我们可以先打开访达</p><p>在左侧列表中找到 位置 下的个人电脑的文件夹</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047501.png" alt="截屏2022-10-19 21.34.50" style="zoom: 50%;" /><p>打开Macintosh HD - 用户 - 自己用户名的文件夹</p><p>然后在这个文件夹里按下⇧ + ⌘ +. </p><p>就可以显示隐藏文件，再按一遍就可以关闭显示隐藏文件</p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202301010047598.png" alt="截屏2022-10-19 21.37.12" style="zoom:50%;" /></blockquote><p><a href="#%E6%8F%92%E4%B8%80%E5%98%B4:%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6">点这里返回刚才阅读的位置</a></p><p>参考文章：《从0开始的Github》</p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_快捷键&amp;热键</title>
      <link href="/chunyujin/bd04c738.html"/>
      <url>/chunyujin/bd04c738.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-光标移动"><a href="#1-光标移动" class="headerlink" title="1. 光标移动"></a>1. 光标移动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ctrl + &lt;      # 移动到前一个单词开头</span><br><span class="line">ctrl + &gt;      # 移动到后一个单词结尾</span><br><span class="line">ctrl + A      # 移动到开头</span><br><span class="line">ctrl + E      # 移动到结尾</span><br><span class="line">alt  + B      # 向左移动一个单词</span><br><span class="line">alt  + F      # 向右移动一个单词</span><br><span class="line">ctrl + B      # 向左移动一个字符</span><br><span class="line">ctrl + F      # 向右移动一个字符</span><br><span class="line">esc  + B      # 向左移动一个单词</span><br><span class="line">esc  + F      # 向右移动一个单词</span><br><span class="line">ctrl + XX     # 在上次光和当前光标所在字符间跳转</span><br><span class="line">esc  + T      # 交换光标位置前的两个单词</span><br></pre></td></tr></table></figure><h2 id="2-拷贝-x2F-剪切-x2F-粘贴-x2F-删除"><a href="#2-拷贝-x2F-剪切-x2F-粘贴-x2F-删除" class="headerlink" title="2. 拷贝&#x2F;剪切&#x2F;粘贴&#x2F;删除"></a>2. 拷贝&#x2F;剪切&#x2F;粘贴&#x2F;删除</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* ctrl/shift + Insert # whindows下复制粘贴文本 </span><br><span class="line">* cmd + c/v # macOS下复制粘贴文本</span><br><span class="line">  ctrl + K      # 剪切光标后所有字符</span><br><span class="line">  ctrl + U      # 剪切光标前所有字符</span><br><span class="line">  ctrl + Y      # 粘贴ctrl+U/K剪切的内容</span><br><span class="line">  ctrl + W      # 删除光标前一个单词</span><br><span class="line">  ctrl + D      # 删除光标所在字符(光标右侧) #不建议使用</span><br><span class="line">  ctrl + H      # 删除光标前字符(光标左侧)</span><br></pre></td></tr></table></figure><h2 id="3-撤销"><a href="#3-撤销" class="headerlink" title="3. 撤销"></a>3. 撤销</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* ctrl + _      # 撤销操作</span><br><span class="line">  ctrl + ?      # 撤消前一次输入</span><br><span class="line">  alt  + R      # 撤消前一次动作</span><br></pre></td></tr></table></figure><h2 id="4-替换"><a href="#4-替换" class="headerlink" title="4. 替换"></a>4. 替换</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* ctrl + T      # 将光标当前字符与前面一个字符替换</span><br></pre></td></tr></table></figure><h2 id="5-历史命令编辑"><a href="#5-历史命令编辑" class="headerlink" title="5. 历史命令编辑"></a>5. 历史命令编辑</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  ctrl + P      # 上条输入的命令(相当于上键)</span><br><span class="line">  ctrl + N      # 上条历史命(相当于下键)</span><br><span class="line">  alt  + &gt;      # 上一次执行命令</span><br><span class="line">* ctrl + R      # 输入残缺指令，搜索对应完整历史指令</span><br></pre></td></tr></table></figure><h2 id="6-控制命令"><a href="#6-控制命令" class="headerlink" title="6. 控制命令"></a>6. 控制命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* ctrl + L      # 清除屏幕，相当于clear</span><br><span class="line">* ctrl + C      # (强制)终止命令&amp;另起一行</span><br><span class="line">* ctrl + D      # 退出(比如用户登出、退出shell、退出终端)</span><br><span class="line">* ctrl + Z      # 暂停并挂起当前任务</span><br><span class="line">  ctrl + I      # 补全功能(类似Tab键)</span><br><span class="line">  ctrl + O      # 重复执行命令</span><br><span class="line">  alt  + &lt;数字&gt;  # 操作的次数</span><br><span class="line">  ctrl + S      # 锁住终端，阻止屏幕输出</span><br><span class="line">  ctrl + Q      # 解锁终端，允许屏幕输出</span><br></pre></td></tr></table></figure><h2 id="7-补全-x2F-补齐"><a href="#7-补全-x2F-补齐" class="headerlink" title="7.补全&#x2F;补齐"></a>7.补全&#x2F;补齐</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tab</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单击tab实现指令补全，仅当通过残缺的指令能确定唯一的完整指令时才可以实现补全</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">双击tab实现档案补全，当通过残缺的指令无法确定唯一完整指令时，显示所有对应指令</span></span><br></pre></td></tr></table></figure><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212121406831.gif" alt="Dec-12-2022 14-04-41"></p><p><img src="https://map--depot.oss-cn-hangzhou.aliyuncs.com/image/202212121406885.gif" alt="Dec-12-2022 14-05-29"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_与Shell的关系</title>
      <link href="/chunyujin/a64800cc.html"/>
      <url>/chunyujin/a64800cc.html</url>
      
        <content type="html"><![CDATA[<p>一个完整的计算机，整体结构如下图：</p><p><img src="https://img-blog.csdnimg.cn/67f4c5c0392d42bb949f4d5f71790a46.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZmF0ZmF0bW9tbw==,size_8,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>①我们的计算机由硬件组成，包括CPU、内存、主板、磁盘、各种外设等等。当这台计算机没有安装任何软件，只是一个硬件的集合体时，也叫做 裸机(纯硬件)。</p><p>②操作系统是系统软件，操作系统的内核控制着和管理计算机上的所有硬件和软件，从而进行任务调度、资源分配等。操作系统起到承上启下的作用。</p><p>③我们平时使用的应用软件(或叫应用程序)，如QQ音乐、英雄联盟等，是基于操作系统开发的，可以理解为在操作系统的上层。这些程序的开发往往调用了操作系统提供的接口，离开了操作系统是无法独立运行的。</p><p><strong>Shell是一个特殊的应用程序，介于操作系统内核和用户之间，是一个“命令解释器”，负责接受用户输入的指令并进行解释，将需要执行的操作传递给内核执行，并输出执行结果返回给用户。</strong></p><p><strong>在linux早期是没有图形化界面的，与系统进行交互的唯一方式就是通过shell提供的命令行界面(command-line interface, CLI)。同样在工作中，需要通过本机登录内网开发机，使用命令行界面进行开发，从而保障安全性。</strong></p><p>命令行界面只接受文本输入。我们想使用shell进行开发，则需要深入了解shell的命令，后续文章会对shell命令进行详细的介绍，本专栏主要针对想入门shell的新同学，有问题欢迎评论或私信，共同交流，一般周末公司不加班都会回复~~~</p><p>PS : 在厂里搬砖，基本都是在linux机器上进行开发的。很多同学在校时大多在机子上装个Pycharm之类的IDE就足够完成科研任务了，这也使得刚工作后不太熟悉linux开发的节奏。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
